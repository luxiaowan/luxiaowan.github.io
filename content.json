{"meta":{"title":"串一串","subtitle":"断舍离","description":null,"author":"cc","url":"http://luxiaowan.github.io","root":"/"},"pages":[{"title":"关于本人","date":"2019-10-21T15:26:09.000Z","updated":"2019-10-21T15:28:30.066Z","comments":true,"path":"about/index.html","permalink":"http://luxiaowan.github.io/about/index.html","excerpt":"","text":"串一串 浪人 非常懒，偶尔写一下 文笔很烂，写的不好 凑合看吧"},{"title":"推荐书单","date":"2019-10-21T15:38:29.000Z","updated":"2019-10-21T15:56:47.928Z","comments":true,"path":"books/index.html","permalink":"http://luxiaowan.github.io/books/index.html","excerpt":"","text":"书名 购买地址 JavaScript权威指南（第6版） JavaScript高级程序设计 Java编程思想（第4版） java并发编程实战 Netty权威指南（第2版） Spring Boot实战 Spring微服务实战 Word Excel PPT 2016入门与提高 编程珠玑（第2版） 操作系统真象还原 大型网站系统与Java中间件实践 高性能JavaScript 高性能MySQL（第3版） 机器学习 极简思维 技术运营 人性的弱点 设计模式解析（第2版） 设计模式之禅 深度思维 深入理解Java虚拟机 深入浅出Node.js 深入浅出React和Redux 移动Web前端高效开发实战 亿级流量网站架构核心技术 原则 怎样管精力就怎样过一生 重构改善既有代码的设计 Excel高效办公：数据处理与分析（修订版） 项目管理艺术 周鸿祎自述 我的互联网方法论 奇点临近 高效能人士的七个习惯 三板斧：阿里巴巴管理之道 掘金移动互联：跨境电商如何挑战海外市场 微信思维 系统之美:决策者的系统思考 思考，快与慢 创新者的窘境 微服务设计 Scrum敏捷软件开发 管理的实践"},{"title":"友情链接","date":"2019-10-21T15:42:43.000Z","updated":"2019-10-21T15:57:01.607Z","comments":true,"path":"links/index.html","permalink":"http://luxiaowan.github.io/links/index.html","excerpt":"","text":"本人还没友链，孤独小客"},{"title":"分类","date":"2019-10-21T15:29:38.000Z","updated":"2019-10-21T15:32:44.295Z","comments":true,"path":"categories/index.html","permalink":"http://luxiaowan.github.io/categories/index.html","excerpt":"","text":""},{"title":"个人项目","date":"2019-10-21T15:54:25.000Z","updated":"2019-10-21T15:57:51.353Z","comments":true,"path":"repository/index.html","permalink":"http://luxiaowan.github.io/repository/index.html","excerpt":"","text":"https://github.com/luxiaowan"},{"title":"标签","date":"2019-10-21T15:35:35.000Z","updated":"2019-10-21T15:35:54.071Z","comments":true,"path":"tags/index.html","permalink":"http://luxiaowan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring-Session和Redis实现Session共享","slug":"Spring-Session和Redis实现Session共享","date":"2019-10-24T11:30:00.000Z","updated":"2019-10-24T15:09:42.022Z","comments":true,"path":"2019/10/24/Spring-Session和Redis实现Session共享/","link":"","permalink":"http://luxiaowan.github.io/2019/10/24/Spring-Session和Redis实现Session共享/","excerpt":"","text":"需求 现在大部分服务都以集群负载均衡的方式部署，几乎很难再遇到单点部署的项目，因为大家都要保证最基本的HA，说到HA，第一要考虑的就是各系统之间的Session共享的问题，如何解决呢？负载均衡当前使用Nginx 分析 不同的POD之间如果需要达到数据共享的目的，那么则需要使用同一个存储媒介，一开始想到使用MySQL来存储登录session，但是每次请求都去MySQL中查询数据，开销还是非常大的；然后最近使用MongoDB比较嗨，想着用MongoDB，但是MongoDB查询起来也不方便，况且我们这个Session也不是量级很大的数据集，最终采用了内存级的Redis来解决这个问题。 使用Redis的基本操作是将jsessionId为key，用户信息为value，使用jedis或者redisTemplate来操作Redis的读写行为。但是这种方式侵入了业务代码，并不是最优解，查了部分资料之后，发现spring-session.jar包中有一个非常有特色的注解@EnableRedisHttpSession，可以不需要侵入业务代码就能使用redis实现session共享的问题。 我们看一下@EnableRedisHttpSession的源码是怎么说的： 将此注释添加到一个单独的类上，该类必须加上@Configuration注解。使用方式在注释里也给出了demo代码。 实现 修改pom.xml文件，引入我们需要的jar包 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 修改application.yml文件，配置redis信息 12345&gt; &gt; spring.redis.database=0&gt; &gt; spring.redis.host=localhost&gt; &gt; spring.redis.port=6379&gt; &gt; spring.redis.password=123456&gt; &gt; 创建配置类 12345678&gt; &gt; import org.springframework.context.annotation.Configuration;&gt; &gt; import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;&gt; &gt; &gt; &gt; @Configuration&gt; &gt; @EnableRedisHttpSession&gt; &gt; public class RedisHttpSessionConfig &#123;&gt; &gt; &#125;&gt; &gt; 到此，我们使用Redis实现Session共享的所有配置和代码都已经写完了，可以看到我们没有侵入到任何业务代码中，从头到尾也很简单。 扩展 1234@EnableGemFireHttpSession@EnableSpringHttpSession@EnableMongoHttpSession@EnableJdbcHttpSession","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://luxiaowan.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"Java简单操作MongoDB","slug":"Java简单操作MongoDB","date":"2019-10-24T02:16:00.000Z","updated":"2019-10-24T13:20:12.762Z","comments":true,"path":"2019/10/24/Java简单操作MongoDB/","link":"","permalink":"http://luxiaowan.github.io/2019/10/24/Java简单操作MongoDB/","excerpt":"","text":"前面已经掌握了mongo最基本的一些命令，对各个命令也都实操过，理解各命令的意思，也对mongo有了最基本的理解，但大部分猿还是想使用Java去连接mongo，串串也不例外 在pom.xml中加入mongodb-java-driver.jar的依赖 Maven项目依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;3.0.4&lt;/version&gt;&lt;/dependency&gt; SpringBoot项目依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 连接mongo 认证连接 12345678// 创建验证信息，根据加密方式选择MongoCredential内对应的加密方式List&lt;MongoCredential&gt; credentials = new ArrayList&lt;&gt;();MongoCredential credential = MongoCredential.createCredential(\"admin\", \"test1\", \"admin\".toCharArray());credentials.add(credential);// 创建mongo服务地址ServerAddress serverAddress = new ServerAddress(\"localhost\", 27017);MongoClient mongoClient = new MongoClient(serverAddress, credentials); 无需认证连接 1MongoClient client = new MongoClient(\"localhost\", 27017); 然后就可以通过MongoClient的实例方法对mongo进行相关操作了 创建数据库连接 1MongoDatabase db = client.getDatabase(\"test1\"); mongo特性是不管数据库事先是否存在，都可以正常创建数据库连接，不会像MySQL一样报错，连接成功后，在mongo服务器上执行show dbs，会发现仍然查不到我们连接的这个数据库，这是正常情况，只有在数据库中有数据的时候，才会查得出来，client.getDatabase(&quot;test&quot;) === use test命令 创建集合 使用数据库连接实例方法创建一个空的集合 1234db.createCollection(\"base_info\");--- 命令：db.createCollection(\"base_info\") 直接向创建的集合中插入数据 12345MongoCollection&lt;Document&gt; collection = db.getCollection(\"base_info\");collection.insertOne(new Document(\"name\", \"lxl\"));--- 命令：db.base_info.insert(&#123;\"name\": \"lxl\"&#125;) 以上两种方式均可创建一个集合，区别在于第一种方式创建的是空集合， 删除集合 1234collection.drop();--- 命令：db.base_info.drop() 对集合的CRUD 新增数据 单条新增 12Document document = new Document().append(\"name\",\"cc\").append(\"age\",30).append(\"location\",\"SZ\");collection.insertOne(document); 批量新增 123456List&lt;Document&gt; documentList = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 1000; i++) &#123; Document doc = new Document().append(\"name\", \"cc\" + i).append(\"age\", new Random().nextInt(100)).append(\"location\", \"SZ\"); documentList.add(doc);&#125;collection.insertMany(documentList); insertOne(Document)方法每次插入一条数据 insertMany(List)方法批量插入数据，并且可以通过参数InsertManyOptions设置是否排序 删除数据 删除第一条匹配的数据 12345Bson condition = Filters.eq(\"age\", 99);collection.deleteOne(condition);--- 命令：db.base_info.deleteOne(&#123;\"age\": 99&#125;) 删除所有匹配数据 12345Bson condition = Filters.eq(\"age\", 99);collection.deleteMany(condition);--- 命令：db.base_info.deleteMany(&#123;\"ag\": 99&#125;) 查询数据 查询返回第一条匹配的数据 1234Bson condition = Filters.eq(\"age\", 16);FindIterable&lt;Document&gt; vals = collection.find(condition);Document document = vals.first();System.out.println(document.toJson()); 通过调用FindIterable的实例方法first()取第一条数据 查询返回所有匹配数据 12345Bson condition = Filters.eq(\"age\", 16);FindIterable&lt;Document&gt; vals = collection.find(condition);for (Document val : vals) &#123; System.out.println(val.toJson());&#125; find()方法返回所有匹配数据 分页查询 分页查询是我们日常开发中经常用到的功能，尤其是mongo这种量级较大的存储，分页使用limit()和skip()两个方法来实现，limit指定查询的条数，skip进行分页，参数为从第几条开始，需要使用当前页码和分页条数进行计算(pageNo - 1) * pageSize 12345Bson condition = Filters.lt(\"age\", 2);FindIterable&lt;Document&gt; vals = collection.find(condition).limit(10).skip(10).sort(Sorts.descending(\"age\"));for (Document val : vals) &#123; System.out.println(val.toJson());&#125; limit(10): 每页取10条数据 skip(10): 从第11条开始查询，起始位置为0 sort(Sorts.descending(“age”)): 以列age倒序 对应MySQL：select * from base_info where age &lt; 2 order by age desc limit 7, 7 更新数据 更新第一条匹配数据中的某些字段 123Bson condition = Filters.eq(\"age\", 15);Document document = new Document(\"$set\", new Document(\"location\", \"XZ\"));collection.updateOne(condition, document); 注意这里有一个$set，这个指令是必须的，相对应的指令还有$inc 替换第一条匹配数据全部内容 123Bson condition = Filters.eq(\"age\", 15);Document document = new Document(\"location\", \"XZ\");collection.updateOne(condition, document); 没有$set指令,则表示使用参数document替换掉第一条匹配到的数据 第一条匹配的数据中指定字段数量+1 123Bson condition = Filters.eq(\"location\", \"XZ\");Document document = new Document(\"$inc\", new Document(\"age\", 1));collection.updateOne(condition, document); 更新所有匹配数据 123Bson condition = Filters.eq(\"age\", 15);Document document = new Document(\"$set\", new Document(\"location\", \"XZ\"));collection.updateMany(condition, document); 全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import org.bson.Document;import org.bson.conversions.Bson;import com.mongodb.MongoClient;import com.mongodb.client.FindIterable;import com.mongodb.client.MongoCollection;import com.mongodb.client.MongoDatabase;import com.mongodb.client.model.Filters;import com.mongodb.client.model.Sorts;/** * @author: cc */public class MongoConnectTest &#123; public static void main(String[] args) &#123; MongoClient client = new MongoClient(\"localhost\", 27017); try &#123; /* // 创建验证信息，根据加密方式选择MongoCredential内对应的加密方式 List&lt;MongoCredential&gt; credentials = new ArrayList&lt;&gt;(); MongoCredential credential = MongoCredential.createCredential(\"admin\", \"test\", \"\".toCharArray()); credentials.add(credential); // 创建mongo服务地址 ServerAddress serverAddress = new ServerAddress(\"localhost\", 27017); MongoClient mongoClient = new MongoClient(serverAddress, credentials);*/ MongoDatabase db = client.getDatabase(\"test1\"); // 创建集合 // 方式1 // db.createCollection(\"base_info2\"); // 方式2 MongoCollection&lt;Document&gt; collection = db.getCollection(\"base_info\"); // collection.insertOne(new Document(\"name\", \"lxl\")); // 删除集合 // collection.drop(); // 新增数据 // 单条新增 /*Document document = new Document().append(\"name\", \"cc\").append(\"age\", 30).append(\"location\", \"SZ\"); collection.insertOne(document); // 批量新增 List&lt;Document&gt; documentList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) &#123; Document doc = new Document().append(\"name\", \"cc\" + i).append(\"age\", new Random().nextInt(100)) .append(\"location\", \"SZ\"); documentList.add(doc); &#125; collection.insertMany(documentList);*/ // 删除数据 // 删除第一条匹配数据 /*Bson condition = Filters.eq(\"age\", 99); collection.deleteOne(condition); // 删除所有匹配数据 collection.deleteMany(condition);*/ // 修改数据 // 修改第一条匹配数据 /*Bson condition = Filters.eq(\"age\", 15); Document document = new Document(\"$set\", new Document(\"location\", \"XZ\")); collection.updateOne(condition, document); collection.updateMany(condition, document);*/ // 年龄+1 /*Bson condition = Filters.eq(\"location\", \"XZ\"); Document document = new Document(\"$inc\", new Document(\"age\", 1)); collection.updateOne(condition, document);*/ // 查询返回第一条匹配数据 Bson condition = Filters.lt(\"age\", 2); FindIterable&lt;Document&gt; vals = collection.find(condition).sort(Sorts.descending(\"age\")).limit(7).skip(7); // Document document = vals.first(); // System.out.println(document.toJson()); for (Document val : vals) &#123; System.out.println(val.toJson()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://luxiaowan.github.io/categories/MongoDB/"}],"tags":[{"name":"Java与MongoDB","slug":"Java与MongoDB","permalink":"http://luxiaowan.github.io/tags/Java与MongoDB/"}]},{"title":"MongoDB监控、分片及备份恢复","slug":"MongoDB监控、分片及备份恢复","date":"2019-10-23T16:00:00.000Z","updated":"2019-10-24T13:20:12.764Z","comments":true,"path":"2019/10/24/MongoDB监控、分片及备份恢复/","link":"","permalink":"http://luxiaowan.github.io/2019/10/24/MongoDB监控、分片及备份恢复/","excerpt":"","text":"","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://luxiaowan.github.io/categories/MongoDB/"}],"tags":[{"name":"监控","slug":"监控","permalink":"http://luxiaowan.github.io/tags/监控/"}]},{"title":"MongoDB基础应用","slug":"MongoDB基础应用","date":"2019-10-22T16:00:00.000Z","updated":"2019-10-24T13:20:12.764Z","comments":true,"path":"2019/10/23/MongoDB基础应用/","link":"","permalink":"http://luxiaowan.github.io/2019/10/23/MongoDB基础应用/","excerpt":"","text":"索引 说明：索引是为了加快查询速度，可以对集合中的一列或多列设置索引。 – 无索引：扫描整个集合的文档，查找符合条件的文档 – 有索引：查找索引，根据索引取出文档数据 创建索引 db.&lt;collection_name&gt;.createIndex(keys, option) 栗子： 123456789101. 单索引db.user.createIndex(&#123;age:-1&#125;)---age:索引列名-1:倒序索引1:正序索引2. 多索引(复合索引)db.user.createIndex(&#123;age:1, gender:-1&#125;) 可选参数 参数 类型 说明 background Boolean 指定创建索引时是否阻塞集合的其他操作。true:后台执行，不阻塞；false:阻塞，默认 unique Boolean 指定索引是否为唯一索引。true:唯一索引；false:不唯一，默认 name String 索引名称，默认为字段名+索引顺序 v indexversion 索引版本号，默认为当前mongo的版本号 weights Integer 1~99999之间，值越大权重越大 expireAfterSeconds Integer 指定集合生存时间。秒级，TTL sparse Boolean 指定是否忽略不存在的字段。true:不查出不包含查询字段的文档；false:查询所有文档，默认 栗子： 12345&gt; db.user.createIndex(&#123;name:1&#125;, &#123;background: true, unique: true, name: \"idx_user_name\", v: 1, weights: 99, sparse: true&#125;)&gt; &gt; ---&gt; 后台不阻塞集合的方式创建一个name列正序,版本号为1,权重99,忽略无name字段的文档的唯一索引idx_user_name&gt; 查看所有索引 db.&lt;collection_name&gt;.getIndexes() 栗子： db.user.getIndexes() 重建索引 方法1：db.&lt;collection_name&gt;.reIndex() 方法2：先删除原索引，然后再创建 12db.&lt;collection_name&gt;.dropIndex(&lt;idx_name&gt;)db.&lt;collection_name&gt;.createIndex(...) 删除索引 删除指定名称的索引： db.user.dropIndex(&lt;idx_name&gt;) 删除集合中所有索引 db.user.dropIndexes() 说明：只会删除自建的索引，集合中_id列的索引不会被删除 聚合查询 12345678910111213141516171819202122232425创建集合并插入数据：db.agg.save([&#123; title: 'MongoDB Overview', description: 'MongoDB is no sql database', by_user: 'runoob.com', url: 'http://www.runoob.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100&#125;,&#123; title: 'NoSQL Overview', description: 'No sql database is very fast', by_user: 'runoob.com', url: 'http://www.runoob.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 10&#125;,&#123; title: 'Neo4j Overview', description: 'Neo4j is no sql database', by_user: 'Neo4j', url: 'http://www.neo4j.com', tags: ['neo4j', 'database', 'NoSQL'], likes: 750&#125;]) 格式： 12345678910&gt; db.&lt;collection_name&gt;.aggregate(condition)&gt; ---&gt; condition:&gt; [&#123;$group:&#123;_id:\"$&lt;key&gt;\", num_tutorial:&#123;$&lt;fun_expression&gt;:\"$&lt;key&gt;\"&#125;&#125;&#125;]&gt; $group:一个组&gt; _id:组合列，类同于MySQL的group by后面的字段，默认_id的列会在查询结果中显示&gt; num_tutorial:输出的列名&gt; $&lt;fun_expression&gt;:聚合表达式&gt; $&lt;key&gt;:运算的列名&gt; 关键字：aggregate 说明：聚合查询就是求和、最大、最小、最前、最后、平均数的统称，类似于MySQL的count()、sum()、avg() 栗子： 12345&gt; db.user.aggregate([&#123;$group: $&#123;_id:\"$gender\", num_tutorial:&#123;$sum:1&#125;&#125;&#125;])&gt; &gt; ---&gt; 等同于MySQL：select gender, count(1) from user group by gender&gt; 聚合表达式 表达式 描述 案例 $sum 计算总和 db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$sum:&quot;$likes&quot;}}}])—等同于MySQL：select by_user, sum(likes) from agg group by by_user $avg 计算平均值 db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$avg:&quot;$likes&quot;}}}])—等同于MySQL：select by_user, avg(likes) from agg group by by_user $min 获取集合中指定列的最小值记录 db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$min:&quot;$like&quot;}}}])—等同于MySQL：select by_user, min(likes) from agg group by by_user $max 获取集合中指定列的最大值记录 db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$max:&quot;$likes&quot;}}}])—等同于MySQL：select by_user, max(likes) from agg group by by_user $push 在结果文档中插入值到数组 db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$push:&quot;$url&quot;}}}])—等同于MySQL：查出所有数据，然后取字段url写入同一个列表中，url不去重，然后输出 $addToSet 在结果文档中插入值到一个数组中，但不创建副本 db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$addToSet:&quot;$url&quot;}}}])—等同于MySQL：查出所有数据，然后取字段url写入同一个列表中，url去重，然后输出 $first 根据资源文档的排序获取第一个文档数据 db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$first:&quot;$title&quot;}}}]) $last 根据资源文档的排序获取最后一个文档数据 db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$last:&quot;$title&quot;}}}]) 管道函数 说明：管道函数类似于Linux系统中的管道操作，将上一步的运算结果作为下一步的输入值，最终达到理想计算结果的运算方式 函数 说明 $project 指定需要输出的列，默认显示_id，格式：{$project:{by_user:1, title:1, url:1, _id:0不显示id}}, $limit 限制查询返回的文档数，格式：{$limit: 1},只返回一个文档 $skip 跳过指定数量的文档，返回之后的所有文档，格式：{$skip: 1},从第二个文档开始输出 $match 条件筛选，格式：{match: {likes: {gte: 10}}} $group 聚合条件，格式：{group: {_id: &quot;by_user&quot;, count: {$sum: -1}}} $sort 排序，格式：{$sort: {likes: -1}}，-1:倒序; 1:正序 $unwind 将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值 $geoNear 输出接近某一地理位置的有序文档。 栗子： 123456&gt; db.agg.aggregate(&#123;$match: &#123;likes: &#123;$gte: 10&#125;&#125;&#125;, &#123; $project: &#123;_id: 0, title: 1, by_user: 1, likes: 1&#125;&#125;, &#123;$limit: 5&#125;, &#123;$skip: 1&#125;, &#123;$sort: &#123;likes: -1&#125;&#125;)&gt; &gt; ---&gt; 等同于MySQL: &gt; select title, by_user, likes from agg where likes &gt;= 10 order by likes desc limit 1,5&gt;","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://luxiaowan.github.io/categories/MongoDB/"}],"tags":[{"name":"基础应用","slug":"基础应用","permalink":"http://luxiaowan.github.io/tags/基础应用/"}]},{"title":"MongoDB连接报错java.lang.NoSuchFieldError ACKNOWLEDGED","slug":"MongoDB连接报错java.lang.NoSuchFieldError-ACKNOWLEDGED","date":"2019-10-22T16:00:00.000Z","updated":"2019-10-24T13:20:12.764Z","comments":true,"path":"2019/10/23/MongoDB连接报错java.lang.NoSuchFieldError-ACKNOWLEDGED/","link":"","permalink":"http://luxiaowan.github.io/2019/10/23/MongoDB连接报错java.lang.NoSuchFieldError-ACKNOWLEDGED/","excerpt":"","text":"BUG描述 使用SpringBoot整合MongoDB时，正要运行代码连接mongo，就赤红赤红的报了个错： 12345Exception in thread \"main\" java.lang.NoSuchFieldError: ACKNOWLEDGED at com.mongodb.MongoClientOptions$Builder.&lt;init&gt;(MongoClientOptions.java:960) at com.mongodb.MongoClient.&lt;init&gt;(MongoClient.java:155) at com.mongodb.MongoClient.&lt;init&gt;(MongoClient.java:145) at com.example.demo.mongo.MongoConnectTest.main(MongoConnectTest.java:15) 这一下就傻眼了，对于刚接触mongo的人来说，是很懵圈的，大脑知识库中没有这个异常信息的解决办法，只能谷歌了，没想到有那么多人遇到过这个问题 BUG解决 在Stack Overflow上找到一个帖子： https://stackoverflow.com/questions/13593614/mongodb-java-lang-nosuchfielderror 其中jyemin的回答可以说是直击要害了，顺利的解决了这个问题，我把截图贴上，以防帖子被删 其实就是在工程中引入了多个版本不同的mongo-java-driver，所以导致程序混乱，只要保留自己真正使用的那个版本，其他的都删除即可 我的配置： 将2.7.1版本的依赖删除就可以正常运行了","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://luxiaowan.github.io/categories/MongoDB/"}],"tags":[{"name":"MongoDB错误记录","slug":"MongoDB错误记录","permalink":"http://luxiaowan.github.io/tags/MongoDB错误记录/"}]},{"title":"MongoDB基本指令","slug":"MongoDB基本指令","date":"2019-10-22T16:00:00.000Z","updated":"2019-10-24T13:20:12.763Z","comments":true,"path":"2019/10/23/MongoDB基本指令/","link":"","permalink":"http://luxiaowan.github.io/2019/10/23/MongoDB基本指令/","excerpt":"","text":"查看所有的db show dbs 切换db user &lt;db_name&gt; 查看当前所在db名称 db 删除db**(必须在要删除的db中操作)** db.dropDatabase() 查看db下所有的集合 show tables show collections 创建集合 db.createCollection(&quot;abc&quot;) db.createCollection(&quot;def&quot;, {capped: true, autoIndexId: true, size: 1024, max: 100}) 往一张不存在的集合中插入一条数据，会自动创建集合 db.test.insert({title: 123}) 删除集合 db.&lt;collection_name&gt;.drop() 例：db.abc.drop() 插入文档 db.&lt;collection_name&gt;.insert({title: 1234}) doc=({title: 12345, name: &quot;MongoDB指南&quot;}) db.&lt;collection_name&gt;.insert(doc) db.&lt;collection_name&gt;.save({name: &quot;MongoDB简单指令&quot;}}) doc2=({name: &quot;MongoDB从入门到放弃&quot;}) db.&lt;collection_name&gt;.save(doc2) doc3=({_id: &quot;edrftgyhjkgjhfgv2ryuoio&quot;, name: &quot;MongoDB从入门到放弃&quot;}) db.&lt;collection_name&gt;.save(doc3)// 若_id对应值的数据已经存在，则更新这条数据，否则新增一条数据 更新文档 db.&lt;collection_name&gt;.update({title: 1234}, {$set:{title: &quot;4321&quot;}}) 格式： 123456789db.&lt;collection_name&gt;.update( &lt;where&gt;,// 相当于MySQL的where &lt;update&gt;,// 相当于MySQL的update语句的set，需要跟一些指令：$,$inc,$set &#123; upsert: true,// true：如果不存在记录，则新增；false相反，默认 multi: true,// true：只更新第一条匹配的记录；false相反，全部更新， 默认 writeConcern: &lt;document&gt;// 异常级别 &#125;) 案例 12345678910111213&gt; 1. 只更新第一条记录：&gt; db.col.update( &#123; \"count\" : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; \"test2\" : \"OK\"&#125; &#125; );&gt; 2. 全部更新：&gt; db.col.update( &#123; \"count\" : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; \"test2\" : \"OK\"&#125; &#125;,false,true );&gt; 3. 只添加第一条：&gt; db.col.update( &#123; \"count\" : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; \"test5\" : \"OK\"&#125; &#125;,true,false );&gt; 4. 全部添加进去:&gt; db.col.update( &#123; \"count\" : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; \"test5\" : \"OK\"&#125; &#125;,true,true );&gt; 5. 全部更新：&gt; db.col.update( &#123; \"count\" : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; \"count\" : 1&#125; &#125;,false,true );&gt; 6. 只更新第一条记录：&gt; db.col.update( &#123; \"count\" : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; \"count\" : 1&#125; &#125;,false,false );&gt; db.&lt;collection_name&gt;.save() 调用save指令一般需要指定_id 删除文档 db.&lt;collection_name&gt;.remove({title: &quot;4321&quot;}, true) 格式 1234db.&lt;collection_name&gt;.remove( &lt;where&gt;,// 相当于MySQL的where &lt;justOne&gt;// true：只删除一条匹配条件的数据；false：匹配条件的数据全部删除，默认) 删除集合中所有数据 db.&lt;collection_name&gt;.remove({}) 新函数： db.&lt;collection_name&gt;.deleteMany({}) db.&lt;collection_name&gt;.deleteOne({title: &quot;12345&quot;}) 查询文档 普通查询 格式： 12345&gt; db.&lt;collection_name&gt;.find(&gt; &lt;where&gt;, // 查询条件&gt; &lt;colName&gt;// 返回字段名称&gt; )&gt; 创建一个集合，插入三条数据 1db.user.insert([&#123;name: \"cc\", age: \"29\", gender: 1&#125;, &#123;name: \"ccc\", age: \"30\", gender: 2&#125;, &#123;name: \"c\", age: \"28\", gender: 1&#125;]) 查询集合中全部数据 普通显示：db.user.find() 格式化显示：db.user.find().pretty() 查询name=&quot;c&quot;的信息 db.user.find({name: &quot;c&quot;}).pretty() 查询只返回第一个匹配到的数据 db.user.findOne({name: &quot;c&quot;}) AND查询 db.user.find({key: value, key: value}) And查询即是在where条件里面用逗号&quot;,&quot;分隔 栗子： 123456&gt; db.user.find(&#123;name:\"cc\", gender:1&#125;)&gt; &gt; ---&gt; 等同于MySQL：&gt; select * from user where name = \"c\" AND gender = 1&gt; OR查询 db.user.find({$or:[{key:value}, {key:value}]}) 栗子： 12345678&gt; db.user.find(&#123;&gt; $or:[&#123;name:\"c\"&#125;, &#123;gender:2&#125;]&gt; &#125;)&gt; &gt; ---&gt; 等同于MySQL：&gt; select * from user where name = \"c\" OR gender = 2&gt; AND和OR组合查询 db.user.find({key:value, $or:[{key:value}, {key:value}]}) 栗子： 123456&gt; db.user.find(&#123;gender:1, $or:[&#123;name: \"c\"&#125;, &#123;age: \"28\"&#125;]&#125;)&gt; &gt; ---&gt; 等同于MySQL：&gt; select * from user where gender = 1 AND (name = \"c\" OR age = \"28\")&gt; 运算符 运算符 格式 案例 MySQL对应语句 等于 {key:value}{key:{$eq:value}} db.user.find({age:“29”})db.user.find({age:{$eq:“29”}}) where age = “29” 大于 {key:{$gt: value}} db.user.find({age:{$gt:“30”}}) where age &gt; “30” 小于 {key:{$lt: value}} db.user.find({age:{$lt: “30”}}) where age &lt; “30” 大于等于 {key:{$gte: value}} db.user.find({age:{$gte:“30”}}) where age &gt;= “30” 小于等于 {key:{$lte: value}} db.user.find({age:{$lte:“30”}}) where age &lt;= “30” 不等于 {key:{ne: value}} db.user.find({age:{$ne:“29”}}) where age != “30” 模糊查询 查询age包含0的：db.user.find({age:/0/}) 查询age以2开头的：db.user.find({age:/^2/}) 查询age以8结束的：db.user.find({age:/8$/}) 分页查询 格式： 123456&gt; db.&lt;collection_name&gt;.find().limit(Number).skip(Number)&gt; &gt; ---&gt; limit(Number)表示查询多少条数据&gt; skip(Number)表示从第几条开始查询&gt; 查询一条数据 第一种方法：db.user.findOne({}) 第二种方法：db.user.find({}).limit(1) 从第二条数据开始查询一条数据 db.user.find().limit(1).skip(2) 查询排序 格式： 1234567&gt; db.&lt;collection_name&gt;.find().sort(&#123;&lt;key_name&gt;:-1/1&#125;)&gt; &gt; ---&gt; &lt;key_name&gt;：排序字段&gt; -1：倒序&gt; 1：正序&gt; 按照年龄倒序 db.user.find().sort({age:-1}) 按照年龄倒序、性别正序 db.user.find().sort({age:-1, gender:1})","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://luxiaowan.github.io/categories/MongoDB/"}],"tags":[{"name":"基本指令","slug":"基本指令","permalink":"http://luxiaowan.github.io/tags/基本指令/"}]},{"title":"Git Stash用法","slug":"git stash命令","date":"2019-10-21T16:00:00.000Z","updated":"2019-10-24T13:20:12.765Z","comments":true,"path":"2019/10/22/git stash命令/","link":"","permalink":"http://luxiaowan.github.io/2019/10/22/git stash命令/","excerpt":"","text":"创建仓库 git init echo 123 &gt; test.txt git add . git commit -m “add test file” git remote add origin git@git.xx.xx.xx:xxx/xxx.git git push origin master 以上内容比较简单，就不作详细讲述，如果上面的内容看不懂，下面的请放弃 使用git stash暂存 随意修改test.txt文件的内容，比如：画个心形，你正热火朝天修改中…… 这时领导走过来拍了拍你的肩膀说到：”小伙子啊，创建个朕.txt文件提交上来，内容就写我还想再活五百年，test.txt文件这一版不作修改“。 你面露笑容的回答：“好的，没问题！”，内心却是：“MMP,MMP,MMP……” 辛辛苦苦修改的test.txt文件怎么办？眼瞅着就要完成了，难道复制出去，然后等解决领导需求后再粘贴回来？low不low？肯定不low啊，一个文件而已，这种方法很简单，*但是当你实际项目中修改了几十个文件的时候呢？*挨个儿复制出去？累傻小子呐？！！！！！ git stash命令帮你解决问题，stash是存储的意思，也就是将当前工作区内的所有东西都存储起来，然后工作区所有文件恢复到修改之前的状态(并不是最新状态，不会和仓库中进行自动同步，需要你自己去pull)，然后你就可以继续完成任务了。(在执行git stash之前需要先执行git add命令) stash可以进行多次操作，每次操作都会将当前工作区的文件情况暂存起来，stash是类栈存储，每次stash的序号都为0，此次之前stash的序号会自动+1 使用git stash pop取出 git stash pop取出栈顶元素，也就是序号为0的那个，即最近一次执行git stash保存的内容。pop之后，暂存列表中就会自动将其清除掉，这个时候你再执行git stash list会发现毛都没有 这个时候可能就会纳闷了，我保存了好几次，但是我这次是想使用最开始stash的那份内容，怎么办？一直pop，直到最后一次？当然不行，上面刚讲过pop之后暂存列表中就没有stash的信息了，已经被pop出去的就找不回来了，等于是自杀式攻击，那咋整呢？ git stash apply stash@{序号}可以将指定序号的stash内容弹出到工作区，此时工作区里文件的状态就和stash@{序号}里的一致了，但是这个命令无法将stash记录从暂存列表中删除，仅仅只是将文件恢复而已 git stash drop stash@{序号}来丢弃暂存列表中的记录，可以配合apply使用 查看暂存记录中的信息 查看暂存列表：git stash list查看当前stash的列表 查看暂存内容：git stash show stash@{序号}查看指定序号的stash的内容 git stash save ‘msg’ 等于是在stash的时候打了个标签，妖娆！！！！","categories":[{"name":"Git","slug":"Git","permalink":"http://luxiaowan.github.io/categories/Git/"}],"tags":[]},{"title":"Hash索引相关","slug":"Hash索引相关","date":"2019-10-12T15:42:43.000Z","updated":"2019-10-21T15:48:05.043Z","comments":true,"path":"2019/10/12/Hash索引相关/","link":"","permalink":"http://luxiaowan.github.io/2019/10/12/Hash索引相关/","excerpt":"","text":"hash索引结构使用方式较为局限，仅适用于=、IN和&lt;=&gt;三种，但是由于通过hash可以直接查找到具体的值，而不用像BT那样每次都从root节点开始遍历，所以在通常情况下，hash的查找效率要比BT高。 hash的缺陷： 1. hash不能进行范围查找 值在计算hash后，并不能保证计算后的hash值和计算前的大小排列一样，所以hash不适用于范围查找 2. hash不能进行排序查询 值计算后的hash值无法保证与原值大小顺序一样，所以无法进行排序 3. 组合索引不能使用部分字段查询 组合索引的hash值是所有索引字段的值组合在一起进行计算的，若仅使用部分字段进行查询的话，计算出的hash值基本不会与索引的hash值相同 4. hash在出现大量值碰撞的时候，性能会降低 hash出现大量的值相等的时候，需要进行表扫描以进行精确匹配，效率较低","categories":[{"name":"Java","slug":"Java","permalink":"http://luxiaowan.github.io/categories/Java/"}],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://luxiaowan.github.io/tags/Java基础知识/"}]},{"title":"Char和varchar简单介绍","slug":"char与varchar简单介绍","date":"2019-10-12T04:10:43.000Z","updated":"2019-10-21T16:19:50.476Z","comments":true,"path":"2019/10/12/char与varchar简单介绍/","link":"","permalink":"http://luxiaowan.github.io/2019/10/12/char与varchar简单介绍/","excerpt":"","text":"1. 数据长度 1) char(最大长度255个字节) 长度固定（字段存入数据长度始终等于字段长度） 2) varchar(最大长度65535个字节) 可变长度，存入数据长度为N个字节，则实际使用了N+1(255以上长度则+2)个字节的空间，多出来的1字节是用来存储数据实际长度。 存入数据对比 存入&quot;ab&quot; char查询出&quot;ab&quot; varchar查询出&quot;ab&quot; 存入&quot;ab &quot;，ab后面有两个空格， char查询出&quot;ab&quot; varchar查询出&quot;ab &quot; 解析： ​ 在入库时，数据库会自动在ab后面添加两位空格，让入库的数据长度保证等于4 char(4) ，这种操作很容易理解，但是如果你去数据表里面去查这条数据，会发现表中数据并没有空格，所以可以推断出这里是逻辑追加，所以在查询数据的时候会并不会出现引擎自动添加的空格。 2. 实操(技术一定要**实操**) 1）无空格数据 先创建一张表 1create table cv(c char(4), v varchar(4)); 插入数据 1insert into cv values(&quot;ab&quot;, &quot;ab&quot;); 查询数据 1select concat(&apos;(&apos;, c, &apos;)&apos;) AS c, concat(&apos;(&apos;, v, &apos;)&apos;) AS v from cv; 结果 结果中char和varchar均查出来为无空格的ab ####2）有空格数据 插入数据 1insert into cv values(&quot;ab &quot;, &quot;ab &quot;); 查询数据 1select concat(&apos;(&apos;, c, &apos;)&apos;) AS c, concat(&apos;(&apos;, v, &apos;)&apos;) AS v from cv; 结果 结果中可以看出，char类型将数据后面的空格自动去掉了，varchar则保留了所有的空格","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://luxiaowan.github.io/categories/MySQL/"}],"tags":[]},{"title":"MySQL使用查询缓存","slug":"MySQL使用查询缓存","date":"2019-10-11T05:01:23.000Z","updated":"2019-10-21T15:48:59.282Z","comments":true,"path":"2019/10/11/MySQL使用查询缓存/","link":"","permalink":"http://luxiaowan.github.io/2019/10/11/MySQL使用查询缓存/","excerpt":"","text":"查询服务是否已开启缓存 执行show variables like '%query_cache%';查看缓存状态 Variable_name: query_cache_type为缓存状态，ON表示开启，OFF表示关闭 开启/关闭使用查询缓存 修改my.cnf文件进行开启和关闭 [mysqld]中添加/修改： query_cache_size = 20M query_cache_type = ON/OFF **修改完成后重启MySQL服务：service mysql restart/systemctl mysql restart ** 查询缓存使用情况 执行show status like 'qcache%';查询缓存使用情况 因为本机MySQL未开启查询缓存，所以此处和使用相关的属性均为0 属性解释: 属性 释义 Qcache_free_blocks 缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。 Qcache_free_memory 缓存中空闲内存大小 Qcache_hits 缓存命中次数，命中一次就+1 Qcache_inserts 查询次数，命中次数/查询次数=缓存命中率 Qcache_lowmem_prunes 缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数，如果数字不断增长，就可能碎片非常严重，或者内存很少，通过Qcache_free_blocks、Qcache_free_memory来分析具体情况 Qcache_not_cached 不适合进行缓存的查询的数量 Qcache_queries_in_cache 当前缓存的查询(和响应)的数量 Qcache_total_blocks 缓存中块的数量","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://luxiaowan.github.io/categories/MySQL/"}],"tags":[]},{"title":"Java基础面试题","slug":"蚂蚁Java基础面试题","date":"2019-10-10T15:21:56.000Z","updated":"2019-10-21T15:49:27.313Z","comments":true,"path":"2019/10/10/蚂蚁Java基础面试题/","link":"","permalink":"http://luxiaowan.github.io/2019/10/10/蚂蚁Java基础面试题/","excerpt":"","text":"一 map怎么实现hashcode和equals,为什么重写equals必须重写hashcode 使用过concurrent包下的哪些类，使用场景等等。 concurrentHashMap怎么实现？concurrenthashmap在1.8和1.7里面有什么区别 CountDownLatch、LinkedHashMap、AQS实现原理 线程池有哪些RejectedExecutionHandler,分别对应的使用场景 多线程的锁？怎么优化的？偏向锁、轻量级锁、重量级锁？ 组合索引？B+树如何存储的？ 为什么缓存更新策略是先更新数据库后删除缓存 OOM说一下？怎么排查？哪些会导致OOM? OSI七层结构，每层结构都是干什么的？ java的线程安全queue需要注意的点 死锁的原因，如何避免 二 jvm虚拟机老年代什么情况下会发生gc，给你一个场景，一台4核8G的服务器，每隔两个小时就要出现一次老年代gc，现在有日志，怎么分析是哪里出了问题 数据库索引有哪些？底层怎么实现的？数据库怎么优化？ 数据库的事务，四个性质说一下，分别有什么用，怎么实现的？ 服务器如何负载均衡，有哪些算法，哪个比较好，一致性哈希原理，怎么避免DDOS攻击请求打到少数机器 volatile讲讲 哪些设计模式？装饰器、代理讲讲？ redis集群会吗？ mysql存储引擎 事务隔离级别 不可重复度和幻读，怎么避免，底层怎么实现（行锁表锁） 三 项目介绍 分布式锁是怎么实现的 MySQL有哪几种join方式，底层原理是什么 Redis有哪些数据结构？底层的编码有哪些？有序链表采用了哪些不同的编码？ Redis扩容，失效key清理策略 Redis的持久化怎么做，aof和rdb，有什么区别，有什么优缺点。 MySQL数据库怎么实现分库分表，以及数据同步？ 单点登录如何是实现？ 谈谈SpringBoot和SpringCloud的理解 未来的技术职业怎么规划？ 为什么选择我们公司？","categories":[{"name":"Java","slug":"Java","permalink":"http://luxiaowan.github.io/categories/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://luxiaowan.github.io/tags/面试/"},{"name":"阿里","slug":"阿里","permalink":"http://luxiaowan.github.io/tags/阿里/"}]}]}