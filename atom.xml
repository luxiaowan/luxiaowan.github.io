<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2020-05-28T09:38:56.730Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程池中运行的线程，当等待队列未满的情况下，一定不大于核心线程数吗</title>
    <link href="http://luxiaowan.github.io/2020/05/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BD%93%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E6%9C%AA%E6%BB%A1%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%B8%80%E5%AE%9A%E4%B8%8D%E5%A4%A7%E4%BA%8E%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%90%97/"/>
    <id>http://luxiaowan.github.io/2020/05/28/线程池中运行的线程，当等待队列未满的情况下，一定不大于核心线程数吗/</id>
    <published>2020-05-28T03:17:00.000Z</published>
    <updated>2020-05-28T09:38:56.730Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="https://luxiaowan.github.io/2020/05/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E/">《线程池内运行的线程抛异常，线程池会怎么办》</a>了解到当线程执行的任务出现异常时，会将当前线程移出线程池，并新增一个线程到线程池中，我们先来回顾一下线程池的运行原理：</p><img src="/images/tpe-process.png" alt="tpe-process" style="zoom:50%;"><p>从原理图中可以看到只有当队列满了之后，才会去创建新的线程执行新加入的任务，那么到底有没有可能出现队列未满， 但是运行中的线程个数大于核心线程数？</p><p>理论上应该是不可能大于核心线程数，那么有没有意外呢？答案暂时不揭晓，我们先往下看，写几个demo测试一下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span> + (<span class="number">10</span> / finalI));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>​第一列为线程hashcode，第二列为阻塞队列中的任务个数，第三列为计算数字</p></blockquote><img src="/images/image-20200528132623899.png" alt="image-20200528132623899" style="zoom:50%;"><p>从控制台的输出能看到一共出现了4个不同的hashcode，也就表示创建过4个线程，然后线程1869318657执行任务时出现了异常，也就是除0异常，然后将其从线程池中移出，后续不再进行任务处理。从之前的文章中我们知道将异常的线程移除之后会重新创建一个线程加入到线程池中，那么正常情况下，线程池移除一个再加入一个，数量应该不变，但是从下面的输出看到这时同时有3个线程在处理任务，但是我们的核心线程数是2，为什么会出现3？</p><p>我们再来看下任务发生异常时的后续处理代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从runWorker方法中传过来的是true，所以这句目前版本中必定会被执行到</span></span><br><span class="line">  <span class="comment">// 作用是将当前线程池中的有效线程数-1，意思也就是出现异常的线程会被从线程池中拿掉</span></span><br><span class="line">  <span class="comment">// 为什么说是出现异常的线程会被拿掉呢？因为在try内部是一个while循环，除非关闭核心线程或运行中线程出现异常，否则不会执行到这里</span></span><br><span class="line">  <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">    decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 更新完成的任务数，只要是被线程池线程执行过的，不管是否出现异常，都被认为是执行成功的任务</span></span><br><span class="line">    completedTaskCount += w.completedTasks;</span><br><span class="line">    <span class="comment">// 将当前Worker线程从线程池中移除销毁</span></span><br><span class="line">    workers.remove(w);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryTerminate();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一系列判断，主要是判断是否符合给线程池创建新的线程</span></span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">      <span class="comment">// 如果核心线程允许超时回收，则不去创建线程，因为有新任务来的时候会自动创建</span></span><br><span class="line">      <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">      <span class="comment">// 如果核心线程可以被回收，但是当前阻塞队列中不为空时，创建1个线程去执行任务</span></span><br><span class="line">      <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 校验当前运行的线程是否大于允许运行的线程数，比如核心线程数</span></span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ①...</span></span><br><span class="line">    <span class="comment">// 给线程池创建新的线程</span></span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在创建新线程时，会进行一系列判断，若判断全部通过，就会去给线程池的池子中创建一个新的工作线程，这里传入的core参数是false，也就是当成非核心线程来创建，难道问题出在这里？如果我此时运行的线程数小于等于核心线程数，那么再加进来一个非核心线程？我们来看看addWorker()方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// goto语法</span></span><br><span class="line">  retry:</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">        ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">           firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           ! workQueue.isEmpty()))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">      <span class="comment">// 判断当前运行的线程个数是否超过了最大线程数</span></span><br><span class="line">      <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">          wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">break</span> retry;</span><br><span class="line">      c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">      <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">        <span class="keyword">continue</span> retry;</span><br><span class="line">      <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...创建线程...</span></span><br><span class="line">  <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法addWorker()的源码中我们看到，当我们参数core传一个false进来时，会去校验当前工作中的线程个数是否超过了最大线程数，如果没有超过的话则创建新的线程，问题就出在这里，为什么？</p><p>在方法processWorkerExit()中，我们对核心线程数进行的比较，但是如果在①处有新的任务调用execute()进来，则发现工作线程未达到核心线程数，这个时候就会去创建一个核心线程，创建之后，线程池中的工作线程就有2个了，然后我们从processWorkerExit()中传过来的请求会去校验工作线程个数是否超过了最大线程数，在我们的demo代码中是肯定不会超过的，那么就又会去创建一个线程放到线程池中，这样线程池中的工作线程就有3个了，具体流程图如下</p><table><thead><tr><th>正常流程</th><th>异常流程</th><th>工作线程数</th></tr></thead><tbody><tr><td>execute()</td><td></td><td>0</td></tr><tr><td>—addWorker()</td><td></td><td>1</td></tr><tr><td>execute()</td><td></td><td>1</td></tr><tr><td>—addWorker()</td><td></td><td>2</td></tr><tr><td></td><td>processWorkerExit()</td><td>2</td></tr><tr><td></td><td>—remove()</td><td>1</td></tr><tr><td>execute()</td><td></td><td>1</td></tr><tr><td>—addWorker()</td><td></td><td>2</td></tr><tr><td></td><td>—addWorker()</td><td>3</td></tr></tbody></table><blockquote><p>这就是为什么我们核心线程数是2，但是最终运行中的线程个数是3的原因</p></blockquote><hr><h4 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 🌰场景</h4><ol><li><p>任务尚未全部进入到队列中，队列未满</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span> + (<span class="number">10</span> / finalI));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/image-20200528132623899.png" alt="image-20200528132623899" style="zoom:50%;"><p>这个也就是我们上面跑的demo，工作线程个数超出了核心线程数。</p></li><li><p>任务已经全部进入到队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (finalI &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 前两个线程等待500毫秒，保证所有的任务都进入到队列中</span></span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(</span><br><span class="line">        Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span> + (<span class="number">10</span> / (finalI - <span class="number">4</span>)));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/image-20200528170037838.png" alt="image-20200528170037838" style="zoom:50%;"><p>我们看到当线程池开始执行任务时，已经把剩余的28个任务都放到队列中了，红色和蓝色下划线的线程是初始线程，当873出现异常后，将其移出线程池，然后创建一个新的线程执行队列中的剩余任务，因为这时所有的任务都在队列中等待被执行，execute()方法不会被调用，所以这种场景下，工作中的线程个数不会超过核心线程数。</p></li><li><p>任务尚未全部进入到队列中，队列已满，未达到最大线程数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">34</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (finalI &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 等待任务全部进入到队列中，且创建完额外线程接收多出来的两个任务</span></span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span></span><br><span class="line">                         + pool.getActiveCount() + <span class="string">", "</span> + (<span class="number">10</span> / (finalI - <span class="number">33</span>)));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>​第一列为线程hashcode，第二列为阻塞队列中的任务个数，第三列为当前的工作线程个数，第四列为计算数字</p></blockquote><img src="/images/image-20200528173106691.png" alt="image-20200528173106691" style="zoom:67%;"><p>从结果中我们看到创建了4个工作线程去执行任务，当线程230执行异常之后，创建了线程734继续执行，线程个数未超过最大线程数</p></li><li><p>任务尚未全部进入到队列中，队列已满，达到最大线程数</p><p>这种情况就会依据拒绝策略执行相关的代码逻辑，线程数不会超过最大线程数</p></li></ol><hr><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>从以上分析我们可以得出，只有在：任务尚未全部进入到队列中且队列未满的情况下，才会出现工作线程个数大于核心线程数，所以我们在使用线程池的过程中，待执行的任务尽量捕获所有的异常情况，不要将其抛出到线程池中的线程里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过&lt;a href=&quot;https://luxiaowan.github.io/2020/05/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>线程池内运行的线程抛异常，线程池会怎么办</title>
    <link href="http://luxiaowan.github.io/2020/05/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://luxiaowan.github.io/2020/05/27/线程池内运行的线程抛异常，线程池会怎么办/</id>
    <published>2020-05-27T04:56:00.000Z</published>
    <updated>2020-05-28T09:38:46.197Z</updated>
    
    <content type="html"><![CDATA[<p>通过文章<a href="https://luxiaowan.github.io/2020/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%AD%E7%AD%89%E5%BE%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%90%97/">《线程池运行的线程和队列中等待的线程是同一个吗》</a>我们了解到线程池中实际运行的是线程池自身的线程，只是在runWorker方法中调用了我们传递进入Runnable对象的run()方法，那么如果run()方法中出现异常了，那么要怎么处理？会不会将我们的线程池停掉？</p><p>我们先来看下runWorker()方法的具体逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  Thread wt = Thread.currentThread();</span><br><span class="line">  Runnable task = w.firstTask;</span><br><span class="line">  w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">  <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">           (Thread.interrupted() &amp;&amp;</span><br><span class="line">            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">          !wt.isInterrupted())</span><br><span class="line">        wt.interrupt();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        beforeExecute(wt, task);</span><br><span class="line">        Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterExecute(task, thrown);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task = <span class="keyword">null</span>;</span><br><span class="line">        w.completedTasks++;</span><br><span class="line">        w.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中我们看到，在调用用户Runnable实例方法run()的时候，进行了try…catch…finally，但是在catch()中是直接将异常抛出了，也就是说并未在while循环内消化掉，而是抛出给外层，这时会将while循环终止掉，然后在外层的try…finally中并未捕获内部传出的异常，所以异常信息会继续往上抛出，我们来关注一下这两层try的finally代码块，内部的finally中执行了一个空的方法afterExecute()，这个方法是留给我们自定义线程池时使用的，和beforeExecute()方法一样，既然是空方法，那我们就先不用去看它了，来看下外层的finally代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从runWorker方法中传过来的是true，所以这句目前版本中必定会被执行到</span></span><br><span class="line">  <span class="comment">// 作用是将当前线程池中的有效线程数-1，意思也就是出现异常的线程会被从线程池中拿掉</span></span><br><span class="line">  <span class="comment">// 为什么说是出现异常的线程会被拿掉呢？因为在try内部是一个while循环，除非关闭核心线程或运行中线程出现异常，否则不会执行到这里</span></span><br><span class="line">  <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">    decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 更新完成的任务数，只要是被线程池线程执行过的，不管是否出现异常，都被认为是执行成功的任务</span></span><br><span class="line">    completedTaskCount += w.completedTasks;</span><br><span class="line">    <span class="comment">// 将当前Worker线程从线程池中移除销毁</span></span><br><span class="line">    workers.remove(w);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryTerminate();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一系列判断，主要是判断是否符合给线程池创建新的线程</span></span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">      <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">      <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给线程池创建新的线程，core之所以传递false，是因为这里要防止创建失败</span></span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们看到在处理任务的过程中，如果线程出现异常，则会将该线程从线程池中移除销毁，然后再新创建一个线程加入到线程池中，也就是说在任务发生异常的时候，会终结掉运行它的线程。</p><blockquote><p>我们从源码中得到的信息，现在来验证一下我们的分析</p></blockquote><p>验证代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="number">10</span> / finalI - <span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><img src="/images/image-20200527152919795.png" alt="image-20200527152919795" style="zoom:70%;"><p>抛异常了，但是并未影响线程池中的其他任务，我们打断点在processWorkerExit()方法中，看下workers变量的数据</p><ul><li><p>异常发生之前</p><p><img src="/images/image-20200527154429404.png" alt="image-20200527154429404"></p></li><li><p>异常发生之后</p><p><img src="/images/image-20200527154504520.png" alt="image-20200527154504520"></p></li></ul><p>看到在异常前后，线程<code>1f36e637</code>被移除了，转而创建了一个<code>7073cb62</code>放到了线程池中，而未发生异常的线程<code>578486a3</code>依然存在于线程池中。</p><hr><blockquote><p>小结</p></blockquote><p>通过示例我们验证了一点：当任务出现未被捕获到的异常时，会将执行该任务的线程池中的线程从线程池移除并结束掉，然后移除之后创建一个新的线程放回到线程池中。</p><hr><p>上面我们知道了当线程执行的任务发生未被捕获的异常时，会将异常一直往上抛出，那么我们能否在主线程中捕获它进行处理呢？我们来试下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="number">10</span> / finalI - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      pool.execute(t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"发生了异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/images/image-20200527165519282.png" alt="image-20200527165519282"></p><p>由运行结果可以看出我们并未捕获到线程池中线程抛出的异常，也就是异常并未被抛出到主线程中，这就尴尬了，毕竟这些异常是和业务相关联的，我们却无法捕获和处理，这咋整呢？</p><p>忽的一下，想到了线程池的比较重要的一个参数：ThreadFactory接口，这个接口的作用是按需创建新线程的，使用线程工厂消除了对Thread#Thread(Runnable) new Thread的强依赖，使应用程序能够使用特殊的Thread子类、优先级等。大白话就是让线程池中的线程使用我们自定义的线程，这个自定义可不是我们通过execute()或submit()传进来的自定义线程，而是Worker类中的thread变量，也就是实际运行的线程，我们看一下Worker类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">  setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">  <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">  <span class="comment">// 调用ThreadFactory的newThread方法创建线程</span></span><br><span class="line">  <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中调用线程工厂的newThread()方法创建运行线程，我们上面通过ThreadPoolExecutor的构造方法创建线程池时并未传入ThreadFactory参数，那么就会使用默认的<code>Executors.defaultThreadFactory()</code>来创建线程，它的实现逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">    t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">    t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们要是想自定义Worker#thread的值的话，就自定义一个ThreadFactory实现类即可，比如我们可以把线程池创建语句升级为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(<span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="number">10</span> / finalI - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用lambda表达式来创建，使用Thread#setUncaughtExceptionHandler()方法来获取线程内未被捕获的异常，我们运行一下看看结果：</p><p><img src="/images/image-20200527175844897.png" alt="image-20200527175844897"></p><p>成功捕获了线程内部出现的异常。</p><hr><p>那么现在就又有一个问题了：如果我们主动捕获并处理线程内抛出的异常，那么这个线程还会从线程池中移除销毁吗？</p><p>我们来试下，还是使用上面的那段代码，然后断点打在processWorkerExit()方法中，看下执行结果</p><ul><li><p>异常之前</p><p><img src="/images/image-20200527180523846.png" alt="image-20200527180523846"></p></li><li><p>异常之后</p><p><img src="/images/image-20200527180634454.png" alt="image-20200527180634454"></p></li></ul><p>从执行结果来看，发生异常的线程是<code>35d176f7</code>，在异常发生之后同样从线程池中被移除了。</p><hr><blockquote><p>总结</p></blockquote><p>当线程池中线程执行任务的时候，任务出现未被捕获的异常的情况下，线程池会将允许该任务的线程从池中移除并销毁，且同时会创建一个新的线程加入到线程池中；可以通过ThreadFactory自定义线程并捕获线程内抛出的异常，也就是说甭管我们是否去捕获和处理线程池中工作线程抛出的异常，这个线程都会从线程池中被移除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过文章&lt;a href=&quot;https://luxiaowan.github.io/2020/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx配置RabbitMQ页面bug</title>
    <link href="http://luxiaowan.github.io/2020/05/26/Nginx%E9%85%8D%E7%BD%AERabbitMQ%E9%A1%B5%E9%9D%A2bug/"/>
    <id>http://luxiaowan.github.io/2020/05/26/Nginx配置RabbitMQ页面bug/</id>
    <published>2020-05-25T19:10:00.000Z</published>
    <updated>2020-05-25T19:15:24.686Z</updated>
    
    <content type="html"><![CDATA[<p>当使用Nginx来配置RabbitMQ的Web页面时，查看Exchange、Queue和Channels时，遇到了<code>the object you clicked on was not found it may have been deleted on the server.</code>，百思不得其解，整个代理都没有问题，配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  rabbitmq.xxx.com;</span><br><span class="line">    client_max_body_size   5m;</span><br><span class="line">    access_log acces.log;</span><br><span class="line">    error_log error.log;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        client_max_body_size   20m;</span><br><span class="line">        proxy_pass http://ip:port/;</span><br><span class="line"></span><br><span class="line">        port_in_redirect on;</span><br><span class="line">proxy_redirect  off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好像没问题，页面也可以正常访问，唯独查看不了消息的详细信息</p><h3 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h3><hr><p>最终瞎捣鼓，发现还是配置的问题，把proxy_pass修改为<code>proxy_pass http://ip:port</code>，把最后的<code>/</code>去掉即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当使用Nginx来配置RabbitMQ的Web页面时，查看Exchange、Queue和Channels时，遇到了&lt;code&gt;the object you clicked on was not found it may have been deleted on the se
      
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://luxiaowan.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Bug" scheme="http://luxiaowan.github.io/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器无法停止和删除</title>
    <link href="http://luxiaowan.github.io/2020/05/26/Docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E5%81%9C%E6%AD%A2%E5%92%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://luxiaowan.github.io/2020/05/26/Docker容器无法停止和删除/</id>
    <published>2020-05-25T17:38:00.000Z</published>
    <updated>2020-05-25T17:41:50.885Z</updated>
    
    <content type="html"><![CDATA[<p>1.停止容器</p><p>docker stop xxx-name</p><p>2.强制移除此容器</p><p>docker rm -f xxx-name</p><blockquote><p>如果出现Device or resource busy，则通过ps -ef | grep port查找容器进程pid，然后使用kill -9 pid停止进程</p></blockquote><p>3.清理此容器的网络占用</p><p>格式：docker network disconnect --force 网络模式 容器名称</p><p>示例：docker network disconnect --force bridge xxx-name</p><p>4.简查是否还有同名容器占用</p><p>格式：docker network inspect 网络模式<br>示例：docker network inspect bridge</p><p>5.重新构建容器</p><p>docker run xxx</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.停止容器&lt;/p&gt;
&lt;p&gt;docker stop xxx-name&lt;/p&gt;
&lt;p&gt;2.强制移除此容器&lt;/p&gt;
&lt;p&gt;docker rm -f xxx-name&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果出现Device or resource busy，则通过ps -e
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://luxiaowan.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Jenkins中创建项目时没有Maven项目</title>
    <link href="http://luxiaowan.github.io/2020/05/26/Jenkins%E4%B8%AD%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%B2%A1%E6%9C%89Maven%E9%A1%B9%E7%9B%AE/"/>
    <id>http://luxiaowan.github.io/2020/05/26/Jenkins中创建项目时没有Maven项目/</id>
    <published>2020-05-25T17:36:00.000Z</published>
    <updated>2020-05-25T17:38:10.178Z</updated>
    
    <content type="html"><![CDATA[<p>如果在创建项目时候，没有“创建一个Maven 项目”的选项，则需要安装Maven项目插件：Maven Integration plugin</p><p><img src="/images/image-20200526013750453.png" alt="image-20200526013750453"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果在创建项目时候，没有“创建一个Maven 项目”的选项，则需要安装Maven项目插件：Maven Integration plugin&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/image-20200526013750453.png&quot; alt=&quot;image-20
      
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://luxiaowan.github.io/categories/Jenkins/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker容器中安装vim</title>
    <link href="http://luxiaowan.github.io/2020/05/26/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AE%89%E8%A3%85vim/"/>
    <id>http://luxiaowan.github.io/2020/05/26/docker容器中安装vim/</id>
    <published>2020-05-25T17:35:00.000Z</published>
    <updated>2020-05-25T17:35:56.177Z</updated>
    
    <content type="html"><![CDATA[<p>在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: command not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package vim</span><br></pre></td></tr></table></figure><p>这时候需要敲：apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。</p><p>等更新完毕以后再敲命令：apt-get install vim命令即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: command not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：&lt;/p&gt;
&lt;figure class=&quot;highlight she
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://luxiaowan.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Jekins忘记admin密码</title>
    <link href="http://luxiaowan.github.io/2020/05/25/Jekins%E5%BF%98%E8%AE%B0admin%E5%AF%86%E7%A0%81/"/>
    <id>http://luxiaowan.github.io/2020/05/25/Jekins忘记admin密码/</id>
    <published>2020-05-25T15:59:00.000Z</published>
    <updated>2020-05-25T16:08:15.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-未修改admin的密码"><a class="markdownIt-Anchor" href="#一-未修改admin的密码"></a> 一、未修改admin的密码</h3><p>若未修改过admin的密码，那么我们可以通过查看<code>/var/jenkins_home/secrets/initialAdminPassword</code>文件来获取admin的初始密码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat <span class="regexp">/var/</span>jenkins_home<span class="regexp">/secrets/i</span>nitialAdminPassword</span><br></pre></td></tr></table></figure><h3 id="二-修改过admin的密码"><a class="markdownIt-Anchor" href="#二-修改过admin的密码"></a> 二、修改过admin的密码</h3><p>如果修改过admin的密码，那么就不能使用初始密码来解决了，可以通过以下步骤：</p><ol><li><p>删除Jenkins目录下config.xml文件中下面代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">useSecurity</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useSecurity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">authorizationStrategy</span> <span class="attr">class</span>=<span class="string">"hudson.security.FullControlOnceLoggedInAuthorizationStrategy"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">denyAnonymousReadAccess</span>&gt;</span>true<span class="tag">&lt;/<span class="name">denyAnonymousReadAccess</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizationStrategy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">securityRealm</span> <span class="attr">class</span>=<span class="string">"hudson.security.HudsonPrivateSecurityRealm"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">disableSignup</span>&gt;</span>true<span class="tag">&lt;/<span class="name">disableSignup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">enableCaptcha</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enableCaptcha</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">securityRealm</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>重启Jenkins</p></li><li><p>重新进入Jenkins，然后进入到<code>系统管理</code>-&gt;<code>全局安全配置(configure global security)</code></p><img src="/images/image-20200526000447792.png" alt="image-20200526000447792" style="zoom:50%;"></li><li><p>勾选<code>Jenkins专有用户数据库</code></p><img src="/images/image-20200526000537282.png" alt="image-20200526000537282" style="zoom:50%;"></li><li><p>回到<code>系统管理</code>页面，选择<code>管理用户</code></p><img src="/images/image-20200526000628607.png" alt="image-20200526000628607" style="zoom: 50%;"></li><li><p>选择用户设置</p><img src="/images/image-20200526000726021.png" alt="image-20200526000726021" style="zoom:50%;"></li><li><p>重置密码</p><img src="/images/image-20200526000747350.png" alt="image-20200526000747350" style="zoom:50%;"></li><li><p>重启Jenkins服务</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-未修改admin的密码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-未修改admin的密码&quot;&gt;&lt;/a&gt; 一、未修改admin的密码&lt;/h3&gt;
&lt;p&gt;若未修改过admin的密码，那么我们可以通过查看&lt;code&gt;/var/jenk
      
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://luxiaowan.github.io/categories/Jenkins/"/>
    
    
  </entry>
  
  <entry>
    <title>反序列化报错：Cannot Deserialize From Object Value (No Delegate- or Property-Based Creator)</title>
    <link href="http://luxiaowan.github.io/2020/05/22/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%A5%E9%94%99%EF%BC%9Acannot-deserialize-from-Object-value-(no-delegate--or-property-based-Creator)/"/>
    <id>http://luxiaowan.github.io/2020/05/22/反序列化报错：cannot-deserialize-from-Object-value-(no-delegate--or-property-based-Creator)/</id>
    <published>2020-05-22T15:50:00.000Z</published>
    <updated>2020-05-22T15:51:32.514Z</updated>
    
    <content type="html"><![CDATA[<p>反序列化报错：cannot deserialize from Object value (no delegate- or property-based Creator)</p><p>这个原因最根本的是没有找到无参构造方法，解决办法是给类加一个无参构造方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反序列化报错：cannot deserialize from Object value (no delegate- or property-based Creator)&lt;/p&gt;
&lt;p&gt;这个原因最根本的是没有找到无参构造方法，解决办法是给类加一个无参构造方法&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>Cannot Determine Value Type From String &#39;Xxxxxx&#39;</title>
    <link href="http://luxiaowan.github.io/2020/05/21/Cannot-determine-value-type-from-string-xxxxxx/"/>
    <id>http://luxiaowan.github.io/2020/05/21/Cannot-determine-value-type-from-string-xxxxxx/</id>
    <published>2020-05-21T11:40:00.000Z</published>
    <updated>2020-05-21T12:11:07.814Z</updated>
    
    <content type="html"><![CDATA[<p>在使用MyBatis的时候，若实体类上使用了lombok的@Builder注解，那么在查询数据做映射的时候会出现<code>Cannot determine value type from string 'xxxxxx'</code>错误，产生这个错误的原因是当使用了@Builder注解之后会默认把无参构造方法忽略掉，创建一个全参的构造方法，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long   id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被编译之后再反编译，变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    DemoBean(Long id, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DemoBean.<span class="function">DemoBeanBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoBean.DemoBeanBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...忽略setter、getter方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBeanBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        DemoBeanBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DemoBean.<span class="function">DemoBeanBuilder <span class="title">id</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DemoBean.<span class="function">DemoBeanBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DemoBean <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DemoBean(<span class="keyword">this</span>.id, <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DemoBean.DemoBeanBuilder(id="</span> + <span class="keyword">this</span>.id + <span class="string">", name="</span> + <span class="keyword">this</span>.name + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看到是没有默认构造方法，而MyBatis进行映射的时候会需要无参构造方法实例化一个类，所以我们再使用@Builder的时候，即使使用@NoArgsConstructor注解也无济于事，那我们该怎么办？</p><hr><p>在lombok中有一个@Tolerate注解，我们看下它的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Put on any method or constructor to make lombok pretend it doesn't exist,</span></span><br><span class="line"><span class="comment"> * i.e., to generate a method which would otherwise be skipped due to possible conflicts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Tolerate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释上的意思就是让lombok在扫描的时候假装被@Tolerate修饰的方法不存在，也就是会原封不动的被编译到字节码中，不会覆盖它，那么这样的话我们就可以进行骚操作了，修改原代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long   id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Tolerate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用MyBatis的时候，若实体类上使用了lombok的@Builder注解，那么在查询数据做映射的时候会出现&lt;code&gt;Cannot determine value type from string &#39;xxxxxx&#39;&lt;/code&gt;错误，产生这个错误的原因是当使用了@Bu
      
    
    </summary>
    
    
      <category term="BUG" scheme="http://luxiaowan.github.io/categories/BUG/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringCloud启动报错，提示The Following Method Did Not exist:CompositeHealthIndicator</title>
    <link href="http://luxiaowan.github.io/2020/05/21/SpringCloud%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%8C%E6%8F%90%E7%A4%BAThe-following-method-did-not-existCompositeHealthIndicator/"/>
    <id>http://luxiaowan.github.io/2020/05/21/SpringCloud启动报错，提示The-following-method-did-not-existCompositeHealthIndicator/</id>
    <published>2020-05-21T04:02:00.000Z</published>
    <updated>2020-05-21T15:26:49.989Z</updated>
    
    <content type="html"><![CDATA[<p>今天升级SpringBoot的版本，然后启动的时候懵逼了，报了个错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> Error starting Tomcat context. Exception: org.springframework.beans.factory.BeanCreationException. Message: Error creating bean with name 'servletEndpointRegistrar' defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web</span><br><span class="line"> </span><br><span class="line"> The web application [ROOT] appears to have started a thread named [spring.cloud.inetutils] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with <span class="string">'debug'</span> enabled.</span><br><span class="line"></span><br><span class="line">**An attempt was made to call a method that does not exist. The attempt was made from the following location:</span><br><span class="line"></span><br><span class="line">    org.springframework.cloud.client.discovery.health.DiscoveryCompositeHealthIndicator.&lt;init&gt;(DiscoveryCompositeHealthIndicator.java:<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">The following method did not exist:</span><br><span class="line"></span><br><span class="line">    org.springframework.boot.actuate.health.CompositeHealthIndicator.&lt;init&gt;(Lorg/springframework/boot/actuate/health/HealthAggregator;)V**</span><br></pre></td></tr></table></figure><p>翻了一下资料后，发现是SpringBoot和SpringCloud的版本不匹配，修改成一致的就行了</p><table><thead><tr><th style="text-align:left">Release Train</th><th style="text-align:left">Boot Version</th></tr></thead><tbody><tr><td style="text-align:left">Hoxton</td><td style="text-align:left">2.2.x</td></tr><tr><td style="text-align:left">Greenwich</td><td style="text-align:left">2.1.x</td></tr><tr><td style="text-align:left">Finchley</td><td style="text-align:left">2.0.x</td></tr><tr><td style="text-align:left">Edgware</td><td style="text-align:left">1.5.x</td></tr><tr><td style="text-align:left">Dalston</td><td style="text-align:left">1.5.x</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天升级SpringBoot的版本，然后启动的时候懵逼了，报了个错：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL自增主键用完了咋整？</title>
    <link href="http://luxiaowan.github.io/2020/05/19/MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%94%A8%E5%AE%8C%E4%BA%86%E5%92%8B%E6%95%B4/"/>
    <id>http://luxiaowan.github.io/2020/05/19/MySQL自增主键用完了咋整/</id>
    <published>2020-05-18T16:15:00.000Z</published>
    <updated>2020-05-18T16:31:42.594Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL自增主键会用完吗？我们先来看下在MySQL中，int和bigint两种类型的值域是多少，</p><table><thead><tr><th>类型</th><th>最小值</th><th>最大值</th><th>所占字节</th></tr></thead><tbody><tr><td>int(有符号)</td><td>-2^31</td><td>2^31</td><td>4</td></tr><tr><td>int(无符号)</td><td>0</td><td>2^32</td><td>4</td></tr><tr><td>bigint(有符号)</td><td>-2^63</td><td>2^63</td><td>8</td></tr><tr><td>bigint(无符号)</td><td>0</td><td>2^64</td><td>8</td></tr></tbody></table><p>当我们使用int(有符号)类型的时候，创建一张表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table test_ai (</span><br><span class="line">id int(10) auto_increment primary key,</span><br><span class="line">name varchar(11) not null</span><br><span class="line">) engine=InnoDB;</span><br></pre></td></tr></table></figure><p>执行两条SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert test_ai(id, name) values(2147483646, &apos;cc1&apos;);</span><br><span class="line">insert test_ai(name) values(&apos;cc2&apos;);</span><br><span class="line">insert test_ai(name) values(&apos;cc3&apos;);</span><br></pre></td></tr></table></figure><p>当执行到第三句SQL的时候就会报错<code>Duplicate entry '2147483647' for key 'PRIMARY'</code>，也就是说当我们的自增主键用完之后，就无法继续往表中新增数据了</p><h4 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h4><hr><p>我们在正常情况下，不会让单表存储那么大的数据量，所以一般不会出现这个问题，如果真的脑抽抽的在一张表中存储那么多数据，或者当数据迁移的时候造成了自增主键混乱，那么我们可以使用bigint(无符号)类型作为自增主键。</p><p>使用bigint(无符号)类型时，如果我们每秒插入1W条数据，不间断的跑100年，单表的数据量为：10000 * 3600 * 24 * 365 * 100 = 31536000000000，还远远小于2^64，完全不会被用完，如果操作正确的话。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL自增主键会用完吗？我们先来看下在MySQL中，int和bigint两种类型的值域是多少，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;最小值&lt;/th&gt;
&lt;th&gt;最大值&lt;/th&gt;
&lt;th&gt;所占字节&lt;/th&gt;
&lt;/tr&gt;
&lt;/th
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot内置Tomcat启动时间</title>
    <link href="http://luxiaowan.github.io/2020/05/15/SpringBoot%E5%86%85%E7%BD%AETomcat%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    <id>http://luxiaowan.github.io/2020/05/15/SpringBoot内置Tomcat启动时间/</id>
    <published>2020-05-15T10:22:00.000Z</published>
    <updated>2020-05-15T17:58:50.202Z</updated>
    
    <content type="html"><![CDATA[<h4 id="疑惑"><a class="markdownIt-Anchor" href="#疑惑"></a> 疑惑</h4><p>SpringBoot中内置了Tomcat容器，那么Tomcat是在什么时间点启动的？是先扫描包加载类再启动Tomcat？，还是先启动Tomcat再扫描包加载类？</p><p>我们做一下假设：</p><ol><li>先启动Tomcat，再扫描包加载类</li><li>先扫描包加载类，再启动Tomcat</li></ol><p>接下来我们做一下验证。</p><h4 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h4><p>首先创建一个空的SpringBoot工程，然后启动它，查看一下控制台的输出日志：</p><img src="/images/image-20200515183550832.png" alt="image-20200515183550832" style="zoom:50%;"><p>从输出的日志中可以看到②中显示Tomcat进行初始化，并且正在启动中，然后③中进行初始化<code>WebApplicationContext</code>，紧接着就是初始化<code>WebApplicationContext</code>完成，然后是在④中报告我们Tomcat启动完成。</p><p>从日志上看，好像是先启动Tomcat再去扫描包的，具体是怎么回事，我们看一下源码，暂时先不揭晓。</p><ul><li><p>从启动类中进入到<code>SpringApplication.run()</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建启动监控类，监控启动过程用了多久，但是ms</span></span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  <span class="comment">// 开始计时，设置开始时间</span></span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="comment">// 上下文实例</span></span><br><span class="line">  ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 启动异常错误报告</span></span><br><span class="line">  Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 启用headless模式（headless模式是在系统缺少部分硬件支持的时候让服务自力更生）</span></span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line">  <span class="comment">// 获取spring.factories文件中配置的org.springframework.boot.SpringApplicationRunListener列表，原理是Spring的事件机制，所有的类都实现自ApplicationEvent，可以监听启动过程中的任意阶段</span></span><br><span class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">  <span class="comment">// 进入监听启动阶段</span></span><br><span class="line">  listeners.starting();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取JVM运行参数，也就是在使用java -jar xxx.jar命令启动时指定的其他参数</span></span><br><span class="line">    ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">    <span class="comment">// 准备运行环境，传入监听器和运行参数，获取环境变量，绑定到环境中</span></span><br><span class="line">    ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">    <span class="comment">// 配置spring.beaninfo.ignore属性，SpringBoot中默认为true</span></span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line">    <span class="comment">// 输出Banner信息，banner的输出方式有三种：none/console/log，默认为console，通过配置参数spring.main.banner-mode指定</span></span><br><span class="line">    Banner printedBanner = printBanner(environment);</span><br><span class="line">    <span class="comment">// ☆创建一个上下文实例，比较重点的地方☆</span></span><br><span class="line">    context = createApplicationContext();</span><br><span class="line">    <span class="comment">// 获取spring.factories文件中声明的SpringBootExceptionReporter</span></span><br><span class="line">    exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                                                     <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">    <span class="comment">// 创建上下文，设置环境变量和资源加载器，创建bean，加载到所有的listener中</span></span><br><span class="line">    prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">    <span class="comment">// 调用spring的refresh方法，并注册一个ShutdownHook（应用关闭时的动作，可以通过继承AbstractApplicationContext实现自定义）</span></span><br><span class="line">    refreshContext(context);</span><br><span class="line">    <span class="comment">// 空方法</span></span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line">    <span class="comment">// 启动完成，停止计时</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">      <span class="comment">// 输出启动信息，包括计时</span></span><br><span class="line">      <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入监听器的启动完成事件</span></span><br><span class="line">    listeners.started(context);</span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 进入监听器的运行中事件</span></span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中并未看到是在哪里启动了Tomcat容器，那么我们就看一下创建Spring上下文的方法中是否有关键字</p></li><li><p>createApplicationContext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">  <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">        <span class="keyword">case</span> SERVLET:</span><br><span class="line">          <span class="comment">// org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REACTIVE:</span><br><span class="line">          <span class="comment">// org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// org.springframework.context.annotation.AnnotationConfigApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个创建<code>ApplicationContext</code>实例的方法，我们只看Tomcat的<code>AnnotationConfigServletWebServerApplicationContext</code>，他的继承关系如下</p><p><img src="/images/AnnotationConfigServletWebServerApplicationContext.png" alt="AnnotationConfigServletWebServerApplicationContext"></p><p>以上类中并没有在静态代码块中启动Tomcat，则说明不是在这里启动的，这里只是创建一个<code>ApplicationContext</code>上下文实例</p></li><li><p>prepareContext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置环境变量</span></span><br><span class="line">  context.setEnvironment(environment);</span><br><span class="line">  <span class="comment">// 处理上下文</span></span><br><span class="line">  postProcessApplicationContext(context);</span><br><span class="line">  <span class="comment">// 做refresh前的初始化准备</span></span><br><span class="line">  applyInitializers(context);</span><br><span class="line">  <span class="comment">// 进入到监听器的上下文准备阶段</span></span><br><span class="line">  listeners.contextPrepared(context);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">    logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">    logStartupProfileInfo(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建特殊的引导类实例，单例的</span></span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">  beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">  <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建Banner类实例，单例的</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">    ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">    .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">    context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Load the sources</span></span><br><span class="line">  Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">  Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">  load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">  listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法里整个过程都在创建各种类的实例，并未出现对Tomcat的启动操作，看来也不在这个方法中，那么就继续往下看</p></li><li><p>refreshContext()方法</p><p>这个方法最终是调用到<code>AbstractApplicationContext#refresh()</code>中，这就到了Spring基础框架中。我们在分析createApplicationContext()方法的时候，知道Tomcat使用的是<code>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</code>类，这个类继承自<code>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext</code>，在这个类中，重写了父类<code>AbstractApplicationContext</code>中的refresh()、onRefresh()和finishRefresh()方法，而在<code>AbstractApplicationContext#refresh()</code>方法中，调用了onRefresh()和finishRefresh()这两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用的onRefresh()和finishRefresh()实际上是调用了<code>ServletWebServerApplicationContext</code>中的方法，那么我们就来看下这个类中的这两个方法分别做了什么</p><ul><li>onRefresh()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类的onRefresh()方法</span></span><br><span class="line">  <span class="keyword">super</span>.onRefresh();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建WebServer</span></span><br><span class="line">    createWebServer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Unable to start web server"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">  ServletContext servletContext = getServletContext();</span><br><span class="line">  <span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取ServletWebServerFactory的实例，使用Tomcat的话会获取到tomcatServletWebServerFactory</span></span><br><span class="line">    ServletWebServerFactory factory = getWebServerFactory();</span><br><span class="line">    <span class="comment">// 获取WebServer实例，方法内创建Tomcat并准备Tomcat启动所需环境变量</span></span><br><span class="line">    <span class="keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getSelfInitializer().onStartup(servletContext);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化自定义的环境变量，涉及到servletContextInitParams和servletConfigInitParams</span></span><br><span class="line">  initPropertySources();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ServletWebServerFactory <span class="title">getWebServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用bean名称，这样我们就不会考虑层次结构</span></span><br><span class="line">  String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class="line">  <span class="keyword">if</span> (beanNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取Bean实例，这里获取到的就是TomcatServletWebServerFactory类的实例</span></span><br><span class="line">  <span class="keyword">return</span> getBeanFactory().getBean(beanNames[<span class="number">0</span>], ServletWebServerFactory.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码我们知道在onRefresh()方法中主要是创建Tomcat实例，准备Tomcat启动所需参数和配置信息，并未启动Tomcat</p><ul><li>finishRefresh()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.finishRefresh();</span><br><span class="line">  <span class="comment">// 启动WebServer，难道是这里启动的Tomcat？</span></span><br><span class="line">  WebServer webServer = startWebServer();</span><br><span class="line">  <span class="keyword">if</span> (webServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    publishEvent(<span class="keyword">new</span> ServletWebServerInitializedEvent(webServer, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> WebServer <span class="title">startWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">  <span class="keyword">if</span> (webServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 启动WebServer，这里调用的是TomcatWebServer#start()方法</span></span><br><span class="line">    webServer.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> webServer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TomcatWebServer#start()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">  <span class="comment">// 加锁防并发</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.started) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      addPreviouslyRemovedConnectors();</span><br><span class="line">      <span class="comment">// 获取Tomcat的Connector</span></span><br><span class="line">      Connector connector = <span class="keyword">this</span>.tomcat.getConnector();</span><br><span class="line">      <span class="keyword">if</span> (connector != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.autoStart) &#123;</span><br><span class="line">        <span class="comment">// 如果connector不为null，并且自动启动，则启动时执行延迟加载</span></span><br><span class="line">        <span class="comment">// 当端口大于0的时候，autoStart就为true</span></span><br><span class="line">        performDeferredLoadOnStartup();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查Connector是否已启动，若有未启动的Connector则抛异常</span></span><br><span class="line">      checkThatConnectorsHaveStarted();</span><br><span class="line">      <span class="comment">// 修改运行标识属性</span></span><br><span class="line">      <span class="keyword">this</span>.started = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 输出Tomcat启动成功日志</span></span><br><span class="line">      logger.info(<span class="string">"Tomcat started on port(s): "</span> + getPortsDescription(<span class="keyword">true</span>) + <span class="string">" with context path '"</span></span><br><span class="line">                  + getContextPath() + <span class="string">"'"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectorStartFailedException ex) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里好像也仅仅就是检测Tomcat服务是否启动成功了，并没有执行启动这个操作，看来也不在这里。</p><p>这就奇怪了，我们几乎翻遍了整个启动类的代码，都没有Tomcat启动的代码，那么Tomcat是怎么启动的呢？是不是我们遗漏了什么？我们来回顾一下上面的分析，TomcatWebServer实例的获取的地方<code>ServletWebServerFactory#getWebServer()</code>方法内我们好像没有看，是不是在创建TomcatWebServer实例的时候直接就启动了，然后在<code>TomcatWebServer#start()</code>方法中只是去检测启动的状态？我们来看下<code>ServletWebServerFactory#getWebServer()</code>的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebServer <span class="title">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.disableMBeanRegistry) &#123;</span><br><span class="line">    Registry.disableRegistry();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 简单略过</span></span><br><span class="line">  Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">  File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span>) ? <span class="keyword">this</span>.baseDirectory : createTempDir(<span class="string">"tomcat"</span>);</span><br><span class="line">  tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">  Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">  connector.setThrowOnFailure(<span class="keyword">true</span>);</span><br><span class="line">  tomcat.getService().addConnector(connector);</span><br><span class="line">  customizeConnector(connector);</span><br><span class="line">  tomcat.setConnector(connector);</span><br><span class="line">  tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">  configureEngine(tomcat.getEngine());</span><br><span class="line">  <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">    tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">  &#125;</span><br><span class="line">  prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">  <span class="comment">// 获取TomcatWebServer实例</span></span><br><span class="line">  <span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不重要</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TomcatWebServer <span class="title">getTomcatWebServer</span><span class="params">(Tomcat tomcat)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// autoStart = getPort() &gt;= 0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatWebServer</span><span class="params">(Tomcat tomcat, <span class="keyword">boolean</span> autoStart)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(tomcat, <span class="string">"Tomcat Server must not be null"</span>);</span><br><span class="line">  <span class="keyword">this</span>.tomcat = tomcat;</span><br><span class="line">  <span class="keyword">this</span>.autoStart = autoStart;</span><br><span class="line">  <span class="comment">// 最重要的方法</span></span><br><span class="line">  initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>initialize()方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动服务器以触发初始化侦听器</span></span><br><span class="line">      <span class="keyword">this</span>.tomcat.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 所有Tomcat线程都是守护进程线程。我们创建一个阻塞非守护进程来停止立即关闭</span></span><br><span class="line">      startDaemonAwaitThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      stopSilently();</span><br><span class="line">      destroySilently();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> WebServerException(<span class="string">"Unable to start embedded Tomcat"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于找到了，语句<code>this.tomcat.start()</code>就是启动Tomcat容器的关监语句。</p></li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>通过对SpringApplication.run()方法执行顺序的分析来看，先构建Spring上下文加载Bean，也就是扫描包，然后再在refreshContext()方法中创建Tomcat容器并启动容器。</p><p>由此我们可以验证出假设2是正确的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;疑惑&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#疑惑&quot;&gt;&lt;/a&gt; 疑惑&lt;/h4&gt;
&lt;p&gt;SpringBoot中内置了Tomcat容器，那么Tomcat是在什么时间点启动的？是先扫描包加载类再启动Tomcat？，还是先启动Tomcat
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM指针碰撞和空闲列表</title>
    <link href="http://luxiaowan.github.io/2020/05/12/JVM%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8/"/>
    <id>http://luxiaowan.github.io/2020/05/12/JVM指针碰撞和空闲列表/</id>
    <published>2020-05-12T02:40:00.000Z</published>
    <updated>2020-05-12T03:17:43.831Z</updated>
    
    <content type="html"><![CDATA[<p>Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，在堆上为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，将对象放进去。常用的分配方法有指针碰撞和空闲列表两种实现方式。</p><h4 id="指针碰撞"><a class="markdownIt-Anchor" href="#指针碰撞"></a> 指针碰撞</h4><p>适用于堆内存完整的情况，已分配的内存和空闲内存分表在不同的一侧，通过一个指针指向分界点，当需要分配内存时，把指针往空闲的一端移动与对象大小相等的距离即可，用于Serial和ParNew等不会产生内存碎片的垃圾收集器。</p><img src="/images/image-20200512111153143.png" alt="image-20200512111153143" style="zoom:50%;"><h4 id="空闲列表"><a class="markdownIt-Anchor" href="#空闲列表"></a> 空闲列表</h4><p>适用于堆内存不完整的情况，已分配的内存和空闲内存相互交错，JVM通过维护一张内存列表记录可用的内存块信息，当分配内存时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录，最常见的使用此方案的垃圾收集器就是CMS。</p><img src="/images/image-20200512111650404.png" alt="image-20200512111650404" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，在堆上为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，将对象放进去。常用的分配方法有指针碰撞和空闲列表两种实现方式。&lt;/p&gt;
&lt;h4 id=&quot;指针碰撞&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>监听Redis中key过期事件</title>
    <link href="http://luxiaowan.github.io/2020/05/11/%E7%9B%91%E5%90%ACRedis%E4%B8%ADkey%E8%BF%87%E6%9C%9F%E4%BA%8B%E4%BB%B6/"/>
    <id>http://luxiaowan.github.io/2020/05/11/监听Redis中key过期事件/</id>
    <published>2020-05-11T15:20:00.000Z</published>
    <updated>2020-05-11T17:11:16.136Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中偶尔会遇到这样一个场景：用户下单之后，若30分钟内未完成支付，则取消订单。</p><p>做过电商业务的同学，尤其是做统一下单业务的同学一般都会接触过这个场景的需求，一般的处理方式是将订单数据存储到数据库中（MySQL之类的），然后由一个定时Job不断的去扫描符合条件的订单，修改订单状态为已取消。当然这只是其中一个处理办法，我们还可以使用到延时队列来处理。</p><p>那么如果我们使用Redis是否可以实现这一功能？我们知道在使用Redis的过程中，大多是由客户端主动的去操作服务端，比如set、del、get、expire等操作。而当一个key过期被删除的时候，由服务端主动的去通知客户端，这个要怎么做？</p><p>之前在一个项目中，是自己写了一个定时Job不断是去轮询要监听的某些key，然后如果发现Redis中不存在要get的key，则执行一段业务逻辑，我们的扫描频率取决于Job的执行频率，所以并不能保证key在过期时被立即监听到，如果n秒执行一次，则key最大可能会在2n-1秒之后被执行，会有一定的延迟，那么我们能否让Redis主动的在缓存失效的时候通知我们呢？</p><h4 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h4><p>由服务端主动通知客户端，那么就是需要通过一个事件来触发某项通知，事件通过Redis的订阅和发布功能来进行分发，我们查看Redis的配置文件中有一个EVENT NOTIFICATION配置，也名键空间通知</p><p><img src="/images/image-20200512002406401.png" alt="image-20200512002406401"></p><p>注释上说：Redis可以通知发布/订阅客户端关于键空间中发生的事件，如果Redis开启了键空间事件通知，且客户端订阅了某些键的事件，则在相应的键发生变动时，会通过发布/订阅向客户端发送两条消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:foo del</span><br><span class="line">PUBLISH __keyevent@0__:del foo</span><br></pre></td></tr></table></figure><p>客户端可以在一组类中选择Redis的通知事件，每个类都需要由唯一字符进行标识。</p><h5 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h5><p>当开启键空间通知功能时，需要额外的消耗一些CPU，所以此功能默认为关闭状态，可以通过修改redis.conf文件或者使用config set命令来开启或关闭键空间通知功能</p><ul><li>当<code>notify-keyspace-events</code>的值为空字符串时，功能关闭</li><li>当参数的值不是空字符串时，功能开启，且参数的值的取值范围是固定的</li></ul><blockquote><p>参数的可选值</p></blockquote><table><thead><tr><th>字符</th><th>通知事件</th></tr></thead><tbody><tr><td><code>K</code></td><td>键空间通知，所有通知以 <code>__keyspace@__</code> 为前缀</td></tr><tr><td><code>E</code></td><td>键事件通知，所有通知以 <code>__keyevent@__</code> 为前缀</td></tr><tr><td><code>g</code></td><td><code>DEL</code> 、 <code>EXPIRE</code> 、 <code>RENAME</code> 等类型无关的通用命令的通知</td></tr><tr><td><code>$</code></td><td>字符串命令的通知</td></tr><tr><td><code>l</code></td><td>列表命令的通知</td></tr><tr><td><code>s</code></td><td>集合命令的通知</td></tr><tr><td><code>h</code></td><td>哈希命令的通知</td></tr><tr><td><code>z</code></td><td>有序集合命令的通知</td></tr><tr><td><code>x</code></td><td>过期事件：每当有过期键被删除时发送</td></tr><tr><td><code>e</code></td><td>驱逐(evict)事件：每当有键因为 <code>maxmemory</code> 政策而被删除时发送</td></tr><tr><td><code>A</code></td><td>参数 <code>g$lshzxe</code> 的别名</td></tr></tbody></table><p>输入的参数中至少要有一个<code>K</code>或<code>E</code>来指定通知类型，否则配置不会生效</p><h5 id="过期通知事件"><a class="markdownIt-Anchor" href="#过期通知事件"></a> 过期通知事件</h5><p>在Redis中有两种方式将key删除：</p><ol><li>当一个键被访问时，Redis会对这个键进行检查，如果键已经过期，则将该键删除</li><li>Redis后台会定期删除那些已经过期的键</li></ol><p>当过期键被删除时，Redis会产生一个expired通知。在此要理解一点，就是并不是当key的TTL变为0时就会立即被删除，所以Redis产生expired通知的时间为键被删除的时候而不是键的TTL变为0的时候。</p><p>依据上述表格，我们可以将<code>notify-keyspace-events</code>设置为<code>Ex</code>，表示键过期事件通知。</p><h5 id="java应用中通知监控"><a class="markdownIt-Anchor" href="#java应用中通知监控"></a> Java应用中通知监控</h5><p>Spring Data Redis 实现发布订阅功能非常简单，只有这样的几个类：<code>Topic</code>、<code>MessageListener</code>、<code>RedisMessageListenerContainer</code>。下面对它们进行解释：</p><p><code>org.springframework.data.redis.listener.Topic</code>消息发送者与接收者之间的 channel 定义，有两个实现类：</p><ol><li><code>org.springframework.data.redis.listener.ChannelTopic</code>：一个确定的字符串</li><li><code>org.springframework.data.redis.listener.PatternTopic</code>：基于模式匹配</li></ol><p><code>org.springframework.data.redis.connection.MessageListener</code>一个回调接口，消息监听器，用于接收发送到 channel 的消息，接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.redis.connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听Redis的订阅通知</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Costin Leau</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christoph Strobl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当从Redis接收到通知后的回调方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message message must not be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern pattern matching the channel (if specified) - can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, @Nullable <span class="keyword">byte</span>[] pattern)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.data.redis.listener.RedisMessageListenerContainer</code>用于消息监听，需要将 <code>Topic</code>和<code>MessageListener</code>注册到<code>RedisMessageListenerContainer</code>中，当 Topic 上有消息时，由<code>RedisMessageListenerContainer</code>通知<code>MessageListener</code>，客户端通过onMessage()拿到消息后，自行处理。</p><ul><li><p>引入redis的依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>RedisMessageListenerContainer</code>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.RedisMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisListenerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建key过期事件监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.KeyExpirationEventMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.RedisMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpirationListener</span> <span class="keyword">extends</span> <span class="title">KeyExpirationEventMessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisKeyExpirationListener</span><span class="params">(RedisMessageListenerContainer listenerContainer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(listenerContainer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        String key = message.toString();</span><br><span class="line">        System.out.println(<span class="string">"监听到key: "</span> + key + <span class="string">" 过期!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在工作中偶尔会遇到这样一个场景：用户下单之后，若30分钟内未完成支付，则取消订单。&lt;/p&gt;
&lt;p&gt;做过电商业务的同学，尤其是做统一下单业务的同学一般都会接触过这个场景的需求，一般的处理方式是将订单数据存储到数据库中（MySQL之类的），然后由一个定时Job不断的去扫描符合条
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jcmd</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjcmd/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jcmd/</id>
    <published>2020-05-11T10:21:00.000Z</published>
    <updated>2020-05-11T12:21:17.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>在jdk1.7之后，jdk命令家族新增了一个特牛的命令：jcmd，它是一个多功能的根据，汇集了jps、jmap、jstack、jinfo、jstat等多个命令的功能，也就是我们之前要使用多个JVM命令才能达到的目的，现在只需要使用一个jcmd命令即可。</p><p><img src="/images/image-20200511182956340.png" alt="image-20200511182956340"></p><ul><li>jcmd &lt;pid | main class&gt; &lt;command … | PerfCounter.print | -f file&gt;<ul><li>pid：Java进程ID</li><li>main class：Java进程的main类，main类名称可以使用通配符，如果正在运行的进程中有多个进程的main类名称相同，则会将诊断命令请求发送到所有的命中进程中</li><li>command：诊断指令参数，可以通过<code>jcmd pid help</code>查看进程支持的参数</li><li>PerfCounter.print：打印Java进程上可用的性能计数器，该计数器的列表会随着Java进程的不同而发生变化</li><li>-f file：从文件file中读取命令并在目标Java进程上执行这些命令。在文件中，每个命令必须单独的写在一行里，以<code>#</code>开头的行会被忽略，当所有行都被调用完毕之后，或者读取到stop命令，将会终止对file的处理</li></ul></li><li>-l：列出JVM进程</li><li>-h：显示帮助信息</li></ul><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><ol><li><p>jcmd -l</p><p>查看当前机器上所有的jvm进程信息，与<code>jps -l</code>、<code>jcmd</code>命令效果一样</p><p><img src="/images/image-20200511193521904.png" alt="image-20200511193521904"></p></li><li><p>jcmd pid PerfCounter.print</p><p>查看指定进程的性能统计信息，相当于<code>jstat -J-Djstat.showUnsupported=true -snap pid</code>效果一样</p><p><img src="/images/image-20200511193725364.png" alt="image-20200511193725364"></p></li><li><p>jcmd pid help</p><p>查看指定进程支持的操作参数</p><p><img src="/images/image-20200511193818369.png" alt="image-20200511193818369"></p></li><li><p>jcmd pid help command</p><p>查看指定命令的帮助信息</p><p><img src="/images/image-20200511193938227.png" alt="image-20200511193938227"></p></li><li><p>jcmd pid VM.uptime</p><p>查看虚拟机的运行时长</p><p><img src="/images/image-20200511194101355.png" alt="image-20200511194101355"></p></li><li><p>jcmd pid VM.classloader_stats</p><p>查看类加载器信息，等同于<code>jmap -clstats</code>命令</p><p><img src="/images/image-20200511194314593.png" alt="image-20200511194314593"></p></li><li><p>jcmd pid Thread.print</p><p>打印Java进程的线程信息，与<code>jstack</code>效果一样</p><p><img src="/images/image-20200511194510978.png" alt="image-20200511194510978"></p></li><li><p>jcmd pid GC.class_histogram</p><p>查看进程中的类统计信息，与<code>jmap -histo</code>效果一样</p><p><img src="/images/image-20200511194712997.png" alt="image-20200511194712997"></p></li><li><p>jcmd pid GC.heap_dump filepath</p><p>生成堆转储文件，与<code>jmap -dump:format=b,file=a.hprof</code>效果一样</p><p><img src="/images/image-20200511194938288.png" alt="image-20200511194938288"></p></li><li><p>jcmd pid GC.heap_info</p><p>查看JVM的堆信息，与<code>jmap -heap</code>效果一样</p><p><img src="/images/image-20200511195121583.png" alt="image-20200511195121583"></p></li><li><p>jcmd pid GC.finalizer_info</p><p>查看正在等待回收的对象信息，与<code>jmap -finalizerinfo</code>效果一样</p></li><li><p>jcmd pid GC.run</p><p>告诉垃圾收集器进行垃圾收集，等于是对JVM执行了<code>System.gc()</code></p></li><li><p>jcmd pid VM.version</p><p>查看JVM当前版本，和<code>jinfo pid | grep version</code>效果一样</p><p><img src="/images/image-20200511200800384.png" alt="image-20200511200800384"></p></li><li><p>jcmd pid VM.system_properties</p><p>查看JVM系统属性信息，和<code>jinfo</code>效果一样</p><p><img src="/images/image-20200511200911867.png" alt="image-20200511200911867"></p></li><li><p>jcmd pid VM.flags</p><p>查看JVM的启动参数，与<code>jinfo -flags</code>效果一样</p><p><img src="/images/image-20200511202039543.png" alt="image-20200511202039543"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;在jdk1.7之后，jdk命令家族新增了一个特牛的命令：jcmd，它是一个多功能的根据，汇集了jps、jmap、jstack、jinfo、jst
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jmap</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjmap/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jmap/</id>
    <published>2020-05-11T07:40:00.000Z</published>
    <updated>2020-05-11T10:02:02.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>jmap是一个多功能命令，它可以生成Java应用的dump文件，也可以查看堆内对象的统计信息、查看ClassLoader信息和finalizer队列等，但是jmap会将整个JVM的线程全部暂停，所以在生产环境中慎重jmap命令。</p><img src="/images/image-20200511155155703.png" alt="image-20200511155155703" style="zoom:50%;"><blockquote><p>参数</p></blockquote><ul><li>option：选项参数</li><li>pid：进程ID</li><li>executable：生成核心dump的Java可执行文件</li><li>core：需要打印配置信息的核心文件</li><li>server_id：唯一服务ID，若一台主机上开启了多个远程debug服务</li><li>remote server IP or hostname：远程debug服务的主机名或IP</li></ul><blockquote><p>option选项</p></blockquote><ul><li>none：查看进程的内存映像信息，和Solaris的pmap命令类似</li><li>heap：显示JVM堆详细信息</li><li>histo[:live]：打印堆中对象的统计信息，<code>:live</code>子选项是指定仅打印出存活的对象</li><li>clstats：打印类加载器信息</li><li>finalizerinfo：显示正在准备被回收的对象信息</li><li>dump:&lt;dump-options&gt;：生成堆转储快照<ul><li>live：仅转储堆中存活的对象</li><li>format=b：二进制方式</li><li>file：堆转储快照文件</li></ul></li><li>F：当dump或histo没有响应时，使用该参数可以强制执行，但是若子选项是<code>:live</code>则使用-F也无效</li><li>h | help：显示命令的帮助信息</li><li>j&lt;flag&gt;：给运行中的JVM传参数给jmap</li></ul><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><blockquote><p>准备：启动一个死循环的main方法</p><p>通过jps命令查看应用的pid</p><p>pid：10456</p></blockquote><ol><li><p>jmap pid</p><p>查看进程的内存映像信息</p><img src="/images/image-20200511162040121.png" alt="image-20200511162040121" style="zoom:50%;"></li><li><p>jmap -heap pid</p><p>显示JVM堆详细信息</p><p><img src="/images/image-20200511162552365.png" alt="image-20200511162552365"></p></li><li><p>jmap -histo:live pid</p><p>显示堆中存活的对象的统计信息，信息包含每个存活的Java类、对象数量、内存大小（从大到小排列，单位：字节）、类全限定名</p><p><img src="/images/image-20200511173916727.png" alt="image-20200511173916727"></p></li><li><p>jmap -clstats pid</p><p>打印类加载器信息，信息包含类加载器名称、所加载的类的数量、所加载的类的大小、父加载器、存活状态、加载器地址等</p><p><img src="/images/image-20200511174142448.png" alt="image-20200511174142448"></p></li><li><p>jmap -finalizerinfo pid</p><p>打印正在等待被回收的对象信息</p><p><img src="/images/image-20200511174414285.png" alt="image-20200511174414285"></p><p>表示当前并无待回收对象</p></li><li><p>jmap -dump:format=b,file=heapdump.hprof pid</p><p>生成堆转储快照dump文件，以hprof二进制格式转储Java堆信息到指定的文件中，可以使用live子选项指定只将堆中存活的对象转储出来，生成的文件可以使用jhat命令或者MAT工具解析</p><p><img src="/images/image-20200511175932610.png" alt="image-20200511175932610"></p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>在jmap执行时，JVM为了保证dump的信息的可靠性，会暂停应用的所有线程，如果堆内对象过大的话，这个过程会非常耗时，在生产环境慎用。</p><p>但是当生产服务处了问题，这个时候不得不使用的话，那就用吧，应用都出问题了，还在意会不会STW干啥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h3&gt;
&lt;p&gt;jmap是一个多功能命令，它可以生成Java应用的dump文件，也可以查看堆内对象的统计信息、查看ClassLoader信息和finalizer
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jstack</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjstack/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jstack/</id>
    <published>2020-05-10T16:11:00.000Z</published>
    <updated>2020-05-11T18:15:48.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h3><p>jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出Java应用中线程堆栈信息，主要用法：</p><img src="/images/image-20200511001238117.png" alt="image-20200511001238117" style="zoom:50%;"><ul><li>-F：强制打印线程堆栈信息，当<code>jstack [-l] &lt;pid&gt;</code>无响应时使用</li><li>-m：打印Java和native框架的所有堆栈信息</li><li>-l：长列表，打印关于锁的附加信息</li><li>-h or -help：打印帮助信息</li></ul><p><code>pid</code>是需要被打印堆栈信息的Java进程id，可以使用jps查看，通过jstack命令可以获取当前进程的所有线程信息，每个线程堆信息中可以看到线程ID、线程状态、是否持有锁等信息。</p><h3 id="死锁排查"><a class="markdownIt-Anchor" href="#死锁排查"></a> 死锁排查</h3><p>线程死锁的情况很简单，我们通过一张图即可理解：</p><img src="/images/image-20200511011015785.png" alt="image-20200511011015785" style="zoom:50%;"><p>首先我们写一段死锁代码，代码逻辑很简单，写两个线程，提供两个ReentrantLock对象，在线程1中先对lock1加锁，然后再对lock2加锁，而在线程2中先对lock2加锁，再对lock1加锁，使这两个线程互相竞争锁lock1和lock2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Lock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock1.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc1获取到lock1"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock2.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc1获取到lock2"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"cc1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock2.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc2获取到lock2"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock1.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc2获取到lock1"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"cc2"</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序之后，控制台输出内容：</p><img src="/images/image-20200511004249590.png" alt="image-20200511004249590" style="zoom:50%;"><p>然后就一直停顿在这里，下面我们使用jstack排查一下：</p><ol><li><p>使用jps查看进程pid</p><img src="/images/image-20200511004456408.png" alt="image-20200511004456408" style="zoom:50%;"><p>我们看到进程的pid为75169，接下来就可以根据该pid打印出堆栈信息</p></li><li><p>通过jstack查看进程的堆栈信息</p><p>执行命令<code>jstack -l 75169</code>，查看控制台输出的信息</p><img src="/images/image-20200511005029659.png" alt="image-20200511005029659" style="zoom:50%;"></li><li><p>排查死锁</p><ul><li>直接方法</li></ul><p>查看红框内的信息，发现在堆栈信息中已经告诉了我们死锁的信息，及发生死锁的线程名称和正在等待的锁，以及等待的锁的当前拥有者的线程名称。</p><p>查看黄框内的信息，这是我们排查代码问题的关键所在，也就是在堆栈信息中，会告诉我们发生死锁的代码位置，便于我们定位发生死锁的代码。</p><ul><li>间接方法</li></ul><p>如果堆栈中未告诉我们死锁的关联线程，那么我们可以通过线程正在等待的锁的信息在堆栈信息中进行搜索，本示例中，线程cc2的堆栈信息中<code>- parking to wait for &lt;0x000000076b2839a8&gt;</code>告诉我们当前线程cc2正在等待锁0x000000076b2839a8，并且当前已经霸占了锁0x000000076b2839d8；</p><img src="/images/image-20200511005806128.png" alt="image-20200511005806128" style="zoom:50%;"><p>而线程cc1的堆栈信息中<code>- parking to wait for &lt;0x000000076b2839d8&gt;</code>告诉我们它正在等待锁0x000000076b2839d8，且当前已经持有了锁0x000000076b2839a8。</p><img src="/images/image-20200511005950037.png" alt="image-20200511005950037" style="zoom:50%;"><p>通过线程cc1和cc2的堆栈信息我们能够直观的分析出它们相互霸占了对方想要获取的锁，并且在未获得所需要的锁之前，相互之间都不会释放已经持有的锁，因此导致了程序出现了死锁。</p></li></ol><h5 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h5><p>以上就是我们通常情况下排查线程死锁的基本操作，主要操作顺序为：</p><ol><li>使用jps查看进程pid</li><li>使用<code>jstack -l pid</code>查看线程堆栈信息</li><li>通过堆栈信息分析死锁情况</li></ol><h3 id="排查cpu过高"><a class="markdownIt-Anchor" href="#排查cpu过高"></a> 排查CPU过高</h3><p>当运行中的线程过多时，CPU负载会极速飙升，如果我们不及时解决就会导致因CPU过高而唤醒的系统的自我保护，将进程杀死。在实际工作当中，我们经常会遇到此种情况，当然我们不能看到CPU达到100%或者300%了就认为是CPU负载过高，这要根据我们服务器的CPU个数和每个CPU的负载来判断CPU是否过高。</p><blockquote><p>查看服务器负载：使用top命令查看机器负载</p><p><img src="/images/image-20200511013557261.png" alt="image-20200511013557261"></p><ul><li>load average后面分表代表1分钟、5分钟、15分钟的系统平均负载情况，一般不超过CPU个数*0.7即可认为是正常，使用uptime命令也可以查看该属性</li><li>按键1可以查看每个CPU的负载情况，若有一个CPU使用量超过75%，那么就需要排查了</li></ul></blockquote><p>我们写一个死循环来将CPU吃满：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullCpuTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>运行程序之后，通过top命令查看CPU负载</p><img src="/images/image-20200511021314252.png" alt="image-20200511021314252" style="zoom:50%;"><p>我们看到load average并不是很高，因为刚启动，待会就飙起来了，但是CPU0的usage已经达到了94.7%，我们的Java进程的pid为23731。</p></li><li><p>通过<code>top -Hp 23731</code>查看进程内的线程负载情况</p><p><img src="/images/image-20200511021510357.png" alt="image-20200511021510357"></p><p>发现pid为23732的线程占用的CPU最高，那么我们就找到了问题所在</p></li><li><p>查看线程的堆栈信息</p><ul><li><p>通过<code>jstack hpid</code>查看线程中处于RUNNABLE状态的线程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 23732是线程的pid</span></span><br><span class="line">jstack 23732</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200511021836792.png" alt="image-20200511021836792"></p></li><li><p>通过<code>jstack pid</code>定位具体的线程</p><ol><li><p>打印线程23732的16进制数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf '%x\n' 23732</span><br></pre></td></tr></table></figure></li><li><p>通过jstack排查具体的线程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 23731是进程的pid</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5cb4是线程pid的十六进制数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C2是输出命中行的上下行数，-C2表示上下各打印两行</span></span><br><span class="line">jstack 23731 | grep '0x5cb4' -C2 --color</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200511022609016.png" alt="image-20200511022609016"></p></li></ol></li><li><p>通过<code>kill -3 pid</code>查看线程堆栈信息</p></li></ul></li></ol><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><p>一般生产环境不会让直接在服务器上操作，所以可以将堆栈信息输出到文件中，然后再详细分析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt; 简述&lt;/h3&gt;
&lt;p&gt;jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出Java应用中线程堆栈信息，主要用法：&lt;/p&gt;
&lt;img src=&quot;/ima
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java垃圾回收名词</title>
    <link href="http://luxiaowan.github.io/2020/05/10/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%8D%E8%AF%8D/"/>
    <id>http://luxiaowan.github.io/2020/05/10/Java垃圾回收名词/</id>
    <published>2020-05-10T14:50:00.000Z</published>
    <updated>2020-05-10T15:17:07.978Z</updated>
    
    <content type="html"><![CDATA[<p>我们在学习JVM的GC相关知识时，必定会接触到几个GC的专有名词：Minor GC、Major GC、Young GC、Old GC、Full GC、Stop The World（STW），现在我们来了解一下这些名词具体指的是什么。</p><h4 id="minor-gc-young-gc"><a class="markdownIt-Anchor" href="#minor-gc-young-gc"></a> Minor GC &amp;&amp; Young GC</h4><p>Minor GC和Young GC都是指新生代的内存回收，两个名词指的是同一件事情，我们都知道现在的商业化虚拟机中，新生代被分为Eden和Survivor区，关于Minor GC我们需要知道以下几点：</p><ol><li>当Eden区无法为新创建的对象分配空间时，会触发Minor GC。Eden区空间越小，Minor GC的频率越高</li><li>当Eden区空间不足触发Minor GC时，新生代中会有部分对象晋升到老年代，所以Minor GC之后，老年代的空间使用量通常会有所升高</li><li>新生代的大部分垃圾收集器都会触发STW，但是新生代的大部分对象通常情况下都是朝生夕死的，所以Eden区的大部分对象都可以认为是垃圾对象，只有很少的一部分对象会被复制到Survivor区和老年代，这种情况下STW的时间会很短；而当Minor GC之后Eden区仍存活非常多的对象，那么垃圾收集器就会将这些对象复制到Survivor区或老年代，此时STW的时间就会变的很长，因为复制大量对象相比复制少量对象更耗时。</li></ol><h4 id="major-gc-old-gc"><a class="markdownIt-Anchor" href="#major-gc-old-gc"></a> Major GC &amp;&amp; Old GC</h4><p>这两个名词都指的是老年代空间回收，也属于是同一件事。很多情况下，Major GC是由Minor GC触发的，比如当发生Minor GC时，会将新生代的部分满足条件的对象晋升到老年代，如果此时老年代的可用空间不足，那么就会触发Major GC，因此说在大部分情况下Major GC都是由Minor GC触发的。</p><h4 id="full-gc"><a class="markdownIt-Anchor" href="#full-gc"></a> Full GC</h4><p>Full GC是比较特殊的一种，它等于是Minor GC和Major GC的结合，主要用于回收新生代、老年代和永久代。</p><ol><li>当老年代空间不足时，会触发Full GC</li><li>在代码中显式调用<code>System.gc()</code>时，JVM会建议执行Full GC</li><li>方法区空间不足时，会触发Full GC，但是在jdk1.8之后采用Metaspace来代替方法区，所以在此之后一般不会因为方法区空间不足而触发Full GC</li><li>通过Minor GC之后存活的对象大于之前每次晋升时老年代的平均可用空间时，会自动触发Full GC</li></ol><h4 id="stop-the-worldstw"><a class="markdownIt-Anchor" href="#stop-the-worldstw"></a> Stop-The-World（STW）</h4><p>STW意为停止全世界，对于JVM来说，它的世界里存活的都是一个个线程，所以意思也就是在进行GC时，会将虚拟机中其他的工作线程全部暂停，当GC结束之后，再继续恢复工作。</p><p>所以对于一个垃圾收集器来说，STW的时间是一个非常重要的性能指标，并且STW直接影响的是虚拟机的吞吐量（吞吐量 = 虚拟机运行时间 / (STW时间 + 虚拟机运行时间)），也就是STW时间越短，虚拟机吞吐量越高，执行效率越高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在学习JVM的GC相关知识时，必定会接触到几个GC的专有名词：Minor GC、Major GC、Young GC、Old GC、Full GC、Stop The World（STW），现在我们来了解一下这些名词具体指的是什么。&lt;/p&gt;
&lt;h4 id=&quot;minor-gc
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Synchronized作用在静态和非静态方法上的区别</title>
    <link href="http://luxiaowan.github.io/2020/05/09/Synchronized%E4%BD%9C%E7%94%A8%E5%9C%A8%E9%9D%99%E6%80%81%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://luxiaowan.github.io/2020/05/09/Synchronized作用在静态和非静态方法上的区别/</id>
    <published>2020-05-09T15:21:00.000Z</published>
    <updated>2020-05-10T14:33:04.503Z</updated>
    
    <content type="html"><![CDATA[<p>synchronized关键字的用法主要有以下几种：</p><ol><li><p>作用在非静态方法上</p><p>非静态方法是只能提供类的实例进行调用，所以实际上就是对调用方法的对象加锁，俗称对象锁</p></li><li><p>作用在静态方法上</p><p>静态方法是可以通过类名直接调用，所以实际上就是对调用方法的类加锁，俗称类锁</p></li><li><p>作用在代码块</p><p>根据传入的是类对象或类实例判断加锁方式</p></li></ol><h4 id="场景分析"><a class="markdownIt-Anchor" href="#场景分析"></a> 场景分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态同步方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncStaticClazz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static---method1--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static---method2--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static---method3--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非静态同步方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncNormalClazz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"normal---method1--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类级别的同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncNormalClazz.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"normal---method2--"</span> + Thread.currentThread());</span><br><span class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类级别的同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncNormalClazz.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"normal---method3--"</span> + Thread.currentThread());</span><br><span class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类实例级别的同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"normal---method4--"</span> + Thread.currentThread());</span><br><span class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>场景1</p><ul><li><p>描述：使用类对象在不同线程中访问不同的静态同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz.method1();</span><br><span class="line">&#125;, <span class="string">"ssc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz.method2();</span><br><span class="line">&#125;, <span class="string">"ssc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：静态同步方法的加锁范围是整个类，所以无论是使用对象或类去访问静态同步方法，锁都会加到类对象上。就好比是房子的大门，房子内不论有多少房间，只要有一个人打开大门进入到房子里，其他人就只能等他出来之后再进去，而已经进去的人拥有所有房间的使用权。</p></li></ul></li><li><p>场景2</p><ul><li><p>描述：在不同线程中用不同的类实例访问相同静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz c = <span class="keyword">new</span> SyncStaticClazz();</span><br><span class="line">    c.method1();</span><br><span class="line">&#125;, <span class="string">"ssc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz c = <span class="keyword">new</span> SyncStaticClazz();</span><br><span class="line">    c.method1();</span><br><span class="line">&#125;, <span class="string">"ssc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：和场景1相同，静态方法虽然可以被类实例访问，但锁依然是类锁</p></li></ul></li><li><p>场景3</p><ul><li><p>描述：同一个对象在不同线程中访问不同的非静态同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method1();</span><br><span class="line">&#125;, <span class="string">"snc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：非静态方法上加的是对象锁，当对象调用一个非静态的同步方法时，其他的非静态同步方法需要等待被执行。</p></li></ul></li><li><p>场景4</p><ul><li><p>描述：不同对象在不同线程中访问同一个非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method1();</span><br><span class="line">&#125;, <span class="string">"snc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method1();</span><br><span class="line">&#125;, <span class="string">"snc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：不互斥</p></li><li><p>解析：因为通过不同的对象调用的是非静态方法，虽然调用的是同一个方法，但是非静态方法加的锁是对象锁，针对的是对象并不是方法，所以可以并发执行，不会互斥。如果像场景1中的比喻的话，就是两个对象是两套房子，户型相同而已。</p></li></ul></li><li><p>场景5</p><ul><li><p>描述：不同对象在不同线程中访问同一个非静态非同步方法，方法内通过synchronized锁定代码块，且锁定对象为类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc3"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc4"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：因为方法<code>method2()</code>内的synchronized锁的是<code>SyncNormalClazz.class</code>，也就是锁定的是类对象，所以与场景2相同</p></li></ul></li><li><p>场景6</p><ul><li><p>描述：同一个对象在不同线程中访问不同的非静态非同步方法，方法内通过synchronized锁定代码块，且锁定对象为类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc2"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method3();</span><br><span class="line">&#125;, <span class="string">"snc3"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：因为方法<code>method2()</code>内的synchronized锁的是<code>SyncNormalClazz.class</code>，也就是锁定的是类对象，所以与场景2相同</p></li></ul></li><li><p>场景7</p><ul><li><p>描述：同一个对象在不同线程中访问不同方法，一个调用静态方法，一个调用非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncStaticClazz ssc = <span class="keyword">new</span> SyncStaticClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method2();</span><br><span class="line">&#125;, <span class="string">"ssc2"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method3();</span><br><span class="line">&#125;, <span class="string">"ssc3"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：不互斥</p></li><li><p>解析：虽然是同一个对象调用，但是两个方法的锁类型不同，静态方法是类锁，非静态方法是对象锁，所以不会互斥</p></li></ul></li><li><p>场景8</p><ul><li><p>描述：同一个对象在不同线程中访问不同synchronized代码块方法，一个调用类对象同步，一个调用类实例同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncNormalClazz ssc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method3();</span><br><span class="line">&#125;, <span class="string">"snc3"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method4();</span><br><span class="line">&#125;, <span class="string">"snc4"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：不互斥</p></li><li><p>解析：与场景8相同</p></li></ul></li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ul><li>对象锁仅锁当前对象，不同对象之间不会互斥</li><li>静态方法上的锁是类锁，非静态方法上的锁是对象锁</li><li>所有静态同步方法互斥，无论是通过类调用还是对象调用</li><li>静态方法上加synchronized与在非静态方法内加synchronized(Xxx.class)效果一致，都是类锁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;synchronized关键字的用法主要有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;作用在非静态方法上&lt;/p&gt;
&lt;p&gt;非静态方法是只能提供类的实例进行调用，所以实际上就是对调用方法的对象加锁，俗称对象锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作用在静态方法上&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM参数介绍</title>
    <link href="http://luxiaowan.github.io/2020/05/09/JVM%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
    <id>http://luxiaowan.github.io/2020/05/09/JVM参数介绍/</id>
    <published>2020-05-09T01:30:00.000Z</published>
    <updated>2020-05-14T15:51:44.663Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-jvm常用参数"><a class="markdownIt-Anchor" href="#1-jvm常用参数"></a> 1. JVM常用参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th><strong>默认值</strong></th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小</td><td></td><td>此处的大小是Eden + Survivor，和jmap -heap中显示的New Gen是不同的。 整个堆大小=年轻代大小 + 老年代大小 + 持久代大小(1.7及之前)，增大年轻代后，将会减小老年代大小，此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>年轻代大小</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td>jdk1.7及之前</td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td>jdk1.7及之前</td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5以后每个线程堆栈大小为1M，之前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右 一般小的应用， 如果栈不是很深， 应该是128k够用的，大的应用建议使用256k。</td></tr><tr><td>-XX:ThreadStackSize</td><td>Thread Stack Size</td><td></td><td></td></tr><tr><td>-XX:NewRatio</td><td>年轻代与老年代的比值</td><td></td><td>-XX:NewRatio=4表示年轻代与老年代所占比值为1:4，年轻代占整个堆栈的1/5，Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:LargePageSizeInBytes</td><td>内存页的大小不可设置过大， 会影响Perm的大小</td><td></td><td>=128m</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td>原始类型的快速优化</td><td></td><td></td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄</td><td>15</td><td>如果设置为0的话，则年轻代对象不经过Survivor区，直接进入老年代. 对于老年代比较多的应用，可以提高效率。此值默认为15，取值范围为0~15</td></tr><tr><td>-XX:+AggressiveOpts</td><td>加快编译</td><td></td><td></td></tr><tr><td>-XX:+UseBiasedLocking</td><td>锁机制的性能改善</td><td></td><td></td></tr><tr><td>-Xnoclassgc</td><td>禁用垃圾回收</td><td></td><td></td></tr><tr><td>-XX:SoftRefLRUPolicyMSPerMB</td><td>每兆堆空闲空间中SoftReference的存活时间</td><td>1s</td><td></td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效 另一种直接在旧生代分配的情况是大的数组对象，且数组中无外部引用对象.</td></tr><tr><td>-XX:+UseTLAB</td><td>开启TLAB</td><td></td><td>默认开启</td></tr><tr><td>-XX:TLABSize</td><td>TLAB大小</td><td></td><td>手动指定TLAB的大小</td></tr><tr><td>-XX:TLABWasteTargetPercent</td><td>TLAB占eden区的百分比</td><td>1%</td><td></td></tr><tr><td>-XX:TLABRefillWasteFraction</td><td>TLAB允许浪费的大小比例</td><td>64</td><td>默认TLAB空间的1/64空间</td></tr><tr><td>-XX:-ResizeTLAB</td><td>禁用ResizeTLAB</td><td></td><td></td></tr><tr><td>-XX:+CollectGen0First</td><td>FullGC时是否先YGC</td><td>false</td><td></td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>在发生OOM时到处堆栈信息</td><td></td><td></td></tr><tr><td>-XX:HeapDumpPath</td><td>堆栈信息输出地址</td><td></td><td></td></tr></tbody></table><h4 id="2-parallel收集器参数"><a class="markdownIt-Anchor" href="#2-parallel收集器参数"></a> 2. Parallel收集器参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th>说明</th></tr></thead><tbody><tr><td>-XX:+UseParallelGC</td><td>Full GC采用parallel MSC</td><td>选择垃圾收集器为并行收集器。此配置仅对年轻代有效，即上述配置下，年轻代使用并发收集，而老年代仍旧使用串行收集</td></tr><tr><td>-XX:+UseParNewGC</td><td>设置年轻代为并行收集</td><td>可与CMS收集同时使用，JVM会根据系统配置自行设置，所以无需再设置此值</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td>此值最好配置与处理器数目相等</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>老年代垃圾收集方式为并行收集(Parallel Compacting)</td><td></td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td>如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值.</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>自动选择年轻代区大小和相应的Survivor区比例</td><td>设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开.</td></tr><tr><td>-XX:GCTimeRatio</td><td>设置垃圾回收时间占程序运行时间的百分比</td><td>公式为1/(1+n)</td></tr><tr><td>-XX:+ScavengeBeforeFullGC</td><td>Full GC前调用YGC</td><td>=true</td></tr></tbody></table><h4 id="3-cms收集器参数"><a class="markdownIt-Anchor" href="#3-cms收集器参数"></a> 3. CMS收集器参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th>说明</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>使用Serial收集器</td><td>年轻代</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>使用CMS收集器</td><td></td></tr><tr><td>-XX:+AggressiveHeap</td><td></td><td>试图是使用大量的物理内存 长时间大内存使用的优化，能检查计算资源（内存， 处理器数量） 至少需要256MB内存 大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td></tr><tr><td>-XX:CMSFullGCsBeforeCompaction</td><td>多少次后进行内存压缩</td><td>由于CMS收集器不对内存空间进行压缩，整理，所以运行一段时间以后会产生&quot;碎片&quot;，使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩，整理.</td></tr><tr><td>-XX:+CMSParallelRemarkEnabled</td><td>降低标记停顿</td><td></td></tr><tr><td>-XX+UseCMSCompactAtFullCollection</td><td>在FULL GC的时候， 对老年代的压缩</td><td>CMS是不会移动内存的，会产生内存碎片， 增加这个参数可以消除碎片</td></tr><tr><td>-XX:+UseCMSInitiatingOccupancyOnly</td><td>使用手动定义初始化定义开始CMS收集</td><td>禁止hostspot自行触发CMS GC</td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction=70</td><td>使用cms作为垃圾回收 使用70％后开始CMS收集</td><td>=92。为了保证不出现promotion failed错误</td></tr><tr><td>-XX:CMSInitiatingPermOccupancyFraction</td><td>设置Perm Gen使用到达多少比率时触发</td><td>=92</td></tr><tr><td>-XX:+CMSIncrementalMode</td><td>设置为增量模式</td><td>用于单CPU情况</td></tr><tr><td>-XX:+CMSClassUnloadingEnabled</td><td></td><td></td></tr></tbody></table><h4 id="4-其他参数"><a class="markdownIt-Anchor" href="#4-其他参数"></a> 4. 其他参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th>说明</th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td>输出GC基本信息</td><td>输出形式：[GC (Allocation Failure)  1024K-&gt;612K(5632K)， 0.0021628 secs]</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出GC详细信息</td><td>输出形式：[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;492K(1536K)] 1024K-&gt;556K(5632K)， 0.0024829 secs] [Times: user=0.00 sys=0.00， real=0.00 secs]</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>在GC信息上输出系统运行时间</td><td>输出形式：0.185: [GC (Allocation Failure)  1620K-&gt;853K(5632K)， 0.0008322 secs]</td></tr><tr><td>-XX:+PrintGCApplicationStoppedTime</td><td>打印垃圾回收期间程序暂停的时间.可与上面混合使用</td><td>输出形式：Total time for which application threads were stopped: 0.0006927 seconds， Stopping threads took: 0.0000094 seconds</td></tr><tr><td>-XX:+PrintGCApplicationConcurrentTime</td><td>打印每次垃圾回收前，程序未中断的执行时间.可与上面混合使用</td><td>输出形式：Application time: 0.0183349 seconds</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>打印GC前后的详细堆栈信息，可单独使用</td><td></td></tr><tr><td>-Xloggc:filepath</td><td>把相关日志信息记录到文件以便分析. 与上面几个配合使用</td><td></td></tr><tr><td>-XX:+PrintClassHistogram</td><td>garbage collects before printing the histogram.</td><td>等同于jmap -histo</td></tr><tr><td>-XX:+PrintTLAB</td><td>查看TLAB空间的使用情况</td><td>输出：TLAB: gc thread: 0x00007fe8d4008800 [id: 3331] desired_size: 20KB slow allocs: 8  refill waste: 320B alloc: 0.99983     1024KB refills: 42 waste  0.5% gc: 0B slow: 4576B fast: 0B<br>TLAB totals: thrds: 1  refills: 42 max: 42 slow allocs: 8 max 8 waste:  0.5% gc: 0B max: 0B slow: 4576B max: 4576B fast: 0B max: 0B</td></tr><tr><td>-XX:+PrintTenuringDistribution</td><td>查看每次minor GC后新的存活周期的阈值</td><td>输出：Desired survivor size 524288 bytes， new threshold 5 (max 15)</td></tr></tbody></table><h4 id="5-常用配置"><a class="markdownIt-Anchor" href="#5-常用配置"></a> 5. 常用配置</h4><ul><li>堆设置<ul><li>-Xms：堆初始大小，-Xms10m</li><li>-Xmx：堆最大大小，-Xmx20m</li><li>-Xmn：新生代大小，-Xmn5m：NewSize=MaxNewSize=5m</li><li>-XX:NewSize：新生代初始大小 ，-XX:NewSize=5m</li><li>-XX:MaxNewSize：新生代最大大小，-XX:MaxNewSize=10m</li><li>-XX:NewRatio：新生代和老年代大小比值，-XX:NewRatio=4：新生代和老年代比值为1:4，新生代占堆的1/5</li><li>-XX:ServivorRatio：新生代中Eden和Survivor大小比值，-XX:SurvivorRatio=8：Eden和Survivor的比例为2:8，一个Survivor区占整个新生代大小的1/10</li><li>-XX:MaxTenuringThreshold：新生代对象转移到老年代的年龄，默认为15，值域0~15，设置为0的话就表示新生代对象从Eden不经过Survivor区而直接转移到老年代，-XX:MaxTenuringThreshold=10：新生代对象年龄达到10时，也就是经历10次YGC之后，转移到老年代</li></ul></li><li>垃圾收集器设置<ul><li>-XX:+UseSerialGC：新生代使用Serial收集器，可与CMS和Serial Old搭配使用</li><li>-XX:+UseParNewGC：新生代使用ParNew收集器</li><li>-XX:+UseParallelGC：新生代使用Parallel Scavenge收集器<ul><li>-XX:+ParallelGCThreads：设置并行收集器收集时使用的线程数，可以设置为CPU个数，-XX:+ParallelGCThreads=8：使用8个线程进行垃圾收集</li><li>-XX:MaxGCPauseMillis：设置并行收集的最大暂停时间，-XX:MaxGCPauseTime=20，单位：毫秒</li><li>-XX:GCTimeRatio：设置垃圾回收占用运行时间的百分比，-XX:GCTimeRatio=9：垃圾回收占用总运行时间的1/10</li></ul></li><li>-XX:+UseParallelOldGC：老年代使用Parallel Old收集器</li><li>-XX:+UseConcMarkSweepGC：老年代使用CMS收集器<ul><li>-XX:+CMSIncrementalMode：设置为增量模式，适用于单CPU环境</li><li>-XX:+UseCMSCompactAtFullCollection：在发生FGC时对老年代进行压缩</li><li>-XX:CMSFullGCsBeforeCompaction：设置在多少次FGC后，对老年代进行压缩，依赖于-XX:+UseCMSCompactAtFullCollection，-XX:CMSFullGCsBeforeCompaction=5：5次FGC后对老年代进行压缩</li></ul></li><li>-XX:+UseSerialOldGC：老年代使用Serial Old收集器</li></ul></li><li>垃圾收集信息<ul><li>-XX:+PrintGC：输出GC信息</li><li>-XX:+PrintGCDetails：输出GC详细信息</li><li>-XX:+PrintGCTimeStamps：输出GC执行时间点（虚拟机启动之后的时间点）</li><li>-Xloggc:filepath：将GC信息输出到某个文件中，不在控制台输出</li></ul></li><li>TLAB设置<ul><li>-XX:+UseTLAB：启用TLAB</li><li>-XX:+PrintTLAB：输出TLAB使用信息</li><li>-XX:-ResizeTLAB：禁用resizeTLAB</li><li>-XX:TLABSize：指定TLAB大小</li><li>-XX:TLABWasteTargetPrecent：设置TLAB空间占Eden区的比例大小，默认为1%</li><li>-XX:TLABRefillWasteFraction：设置TLAB空间允许被浪费的最大空间比例，默认TLAB空间的1/64空间</li></ul></li><li>OOM设置<ul><li>-XX:+HeapDumpOnOutOfMemoryError：当发生OOM时自动生成堆栈信息</li><li>-XX:HeapDumpPath：当发生OOM时堆栈信息文件输出路径，-XX:HeapDumpPath=/var/data/heapd/</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-jvm常用参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-jvm常用参数&quot;&gt;&lt;/a&gt; 1. JVM常用参数&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;参数名称&lt;/strong&gt;&lt;/th&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
</feed>
