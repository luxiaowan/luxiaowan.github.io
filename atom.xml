<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2020-04-27T15:30:46.963Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊一聊MySQL事务</title>
    <link href="http://luxiaowan.github.io/2020/04/27/%E8%81%8A%E4%B8%80%E8%81%8AMySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>http://luxiaowan.github.io/2020/04/27/聊一聊MySQL事务/</id>
    <published>2020-04-27T07:30:00.000Z</published>
    <updated>2020-04-27T15:30:46.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-事务为何物"><a class="markdownIt-Anchor" href="#一-事务为何物"></a> 一、事务为何物</h3><p>事务（Transaction）是保障程序中一组操作的原子性的约束，它使事务中的所有操作都指向同一个结果，也就是要么所有的操作都执行成功，要么所有的操作都执行失败，不允许出现其他结果。例如银行转账，从A账户扣除金额，向B账户添加金额，这两个数据库操作的总和构成一个完整的逻辑过程，不可拆分，这个过程被称为一个事务。在MySQL中，目前只有InnoDB引擎支持事务。</p><h3 id="二-事务的特性"><a class="markdownIt-Anchor" href="#二-事务的特性"></a> 二、事务的特性</h3><p>数据库管理系统在写入或更新数据的过程中，为保证事务是正确可靠的，需要具备四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p><ul><li>原子性（Atomicity）：一个事物中的所有操作，要么全部完成，要么全部失败，不会在中间某个环节结束。若事务在执行过程中发生异常，所有的操作都会被回滚到事务开始前的状态，就像这个事务从没执行过一样。</li><li>一致性（Consistency）：事务操作的数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定，也就是在事务开始之前和结束之后，数据库的完整性没有被破坏。</li><li>隔离性（Isolation）：数据库允许多个事务并发执行，隔离性是为了防止多个事务并发执行导致数据的不一致，事务之间是相互隔离的。事务隔离有四种级别：未提交读（Read UnCommitted）、已提交读（Read Commited）、可重复读（Repeatable Read）、串行化（Serializable）</li><li>持久性：事务成功提交之后，对数据的修改是永久性的，即便系统故障也不会丢失。</li></ul><h3 id="三-为什么要有四种隔离级别"><a class="markdownIt-Anchor" href="#三-为什么要有四种隔离级别"></a> 三、为什么要有四种隔离级别</h3><p>SQL标准定义了4种隔离级别用来限定不同的事务场景，按照隔离级别从低到高为：读未提交、读已提交、可重复读、串行化，级别越高，所支持的并发度越低。</p><blockquote><p>不同的隔离级别会造成不同的影响，体现在数据上就是脏读、不可重复读和幻读。</p></blockquote><ul><li>脏读：A事务读取了B事务中未提交的数据，在A事务提交之前，B事务进行了回滚，此时A事务中的数据就不正确了，所以被定义为脏数据。</li><li>不可重复读：A事务在第一次读取之后到第二次读取之前，B事务对该数据进行了修改，导致A事务两次读取的数据不一致，这就是不可重复读</li><li>幻读：幻读一般发生在范围查询的情况下，A事务第一次读取一批数据，在第二次读取之前，B事务向数据库中插入了新的符合A事务查询条件的数据，此时A事务第二次读取出来的数据条数不一致，这种情况对于A事务来说就是出现了幻读。</li></ul><blockquote><p>事务隔离级别</p></blockquote><ul><li>读未提交（Read UnCommitted）：该隔离级别下的事务可以看到其他事务未提交的执行结果，会引起脏读、不可重复读和幻读，在实际应用中几乎不会使用该级别的事务。</li><li>读已提交（Read Committed）：这是大多数数据库系统的默认隔离级别（如Oracle、阿里云的MySQL）等，但不是官方MySQL默认的。它不允许事务看到未提交的事务中的数据，使事务只能看见已经提交的事务所做的改变。该隔离级别会引起不可重复读和幻读。</li><li>可重复读（Repeatable Read）：这是官方MySQL的默认事务隔离级别，它确保同一事务多次读取的数据的一致性，解决了不可重复读的问题。该隔离级别解决的主要是对数据库进行UPDATE操作造成的数据改变，但还是会引起幻读的情况发生，在InnoDB存储引擎下默认提供MVCC（多版本并发控制）机制解决了幻读的问题。</li><li>串行化（Serializable）：这是最高的隔离级别，串行的意思也就是每次只允许一个事务对数据进行操作，事务按照先来后到的规则进行排队一次执行，这样在事务之间就不会相互冲突，从而解决了幻读的问题。但是串行化执行事务的方式会严重影响事务的执行效率，高并发操作下会造成事务堆积和超时，一般在实际应用中很少使用，虽然它很安全。</li></ul><p>通过上面我们了解了事务隔离级别，也知道每种隔离级别所解决的事情，做一下汇总：</p><table><thead><tr><th style="text-align:center">事务隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">读已提交</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">串行化</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><h3 id="四-如何查看和设置数据库的隔离级别"><a class="markdownIt-Anchor" href="#四-如何查看和设置数据库的隔离级别"></a> 四、如何查看和设置数据库的隔离级别</h3><ol><li><p>查看数据库当前的事务隔离级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200427173518185.png" alt="image-20200427173518185"></p></li><li><p>修改数据库的事务隔离级别</p><p>修改语句格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set [global | session] transaction isolation level [read uncommitted | read committed | repeatable read | serializable]</span><br></pre></td></tr></table></figure><p><code>session</code>：当前session内的事务</p><p><code>global</code>：应用于之后新创建的session，已经存在的session不受影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed</span><br></pre></td></tr></table></figure><p>修改成功之后，我们再看一下当前的隔离级别已经被修改为RC了。</p><p><img src="/images/image-20200427174522929.png" alt="image-20200427174522929"></p></li></ol><h3 id="五-小"><a class="markdownIt-Anchor" href="#五-小"></a> 五、小🌰</h3><ol><li><p>创建一张表备用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table cc_isolation_test</span><br><span class="line">(</span><br><span class="line">    id   int auto_increment primary key,</span><br><span class="line">    name varchar(30) null</span><br><span class="line">) engine=innodb default charset=utf8</span><br><span class="line">    comment &apos;事务隔离级别测试表&apos;;</span><br><span class="line"></span><br><span class="line"># 插入一条数据</span><br><span class="line">insert into cc_isolation_test(name) values(&apos;cc&apos;);</span><br></pre></td></tr></table></figure></li><li><p>RU级别</p><ul><li><p>修改session的事务隔离级别为RU</p><p>打开两个session窗口，将事务隔离级别均修改为RU。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别为RU</span><br><span class="line">set session transaction isolation level read uncommitted ;</span><br><span class="line"># 验证</span><br><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200427184245389.png" alt="image-20200427184245389"></p></li><li><p>脏读验证</p><ol><li><p>在两个窗口中均开启一个事务，在A事务中进行查询操作，在B事务中进行更新操作但不提交</p></li><li><p>A事务：进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><p>这时查到的数据为正常数据：</p><img src="/images/image-20200427185221292.png" alt="image-20200427185221292" style="zoom:50%;"></li><li><p>B事务：进行更新操作但不提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update cc_isolation_test set name=&apos;cc1&apos; where id=1;</span><br></pre></td></tr></table></figure><p>执行完之后可以看一下我们的表中，数据是未被修改的，因为B事务尚未提交</p><img src="/images/image-20200427190836436.png" alt="image-20200427190836436" style="zoom:50%;"></li><li><p>A事务：再次进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427190607659.png" alt="image-20200427190607659" style="zoom:50%;"><p>查询出来的数据中，name竟然变成了cc1，也就是说A事务中读取到了B事务中尚未提交的数据，如果此时B事务回滚，A事务中name的值仍然是读到的cc1，也就出现了脏数据，所以RU级别下会出现脏读的问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>update cc_isolation_test set name=‘cc1’ where id=1;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>rollback;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li><li><p>不可重复读验证</p><p>上面演示脏读的过程中，在A事务中对数据进行了两次读取，且两次读取到的name的值不一致，所以RU也造成了不可重复读的问题。</p></li><li><p>幻读验证</p><ol><li><p>A事务：进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427185221292.png" alt="image-20200427185221292" style="zoom:50%;"></li><li><p>B事务：进行插入操作但不提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into cc_isolation_test(name) values(&apos;cc1&apos;);</span><br></pre></td></tr></table></figure><p>事务未提交，我们的表中还没出现插入的新数据</p><img src="/images/image-20200427190836436.png" alt="image-20200427190836436" style="zoom:50%;"></li><li><p>A事务：再次进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><p>查询出来两条数据，和之前查询的条数不一样，但是我们数据库中仅仅只有一条数据，这就是所谓的幻读，此时若将B事务回滚掉，A事务拿着B事务未提交的数据继续操作，定会出现问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(name) values(‘cc1’);</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>rollback;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li></ul></li><li><p>RC级别</p><ul><li><p>修改session的事务隔离级别为RC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别为RC</span><br><span class="line">set session transaction isolation level read committed ;</span><br><span class="line"># 验证</span><br><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure></li></ul><img src="/images/image-20200427215936571.png" alt="image-20200427215936571" style="zoom:50%;"><ul><li><p>脏读验证</p><p>操作步骤和RU的一致，但是结果却不相同，我们在B事务中对<code>id=1</code>的数据进行修改但是不提交事务，在A事务中是读取不到B事务对该条数据的修改，所以RC级别不会出现脏读的问题。</p></li><li><p>不可重复读验证</p><ol><li><p>A事务：第一次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193013689.png" alt="image-20200427193013689" style="zoom:50%;"></li><li><p>B事务：修改数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">update cc_isolation_test set name=&apos;cc1&apos; where id=1;</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：第二次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193112958.png" alt="image-20200427193112958" style="zoom:50%;"><p>在A事务中读取到了B事务提交的数据，与第一次读取到的数据不一致，也就是说每次读取都是从数据库中读取最新的数据，这也证明了再RC级别下会出现不可重复读的问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td></td><td>update cc_isolation_test set name=‘cc1’ where id=1;</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li><li><p>幻读验证</p><ol><li><p>A事务：第一次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193423746.png" alt="image-20200427193423746" style="zoom:50%;"></li><li><p>B事务：修改数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">insert into cc_isolation_test(name) values(&apos;cc2&apos;);</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：第二次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193523968.png" alt="image-20200427193523968" style="zoom:50%;"><p>两次查询的数据条数不同，在A事务中读取到了B事务新插入的数据，相对于第一次查询结果来说，出现了幻读的问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(name) values(‘cc2’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li></ul></li><li><p>RR级别</p><ul><li><p>修改session的事务隔离级别为RR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别为RC</span><br><span class="line">set session transaction isolation level read committed ;</span><br><span class="line"># 验证</span><br><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427210838009.png" alt="image-20200427210838009" style="zoom:50%;"></li><li><p>脏读验证</p><p>操作步骤和RC的一致，但是结果却不相同，我们在B事务中对<code>id=1</code>的数据进行修改但是不提交事务，在A事务中是读取不到B事务对该条数据的修改，所以RR级别不会出现脏读的问题。</p></li><li><p>不可重复读验证</p><ol><li><p>A事务：第一次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193112958.png" alt="image-20200427193112958" style="zoom:50%;"></li><li><p>B事务：修改数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">update cc_isolation_test set name=&apos;cc2&apos; where id=1;</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：第二次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193112958.png" alt="image-20200427193112958" style="zoom:50%;"><p>通过两次读取之后发现在B事务提交前后读取到的数据是一致的，这样证明了RR级别是支持重复读的，nice~</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td></td><td>update cc_isolation_test set name=‘cc2’ where id=1;</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li><li><p>幻读验证</p><ol><li><p>A事务：进行查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure></li><li><p>B事务：插入数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">insert into cc_isolation_test(id, name) values(1, &apos;cc2&apos;);</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into cc_isolation_test(id, name) values(1, &apos;cc2&apos;);</span><br></pre></td></tr></table></figure><p>主键冲突了，但是在A事务中确实没查询到id=1的数据，其实这个时候数据库中已经有了id=1的数据，但在A事务中却没有查询到，这就是幻读。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(id, name) values(1, ‘cc2’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>insert into cc_isolation_test(id, name) values(1, ‘cc2’);</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li></ul></li><li><p>Serializable级别</p><ul><li><p>修改session的事务隔离级别为Serializable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427215912469.png" alt="image-20200427215912469" style="zoom:50%;"></li><li><p>操作</p><p>先开启事务A，进行查询，但不提交；再开启事务B，然后进行插入操作，会发现操作被阻塞了，如下图中insert语句最后的时间就是等待的时间，事务B必须在事务A提交或回滚之后才能继续执行，这也就是串行化的意义：同时只能有一个事务处于执行中，其他线程都要等待。并发度最低但安全性最高。</p><img src="/images/image-20200427215828454.png" alt="image-20200427215828454" style="zoom:50%;"><p>图解：</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(name) values(‘cc2’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-事务为何物&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-事务为何物&quot;&gt;&lt;/a&gt; 一、事务为何物&lt;/h3&gt;
&lt;p&gt;事务（Transaction）是保障程序中一组操作的原子性的约束，它使事务中的所有操作都指向同一个结果，也就是要么
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot如何以war包形式运行</title>
    <link href="http://luxiaowan.github.io/2020/04/26/SpringBoot%E5%A6%82%E4%BD%95%E4%BB%A5war%E5%8C%85%E5%BD%A2%E5%BC%8F%E8%BF%90%E8%A1%8C/"/>
    <id>http://luxiaowan.github.io/2020/04/26/SpringBoot如何以war包形式运行/</id>
    <published>2020-04-26T09:50:00.000Z</published>
    <updated>2020-04-26T14:40:37.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-简介"><a class="markdownIt-Anchor" href="#一-简介"></a> 一、简介</h3><p>SpringBoot应用默认打包成可执行jar模式方便我们的快速部署，如果是web应用的话，则默认使用内置的tomcat作为servlet容器，但是如果我们需要根据业务特性对容器做一些特殊配置，那么SpringBoot内置的tomcat容器就无法满足我们了，因此我们就需要把SpringBoot应用打包成war包，让其能够在外部tomcat中运行。</p><p>那我们直接打成war包然后部署到tomcat是否可行？我们来试下，看看会发生什么。</p><h3 id="二-直接将springboot打成war包"><a class="markdownIt-Anchor" href="#二-直接将springboot打成war包"></a> 二、直接将SpringBoot打成war包</h3><ol><li><p>创建一个SpringBoot web项目，并修改打包方式和端口</p><ul><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcSpringBootWarApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CcSpringBootWarApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-war<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加packaging并指明方式为war --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改端口，不要和tomcat的8080冲突，修改tomcat的也可以</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8990</span></span><br></pre></td></tr></table></figure></li></ul><p>以上就是我们创建的一个简单的SpringBoot应用所具有的东西</p></li><li><p>创建一个API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"cc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure></li><li><p>放到tomcat中启动，查看控制台信息</p><p><img src="/images/image-20200426212704488.png" alt="image-20200426212704488"></p><p>没有报错，那么我们访问一下接口http://127.0.0.1/boot-war/cc，报了404，说明我们项目未被部署成功。</p><p><img src="/images/image-20200426212841507.png" alt="image-20200426212841507"></p></li></ol><p>未部署成功，是因为我们在打包的时候，将内置的tomcat的jar包一并打到war包中了，这时和外部的tomcat冲突了。</p><h3 id="三-优化后的springboot打war包"><a class="markdownIt-Anchor" href="#三-优化后的springboot打war包"></a> 三、优化后的SpringBoot打war包</h3><ol><li><p>修改依赖的tomcat包的scope</p><ul><li><p>第一种方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接屏蔽掉<code>spring-boot-starter-web</code>中向下传递的<code>spring-boot-starter-tomcat</code>包，并引入<code>javax.servlet-api</code>包，并将scope设置为<code>provided</code>，不然打包的时候会报错。</p></li><li><p>第二种方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将<code>spring-boot-starter-tomcat</code>和<code>javax.servlet-api</code>的jar包的scope设置为<code>provided</code>便于打包。</p></li></ul></li><li><p>修改启动类，设置启动配置</p><p>发布到独立的Tomcat需要继承SpringBootServletInitializer类并重写configure方法，在war包部署解压后的文件夹中没有普通web项目的web.xml，但是仍然能启动，就是因为SpringConfig继承了SpringBootServletInitializer，所以打包的时候SpringBoot做了初始化工作，这个类就是用于代替传统MVC模式中的web.xml。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcSpringBootWarApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CcSpringBootWarApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(CcSpringBootWarApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure></li><li><p>部署</p><p>将war包放到外部tomcat的webapps目录下，然后启动tomcat后访问http://127.0.0.1/boot-war/cc，访问正常。</p><p><img src="/images/image-20200426215949343.png" alt="image-20200426215949343"></p></li></ol><h3 id="四-直接创建war项目"><a class="markdownIt-Anchor" href="#四-直接创建war项目"></a> 四、直接创建war项目</h3><p>在创建应用的时候，packaging选择War（目前只有Jar和War两个选项），就能直接创建出符合条件的应用，不需要再进行任何修改就可以直接打成war包。</p><img src="/images/image-20200426220404239.png" alt="image-20200426220404239" style="zoom: 35%;"><p>创建的应用内容如下：</p><img src="/images/image-20200426220312800.png" alt="image-20200426220312800" style="zoom:35%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-简介&quot;&gt;&lt;/a&gt; 一、简介&lt;/h3&gt;
&lt;p&gt;SpringBoot应用默认打包成可执行jar模式方便我们的快速部署，如果是web应用的话，则默认使用内置的tomcat作为serv
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>使用LockSupport实现线程交替打印1-100</title>
    <link href="http://luxiaowan.github.io/2020/04/25/%E4%BD%BF%E7%94%A8LockSupport%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/"/>
    <id>http://luxiaowan.github.io/2020/04/25/使用LockSupport实现线程交替打印1-100/</id>
    <published>2020-04-25T08:30:00.000Z</published>
    <updated>2020-04-25T12:15:18.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>LockSupport是JDK底层的基于<code>sun.misc.Unsafe</code>来实现的类，用来创建锁和其他同步工具类的基本线程阻塞原语，在AQS中，就是通过调用LockSupport.park()和LockSupport.unpark()来实现线程的阻塞和唤醒的，不清楚的可以先了解一下<a href="https://luxiaowan.github.io/2020/04/24/AQS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/">AQS基本概况</a>。每一个使用LockSupport的线程都会与一个许可关联，如果许可证在线程中可用，则调用park()将会立即返回，否则可能堵塞；若许可证不可用，则调用unpark()将其转为可用状态。调用park()的次数要少于等于调用unpark()的次数，否则将会导致许可不可用引起阻塞。</p><h3 id="locksupport方法介绍"><a class="markdownIt-Anchor" href="#locksupport方法介绍"></a> LockSupport方法介绍</h3><p>LockSupport提供的方法不多，且都是类方法，来看下：</p><ul><li>阻塞线程<ol><li>park()：阻塞当前线程，需要在线程内调用，如果调用unpark()或者将线程中断，则从park()方法中返回</li><li>park(Object blocker)：功能与park()相同，入参是一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查</li><li>parkNanos(long nanos)：阻塞当前线程，阻塞时长不超过nanos纳秒，超时自动返回</li><li>parkNanos(Object blocker, long nanos)：功能同parkNanos(long nanos)，在其基础上增加了Object对象，等同于是park(Object blocker)+parkNanos(long nanos)的组合</li><li>parkUtil(long deadline)：阻塞当前线程，直到deadline后自动返回</li><li>parkUtil(Object blocker, long deadline)：：等同于park(Object blocker)+parkUtil(long deadline)的组合</li></ol></li><li>唤醒线程<ol><li>unpar(Thread thread)：唤醒处于阻塞状态的指定线程</li></ol></li></ul><p>以上就是LockSupport的主要方法，每一种park方法都提供了一个Object对象的入参，目的是为了方便进行问题排查，那我们来看下是怎么方便的</p><ol><li><p>park()的线程栈</p><p><img src="/images/image-20200425175946604.png" alt="image-20200425175946604"></p></li><li><p>park(Object blocker)的线程栈</p><p><img src="/images/image-20200425180113595.png" alt="image-20200425180113595"></p></li></ol><p>使用Object入参的方法之后，线程栈中出现了<code>parking to wait for</code>提示，告诉我们因为哪个对象发生的阻塞，方便我们查找阻塞源头。</p><h3 id="例子1"><a class="markdownIt-Anchor" href="#例子1"></a> 例子1</h3><ol><li><p>使用两个线程交替打印1-100</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintNumTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Print p1 = <span class="keyword">new</span> Print();</span><br><span class="line">        Print p2 = <span class="keyword">new</span> Print();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(p2);</span><br><span class="line">        t1.setName(<span class="string">"thread-cc-1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"thread-cc-2"</span>);</span><br><span class="line">        p1.setT(t2);</span><br><span class="line">        p2.setT(t1);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">      <span class="comment">// 唤醒线程t1打印奇数，线程1打印奇数，线程2打印偶数</span></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">      <span class="comment">// 唤醒线程t2打印奇数，线程1打印偶数，线程2打印奇数</span></span><br><span class="line">      <span class="comment">// LockSupport.unpark(t1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Thread t;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="comment">// 进入之后立即阻塞</span></span><br><span class="line">                LockSupport.park();</span><br><span class="line">                <span class="keyword">if</span> (num.get() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + num.getAndIncrement());</span><br><span class="line">              <span class="comment">// 奇数唤醒偶数线程，偶数唤醒奇数线程</span></span><br><span class="line">                LockSupport.unpark(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程使用死循环来保持运行状态，然后使用return来终止运行，进入循环之后立即调用LockSupport.park()阻塞当前线程，在调用线程的start()方法之后两个线程都堵塞在run()方法开始位置，在线程1中打开线程2的许可证，在线程2中打开线程1的许可证，达到交替执行的目的。此时线程都堵塞了，那么我们就可以在主线程中控制先打开哪一个线程的许可证了，如果想让线程1打印奇数，线程2打印偶数，就先把线程1阻塞的许可证打开，让线程1先执行；如果想让线程1打印偶数，线程2打印奇数，就先把线程2阻塞的许可证打开，让线程2先执行。</p><ul><li>t1打印奇数，t2打印偶数</li></ul><img src="/images/image-20200425194737366.png" alt="image-20200425194737366" style="zoom:50%;"><ul><li><p>t1打印偶数，t2打印奇数</p><img src="/images/image-20200425194937392.png" alt="image-20200425194937392" style="zoom:50%;"></li></ul></li><li><p>使用三个线程交替打印1-100</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintNumTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Print p1 = <span class="keyword">new</span> Print();</span><br><span class="line">        Print p2 = <span class="keyword">new</span> Print();</span><br><span class="line">        Print p3 = <span class="keyword">new</span> Print();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(p2);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(p3);</span><br><span class="line">        t1.setName(<span class="string">"thread-cc-1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"thread-cc-2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"thread-cc-3"</span>);</span><br><span class="line">        p1.setT(t2);</span><br><span class="line">        p2.setT(t3);</span><br><span class="line">        p3.setT(t1);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Thread t;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                <span class="keyword">if</span> (num.get() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + num.getAndIncrement());</span><br><span class="line">                LockSupport.unpark(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h3&gt;
&lt;p&gt;LockSupport是JDK底层的基于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;来实现的类，用来创建锁和其他同步工具类的基本线程
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>AQS基本概况</title>
    <link href="http://luxiaowan.github.io/2020/04/24/AQS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/"/>
    <id>http://luxiaowan.github.io/2020/04/24/AQS基本概况/</id>
    <published>2020-04-24T04:20:00.000Z</published>
    <updated>2020-04-24T18:38:23.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-简介"><a class="markdownIt-Anchor" href="#一-简介"></a> 一、简介</h3><p>在Java中，谈到并发就不得不说到jdk中的J.U.C包，而说到此包必定要说到AQS(AbstractQueuedSynchronizer)，从类名上可以看出这是一个抽象的、使用队列实现的同步器，AQS提供了一个FIFO队列，可以用于构建同步锁的基础框架，内部通过volatile的变量state来表示锁的状态，当state=0时表示锁空闲，当state&gt;0时表示锁被占用，如果锁是可重入的，比如ReentrantLock，state的值会随着重入次数不断的+1，在锁释放的时候需要将state进行-1直到等于0，所以对于重入锁来说，重入多少次就要释放多少次，否则会一直占着锁导致其他线程无法申请到锁而一直等待，最终撑爆CPU。</p><p>AQS的核心思想是如果被请求的共享资源空闲，则将资源分配给当前请求资源的线程，并将共享资源设置为锁定状态，如果此时有其他线程过来请求此共享资源，会发现共享资源已经被占用，则阻塞该线程，将其放入到等待队列中。</p><p>AQS的等待队列又叫CLH队列，是一个FIFO性质的，CLH的名字来自于它的创建者，三位老前辈的名字的首字母(Craig, Landin, Hagersten)，CLH队列是一个双向队列，AQS将每个请求共享资源但未成功的线程封装成一个CLH队列的Node节点并放入队列中等待分配。</p><p><img src="/images/image-20200424221846794.png" alt="image-20200424221846794"></p><h3 id="二-aqs锁方式"><a class="markdownIt-Anchor" href="#二-aqs锁方式"></a> 二、AQS锁方式</h3><p>AQS提供了独占锁和共享锁两种锁的声明，在其内部并未对锁进行具体实现，仅仅提供了一些模板方法，由具体的实现类决定如何实现。</p><ul><li><p>独占锁</p><p>独占锁意思就是同一时刻只能有一个线程霸占共享资源，其他请求的线程全部等待，比如ReentrantLock。看一下大致的流程：</p><img src="/images/image-20200424155241273.png" alt="image-20200424155241273" style="zoom:40%;"></li><li><p>共享锁</p><p>共享锁设计的初衷是允许一个或多个线程等待一组事件完成，主要实现为CountDownLatch，主要原理是在创建的时候给state设定一个数值， 表示需要等待的事件数量，这个值需要和要等待执行的线程数一致，每个线程执行完成后，对state减一，在state不等于0之前，应该一直等待，除非遇到线程中断或等待超时。</p><img src="/images/image-20200424203513738.png" alt="image-20200424203513738" style="zoom:40%;"></li></ul><h3 id="三-aqs等待队列"><a class="markdownIt-Anchor" href="#三-aqs等待队列"></a> 三、AQS等待队列</h3><p>当共享资源被占用时，其他请求该资源的线程将会阻塞，然后被加入到同步队列。就数据结构而言，队列的实现方式一种是数组，一种是链表，AQS中的等待队列是通过链表的方式来实现的，名字叫做CLH队列。</p><ul><li><p>CLH队列节点是通过AQS内部Node类来封装的，一个节点表示一个线程，保存着线程的引用(<code>volatile Thread thread</code>)、状态(<code>volatile int waitStatus</code>)、前驱节点(<code>volatile Node prev</code>)、后继节点(<code>volatile Node next</code>)，这些变量全部都是volatile关键字修饰的，保证了节点的原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 共享 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 独占 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示下一次共享式同步状态获取将会无条件地传播下去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 等待状态 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前驱节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 后继节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取同步状态的线程 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 返回前置节点 */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>入列</p><p>CLH队列是双向链表的FIFO队列，知道了这个特性之后，对于它的入列就基本能明了了，每次入列均放在队列最后，我们来看看AQS的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建CLH队列节点</span></span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  <span class="comment">// 获取当前的尾结点</span></span><br><span class="line">  Node pred = tail;</span><br><span class="line">  <span class="comment">// 如果尾结点不为null，说明队列已完成了初始化</span></span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前节点的前置节点设置为原尾结点</span></span><br><span class="line">    node.prev = pred;</span><br><span class="line">    <span class="comment">// 将当前节点通过CAS设置为尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">      <span class="comment">// 将原尾结点的后置节点设置为当前节点</span></span><br><span class="line">      pred.next = node;</span><br><span class="line">      <span class="comment">// 返回当前节点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 队列为空的处理</span></span><br><span class="line">  enq(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 无限循环入队，直到成功</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 获取尾结点</span></span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="comment">// 尾结点为空，说明队列尚未被初始化</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 设置头结点</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">        <span class="comment">// 设置尾结点，头尾相等则表示队列为空</span></span><br><span class="line">        tail = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当前节点的前置节点设置为原尾结点</span></span><br><span class="line">      node.prev = t;</span><br><span class="line">      <span class="comment">// 将当前节点通过CAS设置为尾结点</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        <span class="comment">// 将原尾结点的后置节点设置为当前节点</span></span><br><span class="line">        t.next = node;</span><br><span class="line">        <span class="comment">// 返回原尾结点</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中看到两个方法都是通过CAS方法<code>compareAndSetHead(Node update)</code>和<code>compareAndSetTail(Node expect, Node update)</code>来设置头尾节点，确保节点的添加是线程安全的，在enq(Node node)方法中通过无限循环来保证节点可用被正确添加，只有在成功之后才会返回。</p></li><li><p>出列</p><p>CLH队列遵循FIFO规则，首节点先占用共享资源，在线程释放同步状态后，将会唤醒它的后继节点(next)，后继节点在获取同步状态成功之后将自己设置为首节点，这个过程其实就是双向链表的移动，将头结点的next指向原首节点的next，然后这个next节点的前置节点设置为null，这个过程不需要使用CAS来保证，因为同时只有一个线程能够成功获取到同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取当前节点的前置节点</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="comment">// 当前节点的前置节点是head的话，则表明轮到它来获取同步状态了</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        <span class="comment">// 加锁成功，将当前节点设置为头结点</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当前节点不是第二个节点 或者再次获取锁失败</span></span><br><span class="line">      <span class="comment">// 判断是否需要挂起，在挂起后，判断线程是否中断</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  head = node;</span><br><span class="line">  node.thread = <span class="keyword">null</span>;</span><br><span class="line">  node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">  Node p = prev;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"><span class="comment">// 当前节点已经被设置为等待唤醒的状态，可以安全的挂起了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点node的前任节点被取消，那么跳过这些取消的节点，当跳过之后，重新尝试获取锁</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过前面的判断，waitStatus一定不是 SIGNAL 或 CANCELLED。</span></span><br><span class="line"><span class="comment">         * 推断出一定是 0 or PROPAGATE</span></span><br><span class="line"><span class="comment">         * 调用者需要再次尝试，在挂起之前能不能获取到锁，</span></span><br><span class="line"><span class="comment">         * 因此，将当前pred的状态设为SIGNAL，再次尝试获取锁之后，如果还没有得到锁那么挂起</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个线程对于锁的一次竞争的结果有两种：</p><ul><li>要么成功获取到锁(不用进入到CLH队列)</li><li>要么获取失败被挂起，等待下次唤醒后继续循环尝试获取锁</li></ul><blockquote><p>因为AQS的队列是FIFO的，所以每次被CPU唤醒之后，如果当前线程不是头结点，则会被挂起，通过这种方式实现了竞争的排队策略。</p></blockquote></li></ul><h3 id="四-独占锁reentrantlock"><a class="markdownIt-Anchor" href="#四-独占锁reentrantlock"></a> 四、独占锁ReentrantLock</h3><ol><li><p>独占锁的实现类有ReentrantLock、ReentrantReadWriteLock、ThreadPoolExecutor等，我们拿ReentrantLock学习一下独占锁的使用。先来看一下ReentrantLock的基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock会保证在lock.lock()和lock.unlock()之间的代码块在同一时间只有一个线程访问，其余线程会被挂起，直至获取到锁。</p></li><li><p>ReentrantLock的基本原理</p><p>ReentrantLock内部有公平锁(FairSync)和非公平锁(NonfairSync)，默认采用非公平锁。</p><ul><li>公平锁：每个线程抢占锁的顺序按照调用lock方法的顺序依次获取锁</li><li>非公平锁：每个线程抢占锁的顺序和调用lock方法的顺序无关，每一个线程到来之后都先获取锁，获取不到的话再加入到队列中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ReentrantLock，公平锁or非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加锁解锁，使用sync完成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了ReentrantLock的锁竞争机制之后，我们来看下它到底是怎么实现独占锁的。既然ReentrantLock的锁是通过公平锁和非公平锁来实现的，那么加锁和释放锁的实现逻辑也都在这两把锁中了。</p><ul><li><p>同步锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非公平锁加锁</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取AQS的state的值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果state=0表示当前共享资源空闲</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 将当前线程设置为独占锁的拥有者</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程已经是锁的拥有者，则增加state的值，重入锁的概念</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取state的值并减去要释放的锁数量</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 判断当前线程是否为锁的拥有者，其实可以替换为if(!isHeldExclusively())</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// state==0，锁释放</span></span><br><span class="line">      free = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 设置拥有者为空</span></span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前线程是否为锁的拥有者</span></span><br><span class="line">    <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Condition控制对象，提供lock.newCondition()方法调用</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前锁的拥有者线程</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取锁的重入次数，如果当前线程不是锁的拥有者，则返回0</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁是否被占用了</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync类是公平锁和非公平锁的基类，默认提供了非公平锁的加锁逻辑，也提供了通用的一些方法，大部分的方法也都被final修饰，不允许被重载和重写。</p></li><li><p>公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现Sync的lock()抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// state设置为1，调用到AQS中的acquire方法</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公平锁加锁，由AQS的acquire方法调用过来</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取state的值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 锁未被占用</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 首先判断队列中是否有等待的线程</span></span><br><span class="line">      <span class="comment">// 队列不为空则加锁失败，并放入队列中</span></span><br><span class="line">      <span class="comment">// 等待队列为空的情况下，使用CAS修改state的值，成功后就是加锁成功</span></span><br><span class="line">      <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">          compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 当前线程设置为锁的拥有者</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁被占有，判断当前线程是否为当前锁的拥有者</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="comment">// 重入锁机制</span></span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非公平的关键</span></span><br><span class="line">    <span class="comment">// 线程调用lock()后，不论等待队列中有没有等待中的线程，都申请一次加锁，CAS操作设置state=1，在原线程拥有者释放锁到队列中头结点加锁成功之间可能会加锁成功，这可以理解为排队的过程中遇到插队的</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">      setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 调用AQS的acquire方法</span></span><br><span class="line">      acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由AQS中的acquire方法调用回来</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为Sync中默认实现了非公平锁，所以只要调用父类的方法即可</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>小总结:</p><ol><li>公平锁与非公平锁的锁释放步骤是一致的</li><li>获取锁的过程不一致，公平锁优先执行等待时间最长的线程，非公平锁让当前线程抢占，如果一直被抢占的话，队列中的等待线程可能一直都执行不了。</li></ol></blockquote></li><li><p>其他方法</p><p>ReentrantLock还为我们提供了一些其他的方法，方便我们的使用。</p><ul><li><p><code>getQueuedThreads()</code>：获取等待队列中等待的线程，返回一个List&lt;Thread&gt;对象，按照加入队列顺序倒序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">  <span class="comment">// 从尾部开始迭代</span></span><br><span class="line">  <span class="keyword">for</span> (Node p = tail; p != <span class="keyword">null</span>; p = p.prev) &#123;</span><br><span class="line">    Thread t = p.thread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">      list.add(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>tryLock()</code>：尝试获取锁</p></li><li><p><code>isFair()</code>：获取当前锁是否为公平锁，true代表公平锁</p></li><li><p><code>newCondition()</code>：锁控制条件类实例，类似于wait和notify</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 使用方式:ArrayBlockingQueue */</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition notEmpty = lock.newCondition();</span><br><span class="line">Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  checkNotNull(e);</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == items.length)</span><br><span class="line">      notFull.await();</span><br><span class="line">    enqueue(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  E x = (E) items[takeIndex];</span><br><span class="line">  items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">    takeIndex = <span class="number">0</span>;</span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">    itrs.elementDequeued();</span><br><span class="line">  notFull.signal();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">      notEmpty.await();</span><br><span class="line">    <span class="keyword">return</span> dequeue();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  items[putIndex] = x;</span><br><span class="line">  <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">    putIndex = <span class="number">0</span>;</span><br><span class="line">  count++;</span><br><span class="line">  notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="五-共享锁countdownlatch"><a class="markdownIt-Anchor" href="#五-共享锁countdownlatch"></a> 五、共享锁CountDownLatch</h3><ol><li><p>CountDownLatch基本原理</p><p>CountDownLatch翻译一下就是&quot;倒数门栓&quot;，可以理解为给一个门上了n把锁，然后锁一把一把的开，直到所有的锁都打开之后，门才能彻底打开。所以CountDownLatch只有一个构造器，构造器传入锁的数量，每个线程执行完一个任务就倒数一次，当所有的线程都执行完成之后，主线程才能继续往下执行，数量需要和需要执行的线程数一致，否则会出现提前释放和无法释放的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">  <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch主要通过await()和countDown()完成锁等待和倒数，没调用一次countDown()就将计数器减一，一般在执行任务的线程内调用，此方法不区分调用者，可以在一个线程内调用多次；await()方法是将调用该方法的线程处于等待状态，一般是主线程调用，可以在多个线程内调用，所有调用了await()方法的线程都将陷入等待，并且共享同一把锁，当CountDownLatch的锁释放完之后，所有等待的线程都同时结束等待并恢复执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 阻塞</span></span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 释放共享锁</span></span><br><span class="line">  sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现在CountDownLatch中也是通过Sync类来控制锁的，并且Sync是CountDownLatch的内部类，我们看一下Sync的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">  Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="comment">// 初始化锁的数量</span></span><br><span class="line">    setState(count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前剩余的锁数量</span></span><br><span class="line">    <span class="keyword">return</span> getState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据剩余锁的数量决定是否加锁成功，若还有剩余锁，则返回-1，表示加锁成功，否则返回1，表示不允许加锁</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState();</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 锁已全部释放，不允许释放</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 锁-1</span></span><br><span class="line">      <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 通过CAS设置state值，确保并发安全</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">        <span class="comment">// 当nextc为0的时候表示锁已经全部释放了</span></span><br><span class="line">        <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>countDown方法工作方式</p><p>tryReleaseShared()方法在AQS的releaseShared()方法中调用，方法中只有一个if判断，控制锁释放的时机，doReleaseShared()方法主要作用是唤醒调用了await()方法的线程。如果CountDownLatch是独占式的，那么当计数器为减至0时，就只有一个线程会被唤醒，这就乱套了，严重BUG。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    doReleaseShared();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 获取等待队列的头结点</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">// 头结点不为空且不是尾结点，也就是等待队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">      <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">      <span class="comment">// SIGNAL表示当前节点的线程正在等待被唤醒</span></span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="comment">// 清楚当前节点的等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 唤醒当前节点的下一个节点</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果h还是头结点，则说明等待队列在上面的代码执行过程中没有被其他线程处理</span></span><br><span class="line">    <span class="keyword">if</span> (h == head)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 清除当前节点的等待状态</span></span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前节点的后继节点</span></span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="comment">// 后继节点不存在或者该节点中的线程已经被取消等待</span></span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 队列从尾部往前遍历，找到最后一个处于等待状态的节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">      <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 唤醒离当前节点最近的处于等待状态的节点线程</span></span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们了解了CountDownLatch的countDown()方法的执行逻辑，总结一下就是每次调用countDown()方法都会将state减1，直到state减至0的时候，调用doReleaseShared()方法将等待队列中的所有线程的等待状态都清除掉(waitStatus通过CAS设置为0)。</p></li><li><p>await()方法工作方式</p><p>await()方法调用了Sync的acquireSharedInterruptibly()方法，在该方法中判断当前线程是否具有共享执行权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 当前线程是否被中断</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">// 判断当前线程是否有执行权限，也就是校验是否还有未释放的锁</span></span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 阻塞</span></span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个共享模式的节点</span></span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取当前节点的前置节点</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="comment">// 前置节点是否为head节点</span></span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="comment">// 加锁，如果还有锁未释放，也就是state&gt;0，方法返回-1，否则返回1</span></span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">        <span class="comment">// 锁已全部释放</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 将当前节点设置为头结点，表示所有线程都已经执行完毕，退出for循环，可以继续await()方法之后的代码</span></span><br><span class="line">          setHeadAndPropagate(node, r);</span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 代码执行到这里说明当前锁还未释放完，使用LockSupport.park(this);挂起当前线程</span></span><br><span class="line">      <span class="comment">// 所有的线程都会等待在此处，在countDown()方法中被LockSupport.unpark(s.thread);唤醒后继续从这里执行</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">  Node h = head;</span><br><span class="line">  setHead(node);</span><br><span class="line">  <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">      (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">      <span class="comment">// 释放并唤醒结束await</span></span><br><span class="line">      doReleaseShared();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用场景</p><ul><li><p>场景1：在每个线程内调用一次countDown()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">  CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> fi = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(fi * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(fi);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        latch.countDown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"before:"</span> + System.currentTimeMillis());</span><br><span class="line">  latch.await();</span><br><span class="line">  System.out.println(<span class="string">"after:"</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>0</p><p>before:1587753222118</p><p>1</p><p>2</p><p>after:1587753224118</p></blockquote></li><li><p>场景2：在每个线程内调用三次countDown()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">  CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> fi = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(fi * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(fi);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        latch.countDown();</span><br><span class="line">        latch.countDown();</span><br><span class="line">        latch.countDown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"before:"</span> + System.currentTimeMillis());</span><br><span class="line">  latch.await();</span><br><span class="line">  System.out.println(<span class="string">"after:"</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>0</p><p>before:1587753292096</p><p>after:1587753292096</p><p>1</p><p>2</p></blockquote></li></ul></li><li><p>总结</p><p>CountDownLatch是通过一个计数器来实现的共享锁，计数器的值就是线程的数量，在主线程中使用CountDownLatch的实例方法await()阻塞所有的线程，阻塞地点在parkAndCheckInterrupt()方法中；每调用一次countDown()方法都会将计数器减1，直到计数器归零之后唤醒所有等待的线程，使await()执行结束，既然await()执行结束了，那么也就可以继续执行await()的后续代码了。</p></li></ol><h3 id="六-总结"><a class="markdownIt-Anchor" href="#六-总结"></a> 六、总结</h3><p>通过CountDownLatch和ReentrantLock可以发现几个特点：</p><ol><li>独占锁的使用和申请加锁线程强关联，每此只能由一个线程霸占着锁，且可以通过当前线程和锁拥有者线程对比来实现锁的重入</li><li>共享锁的使用和线程弱关联，每次可以执行一批线程任务，使用state来控制运行的线程数量，通过LockSupport.park()阻塞这批任务，每个线程执行完之后将state的值减1，直至归零，然后通过LockSupport.unpark()退出阻塞</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-简介&quot;&gt;&lt;/a&gt; 一、简介&lt;/h3&gt;
&lt;p&gt;在Java中，谈到并发就不得不说到jdk中的J.U.C包，而说到此包必定要说到AQS(AbstractQueuedSynchroni
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Canal实现数据库和Redis同步</title>
    <link href="http://luxiaowan.github.io/2020/04/24/%E4%BD%BF%E7%94%A8Canal%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CRedis%E5%90%8C%E6%AD%A5/"/>
    <id>http://luxiaowan.github.io/2020/04/24/使用Canal实现数据库和Redis同步/</id>
    <published>2020-04-23T16:35:00.000Z</published>
    <updated>2020-04-23T17:43:57.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-简介"><a class="markdownIt-Anchor" href="#一-简介"></a> 一、简介</h3><p>Canal是Java开发的基于数据库增量日志解析工具，提供增量数据订阅和消费，目前主要支持MySQL。它的工作原理比较简单，就是将自己伪装成一个MySQL Slave，从Master同步数据。</p><ul><li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</li><li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</li><li>canal 解析 binary log 对象(原始为 byte 流)</li><li>解析后的数据再做后续处理</li></ul><p><img src="/images/canal.png" alt="img"></p><p>先了解一下MySQL主备复制原理：</p><ul><li>MySQL master 将数据变更写入二进制日志( binary log, 其中记录叫做二进制日志事件binary log events，可以通过 show binlog events 进行查看)</li><li>MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)</li><li>MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li></ul><h3 id="二-准备工作"><a class="markdownIt-Anchor" href="#二-准备工作"></a> 二、准备工作</h3><ol><li>对于自建的MySQL，需要开启binlog写入功能，并配置biglog-format为ROW模式，这样才能一行行的检测到数据的变动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin # 开启 binlog</span><br><span class="line">binlog-format=ROW # 选择 ROW 模式</span><br><span class="line">server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复</span><br></pre></td></tr></table></figure><ol start="2"><li>创建canal用户并授权其作为MySQL Slave的权限</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER canal IDENTIFIED BY &apos;canal&apos;;</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;canal&apos;@&apos;%&apos;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h3 id="三-启动canal服务"><a class="markdownIt-Anchor" href="#三-启动canal服务"></a> 三、启动Canal服务</h3><ol><li><p>下载canal</p><p>我们这里使用的是<a href="https://github.com/alibaba/canal/releases/download/canal-1.1.4/canal.deployer-1.1.4.tar.gz" target="_blank" rel="noopener">canal.deployer-1.1.4.tar.gz</a></p></li><li><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf canal.deployer-1.1.4.tar.gz</span><br><span class="line">cd canal.deployer-1.1.4</span><br></pre></td></tr></table></figure><img src="/images/image-20200424004844430.png" alt="image-20200424004844430" style="zoom:50%;"></li><li><p>修改配置文件，主要是MySQL Master的连接信息</p><p>打开文件<code>conf/example/instance.properties</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># mysql serverId , v1.0.26+ will autoGen</span></span></span><br><span class="line">canal.instance.mysql.slaveId=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">enable</span> gtid use <span class="literal">true</span>/<span class="literal">false</span></span></span><br><span class="line">canal.instance.gtidon=false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> position info</span></span><br><span class="line">canal.instance.master.address=127.0.0.1:3306</span><br><span class="line">canal.instance.master.journal.name=</span><br><span class="line">canal.instance.master.position=</span><br><span class="line">canal.instance.master.timestamp=</span><br><span class="line">canal.instance.master.gtid=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rds oss binlog</span></span><br><span class="line">canal.instance.rds.accesskey=</span><br><span class="line">canal.instance.rds.secretkey=</span><br><span class="line">canal.instance.rds.instanceId=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> table meta tsdb info</span></span><br><span class="line">canal.instance.tsdb.enable=true</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.tsdb.dbUsername=canal</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.tsdb.dbPassword=canal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.address =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.journal.name =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.position =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.timestamp =</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.standby.gtid=</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> username/password</span></span><br><span class="line">canal.instance.dbUsername=canal</span><br><span class="line">canal.instance.dbPassword=canal</span><br><span class="line">canal.instance.defaultDatabaseName=test_canal</span><br><span class="line">canal.instance.connectionCharset = UTF-8</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">enable</span> druid Decrypt database password</span></span><br><span class="line">canal.instance.enableDruid=false</span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.pwdPublicKey=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALK4BUxdDltRRE5/zXpVEVPUgunvscYFtEip3pmLlhrWpacX7y7GCMo2/JM6LeHmiiNdH1FWgGCpUfircSwlWKUCAwEAAQ==</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> table regex</span></span><br><span class="line">canal.instance.filter.regex=.*\\..*</span><br><span class="line"><span class="meta">#</span><span class="bash"> table black regex</span></span><br><span class="line">canal.instance.filter.black.regex=</span><br><span class="line"><span class="meta">#</span><span class="bash"> table field filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.filter.field=test1.t_product:id/subject/keywords,test2.t_company:id/name/contact/ch</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> table field black filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">canal.instance.filter.black.field=test1.t_product:subject/product_image,test2.t_company:id/name/contact/ch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mq config</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> canal.mq.topic=example</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dynamic topic route by schema or table regex</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> canal.mq.dynamicTopic=mytest1.user,mytest2\\..*,.*\\..*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> canal.mq.partition=0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">hash</span> partition config</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> canal.mq.partitionsNum=3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> canal.mq.partitionHash=test.table:id^name,.*\\..*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br></pre></td></tr></table></figure><ul><li>canal.instance.connectionCharset 代表数据库的编码方式对应到 java 中的编码类型，比如 UTF-8，GBK , ISO-8859-1</li><li>如果系统是1个 cpu，需要将 canal.instance.parser.parallel 设置为 false</li></ul></li><li><p>启动canal</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/startup.sh</span><br></pre></td></tr></table></figure></li><li><p>查看server和instance日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-04-23 23:48:59.048 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## set default uncaught exception handler</span><br><span class="line">2020-04-23 23:48:59.097 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## load canal configurations</span><br><span class="line">2020-04-23 23:48:59.110 [main] INFO  com.alibaba.otter.canal.deployer.CanalStarter - ## start the canal server.</span><br><span class="line">2020-04-23 23:48:59.178 [main] INFO  com.alibaba.otter.canal.deployer.CanalController - ## start the canal server[192.168.0.106(192.168.0.106):11111]</span><br><span class="line">2020-04-23 23:49:00.243 [main] INFO  com.alibaba.otter.canal.deployer.CanalStarter - ## the canal server is running now ......</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">er.setConnectionCharset(java.lang.String)]</span><br><span class="line">2020-04-23 23:48:59.793 [main] INFO  c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [canal.properties]</span><br><span class="line">2020-04-23 23:48:59.794 [main] INFO  c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [example/instance.properties]</span><br><span class="line">2020-04-23 23:49:00.192 [main] INFO  c.a.otter.canal.instance.spring.CanalInstanceWithSpring - start CannalInstance for 1-example</span><br><span class="line">2020-04-23 23:49:00.199 [main] WARN  c.a.o.canal.parse.inbound.mysql.dbsync.LogEventConvert - --&gt; init table filter : ^.*\..*$</span><br><span class="line">2020-04-23 23:49:00.199 [main] WARN  c.a.o.canal.parse.inbound.mysql.dbsync.LogEventConvert - --&gt; init table black filter :</span><br><span class="line">2020-04-23 23:49:00.206 [main] INFO  c.a.otter.canal.instance.core.AbstractCanalInstance - start successful....</span><br></pre></td></tr></table></figure></li><li><p>关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/stop.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="四-创建java工程"><a class="markdownIt-Anchor" href="#四-创建java工程"></a> 四、创建Java工程</h3><ol><li><p>引入canal和redis包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.otter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal.client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建RedisUtils工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis服务器IP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String      ADDR       = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>         PORT       = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String      AUTH       = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可用连接实例的最大数目，默认值为8；</span></span><br><span class="line">    <span class="comment">// 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>         MAX_ACTIVE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>         MAX_IDLE   = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>         MAX_WAIT   = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过期时间</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span>       expireTime = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接池</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> JedisPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态代码，只在初次调用一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        <span class="comment">//最大连接数</span></span><br><span class="line">        config.setMaxTotal(MAX_ACTIVE);</span><br><span class="line">        <span class="comment">//最多空闲实例</span></span><br><span class="line">        config.setMaxIdle(MAX_IDLE);</span><br><span class="line">        <span class="comment">//超时时间</span></span><br><span class="line">        config.setMaxWaitMillis(MAX_WAIT);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        config.setTestOnBorrow(<span class="keyword">false</span>);</span><br><span class="line">        pool = <span class="keyword">new</span> JedisPool(config, ADDR, PORT, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取jedis实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = pool.getResource();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pool.returnBrokenResource(jedis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放jedis资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isBroken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeResource</span><span class="params">(Jedis jedis, <span class="keyword">boolean</span> isBroken)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isBroken) &#123;</span><br><span class="line">                pool.returnBrokenResource(jedis);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pool.returnResource(jedis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  是否存在key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">existKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isBroken = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            jedis.select(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> jedis.exists(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            isBroken = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeResource(jedis, isBroken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  删除key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isBroken = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            jedis.select(<span class="number">0</span>);</span><br><span class="line">            jedis.del(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            isBroken = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeResource(jedis, isBroken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  取得key的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stringGet</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isBroken = <span class="keyword">false</span>;</span><br><span class="line">        String lastVal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            jedis.select(<span class="number">0</span>);</span><br><span class="line">            lastVal = jedis.get(key);</span><br><span class="line">            jedis.expire(key, expireTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            isBroken = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeResource(jedis, isBroken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  添加string数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stringSet</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isBroken = <span class="keyword">false</span>;</span><br><span class="line">        String lastVal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            jedis.select(<span class="number">0</span>);</span><br><span class="line">            lastVal = jedis.set(key, value);</span><br><span class="line">            jedis.expire(key, expireTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            isBroken = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeResource(jedis, isBroken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  添加hash数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hashSet</span><span class="params">(String key, String field, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isBroken = <span class="keyword">false</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.select(<span class="number">0</span>);</span><br><span class="line">                jedis.hset(key, field, value);</span><br><span class="line">                jedis.expire(key, expireTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            isBroken = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeResource(jedis, isBroken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建CanalClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.common.utils.AddressUtils;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建链接</span></span><br><span class="line">        CanalConnector connector = CanalConnectors</span><br><span class="line">                .newSingleConnector(<span class="keyword">new</span> InetSocketAddress(AddressUtils.getHostIp(), <span class="number">11111</span>), <span class="string">"example"</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connector.connect();</span><br><span class="line">            connector.subscribe(<span class="string">".*\\..*"</span>);</span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Message message = connector.getWithoutAck(batchSize); <span class="comment">// 获取指定数量的数据</span></span><br><span class="line">                <span class="keyword">long</span> batchId = message.getId();</span><br><span class="line">                <span class="keyword">int</span> size = message.getEntries().size();</span><br><span class="line">                <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    printEntry(message.getEntries());</span><br><span class="line">                &#125;</span><br><span class="line">                connector.ack(batchId); <span class="comment">// 提交确认</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEntry</span><span class="params">(List&lt;Entry&gt; entrys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getEntryType() == EntryType.TRANSACTIONBEGIN</span><br><span class="line">                    || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RowChange rowChage = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rowChage = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ERROR ## parser of eromanga-event has an error , data:"</span> + entry.toString(),</span><br><span class="line">                        e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EventType eventType = rowChage.getEventType();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class="line">                    <span class="comment">// 删除，获取删除前的数据</span></span><br><span class="line">                    redisDelete(rowData.getBeforeColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                  <span class="comment">// 新增，获取新增后的数据</span></span><br><span class="line">                    redisSet(rowData.getAfterColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 修改，获取修改后的数据</span></span><br><span class="line">                    <span class="comment">//                    printColumn(rowData.getBeforeColumnsList());</span></span><br><span class="line">                    redisSet(rowData.getAfterColumnsList());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">redisSet</span><span class="params">(List&lt;Column&gt; columns)</span> </span>&#123;</span><br><span class="line">        JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">      <span class="comment">// 字段和值的列表，放入json，后续作为redis的值</span></span><br><span class="line">        <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">            json.put(column.getName(), column.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (columns.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">"set key: "</span> + columns.get(<span class="number">0</span>).getValue() + <span class="string">", value: "</span> + json.toJSONString());</span><br><span class="line">          <span class="comment">// 获取第一列主键的数据</span></span><br><span class="line">            RedisUtils.stringSet(<span class="string">"demo:"</span> + columns.get(<span class="number">0</span>).getValue(), json.toJSONString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">redisDelete</span><span class="params">(List&lt;Column&gt; columns)</span> </span>&#123;</span><br><span class="line">        JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">            json.put(column.getName(), column.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (columns.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">"delete key: "</span> + columns.get(<span class="number">0</span>).getValue());</span><br><span class="line">            RedisUtils.delKey(<span class="string">"demo:"</span> + columns.get(<span class="number">0</span>).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="五-验证"><a class="markdownIt-Anchor" href="#五-验证"></a> 五、验证</h3><ol><li><p>启动CanalClient.java</p></li><li><p>创建数据表test_canal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_canal` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(11) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT 0,</span><br><span class="line">  `sex` varchar(11) DEFAULT &apos;男&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_name` (`name`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4</span><br></pre></td></tr></table></figure></li><li><p>校验一下Redis中目前是否为空</p><p><img src="/images/image-20200424011739125.png" alt="image-20200424011739125"></p></li><li><p>插入数据</p><ul><li>插入三条数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO test_canal(name, age, sex) VALUES(&apos;cc0&apos;, 3, &apos;男&apos;);</span><br><span class="line">INSERT INTO test_canal(name, age, sex) VALUES(&apos;cc1&apos;, 6, &apos;女&apos;);</span><br><span class="line">INSERT INTO test_canal(name, age, sex) VALUES(&apos;cc2&apos;, 9, &apos;男&apos;);</span><br></pre></td></tr></table></figure><ul><li>查看控制台</li></ul><p><img src="/images/image-20200424011949902.png" alt="image-20200424011949902"></p><ul><li>查询Redis中的数据</li></ul><img src="/images/image-20200424012034154.png" alt="image-20200424012034154" style="zoom: 50%;"><p>验证成功，数据同步达到了毫秒级。</p></li><li><p>修改数据</p><ul><li>修改id=5的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE test_canal SET sex=&apos;11&apos; WHERE id=5;</span><br></pre></td></tr></table></figure><ul><li>查看控制台</li></ul><img src="/images/image-20200424012346073.png" alt="image-20200424012346073" style="zoom:44%;"><ul><li>查询Redis中的数据</li></ul><img src="/images/image-20200424012421781.png" alt="image-20200424012421781" style="zoom:50%;"><p>验证成功，Redis中的sex列已经修改为何MySQL表中一致了</p></li><li><p>删除数据</p><ul><li>删除id=5的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM test_canal WHERE id=5;</span><br></pre></td></tr></table></figure><ul><li>查看控制台</li></ul><img src="/images/image-20200424012700399.png" alt="image-20200424012700399" style="zoom:50%;"><ul><li>查询Redis中的数据</li></ul><img src="/images/image-20200424013951523.png" alt="image-20200424013951523" style="zoom:50%;"><p>验证成功，Redis中的&quot;demo:5&quot;已经被删除了</p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>关于更多的Canal介绍可以查看官方文档：<a href="https://github.com/alibaba/canal/wiki/%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">Canal官方介绍</a>，源端目前只支持MySQL，目标端可以是任意组件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-简介&quot;&gt;&lt;/a&gt; 一、简介&lt;/h3&gt;
&lt;p&gt;Canal是Java开发的基于数据库增量日志解析工具，提供增量数据订阅和消费，目前主要支持MySQL。它的工作原理比较简单，就是将自
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Maven中optional和exclusion的区别</title>
    <link href="http://luxiaowan.github.io/2020/04/23/Maven%E4%B8%ADoptional%E5%92%8Cexclusion%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://luxiaowan.github.io/2020/04/23/Maven中optional和exclusion的区别/</id>
    <published>2020-04-23T03:20:00.000Z</published>
    <updated>2020-04-23T05:07:04.699Z</updated>
    
    <content type="html"><![CDATA[<p>用了那么久的Maven，我们都知道Maven的依赖关系具有传递性，比如A依赖B，B依赖C，那么A也依赖于C，具体在项目中的表现见图：</p><p><img src="/images/image-20200423122520591.png" alt="image-20200423122520591"></p><p>上述依赖在pom.xml中的关系是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">C(cc-spring-boot-starter-autoconfigure):</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">B(cc-spring-boot-starter):</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-starter-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">A(cc-starter-demo):</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在实际的应用中，项目A可能不是必须依赖C，如果不做处理的话，最终会让项目A非常的臃肿，打的包非常大。在Maven中，提供了两种方式管理非必须的依赖关系：可选依赖(Optional Dependencies)和依赖排除(Dependency Exclusion)。</p><h3 id="一-依赖排除exclusion"><a class="markdownIt-Anchor" href="#一-依赖排除exclusion"></a> 一、依赖排除(exclusion)</h3><p>在项目A中，不需要依赖项目C中的<code>org.springframework.boot:spring-boot-configuration-processor</code>包，但是项目B仍然需要依赖它，也就是说我们需要在项目A中将这个包排除掉，但是又不能影响其他项目对这个包的依赖，关系图为：</p><p><img src="/images/image-20200423122841522.png" alt="image-20200423122841522"></p><p>我们只要在需要排除的项目A中，对依赖的dependency加上exclusion并指定要排除包的groupId和artifactId即可，不需要指定版本号，若上有项目依赖了多个相同包的不同版本，在这里会全部都排除掉。对应的pom.xml文件内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">C(cc-spring-boot-starter-autoconfigure):</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">B(cc-spring-boot-starter):</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-starter-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">A(cc-starter-demo):</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二-可选依赖optional"><a class="markdownIt-Anchor" href="#二-可选依赖optional"></a> 二、可选依赖(optional)</h3><p>可选依赖就厉害了，只允许在当前项目使用，从不往下传递，下游项目要是想使用的话需要自己重新引入，比如<code>org.springframework.boot:spring-boot-configuration-processor</code>是自动生成配置参数的功能性包，也仅仅就在生成参数声明的时候用到，没必要往下传递，那么这种就需要在项目C中做控制了，严禁它依赖的包向下传递。</p><p><img src="/images/image-20200423124556099.png" alt="image-20200423124556099"></p><p>我们在项目C中将<code>org.springframework.boot:spring-boot-configuration-processor</code>的optional选项设置为true，默认为false（true: 不向下传递，false: 向下传递），在<code>org.mybatis:mybatis</code>包中有大量的应用，可以自行查看一下，这里放张图：</p><img src="/images/image-20200423125547745.png" alt="image-20200423125547745" style="zoom:67%;"><p>项目pom.xml内容如下，关注一下项目C的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C(cc-spring-boot-starter-autoconfigure):</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">B(cc-spring-boot-starter):</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-starter-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">A(cc-starter-demo):</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>在Maven依赖管理中，有依赖排除和可选依赖两种方式可以屏蔽项目不需要的包，区别是只想在当前项目使用的话就用可选依赖，若在当前项目不想使用依赖的包中的某个包，则用依赖排除。</p><ol><li>可选依赖是在第一级被引用的地方使用optional标签声明</li><li>依赖排除是在具体不需要依赖的那一级（也可以理解为最后一级）使用exclusion控制</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用了那么久的Maven，我们都知道Maven的依赖关系具有传递性，比如A依赖B，B依赖C，那么A也依赖于C，具体在项目中的表现见图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/image-20200423122520591.png&quot; alt=&quot;image-20200
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="Maven" scheme="http://luxiaowan.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自定义starter</title>
    <link href="http://luxiaowan.github.io/2020/04/23/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <id>http://luxiaowan.github.io/2020/04/23/SpringBoot自定义starter/</id>
    <published>2020-04-22T17:16:00.000Z</published>
    <updated>2020-04-22T19:15:22.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-简介"><a class="markdownIt-Anchor" href="#一-简介"></a> 一、简介</h3><p>SpringBoot由众多的starter组成，这些starter也被称为是场景启动器，在工程中引入特定的starter再进行少量的配置就可以使用其提供的相应的功能了，SpringBoot在不断的维护和扩展不同场景的starter给使用者提供更完善的功能，我们也可以创建自定义的starter制定我们自己的特定场景。</p><h3 id="二-springboot中的starter"><a class="markdownIt-Anchor" href="#二-springboot中的starter"></a> 二、SpringBoot中的starter</h3><ol><li><p>我们查看SpringBoot提供的starter可以发现所有的starter包下都没有任何代码</p><img src="/images/image-20200423013229581.png" alt="starter" style="zoom:67%;"></li><li><p>我们找到<code>spring-boot-starter-data-redis.jar</code>包的pom.xml查看一下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Boot Data Redis Starter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 省略一部分 --&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们看到这个starter继承自<code>spring-boot-starters</code>包，并且所有的starter都引入了<code>spring-boot-starter</code>包，包中还可以根据需要选择性的引入其他的jar包。</p></li><li><p>进入到<code>spring-boot-starter</code>包中，可以找到它引入了<code>spring-boot-autoconfigure</code>包，这是我们完成自动配置的关键</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>查看<code>spring-boot-autoconfigure.jar</code>的目录结构发现包含了各种starter的配置信息。</p><ul><li>标1：需要自动配置的类声明文件</li><li>标2：配置文件中自动提示的元属性数据声明文件</li><li>标3：自动配置控制类</li><li>标4：场景属性类</li></ul><img src="/images/image-20200423015235559.png" alt="autoconfigure" style="zoom:67%;"></li></ol><p>以上就是一个starter的关键所在了，总结下来就是：</p><blockquote><ul><li>启动器starter只是用来做依赖管理的，其不应该包含任何代码和配置，需要引入autoconfigure包</li><li>自动装配autoconfigure包，需要包含我们需要让SpringBoot自动装配的模块，以及资源配置信息，总的来说包括：spring.factories、spring-configuration-metadata.json、XxxAutoConfiguration、XxxProperties</li><li>使用的时候只需要引入启动器starter就可以实现自动配置</li></ul></blockquote><h3 id="三-自定义starter命名规范"><a class="markdownIt-Anchor" href="#三-自定义starter命名规范"></a> 三、自定义starter命名规范</h3><ul><li>官方命名规范<ul><li>规则：spring-boot-starter-模块名</li><li>举例：spring-boot-starter-data-redis、spring-boot-starter-web</li></ul></li><li>自定义命名规范<ul><li>规则：模块名-spring-boot-starter</li><li>举例：cc-spring-boot-starter</li></ul></li></ul><h3 id="四-自定义starter-demo"><a class="markdownIt-Anchor" href="#四-自定义starter-demo"></a> 四、自定义starter demo</h3><p>根据上面的描述，我们需要创建两个项目：cc-spring-boot-autoconfigure和cc-spring-boot-starter</p><ol><li><p>创建cc-spring-boot-autoconfigure工程</p><p>需要注意的是在工程创建完成之后，要删除启动类、application.properties和test文件夹</p><ul><li><p>pom.xml和控制类</p><ul><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>CcProperties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.lu.autoconfigure.wt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"cc.config"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String  name = <span class="string">"cc"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age  = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String  birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(String birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CcProperties&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">", birthday='"</span> + birthday + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的有些属性被设置了值，这些值就是当配置文件未配置属性时使用的默认值，这就是参数配置设置默认值的一种方式。还有一种，继续往下看</p></li><li><p>CcService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.lu.autoconfigure.wt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CcProperties ccProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCcProperties</span><span class="params">(CcProperties ccProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ccProperties = ccProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ccProperties.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个普通的类，没啥可说的，继续往下</p></li><li><p>CcAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.lu.autoconfigure.wt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; CcService.class &#125;)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123; CcProperties.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CcProperties ccProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(&#123; CcService.class &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CcService <span class="title">ccService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CcService ccService = <span class="keyword">new</span> CcService();</span><br><span class="line">      <span class="comment">// 打个日志查看方法是否被调用</span></span><br><span class="line">        System.out.println(<span class="string">"------auto register!------"</span>);</span><br><span class="line">        ccService.setCcProperties(ccProperties);</span><br><span class="line">        <span class="keyword">return</span> ccService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CcAutoConfiguration的声明上使用了@ConditionalOnClass和@EnableConfigurationProperties做加载控制，然后在类中创建了CcService的实例，并且使用<code>@ConditionalOnMissingBean({ CcService.class })</code>来控制创建条件。</p></li></ul></li><li><p>spring.factories和spring-configuration-metadata.json配置</p><ul><li><p>spring.factories</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">  <span class="attr">cc.lu.autoconfigurer.wt.CcAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>将CcAutoConfiguration放给EnableAutoConfiguration，告知SpringBoot启动的时候进行检测加载。</p></li><li><p>spring-configuration-metadata.json元属性数据配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"groups"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"cc.config"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"cc.lu.autoconfigure.wt.CcProperties"</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"cc.lu.autoconfigure.wt.CcProperties"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"properties"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"cc.config.age"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"java.lang.Integer"</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"cc.lu.autoconfigure.wt.CcProperties"</span>,</span><br><span class="line">      <span class="attr">"defaultValue"</span>: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"cc.config.birthday"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"java.lang.String"</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"cc.lu.autoconfigure.wt.CcProperties"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"cc.config.name"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"java.lang.String"</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"cc.lu.autoconfigure.wt.CcProperties"</span>,</span><br><span class="line">      <span class="attr">"defaultValue"</span>: <span class="string">"cc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"hints"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件的目的是在properties或yml文件中配置自定义属性的时候，可以自动提示，例如：</p><p><img src="/images/image-20200423023445975.png" alt="image-20200423023445975"></p><p>这个文件看上去好像非常复杂，尤其是当我们有几十个自定义配置属性的时候，难道要一个个属性的去写吗？答案是当然不用，可以通过引入一个jar包来在打包的时候自动生成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入之后，执行完命令<code>mvn clean package</code>之后，到target/classes/META-INF目录下查看自动生成的文件</p><img src="/images/image-20200423024104706.png" alt="image-20200423024104706" style="zoom:60%;"></li></ul></li></ul><p>至此，我们的cc-spring-boot-autoconfigure就创建完成了，回瞄一眼，是不是和官方的autoconfigure包含的文件一致了。</p></li><li><p>创建cc-spring-boot-starter工程</p><p>一个很普通的maven工程，因为starter中一般不包含任何代码，仅仅作为包的依赖管理工程，所以创建完成之后依然要删除启动类、application.properties和test文件夹，它只有一个pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>cc-spring-boot-starter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建cc-starter-demo测试工程</p><p>创建一个常规的SpringBoot工程，引入我们自定义的starter，并设置相关的配置信息，就可以使用了。</p><ul><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.properties</p><p>修改birthday和name两个属性，age使用默认值，待会看效果</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">cc.config.birthday</span>=<span class="string">2017-03-09</span></span><br><span class="line"><span class="meta">cc.config.name</span>=<span class="string">yc</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.lu.starter.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cc.lu.autoconfigurer.wt.CcService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CcService ccService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/info"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(ccService.info());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="五-测试"><a class="markdownIt-Anchor" href="#五-测试"></a> 五、测试</h3><h5 id="1-情况一"><a class="markdownIt-Anchor" href="#1-情况一"></a> 1. 情况一</h5><ul><li><p>启动cc-starter-demo工程，查看启动日志，会发现我们在CcAutoConfiguration中打印的字符串<code>------auto register!------</code>出现在了控制台，说明CcService的实例创建是在CcAutoConfiguration中完成的。</p><img src="/images/image-20200423030101381.png" alt="image-20200423030101381" style="zoom:60%;"></li><li><p>访问http://127.0.0.1:8080/info，查看控制台的日志，看到我们在application.properties文件中配置的值生效了，也就是我们的starter写的正常。</p><img src="/images/image-20200423030335580.png" alt="image-20200423030335580" style="zoom:60%;"></li></ul><h5 id="2-情况二"><a class="markdownIt-Anchor" href="#2-情况二"></a> 2. 情况二</h5><ul><li><p>在启动类中重新定义CcService的实例创建方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CcService <span class="title">ccService</span><span class="params">(CcProperties ccProperties)</span> </span>&#123;</span><br><span class="line">  CcService ccService = <span class="keyword">new</span> CcService();</span><br><span class="line">  <span class="comment">// 打个日志查看方法是否被调用</span></span><br><span class="line">  System.out.println(<span class="string">"====client register===="</span>);</span><br><span class="line">  ccService.setCcProperties(ccProperties);</span><br><span class="line">  <span class="keyword">return</span> ccService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动工程，查看控制台是打印了字符串<code>====client register====</code>还是<code>------auto register!------</code></p><img src="/images/image-20200423030703200.png" alt="image-20200423030703200" style="zoom:67%;"><p>控制台打印的是我们demo工程里创建CcService实例方法内的字符串，而CcAutoConfiguration内的打印语句未执行，这是因为我们在CcAutoConfiguration类中的方法加了<code>@ConditionalOnMissingBean({ CcService.class })</code>来控制实例的创建。(划知识点，约定大于配置)</p></li></ul><h3 id="六-总结"><a class="markdownIt-Anchor" href="#六-总结"></a> 六、总结</h3><p>通过自定义starter分析一下其工作原理：</p><ol><li>SpringBoot在启动时扫描项目依赖的全部jar包，并寻找<code>META-INF/spring.factories</code>文件</li><li>根据<code>META-INF/spring.factories</code>加载符合条件的<code>AutoConfigure</code>类</li><li>根据<code>@Conditional</code>注解条件进行自动配置，并将Bean注入到Spring Context中。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-简介&quot;&gt;&lt;/a&gt; 一、简介&lt;/h3&gt;
&lt;p&gt;SpringBoot由众多的starter组成，这些starter也被称为是场景启动器，在工程中引入特定的starter再进行少量的
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>说说SpringBoot是如何实现自动装配的</title>
    <link href="http://luxiaowan.github.io/2020/04/21/%E8%AF%B4%E8%AF%B4SpringBoot%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84/"/>
    <id>http://luxiaowan.github.io/2020/04/21/说说SpringBoot是如何实现自动装配的/</id>
    <published>2020-04-21T12:02:00.000Z</published>
    <updated>2020-04-22T16:09:55.197Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot是Spring家族中的新宠，它不仅继承了Spring框架原有的优秀特性，还通过简化配置来进一步简化Spring应用程序的创建和开发过程。SpringBoot框架中有两个最主要的策略：开箱即用和约定优于配置。</p><ul><li>开箱即用：在开发过程中，通过引入maven依赖包，然后使用注解来代替繁琐的XML配置文件来管理对象的生命周期，这让开发人员摆脱了复杂的配置和包依赖管理的工作，更加专注于业务逻辑。</li><li>约定优于配置：按约定编程是一种软件设计范式，系统、类库、框架应该假定合理的默认值，而非要求提供不必要的配置，从而既能获得配置简单的好处，而又不失灵活性。</li></ul><p>有关SpringBoot的概念就不说太多了，可以查看一下官方文档。</p><h3 id="自动配置"><a class="markdownIt-Anchor" href="#自动配置"></a> 自动配置</h3><p>SpringBoot的自动配置乍一看很神奇，其实原理非常简单，实现自动配置的核心就是@Conditional注解。</p><h4 id="一-condition是什么"><a class="markdownIt-Anchor" href="#一-condition是什么"></a> 一、@Condition是什么</h4><p>@Condition是Spring4的一个新特性，注解的注释第一句写到“表明仅当所有组件都符合注册条件时，该组件才具有注册资格”，所以我们可以根据这个注解动态的决定需要加载的Bean。</p><p>例如我们想要根据不同的环境加载不同的类，我们可以通过<code>spring.profiles.active=dev</code>指定当前环境，创建类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> PropConfig <span class="title">devDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"pre"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> PropConfig <span class="title">preDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"prd"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> PropConfig <span class="title">prdDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里用到了@Profile注解，这个注解是spring3.1之后版本中提供的，从注解的定义上我们可以看到它也是一个Conditional，可以通过<code>ConfigurableEnvironment#setActiveProfiles</code>方法和<code>spring.profiles.active</code>配置完成设置，当然还有其他方法，这里就不一一写出了，详情可以查看类<code>org.springframework.core.env.AbstractEnvironment</code>。</p><p>在业务复杂的情况下，可以使用@Conditional注解来提供更加灵活的条件判断，在SpringBoot中的的很多CccConfiguration类上都设置了很多的Conditional，整理后发现大致有以下几种：</p><ol><li><code>@ConditionalOnClass</code>：当classpath下存在指定的类时，加载被注解的类，使用方法<code>@ConditionalOnClass({A.class, B.class, C.class})</code></li><li><code>@ConditionalOnBean</code>：当Spring容器中存在指定的Bean实例时，加载被注解的类，使用方法<code>@ConditionalOnBean({A.class, B.class})</code></li><li><code>@ConditionalOnMissingBean</code>：当Spring容器中不存在指定的Bean实例时，加载被注解的类，使用方法<code>@ConditionalOnMissingBean({A.class, B.class, C.class})</code></li><li><code>@ConditionalOnMissingClass</code>：当classpath下不存在指定的类时，加载被注解的类，使用方法<code>@ConditionalOnMissingClass({&quot;cc.lu.A&quot;, &quot;cc.lu.B&quot;})</code></li><li><code>@ConditionalOnProperty</code>：控制某个configuration是否生效。具体操作是通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值，如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效，使用方法<code>@ConditionalOnProperty(prefix=&quot;cc.lu.config&quot;, name=&quot;enable&quot;, havingValue=&quot;true&quot;)</code>，上面的<code>@Profile(&quot;dev&quot;)</code>对等于<code>@ConditionalOnProperty(name=&quot;spring.profiles.active&quot;, havingValue=&quot;dev&quot;)</code></li></ol><p>还有很多常用到的注解，可以到<code>org.springframework.autoconfigure.condition</code>包内了解一下，每一个注解单独拿出来都可以讨论半天。下面我们写一个简单的例子：当classpath路径中存在<code>cc.lu.A</code>类、容器中不存在<code>cc.lu.B</code>类且存在配置<code>cc.lu.config.auto=true</code>时加载<code>cc.lu.Cc</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.lu;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(A.class)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(B.class)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix=<span class="string">"cc.lu.config"</span>, name=<span class="string">"auto"</span>, havingValue=<span class="string">"true"</span>, matchIfMissing=<span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在构造器中打印一句话来校验构造器是否被调用</span></span><br><span class="line">    System.out.println(<span class="string">"Cc init......"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二-cccautoconfiguration分析"><a class="markdownIt-Anchor" href="#二-cccautoconfiguration分析"></a> 二、CccAutoConfiguration分析</h4><p>上面了解了<code>@Conditional</code>注解的机制，也写了一个简单的例子，灵的同学应该已经能猜到SpringBoot是如何来实现自动配置的了，我们现在基于2.2.6版本的源码来粗略的看一下。</p><p>我们创建一个SpringBoot工程，idea可以通过Spring Initializr来快速的创建一个项目，然后我们看整个工程的入口，也就是Application.java(新创建的SpringBoot应用一般只有一个启动类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CcApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然过程只有这么一个类，那么关键点就是<code>@SpringBootApplication</code>和<code>SpringApplication#run</code>了，我们先来看下注解<code>@SpringBootApplication</code>，这玩意儿放在启动类上是想要干啥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个注解上有一个<code>@EnableAutoConfiguration</code>，这个注解的目的是启用Spring应用程序上下文的自动配置，尝试猜测和配置可能需要的bean。再来瞜一眼这个注解的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎，这个<code>@Import</code>注解把<code>AutoConfigurationImportSelector</code>这个类导入了进来，也就是说我们使用<code>@EnableAutoConfiguration</code>的时候，<code>AutoConfigurationImportSelector</code>类会自动被加载，那么是不是核心代码就是在这个类中了？(这样写貌似有点尬！)</p><p><code>AutoConfigurationImportSelector</code>实现于<code>ImportSelector</code>，关键方法就是<code>ImportSelector#selectImports</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">    <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 加载META-INF/additional-spring-configuration-metadata.json文件，将配置信息加载到环境中，这里就是为什么配置有默认值的关键，可用到jar包里面查看一下</span></span><br><span class="line">  AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">    .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">  <span class="comment">// 加载META-INF/spring.factories文件，并将org.springframework.boot.autoconfigure.EnableAutoConfiguration的值以列表的形式返回</span></span><br><span class="line">  AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);</span><br><span class="line">  <span class="comment">// 将需要加载的AutoConfiguration返回</span></span><br><span class="line">  <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验是否开启了自动配置</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getClass() == AutoConfigurationImportSelector.class) &#123;</span><br><span class="line">    <span class="keyword">return</span> getEnvironment().getProperty(EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY, Boolean.class, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>selectImports</code>的源码可以看到它只做了两件事：加载默认的配置属性和返回所有的AutoConfiguration的类信息，通过方法调用链找到最终加载的方法是<code>SpringFactoriesLoader#loadSpringFactories</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">  MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取classpath下所有的META-INF/spring.factories文件</span></span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?classLoader.getResources(FACTORIES_RESOURCE_LOCATION):ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">    result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">      URL url = urls.nextElement();</span><br><span class="line">      UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">      <span class="comment">// 加载文件内容</span></span><br><span class="line">      Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">      <span class="comment">// 将文件内容存在到Map中</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">        String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">        <span class="comment">// value是使用逗号分隔的，所以这里转换成数组，也就是把一碗米饭分成一粒粒的</span></span><br><span class="line">        <span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">          result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(classLoader, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot为我们提供的配置类有一二百个，但是我们不可能每个工程都把它们全部引入。所以在自动装配的时候，会去classpath下面寻找，是否有对应的配置类。如果有配置类，则按条件注解 @Conditional或者@ConditionalOnProperty等相关注解进行判断，决定是否需要装配。如果classpath下面没有对应的字节码，则不进行任何处理。</p><p>我们到spring.factories文件中随便找一个AutoConfiguration类，比如<code>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RedisOperations.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(RedisProperties.class)</span><br><span class="line"><span class="meta">@Import</span>(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类被<code>@ConditionalOnClass</code>和<code>@EnableConfigurationProperties</code>两个注解修饰。</p><ul><li><code>@ConditionalOnClass(RedisOperations.class)</code>的意思是当classpath路径下存在<code>RedisOperations</code>这个类的时候加载<code>RedisAutoConfiguration</code>，类<code>RedisOperations</code>在spring-data-redis.jar包中，这个包通过<code>spring-boot-starter-data-redis</code>的starter引入，所以在我们引入这个starter的时候就自动去加载了RedisAutoConfiguration，然后再类中又创建了两个Bean，创建的前提是容器中不存在这两个类的实例，如果我们自定义一个RedisTemplate的实例，RedisAutoConfiguration#redisTemplate方法就会失效。</li><li><code>@EnableConfigurationProperties(RedisProperties.class)</code>：在加载RedisAutoConfiguration的时候同步加载RedisProperties，RedisProperties中通过注解<code>@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</code>指定关联的配置信息，若没有配置则使用类中属性的默认值。</li></ul><p>至此，容器中有了RedisTemplate的实例和StringRedisTemplate的实例，并且还使用了配置文件中我们设置的Redis相关配置。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>整个SpringBoot中，都是通过@Conditional注解的各种扩展来实现自动配置的，我们也可以完全利用这些注解去实现我们自己的starter。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring Boot是Spring家族中的新宠，它不仅继承了Spring框架原有的优秀特性，还通过简化配置来进一步简化Spring应用程序的创建和开发过程。SpringBoot框架中有两个最主要的策略：开箱即用和约定优于配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开箱即用：在开发过
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>服务监控之SpringBoot Admin</title>
    <link href="http://luxiaowan.github.io/2020/04/21/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7%E4%B9%8BSpringBoot-Admin/"/>
    <id>http://luxiaowan.github.io/2020/04/21/服务监控之SpringBoot-Admin/</id>
    <published>2020-04-21T07:28:00.000Z</published>
    <updated>2020-04-21T09:16:12.509Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>Spring Boot Admin是一个管理和健康SpringBoot应用的应用，有点绕口，其实就是用来监控SpringBoot应用的，这些应用可以通过Spring Boot Admin Client或Spring Cloud自动发现的方式注册到Admin Server。</p><h3 id="一-admin-client方式注册"><a class="markdownIt-Anchor" href="#一-admin-client方式注册"></a> 一、Admin Client方式注册</h3><h4 id="admin-server搭建"><a class="markdownIt-Anchor" href="#admin-server搭建"></a> Admin Server搭建</h4><ul><li><p>引入server依赖的包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动类加上<code>@EnableAdminServer</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> de.codecentric.boot.admin.server.config.EnableAdminServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootAdminApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>启动项目，然后访问<code>http://localhost:8080/</code>，到此Admin Server就搭建好了，跟Eureka Server似的，一包一注释，仗势走天涯。</p><p><img src="/images/image-20200421161507822.png" alt="image-20200421161507822"></p><h4 id="admin-client注册"><a class="markdownIt-Anchor" href="#admin-client注册"></a> Admin Client注册</h4><ul><li><p>引入client依赖包</p><p>Spring Boot Admin是使用actuator实现的服务监控，所以在client应用中需要引入actuator的包，并开放相关的接口，否则监控的信息不完整。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">boot-log</span></span><br><span class="line"><span class="attr">  boot:</span></span><br><span class="line"><span class="attr">    admin:</span></span><br><span class="line"><span class="attr">      client:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:8080</span> <span class="comment"># 指定admin-server注册地址，和Eureka更像了</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span> <span class="comment"># 暴露actuator所有接口</span></span><br></pre></td></tr></table></figure></li></ul><p>至此就完成了Admin Client端的配置，可以启动服务了，查看admin页面</p><p><img src="/images/image-20200421163624584.png" alt="image-20200421163624584"></p><h3 id="二-eureka注册中心自动发现"><a class="markdownIt-Anchor" href="#二-eureka注册中心自动发现"></a> 二、Eureka注册中心自动发现</h3><p>使用Eureka可以解放Client端的配置，不再需要给Client端配置任何东西(除actuator暴露接口列表)</p><h4 id="eureka-server搭建"><a class="markdownIt-Anchor" href="#eureka-server搭建"></a> Eureka Server搭建</h4><p>搭建Eureka Server就不做特殊解释了，直接贴配置代码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9001</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#是否将eureka自身作为应用注册到eureka注册中心</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span> <span class="comment">#为true时，可以启动，但报异常：Cannot execute request on any known server</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:9001/eureka/</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEurekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudEurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动之后访问<code>http://127.0.0.1:9001/</code>进入Eureka控制台</p><h4 id="admin-server搭建-2"><a class="markdownIt-Anchor" href="#admin-server搭建-2"></a> Admin Server搭建</h4><p>Admin Server的搭建方式和第一种相差无几，唯一的差别就是需要把Server应用注册到Eureka中</p><ul><li>在启动类加上<code>@EnableEurekaClient</code>注解</li><li>在配置文件中加上<code>eureka.client.service-url.defaultZone=http://127.0.0.1:9001/eureka</code>配置</li></ul><h4 id="admin-client搭建"><a class="markdownIt-Anchor" href="#admin-client搭建"></a> Admin Client搭建</h4><p>Admin Client正常配置注册到Eureka，然后暴露actuator的相关接口<code>management.endpoints.web.exposure.include=*</code>。</p><p>启动client，查看Eureka和Admin控制台</p><ul><li><p>Eureka Server</p><p><img src="/images/image-20200421171038407.png" alt="image-20200421171038407"></p></li><li><p>Admin Server</p><p><img src="/images/image-20200421171100096.png" alt="image-20200421171100096"></p></li></ul><h3 id="三-spring-boot-admin提供了哪些功能"><a class="markdownIt-Anchor" href="#三-spring-boot-admin提供了哪些功能"></a> 三、Spring Boot Admin提供了哪些功能</h3><p><img src="/images/image-20200421171313326.png" alt="image-20200421171313326"></p><p>就不一一赘述了，搭建了玩玩就都明白了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h3&gt;
&lt;p&gt;Spring Boot Admin是一个管理和健康SpringBoot应用的应用，有点绕口，其实就是用来监控SpringBoot应用的，这些应用
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>简单的看一下服务治理是什么</title>
    <link href="http://luxiaowan.github.io/2020/04/20/%E7%AE%80%E5%8D%95%E7%9A%84%E7%9C%8B%E4%B8%80%E4%B8%8B%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://luxiaowan.github.io/2020/04/20/简单的看一下服务治理是什么/</id>
    <published>2020-04-20T14:35:00.000Z</published>
    <updated>2020-04-21T07:22:59.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引文"><a class="markdownIt-Anchor" href="#引文"></a> 引文</h3><p>开始看文章之前不妨先思考几个问题：服务治理是什么，什么样子的服务需要治理，为什么需要治理服务，应该怎样治理服务，治理服务的哪些方面，不治理的话服务会怎样？这些问题基本就是服务治理的关键思想了，搞懂这些问题，就相当于是掌握了服务治理的基本概念。</p><h3 id="服务演变过程"><a class="markdownIt-Anchor" href="#服务演变过程"></a> 服务演变过程</h3><p>我们在解决上述问题之前，先来看一下服务架构的发展过程。</p><h4 id="单体服务"><a class="markdownIt-Anchor" href="#单体服务"></a> 单体服务</h4><p>对于单体服务来说，应用结构一般比较简单，一般不需要特别的服务治理手段，但随着服务承载的业务越来越庞大，服务内部逻辑变得复杂起来，扩展性也越来越差，这时最好的治理办法就是将其进行拆分，除此之外的治理手段都是徒劳，反而会让应用变得越来越臃肿。</p><h4 id="集群服务"><a class="markdownIt-Anchor" href="#集群服务"></a> 集群服务</h4><p>单体架构在流量较少时能够满足基本需求，随着业务的发展，产品流量越来越多，一秒钟的服务宕机都可能造成很大的损失，基于此，将由单体架构延伸到集群架构。集群中每台服务器都提供相同的服务，使用负载均衡器来实现每台服务器的负载分配，这其实也能算是一种治理，在分配请求时需要选择出最适合的健康的服务器，将请求发送过去，并且要时刻的检查集群中节点的健康状态，及时将故障节点从健康服务列表中剔除。</p><h4 id="分布式服务"><a class="markdownIt-Anchor" href="#分布式服务"></a> 分布式服务</h4><p>当单体应用变得臃肿之后，整个团队维护同一套代码，所有的业务都集中在一个应用中，服务的健壮性会随着业务的发展变得越来越脆弱，当维护一个服务变得困难的时候，就需要考虑将此服务拆分成若干个小而美的服务了，即微服务化，将单一服务架构向微服务架构演进。</p><p>当服务演进到微服务架构之后，会出现新的问题，比如之前所有的业务逻辑都在一个进程中执行，日志查看、问题排查等都很方便，也不存在进程之间的通信，更不存在依赖服务状态的监控等情况。那么既然拆分成微服务之后会遇到这么多问题，为什么还要拆呢？其实大部分由单体服务拆分成微服务的初衷都是想分而治之，也就是单一职责的服务更方便优化和维护。</p><ul><li><p>服务定义：服务拆分要根据一定的规则进行，定义拆分后每个服务的业务范围和边界，不能为了拆而拆，微服务的提出者Matin Fowler在首提微服务的时候是以业务为拆分基准，后续发展过程中，越来越多的条件都可以作为拆分的理由了，比如业务、流量大小等。</p></li><li><p>服务注册与发现：微服务架构体系中，必定会出现服务之间的调用依赖，这就需要调用方知道目标服务的地址，从而发起请求。如果将服务端的地址预先告知调用方，其实也是可行的，缺陷就是当服务越来越多时，服务URL的配置管理变得非常困难，所以在这个过程中我们需要借助一个中介来提供一个接口让我们可以随时获取健康的服务列表，所以服务注册中心应运而生(Zookeeper、Etcd、Consul、Eureka、Dubbo等)，它的理念是由服务端将可提供的服务注册到服务中心，并由服务中心来维护每个服务节点的健康状态，客户端从服务中心获取健康的服务列表用于发送请求。</p></li><li><p>接口调用链监控：微服务架构体系中以服务多著称，服务都具有单一职责，服务之间需要互相调用才能完成一次请求的处理。在单体应用架构中，调用链都是在同一个进程中，只要通过线程ID或者MDC即可查询到请求的整个调用链，定位很轻松；但是在分布式架构中，想要跟踪一次请求的整个调用链就比较麻烦了，一般需要通过第三方组件来完成，比如Twitter的Zipkin。</p></li><li><p>应用服务监控：SpringBootAdmin提供了一套开箱即用的监控工具箱，可以看到监控的每个微服务实例的运行情况，具体操作稍后再嗷嗷</p></li><li><p>负载均衡：在服务拆分设计过程中，每一个服务都需要保证是高可用的，也就是每一个微服务又都是高可用的。</p></li><li><p>服务降级熔断：单体服务拆分后导致服务变多了，调用链出故障的概率就更大了，我们在保证了服务的高可用的同时，仍然需要保证接口的可用性，如果接口出现故障，要能够将故障快速转移并响应调用端，否则可能会造成大量的请求积压，进而拖垮整个系统。断路器和服务降级为接口的快速故障转移提供了保障。</p></li><li><p>服务调用：在分布式架构中，服务之间可以通过http、rpc等方式互相调用，比如Feign是一种http方式的声明式调用，在SpringCloud中有广泛的使用。</p></li><li><p>服务安全：服务自身需要保证接口、数据和服务的安全性，不能出现被随意调用的现象。</p></li><li><p>服务版本：服务在升级过程中，需要考虑到对老版本的兼容性，避免造成因升级带来的系统故障。</p></li></ul><h3 id="回看"><a class="markdownIt-Anchor" href="#回看"></a> 回看</h3><p>简单的描述了一下服务架构的演进路线，我们来看看前面说的几个问题：</p><ol><li><p>服务治理是什么</p><blockquote><p>服务治理是通过一系列手段来更好的管理服务，确保系统能够顺利、安全、稳定的运行。</p></blockquote></li><li><p>什么样子的服务需要治理</p><blockquote><p>任何服务都需要治理</p></blockquote></li><li><p>为什么需要治理服务</p><blockquote><ol><li>为了提升系统的稳定性</li><li>保证服务的可用性</li></ol></blockquote></li><li><p>应该怎样治理服务</p><blockquote><ol><li>建立授权的责任链</li><li>评估服务的有效性</li><li>服务监控告警</li><li>故障转移</li></ol></blockquote></li><li><p>治理服务的哪些方面</p><blockquote><ol><li>服务定义</li><li>服务注册与发现</li><li>接口调用链</li><li>应用服务监控</li><li>负载均衡</li><li>服务降级熔断</li><li>服务调用协议</li><li>服务安全</li><li>服务版本</li></ol></blockquote></li><li><p>不治理的话服务会怎样</p><blockquote><p>场景一：周末你正在逛街，然后老板在群里艾特你，说系统服务器宕机了、机房停电了、光缆被施工队挖断了，系统没办法使用了。这个时候你是不是需要立刻赶到公司去搬砖，直到系统恢复正常。</p><p>场景二：正在与周公下棋，然后一阵滴滴声，发现某个服务节点的故障告警邮件快撑爆收件箱了，并且还不断的有流量打到这个服务节点，如果没有治理的话，你要立刻起床打开电脑尽快恢复这个节点。有了服务治理，你打开服务管理器，一键熔断降级，搞定。然后可以起床吃个早饭再来修复了(呸~当然立刻修复，哪还有心思吃早饭)。</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引文&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引文&quot;&gt;&lt;/a&gt; 引文&lt;/h3&gt;
&lt;p&gt;开始看文章之前不妨先思考几个问题：服务治理是什么，什么样子的服务需要治理，为什么需要治理服务，应该怎样治理服务，治理服务的哪些方面，不治理的话服
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>聊一聊负载均衡</title>
    <link href="http://luxiaowan.github.io/2020/04/20/%E8%81%8A%E4%B8%80%E8%81%8A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://luxiaowan.github.io/2020/04/20/聊一聊负载均衡/</id>
    <published>2020-04-20T03:53:00.000Z</published>
    <updated>2020-04-20T10:58:55.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>负载均衡是实现服务高可用的一个关键性技术，在集群环境中，常常会将一个应用部署在多台服务器上同时提供服务，负载均衡将任务均衡的分配给不同的服务器，减少单一服务器的负载，达到水平扩容的目的，再者如果集群中某个节点的服务宕机了，负载均衡器会及时发现不可用的节点，并将其从集群服务节点中逻辑移除，此后的流量不会再转发到这台服务器上。</p><h3 id="单点服务"><a class="markdownIt-Anchor" href="#单点服务"></a> 单点服务</h3><p>没有使用负载均衡的服务架构一般如图：</p><img src="/images/image-20200420122319035.png" alt="image-20200420122319035" style="zoom:60%;"><p>如果Server出现故障导致服务不可用，则整个系统都会无法使用，这种故障的危害对于一个产品而言是非常巨大的。在微服务流行之前，一些中小型公司和传统IT公司大多采用单点部署方案。</p><p>既然单点服务无法保证故障的自动切换，所以为了避免单节点故障而导致的服务不可用，就需要将服务多节点部署，服务之间以主备的方式提供服务，这就延伸到了另外一个方案：多节点主备服务。</p><h3 id="多节点主备"><a class="markdownIt-Anchor" href="#多节点主备"></a> 多节点主备</h3><p>多节点主备不算是负载均衡的一种实现，这种方案只是为服务提供了一个备份，虽然服务部署在多台服务器上，但同时只有一台服务器提供服务，当正在提供服务不可用时，自动将请求切换到备份的服务器上。</p><img src="/images/image-20200420144949473.png" alt="image-20200420144949473" style="zoom:60%;"><p>多节点主备方案保证了服务的高可用，但并没有保证负载的均衡分配，由于同一时间只有一台机器提供服务，所有的流量全部都会透传到这一台服务器上，当流量激增的时候可能会很快的压垮这台服务器，然后不断的在主备机器之间来回切换，每隔一段时间压垮一台服务器。</p><p>我们通常解决这种情况的办法就是增加每台服务器的配置，也可以理解为F5负载均衡（压缩数据、连接聚合、页面缓存、浏览器缓存），但是这种方案的成本非常高，一般的中小企业都难以承担这个费用。所以智者又提出能否让多台服务器同时对外提供服务，然后根据一定的规则将流量分配到每一台机器上，这样既能保证服务的高可用，也能缓解每台服务器的压力，因此Nginx这类负载均衡组件应运而生。</p><h3 id="负载均衡策略"><a class="markdownIt-Anchor" href="#负载均衡策略"></a> 负载均衡策略</h3><p>既然多台服务器可以同时提供相同的服务，那么就需要指定响应的规则进行流量分配，并且要确保服务是可用的，不然请求过来之后不知道该往哪转发，所以在做负载均衡服务配置之前需要先确定均衡策略。</p><img src="/images/image-20200420151415778.png" alt="image-20200420151415778" style="zoom:50%;"><ul><li>轮询策略：轮询也就意味着服务器会被按顺序的选择，从1到N然后重新开始，比如由两台服务器，请求1分配给Server1，请求2分配给Server2，请求3分配给Server1…，所有的服务器都会被分配数量相同的流量。这种策略适合用于各服务器处理能力相同并且每个业务处理量差不多的情况。</li><li>随机策略：请求随机发送到各个节点，每台服务器处理的请求数量可能会有很大的差异。一般不使用随机策略。</li><li>最少连接策略：客户端的每次请求所消耗的时长可能会有很大差异，每台服务器上的连接线程可能会因此产生较大的不同，长此以往并不能达到真正的负载均衡。最少连接策略是让负载均衡器记录每台服务器正在处理的请求数，新的请求打过来之后会分配给当前正在处理请求数最少的那台机器，使每台服务器处理的请求数更加均衡。这种策略适合长时处理的请求服务。</li><li>权重策略：事先为每台服务器分配不同的权重，比如Server1和Server2分别设置为3和7，也就意味着Server2将承担70%的请求，Server1则承担30%的请求，保证性能更优的服务器能够承担更多的请求处理任务。权重策略适用于服务器性能不同的情况。</li><li>IP-Hash策略：负载均衡器根据请求来源的IP计算Hash值，然后决定分配给哪一台服务器，当用户IP和Hash计算方式不发生变化的情况下，他发出的所有请求最终都会落在一台机器上。该策略适用于想简单解决session问题的情况。</li></ul><h3 id="健康检查"><a class="markdownIt-Anchor" href="#健康检查"></a> 健康检查</h3><p>使用负载均衡的目的既然是提升服务的高可用，那么前提自然是要确保集群中的每个服务都是健康可用的，负载均衡器会通过健康检查的方式来识别服务是否可用。</p><p>常用的负载均衡器基本属Nginx莫属了，使用Nginx的好处是它自带健康检查模块<code>ngx_http_upstream_module</code>，可用做到最基本的健康检查。但是Nginx是被动的进行健康检查，也就是健康检查是依赖于请求的，如果服务1出现异常，则需要再将请求转发给服务2，直到遇到能够成功返回的接口，每一次的失败请求都会被记录下来，若失败节点达到了预设的最大次数，则将其从健康服务列表中移除，效率不高。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">  <span class="comment"># max_fails表示失败次数，整体的意思是在fail_timeout时间内若失败次数达到了max_fails，则认为该节点的服务异常，移除健康服务列表</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>  max_fails=<span class="number">1</span> fail_timeout=<span class="number">40s</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8090</span>  max_fails=<span class="number">1</span> fail_timeout=<span class="number">40s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> d.kv.cc; </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span>http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="负载均衡session共享问题"><a class="markdownIt-Anchor" href="#负载均衡session共享问题"></a> 负载均衡session共享问题</h3><p>在使用IP-Hash做负载均衡策略时，因为同一个用户的请求都会转发到固定的一台机器上，所以在服务稳定的情况下，不用考虑session共享的问题，但是为了防止服务器突然宕机而引起的请求被转发到其他机器造成的session丢失的情况出现，所以不管哪一种策略，最好都做好session共享的解决方案。</p><ol><li>Redis：可以使用spring-session+Redis来实现session共享，很简单，请看<a href="https://luxiaowan.github.io/2019/10/24/Spring-Session%E5%92%8CRedis%E5%AE%9E%E7%8E%B0Session%E5%85%B1%E4%BA%AB/">Spring-Session和Redis实现Session共享</a></li><li>基于token认证：JWT认证</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;负载均衡是实现服务高可用的一个关键性技术，在集群环境中，常常会将一个应用部署在多台服务器上同时提供服务，负载均衡将任务均衡的分配给不同的服务器，
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>软件开发中的幂等是什么</title>
    <link href="http://luxiaowan.github.io/2020/04/20/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B9%82%E7%AD%89%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://luxiaowan.github.io/2020/04/20/软件开发中的幂等是什么/</id>
    <published>2020-04-19T22:06:00.000Z</published>
    <updated>2020-04-19T23:31:00.914Z</updated>
    
    <content type="html"><![CDATA[<p>工作中经常会遇到一个事务型接口或者一个事务型方法被调用方重复调用，实际上每次调用的数据都是相同的，有可能是因为网络延迟，客户端点击了多次，也可能是调用方故意而为之，不论是哪种情况，我们都不能让这种重复的操作对我们自己的系统造成不必要的影响。因此，我们需要对于接口和方法做幂等校验。其实幂等过滤一直都贯穿IT行业，只不过现在随着互联网行业的发展，行业内的造词能力和词语引用能力越来越强，幂等被计算机行业正式引用。</p><h3 id="幂等性"><a class="markdownIt-Anchor" href="#幂等性"></a> 幂等性</h3><p>在数学概念里，幂等是指一次变换和N次变换的结果都相同。而在计算机概念中，幂等是指某一操作执行n次和执行一次所产生的影响是一样的，也就是重复执行这项操作也不会对系统造成改变，比如抢优惠券，每人限制抢一张优惠券，可以使用用户ID+优惠券ID做幂等条件，这样就可以保证每个用户只能抢一张此优惠券。</p><h3 id="restful幂等"><a class="markdownIt-Anchor" href="#restful幂等"></a> RESTFul幂等</h3><ul><li>GET请求：GET请求属于是非事务型请求，每次请求都不会对系统造成任何影响，所以这类接口本身就符合了幂等性（这里说的是对系统造成影响，而不是说每次调用获取到的数据相同，幂等是针对于系统而非接口）</li><li>DELETE请求：DELETE请求是一个特殊的事务型请求，在调用第一次的时候就已经把数据删除了，所以不论后续再次调用多少次，对系统产生的影响都是一样的，所以DELETE类型的请求本身也是符合幂等性的</li><li>PUT请求：PUT请求是对数据进行修改，理论上对同一URI进行多次PUT操作对整个系统的影响和一次PUT是相同的，但是这要结合接口具体代码实现来考量<ul><li>直接将PUT的数值替换掉原有数据：幂等</li><li>每次调用都对某个数据递增：非幂等，需要手动幂等</li></ul></li><li>POST请求：POST是创建资源的事务型请求，每次请求都会创建一份资源，所以多次调用对整个系统产生的影响是不同的，该类型的请求是非幂等的</li></ul><h3 id="常用幂等方法"><a class="markdownIt-Anchor" href="#常用幂等方法"></a> 常用幂等方法</h3><ul><li><p>数据库唯一索引去重</p><p>利用数据库唯一索引的特性达到幂等的效果，不会往数据表中插入两条幂等字段相同的数据。例如文章点赞功能，为了防止用户重复点赞，可以在点赞表中以用户ID+文章ID为唯一索引，这样就可以有效的防止用户给一篇文章重复点赞，最终达到幂等操作的效果。</p></li><li><p>版本锁控制</p><p>版本锁属于是乐观锁的一种实现，MySQL中的MVCC就是版本锁的一种应用方式，通过每次更新都通过版本号控制权限来达到幂等操作的效果</p></li><li><p>token缓存机制</p><p>token缓存机制是一种比较常见的幂等处理方式，应用范围较广，不限定场景和语言。核心思想就是为每个请求分配一个全局唯一标识(token)，一个token在一条业务线的每个阶段只能执行一次，执行之后将这个阶段的结果缓存起来，每次执行前先校验是否已有缓存，没有缓存则执行流程，已有缓存则直接返回结果。</p></li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>不同的业务需求会面临不同的幂等要求，也就会有不同的解决方案，所以幂等的实现难度是不同的。在做系统设计时，一定要将幂等性考虑周全，否则可能会给系统带来不必要的潜在隐患。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作中经常会遇到一个事务型接口或者一个事务型方法被调用方重复调用，实际上每次调用的数据都是相同的，有可能是因为网络延迟，客户端点击了多次，也可能是调用方故意而为之，不论是哪种情况，我们都不能让这种重复的操作对我们自己的系统造成不必要的影响。因此，我们需要对于接口和方法做幂等
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Git分支管理</title>
    <link href="http://luxiaowan.github.io/2020/04/20/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>http://luxiaowan.github.io/2020/04/20/Git分支管理/</id>
    <published>2020-04-19T18:18:00.000Z</published>
    <updated>2020-04-19T18:53:22.831Z</updated>
    
    <content type="html"><![CDATA[<p>目前最流行的Git分支管理规范应该属git-flow莫属了，它的核心概念是版本发布，适用于项目的持续集成和频繁发布，这也是近些年使用Git的过程中一直使用的规范。</p><p>git-flow流程中有5类分支，分别是master、develop、relaese(发布版本)、feature(新功能分支)、hotfix(修复bug版本)，这些分支都有各自的作用和生命周期，master是最稳定的分支，develop是一个新代码集成分支，所有发布后的代码都合并到develop，然后由develop合并到master，开发完成后在发布的时候创建release分支进行发布，在开发新功能的时候创建一个feature分支，生产上遇到需要修复的紧急bug时，创建一个hotfix分支。</p><p>分支名称规则：<code>release/feature/hotfix-分支创建日期-分支版本号</code></p><table><thead><tr><th style="text-align:left">分支类型</th><th style="text-align:left">命名规范</th><th style="text-align:left">创建自</th><th style="text-align:left">合并到</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">feature</td><td style="text-align:left">feature/*</td><td style="text-align:left">develop</td><td style="text-align:left">develop</td><td style="text-align:left">新功能</td></tr><tr><td style="text-align:left">release</td><td style="text-align:left">release/*</td><td style="text-align:left">develop</td><td style="text-align:left">develop 和 master</td><td style="text-align:left">一次新版本的发布</td></tr><tr><td style="text-align:left">hotfix</td><td style="text-align:left">hotfix/*</td><td style="text-align:left">master</td><td style="text-align:left">develop 和 master</td><td style="text-align:left">生产环境中发现的紧急 bug 的修复</td></tr></tbody></table><blockquote><p>Git分支关系图</p></blockquote><img src="/images/git-model.png" alt="img" style="zoom: 67%;"><ul><li><p>对于不同的开发任务，需要在不同的分支上完成开发，开发完成后合并到develop分支进行测试，基本流程如下：</p><ol><li><p>从develop分支创建一个feature分支：feature/cc-20200420-v1.0.1</p></li><li><p>在feature/cc分支上进行开发</p></li><li><p>开发完成后将feature/cc合并到develop分支</p></li></ol></li><li><p>在进行版本发布时的基本流程如下：</p><ol><li>从develop创建release分支：release/cc-20200420-v1.0.1</li><li>将release/cc分支发布到测试环境进行测试，测试中出现的bug直接在release/cc分支上修改并提交</li><li>测试完成后合并到develop和master，并在master上打一个Tag</li></ol></li><li><p>在进行生产bug紧急修复时的基本流程如下：</p><ol><li>从master创建hotfix分支：hotfix/cc-20200420-v1.0.1</li><li>验证完成后将hotfix/cc分支合并到develop和master，并在master上打一个Tag</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前最流行的Git分支管理规范应该属git-flow莫属了，它的核心概念是版本发布，适用于项目的持续集成和频繁发布，这也是近些年使用Git的过程中一直使用的规范。&lt;/p&gt;
&lt;p&gt;git-flow流程中有5类分支，分别是master、develop、relaese(发布版本)
      
    
    </summary>
    
    
      <category term="Git" scheme="http://luxiaowan.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Git本地仓库关联远程仓库</title>
    <link href="http://luxiaowan.github.io/2020/04/20/Git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://luxiaowan.github.io/2020/04/20/Git本地仓库关联远程仓库/</id>
    <published>2020-04-19T17:39:00.000Z</published>
    <updated>2020-04-19T18:11:05.431Z</updated>
    
    <content type="html"><![CDATA[<h3 id="情景"><a class="markdownIt-Anchor" href="#情景"></a> 情景</h3><p>本地创建了一个工程，开发完成后想要提交到github/gitlab上</p><ul><li>本地</li></ul><p><img src="/images/image-20200420014905633.png" alt="image-20200420014905633"></p><ul><li>远程</li></ul><p><img src="/images/image-20200420014219180.png" alt="image-20200420014219180"></p><h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h3><ol><li><p>进入到工程目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd git-demo</span><br></pre></td></tr></table></figure></li><li><p>初始化本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>初始化之后，可以通过<code>ls -al</code>查看本地仓库文件，发现此时工程内多出了一个<code>.git</code>目录</p><p><img src="/images/image-20200420015451562.png" alt="image-20200420015451562"></p></li><li><p>设置关联远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http://gitlab.xxx.cc/utils/demo.git</span><br></pre></td></tr></table></figure><p>命令执行之后，可以通过<code>git remote -v</code>查看是否关联成功，fetch是从远程仓库同步，push是推送到远程仓库</p><p><img src="/images/image-20200420015810083.png" alt="image-20200420015810083"></p></li><li><p>将本地文件add之后commit</p><p>在执行add命令之前，使用<code>git branch</code>查看本地分支会发现本地当前尚无分支，在add和commit之前，先确定一下本地仓库的账号是否可以连通远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看仓库所有配置</span></span><br><span class="line">git config -l</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200420020611199.png" alt="image-20200420020611199"></p><p>如果账号不对，则可以通过<code>git config user.name</code>等命令修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m "初始化"</span><br></pre></td></tr></table></figure><p>命令执行完后再使用<code>git branch</code>会看到本地已经有了master分支</p><p><img src="/images/image-20200420020224634.png" alt="image-20200420020224634"></p></li><li><p>将本地仓库的文件推送到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>推送之后查看远程仓库，会发现远程仓库已经初始化好了</p><p><img src="/images/image-20200420020848287.png" alt="image-20200420020848287"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;情景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#情景&quot;&gt;&lt;/a&gt; 情景&lt;/h3&gt;
&lt;p&gt;本地创建了一个工程，开发完成后想要提交到github/gitlab上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img sr
      
    
    </summary>
    
    
      <category term="Git" scheme="http://luxiaowan.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka在数据传递上的场景分析</title>
    <link href="http://luxiaowan.github.io/2020/04/19/Kafka%E5%9C%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E4%B8%8A%E7%9A%84%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    <id>http://luxiaowan.github.io/2020/04/19/Kafka在数据传递上的场景分析/</id>
    <published>2020-04-19T14:38:00.000Z</published>
    <updated>2020-04-19T17:00:39.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h3><p>前段时间遇到一个场景，有一个用户社区模块，用户可以在社区的帖子专区发布帖子，或评论帖子，帖子和评论信息需要依据产生时间依次发送给第三方，消息内容为帖子和帖子评论，接收方必须先接收帖子再接收帖子评论，且需要按照发生时间顺序依次接收。第三接收方随时可能新增或减少，新增的接收方需要获取加入时间前30天之内的历史数据。</p><h3 id="消息中间件选择"><a class="markdownIt-Anchor" href="#消息中间件选择"></a> 消息中间件选择</h3><p>这是一个纯粹的消息传递功能，不涉及数据的整合和流处理，但是因为新增的消费者(第三方)要能获取到前30天之内的历史数据，所以我们需要一个能够将消息持久化的消息组件，并且要能自动清理30天之前的历史消息数据，选来选取，目前最方便的就是kafka了，我们来看一下kafka的特性：</p><ul><li>持久化：kafka默认就支持将消息持久化到磁盘，被消费的消息不会被删除</li><li>历史数据：kafka可以通过<code>log.retention.hours=720</code>指定只保存30天的数据</li><li>帖子顺序发送：kafka的partition是有序的</li><li>效率：kafka的topic可以通过多分区提升效率，为分区设置副本提升高可用</li></ul><h3 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现"></a> 具体实现</h3><blockquote><p>Kafka配置</p></blockquote><p>设置kafka持久化日志过期时间：<code>log.retention.hours=720</code></p><blockquote><p>Topic分区数量</p></blockquote><p>依据帖子和评论的数量估算Topic的分区数量</p><blockquote><p>伪代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">  queryPostFromDB();</span><br><span class="line">  queryTopicPartitionSize();</span><br><span class="line">  calcPartitionForPostByPostId();</span><br><span class="line">  sendMessageToPartition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先从DB中查询帖子和帖子评论</li><li>查询topic在kafka中的分区数</li><li>根据帖子ID和分区数取模，将帖子和评论均衡分配到各个分区中</li><li>将消息发送给对应分区，帖子和对应评论需要发送到同一分区，并且要按照时间发送，这样才能保证同一个帖子的发送顺序</li></ol><blockquote><p>消费者</p></blockquote><p>每一个第三方的消费者都归属于唯一的消费者组，且必须给所有的消费者都设置一个消费者组</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;场景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#场景&quot;&gt;&lt;/a&gt; 场景&lt;/h3&gt;
&lt;p&gt;前段时间遇到一个场景，有一个用户社区模块，用户可以在社区的帖子专区发布帖子，或评论帖子，帖子和评论信息需要依据产生时间依次发送给第三方，消息内容
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://luxiaowan.github.io/categories/Kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka应用场景</title>
    <link href="http://luxiaowan.github.io/2020/04/18/Kafka%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://luxiaowan.github.io/2020/04/18/Kafka应用场景/</id>
    <published>2020-04-18T15:35:00.000Z</published>
    <updated>2020-04-19T11:34:27.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序"><a class="markdownIt-Anchor" href="#序"></a> 序</h3><p>在学习一门新技术之前，我们需要先去了解一下这门技术的具体应用场景，使用它能够做什么，能够达到什么目的，学习kafka的初衷是用作消息队列；但是还可以使用Kafka Stream进行一些实时的流计算，多用于大数据处理；也可以做日志收集汇总、网站活动跟踪等任务。</p><h3 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h3><p>kafka可以很好的替代一些传统的消息系统，kafka具有更好的吞吐量，内置的分区使kafka具有更好的容错和伸缩性，这些特性使它可以替代传统的消息系统，成为大型消息处理应用的首选方案。</p><blockquote><p>场景：异步、解耦、削峰填谷</p><ol><li>生成订单：给不同的产品业务线分配同一个topic的不同partition，用户下单后根据订单类型发送到对应的partition</li><li>消息通知：用户登录后计算积分</li></ol></blockquote><ul><li><p>消息生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">  prop.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"127.0.0.1:9092"</span>);</span><br><span class="line">  prop.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line">  prop.put(<span class="string">"retries"</span>, <span class="string">"0"</span>);</span><br><span class="line">  <span class="comment">// 缓冲区大小</span></span><br><span class="line">  prop.put(<span class="string">"batch.size"</span>, <span class="string">"10"</span>);</span><br><span class="line">  prop.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">  prop.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">  KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(prop);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">    ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"my_topics"</span>, <span class="string">"value_"</span> + i);</span><br><span class="line">    <span class="comment">// 阻塞到消息发送完成</span></span><br><span class="line">    producer.send(record).get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新缓冲区，发送到分区，并清空缓冲区</span></span><br><span class="line">  <span class="comment">// producer.flush();</span></span><br><span class="line">  <span class="comment">// 关闭生产者，会阻塞到缓冲区内的数据发送完</span></span><br><span class="line">  producer.close();</span><br><span class="line">  <span class="comment">// producer.close(Duration.ofMillis(1000));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者发送消息是先将消息放到缓冲区，当缓冲区存满之后会自动flush，或者手动调用flush()方法</p></li><li><p>消息消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">  properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"127.0.0.1:9092"</span>);</span><br><span class="line">  properties.put(<span class="string">"group.id"</span>, <span class="string">"cc_consumer"</span>);</span><br><span class="line">  properties.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">  properties.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">  KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line">  <span class="comment">// 指定topic</span></span><br><span class="line">  consumer.subscribe(Arrays.asList(<span class="string">"my_topics"</span>));</span><br><span class="line">  <span class="comment">// 指定topic的partition</span></span><br><span class="line">  <span class="comment">// TopicPartition partition0 = new TopicPartition("my_topics", 10);</span></span><br><span class="line">  <span class="comment">// consumer.assign(Arrays.asList(partition0));</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record.toString());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close(Duration.ofMillis(<span class="number">2000</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="流计算"><a class="markdownIt-Anchor" href="#流计算"></a> 流计算</h3><p>​<em><font color="gray">[todo]</font></em></p><h3 id="日志收集"><a class="markdownIt-Anchor" href="#日志收集"></a> 日志收集</h3><p>应用程序的日志可以通过log4j收集日志信息，并将日志直接打到kafka中：客户端—&gt;应用—&gt;kafka</p><p>SpringBoot中默认使用的是logback，所以要在引入SpringBoot的jar包时排除掉logback的jar包</p><blockquote><p>日志消息发送有同步和异步两种方式，由KafkaAppender中的<code>syncSend</code>属性决定，默认为true(同步)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">Kafka</span> <span class="attr">name</span>=<span class="string">"KAFKA-LOGGER"</span> <span class="attr">topic</span>=<span class="string">"cc_log_test"</span> <span class="attr">syncSend</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>pom.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springboot 1.3.x之前版本是log4j，之后版本都是log4j2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>log4j2.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"off"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d %p %c&#123;1.&#125; %t %m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--kafka topic--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Kafka</span> <span class="attr">name</span>=<span class="string">"KAFKA-LOGGER"</span> <span class="attr">topic</span>=<span class="string">"my_topics"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--JsonLayout：日志格式为json,方便在ES中处理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">JsonLayout</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--kafka server的ip:port--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"bootstrap.servers"</span>&gt;</span>127.0.0.1:9092<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"retries"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"linger.ms"</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"buffer.memory"</span>&gt;</span>10485760<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Kafka</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Async</span> <span class="attr">name</span>=<span class="string">"ASYNC-KAFKA-LOGGER"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"KAFKA-LOGGER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinkedTransferQueue</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Async</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--日志级别大于info都会被记录到Kafka--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"cc.kevinlu.springbootkafka.controller.MessageController"</span> <span class="attr">level</span>=<span class="string">"info"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"KAFKA-LOGGER"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Root表示所有Logger用Root中的Appender打印日志  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>code</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/log"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sendLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    log.info(<span class="string">"kafka log i = "</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>consumer视图</li></ul><img src="/images/image-20200419032218971.png" alt="image-20200419032218971" style="zoom: 50%;"><h3 id="网站活动跟踪"><a class="markdownIt-Anchor" href="#网站活动跟踪"></a> 网站活动跟踪</h3><ol><li><p>前端Nodejs控制</p><p>Node接入kafka需要使用kafka-node库，下面是网上的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kafka = <span class="built_in">require</span>(<span class="string">'kafka-node'</span>),</span><br><span class="line">    Producer = kafka.Producer,</span><br><span class="line">    client = <span class="keyword">new</span> kafka.KafkaClient(&#123;<span class="attr">kafkaHost</span>: <span class="string">'localhost:9092'</span>&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义生产类</span></span><br><span class="line"><span class="comment"> * partitionerType 定义</span></span><br><span class="line"><span class="comment"> * 0:默认模式 只产生数据在第一个分区</span></span><br><span class="line"><span class="comment"> * 1:随机分配，在分区个数内，随机产生消息到各分区</span></span><br><span class="line"><span class="comment"> * 2:循环分配，在分区个数内，按顺序循环产生消息到各分区</span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line"><span class="keyword">var</span> producerOption = &#123;</span><br><span class="line">    requireAcks: <span class="number">1</span>,</span><br><span class="line">    ackTimeoutMs: <span class="number">100</span>,</span><br><span class="line">    partitionerType: <span class="number">0</span> <span class="comment">//默认为第一个分区</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> producer = <span class="keyword">new</span> Producer(client,producerOption);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TOPIC的创建需要在命令行进行创建，以便指定分区个数以及备份个数</span></span><br><span class="line"><span class="comment"> * PS：kafka-node的创建topic不行，不能创建分区</span></span><br><span class="line"><span class="comment"> * 产生消息,如果不指定partition</span></span><br><span class="line"><span class="comment"> * 则根据 partitionerType 的值来指定发送数据到哪个分区</span></span><br><span class="line"><span class="comment"> * 我们创建的topic-test-one只有一个分区，所以只能产生数据到第1个分区（下标0），否则不会生产数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPayloads</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        &#123;<span class="attr">topic</span>:<span class="string">"topic-test-one"</span>,<span class="attr">messages</span>:<span class="built_in">JSON</span>.stringify(&#123;<span class="string">"name"</span>:<span class="string">"jack"</span>,<span class="string">"age"</span>:<span class="string">"120"</span>&#125;),<span class="attr">partition</span>:<span class="number">0</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer.on(<span class="string">"ready"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        producer.send(getPayloads(),<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"send message complete!data:"</span>+<span class="built_in">JSON</span>.stringify(data),<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">     &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">producer.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">"send message error!\r\n"</span>+err);&#125;)</span><br></pre></td></tr></table></figure></li><li><p>后端日志控制</p><p>后端也可以使用log4j的日志系统来完成，拦截所有需要监控的api请求，使用log4j输出日志到kafka队列中，和上述日志收集方法相同。若同一个应用中需要通过日志输出到kafka的多个topic中，可以使用log4j的Marker标记来区分，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"off"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d %p %c&#123;1.&#125; %t %m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 日志收集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Kafka</span> <span class="attr">name</span>=<span class="string">"KAFKA-LOGGER"</span> <span class="attr">topic</span>=<span class="string">"cc_log_test"</span> <span class="attr">syncSend</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">JsonLayout</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"bootstrap.servers"</span>&gt;</span>127.0.0.1:9092<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"retries"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"linger.ms"</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"buffer.memory"</span>&gt;</span>10485760<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!-- 通过Marker过滤消息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">MarkerFilter</span> <span class="attr">marker</span>=<span class="string">"Kafka"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Kafka</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 轨迹跟踪 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Kafka</span> <span class="attr">name</span>=<span class="string">"KAFKA-TRACK-LOGGER"</span> <span class="attr">topic</span>=<span class="string">"cc_test1"</span> <span class="attr">syncSend</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">JsonLayout</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"bootstrap.servers"</span>&gt;</span>127.0.0.1:9092<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"retries"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"linger.ms"</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"buffer.memory"</span>&gt;</span>10485760<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!-- 通过Marker过滤消息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">MarkerFilter</span> <span class="attr">marker</span>=<span class="string">"Track"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Kafka</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Async</span> <span class="attr">name</span>=<span class="string">"ASYNC-KAFKA-LOGGER"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"KAFKA-LOGGER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"KAFKA-TRACK-LOGGER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinkedTransferQueue</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Async</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"cc.kevinlu.springbootkafka.controller"</span> <span class="attr">level</span>=<span class="string">"info"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"KAFKA-LOGGER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"KAFKA-TRACK-LOGGER"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Marker KAFKA_MARKER       = MarkerManager.getMarker(<span class="string">"Kafka"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Marker KAFKA_TRACK_MARKER = MarkerManager.getMarker(<span class="string">"Track"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/log"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sendLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 轨迹跟踪</span></span><br><span class="line">  log.info(KAFKA_TRACK_MARKER, <span class="string">"send async message!"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 日志收集</span></span><br><span class="line">    log.info(KAFKA_MARKER, <span class="string">"kafka log i = &#123;&#125;"</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前端+后端组合</p><p>后端提供API供前端传递轨迹，后端接收到请求之后将消息同步到kafka中。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#序&quot;&gt;&lt;/a&gt; 序&lt;/h3&gt;
&lt;p&gt;在学习一门新技术之前，我们需要先去了解一下这门技术的具体应用场景，使用它能够做什么，能够达到什么目的，学习kafka的初衷是用作消息队列；但是还可以使
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://luxiaowan.github.io/categories/Kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka消费者</title>
    <link href="http://luxiaowan.github.io/2020/04/17/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://luxiaowan.github.io/2020/04/17/Kafka消费者/</id>
    <published>2020-04-17T06:46:00.000Z</published>
    <updated>2020-04-17T14:40:13.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简"><a class="markdownIt-Anchor" href="#简"></a> 简</h3><p>消息由生产者产出，产出后push到partition中，但是既然有生产了，那肯定就要有消费，不然我们生产出来的消息岂不成了垃圾数据，所以在kafka中有一个与生产者对应的玩意儿：消费者。生产者是往partition中push数据，而消费者是从partition中pull消息，有些MQ中是由服务端push消息给消费者，并且是阅后即焚的模式，但是kafka是支持将消息持久化到磁盘上，并且并不会因为消息被消费了而删除，每一个消费者都可以自由的消费partition中的历史消息，即使是一个新加入的Consumer，也可以通过指定offset将partition中所有的历史消息都从头消费一次，而服务端只负责为消息设定offset，Consumer从哪一条消息开始消费完全由自己决定，每一个Consumer都会在本地维护自己的offset，Consumer之间的offset互不干扰。</p><p>每一个消费者都归属于一个消费者群组，一个partition只能被同一个消费者群组内的一个消费者实例消费，但可以被不同消费者群组同时消费，每个群组内的所有消费者订阅的都是同一个topic，每个消费者接收一个topic中一部分partition的消息，若消费者数量多于partition的数量，则会出现闲置的消费者，而若消费者数量小于partition的数量，则会出现某个消费者消费多个partition中的数据。</p><h3 id="消费者群组consumer-group"><a class="markdownIt-Anchor" href="#消费者群组consumer-group"></a> 消费者群组(Consumer Group)</h3><p>消费者群组是由一个或多个消费者实例组成的群组，具有可扩展性和容错性。每一个消费者群组都拥有全局唯一的group_id，群组内的所有的消费者实例共享这个group_id，群组内的所有消费者订阅同一个topic，组内的一个消费者实例只能消费topic中的一个Partition的消息。</p><p>消费类型：</p><ol><li>点对点：一个topic对应一个消费者群组</li><li>广播（发布-订阅）：一个topic对应多个消费者群组</li></ol><h3 id="消费者和分区"><a class="markdownIt-Anchor" href="#消费者和分区"></a> 消费者和分区</h3><ol><li><p>Consumer数量 &lt; Partition数量</p><p>当Partition的数量多于Consumer的时候，一个Consumer会消费来自多个Partition的消息，此种情形下会加大Consumer的压力，单Consumer实例的吞吐量决定了消息消费的效率，当消息井喷的时候，会造成大多数消息都积压在Partition中，严重的时候会影响服务性能。若想提升消息消费效率，可以通过增加Consumer实例解决。</p><img src="/images/image-20200417151054543.png" alt="image-20200417151054543" style="zoom:50%;"></li><li><p>Consumer数量 = Partition数量</p><p>当Partition和Consumer数量相等的时候属于是最平衡的状态，一个Partition对应一个Consumer，消息的消费效率完全取决于Consumer实例的吞吐量</p><img src="/images/image-20200417151007055.png" alt="image-20200417151007055" style="zoom:50%;"></li><li><p>Consumer数量 &gt; Partition数量</p><p>因为一个Partition只能被同一个消费者组内的一个Consumer实例消费，所以当Consumer的数量大于Partition的数量时，将会有多个Consumer实例空闲着，无消息可消费。比如下图中，Topic0有4个Partition，而Consumer Group中有5个消费者实例，由消费关系来看，Consumer4这个实例会一直空闲着。</p><img src="/images/image-20200417150940246.png" alt="image-20200417150940246" style="zoom: 50%;"></li><li><p>多元化消费消息</p><p>一个Partition只能被同一个消费者群组内的一个Consumer实例消费，但是我们在实际生产中可能会遇到需要将一条消息发送给多端的情况，比如订单生成佣金的时候，不同的项目组都有各自的佣金策略，这种情况可以给每一个项目组分配一个group的形式让所有的项目组共享消息</p><img src="/images/image-20200417165151251.png" alt="image-20200417165151251" style="zoom:50%;"></li></ol><h3 id="消费者重平衡rebalance"><a class="markdownIt-Anchor" href="#消费者重平衡rebalance"></a> 消费者重平衡(ReBalance)</h3><p>当消费者群组内的消费者实例发生变化时，消息的消费情况会是什么样子？用户群组初始有两个Consumer实例，每一个都要负责消费两个Partition的消息，然后群组内新增了两个Consumer实例，这样Consumer和Partition的数量一致了，新增加的消费者会均衡的替原有消费者分摊处理Partition的消息，最终达到一对一的平衡状态，这个过程就叫作ReBalance。</p><p><img src="/images/image-20200417172313104.png" alt="image-20200417172313104"></p><p>kafka通过消费者群组的ReBalance实现高可用和伸缩性，在群组做ReBalance期间，整个群组的消费者都无法消费消息，所以一般情况下我们都会预先估算好消费者群组内的消费者数量，估算的依据是消息量和topic下的Partition数。且当一个Partition重新分配给另一个消费者实例时，会造成当前正在消费的消息状态丢失。</p><p>消费者群组内的消费者实例需要定期向broker发送心跳来维护自己在群组内的地位，比如消费者进行poll和commit的同时，会发送一次心跳。如果broker长时间未接收到来自Consumer的心跳请求，则认为该Consumer实例已宕机，自动将其从群组中移除，并做一次ReBalance，Consumer之前对应的Partition的消息会暂时不再被消费。</p><h3 id="偏移量"><a class="markdownIt-Anchor" href="#偏移量"></a> 偏移量</h3><p>偏移量可以分为生产者偏移量和消费者偏移量，生产者偏移量实际上就是每一个Partition的偏移量，Partition之间是相互隔离的，也可以理解为Partition中的每一个消息都一个offset属性，每一个Producer针对topic-Partition都在自身维护一个offset；同时也可以理解为生产者偏移量只是一个虚拟的offset，实际上就是消息队列的size。消费者偏移量是切切实实和消费者相关的一个最重要的元素，使用偏移量，Consumer才能知道要从哪条消息开始读取，偏移量主要和topic的Partition相关，尤其是在消费者群组发生ReBalance的时候，调整后的Consumer从新的Partition接收消息之前需要知道这个Partition有多少消息已经被消费了，当前的消费者要从哪一条消息开始消费，否则就会出现重复消费或者遗漏消息的情况。</p><p>kafka中默认一个topic：<code>__consumer_offsets</code>，消费者每消费一次就会像该topic发送一次消息，消息中包含每一个Topic-Partition的offset，在发生ReBalance之后，消费者开始负责另外一个Partition的消息，这个时候会向<code>__consumer_offsets</code>获取该Partition最后一次被消费的偏移量，然后从该偏移量开始继续消费数据。</p><p>通过topic、partition、offset三个元素可以定位一条消息。</p><p>消费者在获取一批消息之后，需要将最后一条消息的偏移量提交给服务器，也就是将偏移量commit给topic<code>__consumer_offsets</code>，提交方式有自动提交和手动提交两种，通过参数<code>enable.auto.commit</code>来控制，默认值为true，也就是默认自动提交；而将参数值改为false，就是手动提交。</p><ul><li>自动提交<ol><li><code>enable.auto.commit=true</code>，设置为自动提交</li><li><code>auto.commit.interval.ms=3000</code>，设置自动提交时间间隔，单位：毫秒，默认5秒</li></ol></li><li>手动提交<ol><li><code>enable.auto.commit=false</code>，设置为手动提交</li><li>同步提交：<code>consumer.commitSync()</code></li><li>异步提交：<code>consumer.commitAsync()</code></li></ol></li></ul><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><ul><li><code>fetch.min.bytes</code>：指定消费者每次获取记录的最小字节数，默认为1字节，若本次poll时数据量大小不满足条件，则会等到有足够的数据时再拉取。当消息不用非常实时的时候，可以将消费者的此值设置略大一些，以此降低消费者和broker的工作负载。</li><li><code>fetch.max.bytes</code>：指定消费者每次获取记录的最大字节数，默认为50M</li><li><code>max.partition.fetch.bytes</code>：指定每个分区每次拉取消息的最大字节数，默认为1M</li><li><code>auto.offset.reset</code>：指定消费者在读取一个没有偏移量的分区或者偏移量无效的情况下的处理方式，默认值是latest，也就是从最新的记录开始读取，也可以设置为earliest，让消费者从第一条消息开始读取</li><li><code>enable.auto.commit</code>：设置消费者是否自动提交偏移量，默认为true</li><li><code>heartbeat.interval.ms</code>：消费者每次心跳间隔，单位：毫秒，默认为3s</li><li><code>bootstrap.servers</code>：指定消费者连接的kafka集群地址，通过逗号分隔，格式：<code>host1:port1,host2:port2,...</code></li><li><code>group.id</code>：消费者所属群组id，默认为默认分组</li><li><code>key.deserializer</code>：key反序列化方式</li><li><code>value.deserializer</code>：value反序列化方式</li></ul><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="comment">// kafka集群地址</span></span><br><span class="line">  properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"127.0.0.1:9092"</span>);</span><br><span class="line">  <span class="comment">// 消费者群组id</span></span><br><span class="line">  properties.put(<span class="string">"group.id"</span>, <span class="string">"cc_consumer"</span>);</span><br><span class="line">  <span class="comment">// key反序列化</span></span><br><span class="line">  properties.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">  <span class="comment">// value反序列化</span></span><br><span class="line">  properties.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">  <span class="comment">// 创建消费者</span></span><br><span class="line">  KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line">  <span class="comment">// 指定消费者监听的topic</span></span><br><span class="line">  consumer.subscribe(Arrays.asList(<span class="string">"my_topics"</span>));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 拉取topic</span></span><br><span class="line">      ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record.toString());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close(Duration.ofMillis(<span class="number">2000</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简&quot;&gt;&lt;/a&gt; 简&lt;/h3&gt;
&lt;p&gt;消息由生产者产出，产出后push到partition中，但是既然有生产了，那肯定就要有消费，不然我们生产出来的消息岂不成了垃圾数据，所以在kafka中
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://luxiaowan.github.io/categories/Kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka生产者</title>
    <link href="http://luxiaowan.github.io/2020/04/17/Kafka%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    <id>http://luxiaowan.github.io/2020/04/17/Kafka生产者/</id>
    <published>2020-04-16T16:46:00.000Z</published>
    <updated>2020-04-17T05:06:52.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简"><a class="markdownIt-Anchor" href="#简"></a> 简</h3><p>在kafka中把产生消息的一方称为生产者（Producer），尽管消息的产生非常简单，但是消息的发送过程比较复杂</p><p><img src="/images/kafka-p-send.png" alt="img"></p><p>发送消息从创建一个ProducerRecord对象开始，此类是kafka中的一个核心类，表示kafka需要发送的K-V键值对，记录了要发送的topic、partition、key、value、timestamp等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerRecord</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer partition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发送ProducerRecord的时候需要将对象序列化为字节数组，便于在网络上传输，之后消息达到分区器，若发送过程中指定了分区号，也就是partition，则在发送消息的时候将使用指定的分区，若发送过程中未制定分区，则根据topic和cluster中的partition数量顺序选择一个分区进行发送，分区选择器由接接口<code>org.apache.kafka.clients.producer.Partitioner</code>的实现类指定。</p><blockquote><p>org.apache.kafka.clients.producer.KafkaProducer</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(ProducerRecord&lt;K, V&gt; record, <span class="keyword">byte</span>[] serializedKey, <span class="keyword">byte</span>[] serializedValue, Cluster cluster)</span> </span>&#123;</span><br><span class="line">  Integer partition = record.partition();</span><br><span class="line">  <span class="keyword">return</span> partition != <span class="keyword">null</span> ?</span><br><span class="line">    partition :</span><br><span class="line">  partitioner.partition(</span><br><span class="line">    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>org.apache.kafka.clients.producer.internals.DefaultPartitioner</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选取分区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">  List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">  <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">  <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 顺序index</span></span><br><span class="line">    <span class="keyword">int</span> nextValue = nextValue(topic);</span><br><span class="line">    List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 取模</span></span><br><span class="line">      <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">      <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">      <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">    <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProducerRecord内关联的时间戳timestamp，如果用户未指定，则使用KafkaProducer内的time的时间作为时间戳，但是kafka最终使用的时间戳取决于topic配置的时间戳类型：</p><ul><li>topic为CreateTime，则消息记录中的时间戳由broker使用</li><li>topic为LogAppendTime，则消息记录中的时间戳会在追加到日志中时由broker重写</li></ul><p><img src="/images/kafka_log.png" alt="img"></p><p>消息被放在一个记录批次里<code>ProducerBatch</code>，这个批次的所有消息都会被发送到相同的topic和partition上，由一个FutureRecordMetadata负责发送。</p><p>broker收到消息后会返回一个响应，如果发送正常的话，会返回一个<code>RecordAppendResult</code>对象，包含了topic、partition、offset、时间戳等信息，发送失败则会将失败的消息记录下来，然后后续重试发送。</p><blockquote><p>org.apache.kafka.clients.producer.KafkaProducer</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;RecordMetadata&gt; <span class="title">doSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">  TopicPartition tp = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    throwIfProducerClosed();</span><br><span class="line">    <span class="comment">// first make sure the metadata for the topic is available</span></span><br><span class="line">    ClusterAndWaitTime clusterAndWaitTime;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (metadata.isClosed())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">    Cluster cluster = clusterAndWaitTime.cluster;</span><br><span class="line">    <span class="comment">// 序列化key</span></span><br><span class="line">    <span class="keyword">byte</span>[] serializedKey;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Can't convert key of class "</span> + record.key().getClass().getName() +</span><br><span class="line">                                       <span class="string">" to class "</span> + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                                       <span class="string">" specified in key.serializer"</span>, cce);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 序列化value</span></span><br><span class="line">    <span class="keyword">byte</span>[] serializedValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Can't convert value of class "</span> + record.value().getClass().getName() +</span><br><span class="line">                                       <span class="string">" to class "</span> + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                                       <span class="string">" specified in value.serializer"</span>, cce);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 决定要发送的partition</span></span><br><span class="line">    <span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">    tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置header</span></span><br><span class="line">    setReadOnly(record.headers());</span><br><span class="line">    Header[] headers = record.headers().toArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),</span><br><span class="line">                                                                       compressionType, serializedKey, serializedValue, headers);</span><br><span class="line">    ensureValidRecordSize(serializedSize);</span><br><span class="line">    <span class="comment">// 设置消息时间戳</span></span><br><span class="line">    <span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? time.milliseconds() : record.timestamp();</span><br><span class="line">    log.trace(<span class="string">"Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;"</span>, record, callback, record.topic(), partition);</span><br><span class="line">    <span class="comment">// producer callback will make sure to call both 'callback' and interceptor callback</span></span><br><span class="line">    Callback interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务</span></span><br><span class="line">    <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; transactionManager.isTransactional())</span><br><span class="line">      transactionManager.maybeAddPartitionToTransaction(tp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息，见下方代码</span></span><br><span class="line">    RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey,</span><br><span class="line">                                                                     serializedValue, headers, interceptCallback, remainingWaitMs);</span><br><span class="line">    <span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">      log.trace(<span class="string">"Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch"</span>, record.topic(), partition);</span><br><span class="line">      <span class="keyword">this</span>.sender.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.future;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ApiException e) &#123;</span><br><span class="line">    log.debug(<span class="string">"Exception occurred during message send:"</span>, e);</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>)</span><br><span class="line">      callback.onCompletion(<span class="keyword">null</span>, e);</span><br><span class="line">    <span class="comment">// 记录错误信息</span></span><br><span class="line">    <span class="keyword">this</span>.errors.record();</span><br><span class="line">    <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureFailure(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.errors.record();</span><br><span class="line">    <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BufferExhaustedException e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.errors.record();</span><br><span class="line">    <span class="keyword">this</span>.metrics.sensor(<span class="string">"buffer-exhausted-records"</span>).record();</span><br><span class="line">    <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.errors.record();</span><br><span class="line">    <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>org.apache.kafka.clients.producer.internals.RecordAccumulator</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RecordAppendResult <span class="title">append</span><span class="params">(TopicPartition tp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">byte</span>[] key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">byte</span>[] value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Header[] headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Callback callback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> maxTimeToBlock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  appendsInProgress.incrementAndGet();</span><br><span class="line">  ByteBuffer buffer = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (headers == <span class="keyword">null</span>) headers = Record.EMPTY_HEADERS;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Deque&lt;ProducerBatch&gt; dq = getOrCreateDeque(tp);</span><br><span class="line">    <span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">      <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>);</span><br><span class="line">      RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">      <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> maxUsableMagic = apiVersions.maxUsableProduceMagic();</span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="keyword">this</span>.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(maxUsableMagic, compression, key, value, headers));</span><br><span class="line">    log.trace(<span class="string">"Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;"</span>, size, tp.topic(), tp.partition());</span><br><span class="line">    <span class="comment">// 申请一个缓冲区，将消息数据写入到缓冲区中</span></span><br><span class="line">    buffer = free.allocate(size, maxTimeToBlock);</span><br><span class="line">    <span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">      <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>);</span><br><span class="line"></span><br><span class="line">      RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">      <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendResult;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      MemoryRecordsBuilder recordsBuilder = recordsBuilder(buffer, maxUsableMagic);</span><br><span class="line">      <span class="comment">// 将消息分批处理</span></span><br><span class="line">      ProducerBatch batch = <span class="keyword">new</span> ProducerBatch(tp, recordsBuilder, time.milliseconds());</span><br><span class="line">      FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, headers, callback, time.milliseconds()));</span><br><span class="line"></span><br><span class="line">      dq.addLast(batch);</span><br><span class="line">      incomplete.add(batch);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 清空缓冲区</span></span><br><span class="line">      buffer = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RecordAppendResult(future, dq.size() &gt; <span class="number">1</span> || batch.isFull(), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer != <span class="keyword">null</span>)</span><br><span class="line">      free.deallocate(buffer);</span><br><span class="line">    appendsInProgress.decrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息发送类型"><a class="markdownIt-Anchor" href="#消息发送类型"></a> 消息发送类型</h3><ol><li><p>简单发送</p><p>kafka最简单的消息发送是只指定topic和key及value，分区及时间戳均使用默认值，send()方法会返回一个<code>Future&lt;RecordMetadata&gt;</code>对象，如果不需要关心返回值，则可以忽略这个返回值，否则必须关注此值，方法返回的异常信息可能有<code>InterruptedException(发送线程中断异常)</code>，<code>BufferExhaustedException(缓冲区已满)</code>，<code>SerializationException(序列化异常)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String,String&gt; record =</span><br><span class="line">                <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"cc_test"</span>,<span class="string">"cc"</span>,<span class="string">"chuanchuan"</span>);</span><br><span class="line">producer.send(record);</span><br></pre></td></tr></table></figure></li><li><p>同步发送</p><p>第一种简单发送方式的前提是我们不在意发送的结果，但是我们在正常的情况下都会等待broker的反馈。我们从发送的源码中看到send()方法返回的<code>Future&lt;RecordMetadata&gt;</code>对象，我们可以调用Future的get()方法阻塞主线程等待broker的响应，如果返回错误，则我们调用get()方法的时候会抛出异常，如果没发生异常，则顺利获取到<code>RecordMetadata</code>对象，使用该对象查看消息的详细信息：topic、key和value的序列化后的大小、offset、partition。</p><p>生产者发送过程中一般会出现两类错误：一类可以通过重试解决，一类无法通过重试解决。比如连接错误、无Leader错误等都可以通过重试来实现，而消息过大这类错误KafkaProducer会直接抛出异常，不会重试，因为不管重试多少次都是消息过大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"cc_test"</span>, <span class="string">"cc"</span>, <span class="string">"chuanchuan"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  RecordMetadata rm = producer.send(record).get();</span><br><span class="line">  System.out.println(rm.offset());</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">  log.error(<span class="string">"occur error"</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异步发送</p><p>消息同步发送会造成同一时间只能有一条消息在发送中，在其有返回之前，其他的消息都需要一直等待，这样会造成消息堵塞滞后，无法让kafka发挥更大的效益，若一个消息发送需要20ms，发送五十条消息就需要1s，如果我们使用异步这种方式，那么发送五十条可能只需要30ms，甚至更少。异步发送的原理是在我们调用send()方法时传入一个接口<code>org.apache.kafka.clients.producer.Callback</code>的实现类的对象，由ProducerBatch的私有方法<code>completeFutureAndFireCallbacks</code>完成回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"cc_test"</span>, <span class="string">"cc"</span>, <span class="string">"chuanchuan"</span>);</span><br><span class="line">producer.send(record, );</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CcProducerCallback</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata,Exception exception)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exception != <span class="keyword">null</span>)&#123;</span><br><span class="line">      exception.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>org.apache.kafka.clients.producer.internals.ProducerBatch</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">completeFutureAndFireCallbacks</span><span class="params">(<span class="keyword">long</span> baseOffset, <span class="keyword">long</span> logAppendTime, RuntimeException exception)</span> </span>&#123;</span><br><span class="line">  produceFuture.set(baseOffset, logAppendTime, exception);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// execute callbacks</span></span><br><span class="line">  <span class="keyword">for</span> (Thunk thunk : thunks) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发生异常</span></span><br><span class="line">      <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RecordMetadata metadata = thunk.future.value();</span><br><span class="line">        <span class="keyword">if</span> (thunk.callback != <span class="keyword">null</span>)</span><br><span class="line">          thunk.callback.onCompletion(metadata, <span class="keyword">null</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常</span></span><br><span class="line">        <span class="keyword">if</span> (thunk.callback != <span class="keyword">null</span>)</span><br><span class="line">          thunk.callback.onCompletion(<span class="keyword">null</span>, exception);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">"Error executing user-provided callback on message for topic-partition '&#123;&#125;'"</span>, topicPartition, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  produceFuture.done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="分区机制"><a class="markdownIt-Anchor" href="#分区机制"></a> 分区机制</h3><p>kafka对于数据的读写是以partition为粒度的，partition可以分布在不同的broker上，每个节点都可以独立的实现消息的读写，并且能够通过新增新的broker来提升kafka集群的吞吐量，partition部署在多个broker来实现负载均衡。</p><p>kafka的分区策略其实指的就是Producer将消息发送到哪个分区的算法，kafka提供了默认的分区策略，同时也支持我们自定义分区策略，所有的策略都实现于接口<code>org.apache.kafka.clients.producer.Partitioner</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Partitioner</span> <span class="keyword">extends</span> <span class="title">Configurable</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供消息信息计算partition</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic topic名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyBytes key序列化字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> valueBytes value序列化字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cluster 集群</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭partitioner</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息发送到哪一个partition上涉及到分区选择机制，主要有顺序、随机、按key分配、自定义分配等方式，具体的实现方法就是<code>public int partition()</code>。</p><ol><li><p>顺序轮询</p><p>顺序分配就是消息均匀的发送给每一个partition，每个partition存储一次消息，kafka的默认策略。</p><img src="/images/image-20200417033430230.png" alt="image-20200417033430230" style="zoom: 67%;"></li><li><p>随机策略</p><p>随机策略可以先计算出topic的总的partition数，然后使用<code>ThreadLocalRandom.current().nextInt()</code>方法来获取一个小于分区总数的随机值，随机策略会导致消息分布不均匀。虽然是随机的，但是单个分区内也是有序的。</p><img src="/images/image-20200417035130292.png" alt="image-20200417035130292" style="zoom:67%;"><blockquote><p>策略代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> ThreadLocalRandom.current().nextInt(partitions.size());</span><br></pre></td></tr></table></figure></li><li><p>key分配策略</p><p>这个策略也叫做 key-ordering策略，kafka中每条消息都会有自己的key，一旦消息被定义了 key，那么你就可以保证同一个key的所有消息都进入到相同的partition里面，因为每个partition下的消息处理都是有顺序的，所以这个策略也被称为按消息键保序策略</p><img src="/images/image-20200417035625713.png" alt="image-20200417035625713" style="zoom:60%;"><blockquote><p>策略代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="comment">// Math.abs()的原因是hashCode可能是负数</span></span><br><span class="line"><span class="keyword">return</span> Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure></li><li><p>自定义分配策略</p><p>自由发挥吧，只要实现Partitioner接口就成了</p><blockquote><p>application.properties</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># org.apache.kafka.clients.producer.ProducerConfig类中定义了各类参数配置信息</span></span><br><span class="line"><span class="meta">spring.kafka.properties.partitioner.class</span>=<span class="string">cc.kevinlu.springboot.kafka.partitioners.CcPartitioner</span></span><br></pre></td></tr></table></figure><blockquote><p>CcPartitioner</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.kevinlu.springboot.kafka.partitioners;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Partitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.Cluster;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"&#123;&#125;------------&#123;&#125;"</span>, topic, cluster.availablePartitionsForTopic(topic).size());</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 永远都打到partition 0上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="producer-property"><a class="markdownIt-Anchor" href="#producer-property"></a> Producer Property</h3><ol><li>retries：消息重试次数，若消息发送过程中出现错误，但是可通过重新发送来弥补错误，比如Leader缺失，则生产者会不断的重发消息，直到重发次数达到此参数指定的值后放弃重试并返回错误，默认情况下每次重试间隔100ms，通过参数<code>retry.backoff.ms</code>指定</li><li>acks：指定要有多少个partition副本接收消息，生产者才认为消息是成功写入，acks能够控制消息丢失概率。<ul><li>acks=0：表示生产者只管发不管服务器是否接收了，非常容易丢消息</li><li>acks=1：只要集群的Leader收到了消息就立刻反馈给生产者，消息可能会丢失</li><li>acks=all：只有当所有的参与复制的节点都接收到消息时，broker才会反馈给生产者，能够保证消息绝不丢失，但是延迟更高</li></ul></li><li>key.serializer：key的序列化类，需是接口<code>org.apache.kafka.common.serialization.Serializer</code>的实现类</li><li>value.serializer：value的序列化类，需是接口<code>org.apache.kafka.common.serialization.Serializer</code>的实现类</li><li>compression.type：消息压缩类型，默认为none, 可选值有none、gzip、snappy、lz4、zstd</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简&quot;&gt;&lt;/a&gt; 简&lt;/h3&gt;
&lt;p&gt;在kafka中把产生消息的一方称为生产者（Producer），尽管消息的产生非常简单，但是消息的发送过程比较复杂&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://luxiaowan.github.io/categories/Kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>Git切换回某个commit</title>
    <link href="http://luxiaowan.github.io/2020/04/16/Git%E5%88%87%E6%8D%A2%E5%9B%9E%E6%9F%90%E4%B8%AAcommit/"/>
    <id>http://luxiaowan.github.io/2020/04/16/Git切换回某个commit/</id>
    <published>2020-04-16T15:45:00.000Z</published>
    <updated>2020-04-16T16:00:43.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原由"><a class="markdownIt-Anchor" href="#原由"></a> 原由</h3><p>commit之后忘了push，然后就revert HEAD了，导致本地的代码丢失了刚修改的内容</p><h3 id="第一步"><a class="markdownIt-Anchor" href="#第一步"></a> 第一步</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>使用该命令查看commit记录</p><img src="/images/image-20200416235542502.png" alt="git commit log" style="zoom:50%;"><p>格式<code>commit commit_id</code>，比如<code>commit bc208f03c3bb341dfc56533d9ea196b6d347ff34</code>中，bc208f03c3bb341dfc56533d9ea196b6d347ff34就是commit_id，每一次commit的id都是全局唯一的</p><h3 id="第二步"><a class="markdownIt-Anchor" href="#第二步"></a> 第二步</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard $&#123;commit_id&#125;</span><br></pre></td></tr></table></figure><p>若想切换回jmm这次的commit，则语句为<code>git reset --hard 81fc9404e8186d132c799ffaf62e652a4c8c98f0</code></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>git操作要慎重，不过即使出了问题也有恢复的小技巧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原由&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#原由&quot;&gt;&lt;/a&gt; 原由&lt;/h3&gt;
&lt;p&gt;commit之后忘了push，然后就revert HEAD了，导致本地的代码丢失了刚修改的内容&lt;/p&gt;
&lt;h3 id=&quot;第一步&quot;&gt;&lt;a clas
      
    
    </summary>
    
    
      <category term="Git" scheme="http://luxiaowan.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka初探</title>
    <link href="http://luxiaowan.github.io/2020/04/16/Kafka%E5%88%9D%E6%8E%A2/"/>
    <id>http://luxiaowan.github.io/2020/04/16/Kafka初探/</id>
    <published>2020-04-15T18:51:00.000Z</published>
    <updated>2020-04-16T16:00:26.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本名词"><a class="markdownIt-Anchor" href="#基本名词"></a> 基本名词</h3><ul><li>消息：kafka中的数据单元称为消息，也可以叫记录，相当于MySQL表中的一条记录</li><li>批次：为了提高效率，kafka可以一次性写入一批数据(消息)，批次指的就是一组消息</li><li>主题：相当于MySQL的表，一个主题(Topic)代表着一类消息，kafka使用主题对消息分类</li><li>分区：分区(partition)归属于主题，一个主题可以划分为若干个分区，分区可以分布在不同的broker上，也可以在同一个broker上，使用分区来实现kafka的伸缩性。主题的单个分区上的消息是有序的，但是不同分区上的消息无法保证有序。</li><li>生产者：向主题发布消息的客户端称为生产者，生产者用于不断的向主题发送消息</li><li>消费者：订阅主题消息的客户端称为消费者，消费者用于处理生产者生产的消息</li><li>消费者群组：生产者与消费者的关系是一对多，比如一个客服对应多个咨询者，消费者群组就是由一批消费者组成的</li><li>偏移量：偏移量(Consumer Offset)是一种源数据，是一个单向递增的整数标识，用于记录消费者发生重平衡时的位置，以便用来恢复数据</li><li>broker：一个独立的服务器被称为broker，broker接收来自生产者的消息，并为消息设置偏移量，并提交消息持久化到磁盘</li><li>broker集群：多个broker组成一个集群，保证kafka的高可用，每个集群中都有一个broker充当集群Leader的角色</li><li>副本：kafka中消息的备份又称为副本(Replica)，副本的数量是可配置的，类型有Leader和Follower两种，Leader对外提供服务，Follower辅助</li><li>重(chong)平衡(ReBalance)：若消费者组内某个消费者宕了，其他存活的消费者自动重新分配订阅主题分区，kafka高可用的必备能力</li></ul><h3 id="关系介绍"><a class="markdownIt-Anchor" href="#关系介绍"></a> 关系介绍</h3><ul><li><p>Topic&amp;Partition</p><ol><li><p>Topic是kafka中给消息分类的标记，一个消息必定属于一个Topic，一个Topic可以包括一个或多个Partition，Partition又可以有多个副本，副本又可以分配在不同的broker上。</p></li><li><p>Partition内部是有序的，Partition之间是无序的</p><img src="/images/log_anatomy.png" alt="img" style="zoom: 130%;"></li><li><p>内部存储是以append-log的方式不断进行log文件尾部追加，文件读写是在磁盘上是顺序的，效率极高，媲美内存操作，每一条log对应一个offset，可以把offset理解为一个数组的下标，通过这个下标就可以读取对应的消息数据，Partition只负责为消息分配offset，消费者具体由哪个offset开始消费消息完全由消费者自己控制，也就是kafka服务端只负责提供数据，消费者自己控制消息消费进度。</p><img src="/images/log_consumer.png" alt="img" style="zoom: 25%;"></li><li><p>kafka虽然是可以持久化消息，并且不删除已经被消费过的消息，但消息也不是被永久存储在磁盘上的，为了防止磁盘长期被消息写入数据日积月累，kafka提供两种旧数据淘汰策略：</p></li></ol><ul><li><p>开启数据清理：<code>log.cleaner.enable=true</code>，默认关闭状态</p></li><li><p>基于时间：<code>log.retention.hours=168</code>，单位：小时；<code>log.retention.ms=100</code>，单位：毫秒；<code>log.retention.minutes</code>，单位：分钟</p></li><li><p>基于文件大小：<code>log.retention.bytes=1073741824</code>，单位：字节</p></li></ul></li><li><p>Consumer&amp;Consumer Group</p><ol><li><p>一个消费者组由一个或多个消费者组合而成，每一条消息只会被同一个group中的一个消费者消费，但是不同group中的消费者可以同时消费同一条消息，保证了 消息队列中的消息只被消费一次；kafka是发布订阅模式的消息队列，这里订阅的是消费者组，而不是特定的一个消费者实例。</p><p><img src="/images/consumer-groups.png" alt="img"></p><p>kafka支持离线处理和实时处理，所以我们可以使用Hadoop进行离线处理，也可以使用Storm这种实时流处理系统进行实时处理，还可以将数据实时的同步到其他的数据中心，前提是这些消费者处于不同的消费者组。</p><p>可以测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 创建一个topic</span></span><br><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 3 --partition 1 --topic cc_topic</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 启动一个Producer</span></span><br><span class="line">kafka-console-producer --broker-list localhost:9092 --topic cc_topic</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 启动五个Consumer，1~3号放cc_group_1，4~5放cc_group_2</span></span><br><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --group cc_group_1 --from-beginning --topic cc_topic</span><br><span class="line"></span><br><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --group cc_group_1 --from-beginning --topic cc_topic</span><br><span class="line"></span><br><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --group cc_group_1 --from-beginning --topic cc_topic</span><br><span class="line"></span><br><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --group cc_group_2 --from-beginning --topic cc_topic</span><br><span class="line"></span><br><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --group cc_group_2 --from-beginning --topic cc_topic</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 发送一条消息</span></span><br><span class="line">123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 查看消费者</span></span><br><span class="line">cc_group_1和cc_group_2各自收到123这条消息一次</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Consumer ReBalance</p><p>Consumer ReBalance是通过Zookeeper实现，kafka保证了同一个消费者组中只能有一个消费者消费某条消息，其实kafka保证的是在稳定状态下每一个消费者都只会消费一个或多个Partition的消息，而某一Partition的消息仅会被一个消费者消费，这样设计的优势是每个消费者不用跟所有的broker进行通信，减少了通信开销，劣势是同一个消费组内的消费者不能均匀消费，而且单个Partition内部的数据是有序的，所以对于单个消费者来说，其消费的消息是有序的。</p><ol><li>Consumer &lt; Partition：会出现某些Consumer消费多个Partition的数据</li><li>Consumer &gt; Partition：会出现某些Consumer没有可消费的Partition</li><li>Consumer = Partition：一个Consumer消费一个Partition，均匀</li></ol></li></ul><h3 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h3><ul><li>高吞吐、低延迟：kafka处理消息的速度非常快，每秒几乎可以处理几十万条消息，并且最低延迟只有几毫秒</li><li>高伸缩性：每个topic都能有多个partition，每个partition又可以分布在不同的broker上</li><li>高并发：能够同时支持数千个客户端进行读写</li><li>容错性：允许集群中的某些节点失败，某个节点宕机，kafka仍然可用继续提供服务</li><li>持久性、可靠性：kafka的消息存储是基于Zookeeper的，Zookeeper是可以将消息持久化到磁盘上，并且支持数据备份，所以kafka是一个非常可靠的可持久化消息中间件</li><li>速度快：kafka采用零拷贝的模式实现数据的快速移动，避免了内核空间和用户空间的频繁切换，kafka可以批量发送数据，从生产者到文件系统到消费者；数据压缩可以通过有效的数据压缩减少IO次数，并且采用顺序读写的方式避免寻址造成的消耗。总结起来就是零拷贝、顺序读写、数据压缩、分批发送。</li></ul><h3 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h3><ul><li><p>点对点（一对一）：一个生产者所生产的消息只会被一个消费者进行消费，不会同时被多个消费者消费</p><img src="/images/image-20200416173858298.png" alt="image-20200416173858298" style="zoom:50%;"></li><li><p>发布订阅（一对多、多对多）：一个或多个生产者所生产的消息会被多个消费者同时消费</p><img src="/images/image-20200416173919621.png" alt="image-20200416173919621" style="zoom:50%;"></li></ul><h3 id="架构体系"><a class="markdownIt-Anchor" href="#架构体系"></a> 架构体系</h3><img src="/images/image-20200416220029587.png" alt="image-20200416220029587" style="zoom:45%;"><p>一个kafka集群包含若干个Producer、若干Consumer group、若干broker和Zookeeper集群组成，kafka通过Zookeeper管理Partition，选举Leader，以及在Consumer发生变化时通过Zookeeper进行ReBalance。Producer将消息push到Partition，Consumer通过pull将消息从Partition拉取到本地。</p><h3 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h3><p>kafka目前提供五类常用的API，主要有Producer、Consumer、Stream、Connect、Admin API：</p><ul><li>Producer API：允许App作为Producer将消息发送到kafka集群的一个或多个topic上</li><li>Consumer API：允许App作为Consumer从kafka集群上的一个或多个topic拉取消息</li><li>Stream API：允许App作为流处理器，从一个或多个topic中消费输入流并转化为输出流</li><li>Connector API：允许将现有的应用程序或存储系统连接到kafka的topic，充当Producer或Consumer</li><li>Admin API：允许管理和检查topic、broker和kafka的其他内容</li></ul><img src="/images/kafka-apis.png" alt="img" style="zoom:50%;"><h3 id="重要配置参数"><a class="markdownIt-Anchor" href="#重要配置参数"></a> 重要配置参数</h3><p>kafka的参数配置文件是server.properties</p><ul><li><a href="http://broker.id" target="_blank" rel="noopener">broker.id</a>：每个broker都有一个唯一标识，就像是MySQL表中的主键ID，默认值是0，这个值在kafka集群中必须是唯一不可重复的，值随意设置。</li><li>port：kafka broker的默认端口是9092，若未指定port参数，则就是9092，修改port参数可以是任意端口，但是最好不要低于1024，不然就需要管理员权限启动了</li><li>zookeeper.connect：设置broker源数据的Zookeeper地址，参数的值可以设置一个或多个，多个zk通过逗号分隔，比如<code>zk1:port,zk2:port,zk3:port</code>，不同的kafka集群可以使用同一个zk集群，可以通过指定zk的具体path来区分每个kafka的使用，比如kafka cluster1使用<code>zk:port/path1</code>，kafka cluster2使用<code>zk:port/path2</code>。</li><li><a href="http://zookeeper.connection.timeout.ms" target="_blank" rel="noopener">zookeeper.connection.timeout.ms</a>：设置broker连接Zookeeper的超时时间，单位是毫秒</li><li>log.dirs：kafka把所有的消息都保存在本地磁盘上，保存的日志地址通过该参数指定，可以指定多个存储目录，通过逗号分隔，例如<code>/home/kafka/1,/home/kafka/2,/home/kafka/3</code></li><li>auto.create.topic.enable：默认为true，允许随意的创建topic，参数为true时，使用Producer往一个不存在的topic发送消息时会自动创建topic、使用Consumer从一个不存在的topic拉取消息时自动创建topic、主动创建topic、当任意一个客户端向topic发送元数据请求时。此值建议在生产上设置为false，topic由人工进行分配，防止生产环境出现各种乱七八糟的topic。</li><li>topic相关参数<ul><li>num.partitions：主题拥有的Partition数量，若在创建topic的时候未指定分区数量，则使用该参数的值，默认为1。在运行过程中，分区数量可以增加不能减少，在创建时可以通过<code>--partition</code>指定个数</li><li>default.replication.factor：kafka消息的默认副本数，默认为1，只有在自动创建topic的时候才有效，在创建时可以通过<code>--replication-factor</code>指定</li><li>log.cleaner.enable：是否开启日志清理功能，默认为true，清理方式有时间和日志文件大小两种方式</li><li>log.retention.hours：设置kafka消息保存的时间，默认为168个小时，还可以通过<code>log.retention.ms</code>和<code>log.retention.minutes</code>来设置清理时间的毫秒和分钟时间</li><li>log.retention.bytes：设置topic的每个Partition所能保存的数据量，比如若一个topic有10个Partition，此参数的值为1G，那么该topic的最大存储容量为8G，topic的容量随着Partition的增加而增加。</li><li>log.segment.bytes：设置日志文件的最大的容量大小。当消息到达broker时，会被追加到日志文件中，但是如果日志片段的当前大小加上新接收消息的打小后超过了该参数设置的值，则将新消息和后续的消息写入到一个新的日志文件中。该参数的值越小，分割的文件就越多，磁盘的写入效率就越低。</li><li><a href="http://log.segment.ms" target="_blank" rel="noopener">log.segment.ms</a>：除了待日志文件大小超值后重新分配新文件之外，还可以通过日志创建时间来控制消息日志文件的生命周期，可以和<code>log.segment.bytes</code>同时设置，哪一个先达标使用哪一个策略，比如bytes设置为1G，ms设置为1小时，若30分钟内文件容量已达1G，则后续消息写入到新的日志文件中，若1小时内日志文件尚未达到1G，则也分配新的日志文件记录后续的消息。</li><li><a href="http://log.retention.check.interval.ms" target="_blank" rel="noopener">log.retention.check.interval.ms</a>：检查日志段以查看是否可以根据保留策略删除它们的时间间隔，单位：毫秒</li><li>message.max.bytes：该参数限定broker可接收的单个消息的大小，默认是1MB，如果Producer发送的消息大于此值，则broker会直接拒绝并返回错误。该参数指定的是压缩后的消息大小，消息的实际大小可能大于此值。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本名词&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本名词&quot;&gt;&lt;/a&gt; 基本名词&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;消息：kafka中的数据单元称为消息，也可以叫记录，相当于MySQL表中的一条记录&lt;/li&gt;
&lt;li&gt;批次：为了提高效率
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://luxiaowan.github.io/categories/Kafka/"/>
    
    
  </entry>
  
</feed>
