<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2020-05-30T16:09:39.152Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软引用、弱引用和虚引用</title>
    <link href="http://luxiaowan.github.io/2020/05/29/%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    <id>http://luxiaowan.github.io/2020/05/29/软引用、弱引用和虚引用/</id>
    <published>2020-05-29T04:50:00.000Z</published>
    <updated>2020-05-30T16:09:39.152Z</updated>
    
    <content type="html"><![CDATA[<h4 id="强引用"><a class="markdownIt-Anchor" href="#强引用"></a> 强引用</h4><p>强引用(strong reference)是使用最普遍的引用，如果一个对象具有强引用，那垃圾回收器绝不会回收它，例如<code>Object obj = new Object();</code>，即使当内存空间不足时，JVM宁愿抛出OOM，也不会回收具有强引用的对象来解决内存不足的问题。</p><p>我们可以显示的设置对象为null，或者跳出对象的生命周期范围，让垃圾收集器将其判定为不存在引用，是个可以被回收的对象，例如<code>obj = null;</code></p><p>全局对象：手动的将对象赋值为null，最典型的全局对象设置为null的就是在ArrayList的clear()方法中，对于类中的全局变量<code>elementData</code>来说，仅仅的将其置为null是不可行的，因为数组中的对象还是会继续引用的，所以此时需要将数组中每个位置的对象全部置为null，也就是将所有的对象的引用都释放掉，这样才会被GC回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment"> * be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear to let GC do its work</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量：一般情况下，一个对象保存在堆中，对象的引用保存在Java栈中，由于栈是线程私有的，所以当线程结束时，Java栈被自动回收，这时堆中对象的引用数-1，直到引用数变为0后，可以被GC回收。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们通过new创建的对象一般都是强引用</p></blockquote><h4 id="弱引用"><a class="markdownIt-Anchor" href="#弱引用"></a> 弱引用</h4><p>弱引用(weak reference)是可以被GC强制回收的，当垃圾收集器发现一个存活的弱可达对象时，就会将其放入响应的ReferenceQueue中，之后可能会遍历这个ReferenceQueue并执行响应的清理，弱可达对象是指该对象的引用只剩下弱引用。</p><p>我们可以通过弱引用的get()方法给对象赋值给新的强引用，在回收前，GC会再次判断该对象是否可以安全回收。所以，弱引用的对象的回收过程可以横跨多个GC周期，在Java中可以使用<code>WeakReference</code>类创建一个弱引用对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String cc = <span class="keyword">new</span> String(<span class="string">"串串"</span>);</span><br><span class="line">  <span class="comment">// 创建对象cc的弱引用</span></span><br><span class="line">  WeakReference&lt;String&gt; cc_wr = <span class="keyword">new</span> WeakReference&lt;&gt;(cc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ① cc = null;</span></span><br><span class="line">  <span class="comment">// ② System.gc();</span></span><br><span class="line">  <span class="comment">// 为对象cc创建一个强引用，若对象cc已经被回收，则返回null</span></span><br><span class="line">  String cc_s = cc_wr.get();</span><br><span class="line">  <span class="comment">// ③ cc = null;</span></span><br><span class="line">  System.out.println(cc_s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析</p><ol><li><p>仅开启①</p><p><img src="/images/image-20200530000738739.png" alt="image-20200530000738739"></p><p>弱引用对象尚未被回收</p></li><li><p>仅开启②</p><p><img src="/images/image-20200530001335758.png" alt="image-20200530001335758"></p></li><li><p>仅开启③</p><p><img src="/images/image-20200530001504957.png" alt="image-20200530001504957"></p></li><li><p>开启①②</p><p><img src="/images/image-20200530001545556.png" alt="image-20200530001545556"></p><p>哇啊哦~对象被回收了，这是因为我们先将对象的弱引用断开，然后又手动进行了一次gc，把对象给回收了</p></li><li><p>开启②③</p><p><img src="/images/image-20200530002013851.png" alt="image-20200530002013851"></p></li><li><p>开启①②③</p><p><img src="/images/image-20200530002029511.png" alt="image-20200530002029511"></p></li></ol></blockquote><h4 id="软引用"><a class="markdownIt-Anchor" href="#软引用"></a> 软引用</h4><p>软引用(Soft Reference)是比弱引用更难被垃圾回收器回收的对象，什么时候回收软引用完全由JVM自己觉得，一般只会在即将OOM时才会回收软引用，算是JVM内存管理最后的倔强。这就意味着可能会有非常频繁的Full GC，STW时间也变长，因为老年代中的存活对象多了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SoftReference&lt;String&gt; cc_sr = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"串串"</span>));</span><br><span class="line">  System.out.println(cc_sr.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚引用"><a class="markdownIt-Anchor" href="#虚引用"></a> 虚引用</h4><p>虚引用和弱引用、软引用不同，它并不影响对象的生命周期，使用<code>java.lang.ref.PhantomReference</code>类表示，和弱引用、软引用不同的是，虚引用必须和引用队列关联使用，当GC准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用放进与之关联的引用队列中。</p><p>为了防止可回收对象的残留，虚引用对象不应该被获取，PhantomReference的get()方法始终返回null，虚引用不会被GC自动清除，因为它们被存放到队列中，通过虚引用可达的对象会继续留在内存中，直到调用此引用的clear()方法，或者引用自身变为不可达。</p><p>也就是说我们如果不手动调用clear()方法来清除虚引用，则非常可能造成OOM而导致JVM宕机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ReferenceQueue&lt;String&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">  PhantomReference&lt;String&gt; cc_p = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"cc"</span>), rq);</span><br><span class="line">  System.out.println(cc_p.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以使用JVM参数<code>-XX:+PrintReferenceGC</code>查看各类引用对GC的影响</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;强引用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#强引用&quot;&gt;&lt;/a&gt; 强引用&lt;/h4&gt;
&lt;p&gt;强引用(strong reference)是使用最普遍的引用，如果一个对象具有强引用，那垃圾回收器绝不会回收它，例如&lt;code&gt;Objec
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM优化之提升速率</title>
    <link href="http://luxiaowan.github.io/2020/05/29/JVM%E4%BC%98%E5%8C%96%E4%B9%8B%E6%8F%90%E5%8D%87%E9%80%9F%E7%8E%87/"/>
    <id>http://luxiaowan.github.io/2020/05/29/JVM优化之提升速率/</id>
    <published>2020-05-29T01:50:00.000Z</published>
    <updated>2020-05-29T04:21:04.343Z</updated>
    
    <content type="html"><![CDATA[<p>提升速率(promotion rate)是用于衡量单位时间内从新生代晋升到来年代的数据量，一般用MB/sec表示单位。JVM会将存活时间较长的对象从新生代提升到老年代，根据分代规则，老年代中不仅有存活时间长的对象，也有存活时间短的对象，这些存活时间短的对象的晋升过程就是过早提升，简单点讲就是对象存活时间尚未达到晋升年龄之前就被提升到了老年代。</p><hr><h4 id="测量提升速率"><a class="markdownIt-Anchor" href="#测量提升速率"></a> 测量提升速率</h4><p>一般情况下我们需要通过GC日志来测量提升速率，我们来跑一段代码查看一下GC日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boxing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">double</span> sensorValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sensorValue = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processSensorValue</span><span class="params">(Double value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LockSupport.parkNanos(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iterations = args.length &gt; <span class="number">0</span> ? Integer.parseInt(args[<span class="number">0</span>]) : <span class="number">1_000_000</span>;</span><br><span class="line"></span><br><span class="line">        initSensor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iterations;) &#123;</span><br><span class="line">            processSensorValue(sensorValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread sensorReader = <span class="keyword">new</span> Thread(Boxing::readSensor);</span><br><span class="line"></span><br><span class="line">        sensorReader.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        sensorReader.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200529103423364.png" alt="image-20200529103423364"></p><p>我们来分析一下这段GC日志，通过计算新生代使用量以及堆内存使用量，就可以通过差值算出老年代的使用量：</p><table><thead><tr><th>Event</th><th>Time</th><th>Yound</th><th>整个堆减少内存</th><th>提升量</th><th>提升速率</th></tr></thead><tbody><tr><td>1st GC</td><td>425ms</td><td>63553kb</td><td>63545kb</td><td>8kb</td><td>0.02MB/sec</td></tr><tr><td>2nd GC</td><td>508ms</td><td>66003kb</td><td>65995kb</td><td>8kb</td><td>0.02MB/sec</td></tr><tr><td>3rd GC</td><td>587ms</td><td>65488kb</td><td>65488kb</td><td>0kb</td><td>0MB/sec</td></tr><tr><td>Total</td><td>587ms</td><td></td><td></td><td>16kb</td><td>0.03MB/sec</td></tr></tbody></table><p>从表格中我们看到平均的提升速率是0.03MB/sec，峰值是0.02MB/sec。</p><p>我们只能根据Minor GC计算提升速率，Full GC的日志不能用于计算提升速率，因为Major GC会清理掉老年代中的一部分对象，所以会计算不准确。</p><hr><p>和分配速率<a href="https://luxiaowan.github.io/2020/05/28/JVM%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E9%85%8D%E9%80%9F%E7%8E%87/">JVM优化之分配速率</a>一样，提升速率也会影响STW的频率，但分配速率主要影响Minor GC，而提升速率则影响Major GC的频率，若每次都有大量的对象从新生代晋升到老年代，那么老年代会很快被填满，老年代填充的越快，Major GC的频率就会越高。</p><p>一般来说，过早提升的症状会表现为以下形式：</p><ul><li>短时间内频繁的执行Full GC</li><li>每次Full GC后老年代的使用率都很低</li><li>提升速率接近于分配速率</li></ul><p><img src="/images/how-java-garbage-collection-works.png" alt="jgc"></p><p>我们来看一个过早提升的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrematurePromotion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>                MAX_CHUNKS        = Integer.getInteger(<span class="string">"max.chunks"</span>, <span class="number">10_000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Collection&lt;<span class="keyword">byte</span>[]&gt; accumulatedChunks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onNewChunk</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        accumulatedChunks.add(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (accumulatedChunks.size() &gt; MAX_CHUNKS) &#123;</span><br><span class="line">            processBatch(accumulatedChunks);</span><br><span class="line">            accumulatedChunks.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            onNewChunk(produceChunk());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] produceChunk() &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            bytes[i] = (<span class="keyword">byte</span>) (Math.random() * Byte.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">byte</span> sink;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processBatch</span><span class="params">(Collection&lt;<span class="keyword">byte</span>[]&gt; bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span>[] chunk : bytes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : chunk) &#123;</span><br><span class="line">                result ^= b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sink = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的JVM参数：<code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1</code>，将晋升年龄设置为1</p><blockquote><p>GC日志</p></blockquote><p><img src="/images/image-20200529111456993.png" alt="image-20200529111456993"></p><p>从日志中看到Full GC的频率很高，但是每次GC之后老年代的使用量都在减少，从日志上看是不是觉得和过早提升没多大关系？但是仔细想想，其实如果没有对象晋升到老年代或者晋升量很少的话，老年代的空间就不会不够用，也就不会被频繁的发生Full GC了，那么为什么老年代的使用量会减少呢？因为对象提升到老年代，同时老年代也有很多对象被回收，这就造成了老年代使用量减少的情况，但事实是大量的对象不断的提升到老年代，并触发Full GC。</p><hr><h4 id="优化策略"><a class="markdownIt-Anchor" href="#优化策略"></a> 优化策略</h4><ol><li><p>在JVM的整个GC流程里，Major GC和Full GC都依赖于Minor GC，可以简单的理解为都是由Minor GC触发的，那么我们就增大新生代的容量，让年轻代能放得下更多的对象，然后减少Minor GC的频率，这样的话Full GC的次数自然会被减少了。</p><p>比如上面的代码，我们通过JVM参数<code>-Xmx64m -XX:NewSize=32m</code>来扩充整堆和新生代的大小，运行上述代码，查看GC日志信息：</p><p><img src="/images/image-20200529120119214.png" alt="image-20200529120119214"></p><p>加大了新生代的大小，发现只发生了Minor GC，未触发Full GC，由此可见增加新生代的空间大小是可以减少Full GC</p></li><li><p>减少每次批处理的数量，但是此种情况要根据实际业务来决定</p></li><li><p>加大对象晋升年龄，防止对象过早晋升到老年代，可以通过JVM参数<code>-XX:MaxTenuringThreshold=15</code>来指定晋升年龄，但是新生代的对象晋升老年代并不一定非要等到最大年龄，比如当Survivor区的某个年龄的对象总量超过Survivor大小的一半时，大于等于这个年龄的所有对象都会被晋升到老年代</p></li><li><p>如果以上方案都不可以的话，就只能优化数据结构，减少内存消耗</p></li></ol><p>以上方案的总体目标都是为了让年轻代能够放得下更多的对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提升速率(promotion rate)是用于衡量单位时间内从新生代晋升到来年代的数据量，一般用MB/sec表示单位。JVM会将存活时间较长的对象从新生代提升到老年代，根据分代规则，老年代中不仅有存活时间长的对象，也有存活时间短的对象，这些存活时间短的对象的晋升过程就是过早
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://luxiaowan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM优化之分配速率</title>
    <link href="http://luxiaowan.github.io/2020/05/28/JVM%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E9%85%8D%E9%80%9F%E7%8E%87/"/>
    <id>http://luxiaowan.github.io/2020/05/28/JVM优化之分配速率/</id>
    <published>2020-05-28T15:53:00.000Z</published>
    <updated>2020-05-28T18:48:40.341Z</updated>
    
    <content type="html"><![CDATA[<p>在实际的开发过程中，使用Java语言开发的应用基本上都会遇到性能问题，比如接口超时、服务器负载高、并发数低、数据库性能低或死锁等，并且现在随着互联网的发展，“猛快槽”的开发方式会让代码变得越来越臃肿，随着系统访问量的增加，各种性能问题就随之而来了。</p><p>应用的性能问题非常多，比如磁盘、内存、网络IO、应用代码、数据库、缓存、JVM等，有前辈总结过可以将Java性能优化分为4个层级：</p><ol><li>应用层优化：也就是代码层，主要是代码上的优化，这个主要就要靠代码review和扎实的个人基础价知识了，可以通过Java线程栈定位问题代码</li><li>数据库层优化：优化数据库读写方面的优化，分析SQL、定位死锁、分库分表</li><li>框架层优化：为应用选择合适的框架是最重要的，合适的框架能够带来更优的性能</li><li>JVM层优化：JVM是应用的最底层，属于是最难也是最容易出现性能瓶颈的一层，GC、JVM参数合理使用</li></ol><p>优化难度逐层增加，涉及的知识和解决的问题也不同，我们本文主要讲解一下JVM的年轻代GC方面的优化知识。</p><hr><p>运行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boxing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Double sensorValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sensorValue = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processSensorValue</span><span class="params">(Double value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LockSupport.parkNanos(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iterations = args.length &gt; <span class="number">0</span> ? Integer.parseInt(args[<span class="number">0</span>]) : <span class="number">1_000_000</span>;</span><br><span class="line"></span><br><span class="line">        initSensor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">            processSensorValue(sensorValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread sensorReader = <span class="keyword">new</span> Thread(Boxing::readSensor);</span><br><span class="line"></span><br><span class="line">        sensorReader.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        sensorReader.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM参数设置为<code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xmx32m</code>，运行代码，查看GC情况：</p><p><img src="/images/image-20200529013346025.png" alt="image-20200529013346025"></p><blockquote><p>这里先说一下什么叫分配速率(Allocation Rate)，分配速率是指单位时间内分配的内存量，通常使用<code>MB/sec</code>作为单位，也可以使用<code>PB/year</code>来表示，分配速率过高就会严重影响程序的性能，在JVM中会导致巨大的GC开销</p><p>计算上一次GC之后与下一次GC之前的年轻代使用量，两者差值除以时间，就是分配速率</p></blockquote><p>从上图GC日志中，我们计算一下信息：</p><ul><li>在JVM启动后391ms，共创建8704kb的对象，第一次YGC之后，年轻代中还有1004kb的存活对象</li><li>在JVM启动后459ms，年轻代的使用量再次增加到9708kb，触发第二次YGC，GC之后年轻代的使用量缩减到1004kb</li><li>在JVM启动后471ms，年轻代的使用量为9708kb，GC后为1020kb</li></ul><p>然后我们现在来计算一下这三次GC的分配速率：</p><table><thead><tr><th>Event</th><th>Time</th><th>YGC before</th><th>YGC after</th><th>Allocated During</th><th>Allocation Rate</th></tr></thead><tbody><tr><td>1st YGC</td><td>391ms</td><td>8704kb</td><td>1004kb</td><td>8704kb</td><td>22MB/sec</td></tr><tr><td>2nd YGC</td><td>459ms</td><td>9708kb</td><td>1004kb</td><td>8704kb</td><td>51MB/sec</td></tr><tr><td>3rd YGC</td><td>471ms</td><td>9708kb</td><td>1020kb</td><td>8704kb</td><td>709MB/sec</td></tr><tr><td>Total</td><td>471ms</td><td></td><td></td><td>26112kb</td><td>55MB/sec</td></tr></tbody></table><p>从表中我们看到，该程序的内存分配速率在55MB/sec。</p><hr><h4 id="分配速率的意义"><a class="markdownIt-Anchor" href="#分配速率的意义"></a> 分配速率的意义</h4><p>分配速率的变化会增加或降低STW的频率，从而影响吞吐量，但仅仅只有年轻代的YGC会受分配速率的影响，老年代GC的频率和持续时间不收分配速率的直接影响，而是受到提升速率的影响，也就是Major GC是受Minor GC影响的。</p><p>我们知道年轻代中分为Eden、Survivor from和Survivor to三个区，因为分配速率直接影响Minor GC，所以我们先看下修改Eden的大小是否会减小Minor GC的频率，提升分配速率。</p><p>使用JVM参数<code>-XX:NewSize</code>、<code>-XX:MaxNewSize</code>和<code>-XX:SurvivorRatio</code>设置Eden和Survivor区的大小，我们将Eden区分别设置为100M和500M，看一下GC日志：</p><ul><li><p>Eden区100M</p><p>JVM参数：<code>-XX:NewSize=125m -XX:MaxNewSize=125m -XX:SurvivorRatio=8</code></p><p><img src="/images/image-20200529015605343.png" alt="image-20200529015605343"></p><table><thead><tr><th>Event</th><th>Time</th><th>YGC before</th><th>YGC after</th><th>Allocated During</th><th>Allocation Rate</th></tr></thead><tbody><tr><td>1st YGC</td><td>686ms</td><td>102400kb</td><td>1967kb</td><td>102400kb</td><td>146MB/sec</td></tr><tr><td>2nd YGC</td><td>820ms</td><td>104367kb</td><td>1548kb</td><td>102400kb</td><td>747MB/sec</td></tr><tr><td>3rd YGC</td><td>947ms</td><td>103948kb</td><td>1548kb</td><td>102400kb</td><td>788MB/sec</td></tr><tr><td>Total</td><td>947ms</td><td></td><td></td><td>307200kb</td><td>317MB/sec</td></tr></tbody></table><p>分配速率为317MB/sec</p></li><li><p>Eden区500M</p><p>JVM参数：<code>-XX:NewSize=625m -XX:MaxNewSize=625m -XX:SurvivorRatio=8</code></p><p><img src="/images/image-20200529020327070.png" alt="image-20200529020327070"></p><table><thead><tr><th>Event</th><th>Time</th><th>YGC before</th><th>YGC after</th><th>Allocated During</th><th>Allocation Rate</th></tr></thead><tbody><tr><td>1st YGC</td><td>1126ms</td><td>512000kb</td><td>1967kb</td><td>512000kb</td><td>445MB/sec</td></tr><tr><td>2nd YGC</td><td>1752ms</td><td>513967kb</td><td>1836kb</td><td>512000kb</td><td>799MB/sec</td></tr><tr><td>3rd YGC</td><td>2429ms</td><td>513836kb</td><td>1772kb</td><td>512000kb</td><td>739MB/sec</td></tr><tr><td>Total</td><td>2429ms</td><td></td><td></td><td>1536000kb</td><td>618MB/sec</td></tr></tbody></table><p>分配速率为618MB/sec</p></li></ul><p>随着Eden区大小越来越大，分配速率也越来越大，因为减少了GC频率，就等于减少了任务线程的停顿，就可以做更多的工作，也就创建了更多的对象，所以对于同一个Java应用来说，分配速率越高，性能越高。</p><hr><h4 id="高分配速率对jvm的影响"><a class="markdownIt-Anchor" href="#高分配速率对jvm的影响"></a> 高分配速率对JVM的影响</h4><p>如果创建了过多的朝生夕死的对象，Minor GC的频率就会增加，在并发较大的情况下，会严重的影响吞吐量，从上面的三个场景可以看出来，当年轻代越大时Minor GC的次数就会越来越少，但是分配速率并没有降低，如果每次GC后只有少量的对象存活，Minor GC的暂停时间也不会明显的增加。</p><p>但是有时候增加年轻代的大小并不能彻底的解决问题，我们通过工具jvisualvm查看堆信息</p><p><img src="/images/image-20200529022229415.png" alt="image-20200529022229415"></p><p>大部分堆内存都被Double对象占用了，这个对象是在readSensor()方法中创建的，最简单的代码层面的优化就是将包装类Double换成原生类型，因为原生类型不算是对象，所以也就不会在堆中分配内存，而是之间覆盖一个属性域即可，不会产生GC事件，所以GC基本上完全消除。并且JVM通过逃逸分析技术来避免过度分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boxing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">double</span> sensorValue = Double.NaN;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sensorValue = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processSensorValue</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Double.isNaN(value)) &#123;</span><br><span class="line">            LockSupport.parkNanos(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iterations = args.length &gt; <span class="number">0</span> ? Integer.parseInt(args[<span class="number">0</span>]) : <span class="number">1_000_000</span>;</span><br><span class="line"></span><br><span class="line">        initSensor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iterations;) &#123;</span><br><span class="line">            processSensorValue(sensorValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread sensorReader = <span class="keyword">new</span> Thread(Boxing::readSensor);</span><br><span class="line"></span><br><span class="line">        sensorReader.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        sensorReader.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200529023002189.png" alt="image-20200529023002189"></p><p><img src="/images/image-20200529023022780.png" alt="image-20200529023022780"></p><p>控制台未输出任何GC日志，而jvisualvm上监控到的堆使用情况也极低，由此可见在代码中可以在适当情况下使用原生类型代替包装类。</p><hr><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>在年轻代使用上，应当适当的提高分配速率，减少Minor GC的频率，可以通过两种方式实现</p><ol><li>增大新生代大小</li><li>使用原生类型代替包装类，减少堆内对象的创建</li></ol><p>简单点说就是少创建对象、多分配空间，以减少GC次数，加大系统吞吐量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实际的开发过程中，使用Java语言开发的应用基本上都会遇到性能问题，比如接口超时、服务器负载高、并发数低、数据库性能低或死锁等，并且现在随着互联网的发展，“猛快槽”的开发方式会让代码变得越来越臃肿，随着系统访问量的增加，各种性能问题就随之而来了。&lt;/p&gt;
&lt;p&gt;应用的性能
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://luxiaowan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线程池中运行的线程，当等待队列未满的情况下，一定不大于核心线程数吗</title>
    <link href="http://luxiaowan.github.io/2020/05/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BD%93%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E6%9C%AA%E6%BB%A1%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%B8%80%E5%AE%9A%E4%B8%8D%E5%A4%A7%E4%BA%8E%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%90%97/"/>
    <id>http://luxiaowan.github.io/2020/05/28/线程池中运行的线程，当等待队列未满的情况下，一定不大于核心线程数吗/</id>
    <published>2020-05-28T03:17:00.000Z</published>
    <updated>2020-05-28T09:38:56.730Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="https://luxiaowan.github.io/2020/05/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E/">《线程池内运行的线程抛异常，线程池会怎么办》</a>了解到当线程执行的任务出现异常时，会将当前线程移出线程池，并新增一个线程到线程池中，我们先来回顾一下线程池的运行原理：</p><img src="/images/tpe-process.png" alt="tpe-process" style="zoom:50%;"><p>从原理图中可以看到只有当队列满了之后，才会去创建新的线程执行新加入的任务，那么到底有没有可能出现队列未满， 但是运行中的线程个数大于核心线程数？</p><p>理论上应该是不可能大于核心线程数，那么有没有意外呢？答案暂时不揭晓，我们先往下看，写几个demo测试一下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span> + (<span class="number">10</span> / finalI));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>​第一列为线程hashcode，第二列为阻塞队列中的任务个数，第三列为计算数字</p></blockquote><img src="/images/image-20200528132623899.png" alt="image-20200528132623899" style="zoom:50%;"><p>从控制台的输出能看到一共出现了4个不同的hashcode，也就表示创建过4个线程，然后线程1869318657执行任务时出现了异常，也就是除0异常，然后将其从线程池中移出，后续不再进行任务处理。从之前的文章中我们知道将异常的线程移除之后会重新创建一个线程加入到线程池中，那么正常情况下，线程池移除一个再加入一个，数量应该不变，但是从下面的输出看到这时同时有3个线程在处理任务，但是我们的核心线程数是2，为什么会出现3？</p><p>我们再来看下任务发生异常时的后续处理代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从runWorker方法中传过来的是true，所以这句目前版本中必定会被执行到</span></span><br><span class="line">  <span class="comment">// 作用是将当前线程池中的有效线程数-1，意思也就是出现异常的线程会被从线程池中拿掉</span></span><br><span class="line">  <span class="comment">// 为什么说是出现异常的线程会被拿掉呢？因为在try内部是一个while循环，除非关闭核心线程或运行中线程出现异常，否则不会执行到这里</span></span><br><span class="line">  <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">    decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 更新完成的任务数，只要是被线程池线程执行过的，不管是否出现异常，都被认为是执行成功的任务</span></span><br><span class="line">    completedTaskCount += w.completedTasks;</span><br><span class="line">    <span class="comment">// 将当前Worker线程从线程池中移除销毁</span></span><br><span class="line">    workers.remove(w);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryTerminate();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一系列判断，主要是判断是否符合给线程池创建新的线程</span></span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">      <span class="comment">// 如果核心线程允许超时回收，则不去创建线程，因为有新任务来的时候会自动创建</span></span><br><span class="line">      <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">      <span class="comment">// 如果核心线程可以被回收，但是当前阻塞队列中不为空时，创建1个线程去执行任务</span></span><br><span class="line">      <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 校验当前运行的线程是否大于允许运行的线程数，比如核心线程数</span></span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ①...</span></span><br><span class="line">    <span class="comment">// 给线程池创建新的线程</span></span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在创建新线程时，会进行一系列判断，若判断全部通过，就会去给线程池的池子中创建一个新的工作线程，这里传入的core参数是false，也就是当成非核心线程来创建，难道问题出在这里？如果我此时运行的线程数小于等于核心线程数，那么再加进来一个非核心线程？我们来看看addWorker()方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// goto语法</span></span><br><span class="line">  retry:</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">        ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">           firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           ! workQueue.isEmpty()))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">      <span class="comment">// 判断当前运行的线程个数是否超过了最大线程数</span></span><br><span class="line">      <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">          wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">break</span> retry;</span><br><span class="line">      c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">      <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">        <span class="keyword">continue</span> retry;</span><br><span class="line">      <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...创建线程...</span></span><br><span class="line">  <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法addWorker()的源码中我们看到，当我们参数core传一个false进来时，会去校验当前工作中的线程个数是否超过了最大线程数，如果没有超过的话则创建新的线程，问题就出在这里，为什么？</p><p>在方法processWorkerExit()中，我们对核心线程数进行的比较，但是如果在①处有新的任务调用execute()进来，则发现工作线程未达到核心线程数，这个时候就会去创建一个核心线程，创建之后，线程池中的工作线程就有2个了，然后我们从processWorkerExit()中传过来的请求会去校验工作线程个数是否超过了最大线程数，在我们的demo代码中是肯定不会超过的，那么就又会去创建一个线程放到线程池中，这样线程池中的工作线程就有3个了，具体流程图如下</p><table><thead><tr><th>正常流程</th><th>异常流程</th><th>工作线程数</th></tr></thead><tbody><tr><td>execute()</td><td></td><td>0</td></tr><tr><td>—addWorker()</td><td></td><td>1</td></tr><tr><td>execute()</td><td></td><td>1</td></tr><tr><td>—addWorker()</td><td></td><td>2</td></tr><tr><td></td><td>processWorkerExit()</td><td>2</td></tr><tr><td></td><td>—remove()</td><td>1</td></tr><tr><td>execute()</td><td></td><td>1</td></tr><tr><td>—addWorker()</td><td></td><td>2</td></tr><tr><td></td><td>—addWorker()</td><td>3</td></tr></tbody></table><blockquote><p>这就是为什么我们核心线程数是2，但是最终运行中的线程个数是3的原因</p></blockquote><hr><h4 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 🌰场景</h4><ol><li><p>任务尚未全部进入到队列中，队列未满</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span> + (<span class="number">10</span> / finalI));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/image-20200528132623899.png" alt="image-20200528132623899" style="zoom:50%;"><p>这个也就是我们上面跑的demo，工作线程个数超出了核心线程数。</p></li><li><p>任务已经全部进入到队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (finalI &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 前两个线程等待500毫秒，保证所有的任务都进入到队列中</span></span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(</span><br><span class="line">        Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span> + (<span class="number">10</span> / (finalI - <span class="number">4</span>)));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/image-20200528170037838.png" alt="image-20200528170037838" style="zoom:50%;"><p>我们看到当线程池开始执行任务时，已经把剩余的28个任务都放到队列中了，红色和蓝色下划线的线程是初始线程，当873出现异常后，将其移出线程池，然后创建一个新的线程执行队列中的剩余任务，因为这时所有的任务都在队列中等待被执行，execute()方法不会被调用，所以这种场景下，工作中的线程个数不会超过核心线程数。</p></li><li><p>任务尚未全部进入到队列中，队列已满，未达到最大线程数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">34</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (finalI &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 等待任务全部进入到队列中，且创建完额外线程接收多出来的两个任务</span></span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span></span><br><span class="line">                         + pool.getActiveCount() + <span class="string">", "</span> + (<span class="number">10</span> / (finalI - <span class="number">33</span>)));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>​第一列为线程hashcode，第二列为阻塞队列中的任务个数，第三列为当前的工作线程个数，第四列为计算数字</p></blockquote><img src="/images/image-20200528173106691.png" alt="image-20200528173106691" style="zoom:67%;"><p>从结果中我们看到创建了4个工作线程去执行任务，当线程230执行异常之后，创建了线程734继续执行，线程个数未超过最大线程数</p></li><li><p>任务尚未全部进入到队列中，队列已满，达到最大线程数</p><p>这种情况就会依据拒绝策略执行相关的代码逻辑，线程数不会超过最大线程数</p></li></ol><hr><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>从以上分析我们可以得出，只有在：任务尚未全部进入到队列中且队列未满的情况下，才会出现工作线程个数大于核心线程数，所以我们在使用线程池的过程中，待执行的任务尽量捕获所有的异常情况，不要将其抛出到线程池中的线程里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过&lt;a href=&quot;https://luxiaowan.github.io/2020/05/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>线程池内运行的线程抛异常，线程池会怎么办</title>
    <link href="http://luxiaowan.github.io/2020/05/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://luxiaowan.github.io/2020/05/27/线程池内运行的线程抛异常，线程池会怎么办/</id>
    <published>2020-05-27T04:56:00.000Z</published>
    <updated>2020-05-28T09:38:46.197Z</updated>
    
    <content type="html"><![CDATA[<p>通过文章<a href="https://luxiaowan.github.io/2020/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%AD%E7%AD%89%E5%BE%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%90%97/">《线程池运行的线程和队列中等待的线程是同一个吗》</a>我们了解到线程池中实际运行的是线程池自身的线程，只是在runWorker方法中调用了我们传递进入Runnable对象的run()方法，那么如果run()方法中出现异常了，那么要怎么处理？会不会将我们的线程池停掉？</p><p>我们先来看下runWorker()方法的具体逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  Thread wt = Thread.currentThread();</span><br><span class="line">  Runnable task = w.firstTask;</span><br><span class="line">  w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">  <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">           (Thread.interrupted() &amp;&amp;</span><br><span class="line">            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">          !wt.isInterrupted())</span><br><span class="line">        wt.interrupt();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        beforeExecute(wt, task);</span><br><span class="line">        Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterExecute(task, thrown);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task = <span class="keyword">null</span>;</span><br><span class="line">        w.completedTasks++;</span><br><span class="line">        w.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中我们看到，在调用用户Runnable实例方法run()的时候，进行了try…catch…finally，但是在catch()中是直接将异常抛出了，也就是说并未在while循环内消化掉，而是抛出给外层，这时会将while循环终止掉，然后在外层的try…finally中并未捕获内部传出的异常，所以异常信息会继续往上抛出，我们来关注一下这两层try的finally代码块，内部的finally中执行了一个空的方法afterExecute()，这个方法是留给我们自定义线程池时使用的，和beforeExecute()方法一样，既然是空方法，那我们就先不用去看它了，来看下外层的finally代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从runWorker方法中传过来的是true，所以这句目前版本中必定会被执行到</span></span><br><span class="line">  <span class="comment">// 作用是将当前线程池中的有效线程数-1，意思也就是出现异常的线程会被从线程池中拿掉</span></span><br><span class="line">  <span class="comment">// 为什么说是出现异常的线程会被拿掉呢？因为在try内部是一个while循环，除非关闭核心线程或运行中线程出现异常，否则不会执行到这里</span></span><br><span class="line">  <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">    decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 更新完成的任务数，只要是被线程池线程执行过的，不管是否出现异常，都被认为是执行成功的任务</span></span><br><span class="line">    completedTaskCount += w.completedTasks;</span><br><span class="line">    <span class="comment">// 将当前Worker线程从线程池中移除销毁</span></span><br><span class="line">    workers.remove(w);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryTerminate();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一系列判断，主要是判断是否符合给线程池创建新的线程</span></span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">      <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">      <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给线程池创建新的线程，core之所以传递false，是因为这里要防止创建失败</span></span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们看到在处理任务的过程中，如果线程出现异常，则会将该线程从线程池中移除销毁，然后再新创建一个线程加入到线程池中，也就是说在任务发生异常的时候，会终结掉运行它的线程。</p><blockquote><p>我们从源码中得到的信息，现在来验证一下我们的分析</p></blockquote><p>验证代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="number">10</span> / finalI - <span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><img src="/images/image-20200527152919795.png" alt="image-20200527152919795" style="zoom:70%;"><p>抛异常了，但是并未影响线程池中的其他任务，我们打断点在processWorkerExit()方法中，看下workers变量的数据</p><ul><li><p>异常发生之前</p><p><img src="/images/image-20200527154429404.png" alt="image-20200527154429404"></p></li><li><p>异常发生之后</p><p><img src="/images/image-20200527154504520.png" alt="image-20200527154504520"></p></li></ul><p>看到在异常前后，线程<code>1f36e637</code>被移除了，转而创建了一个<code>7073cb62</code>放到了线程池中，而未发生异常的线程<code>578486a3</code>依然存在于线程池中。</p><hr><blockquote><p>小结</p></blockquote><p>通过示例我们验证了一点：当任务出现未被捕获到的异常时，会将执行该任务的线程池中的线程从线程池移除并结束掉，然后移除之后创建一个新的线程放回到线程池中。</p><hr><p>上面我们知道了当线程执行的任务发生未被捕获的异常时，会将异常一直往上抛出，那么我们能否在主线程中捕获它进行处理呢？我们来试下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="number">10</span> / finalI - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      pool.execute(t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"发生了异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/images/image-20200527165519282.png" alt="image-20200527165519282"></p><p>由运行结果可以看出我们并未捕获到线程池中线程抛出的异常，也就是异常并未被抛出到主线程中，这就尴尬了，毕竟这些异常是和业务相关联的，我们却无法捕获和处理，这咋整呢？</p><p>忽的一下，想到了线程池的比较重要的一个参数：ThreadFactory接口，这个接口的作用是按需创建新线程的，使用线程工厂消除了对Thread#Thread(Runnable) new Thread的强依赖，使应用程序能够使用特殊的Thread子类、优先级等。大白话就是让线程池中的线程使用我们自定义的线程，这个自定义可不是我们通过execute()或submit()传进来的自定义线程，而是Worker类中的thread变量，也就是实际运行的线程，我们看一下Worker类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">  setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">  <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">  <span class="comment">// 调用ThreadFactory的newThread方法创建线程</span></span><br><span class="line">  <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中调用线程工厂的newThread()方法创建运行线程，我们上面通过ThreadPoolExecutor的构造方法创建线程池时并未传入ThreadFactory参数，那么就会使用默认的<code>Executors.defaultThreadFactory()</code>来创建线程，它的实现逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">    t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">    t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们要是想自定义Worker#thread的值的话，就自定义一个ThreadFactory实现类即可，比如我们可以把线程池创建语句升级为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(<span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="number">10</span> / finalI - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用lambda表达式来创建，使用Thread#setUncaughtExceptionHandler()方法来获取线程内未被捕获的异常，我们运行一下看看结果：</p><p><img src="/images/image-20200527175844897.png" alt="image-20200527175844897"></p><p>成功捕获了线程内部出现的异常。</p><hr><p>那么现在就又有一个问题了：如果我们主动捕获并处理线程内抛出的异常，那么这个线程还会从线程池中移除销毁吗？</p><p>我们来试下，还是使用上面的那段代码，然后断点打在processWorkerExit()方法中，看下执行结果</p><ul><li><p>异常之前</p><p><img src="/images/image-20200527180523846.png" alt="image-20200527180523846"></p></li><li><p>异常之后</p><p><img src="/images/image-20200527180634454.png" alt="image-20200527180634454"></p></li></ul><p>从执行结果来看，发生异常的线程是<code>35d176f7</code>，在异常发生之后同样从线程池中被移除了。</p><hr><blockquote><p>总结</p></blockquote><p>当线程池中线程执行任务的时候，任务出现未被捕获的异常的情况下，线程池会将允许该任务的线程从池中移除并销毁，且同时会创建一个新的线程加入到线程池中；可以通过ThreadFactory自定义线程并捕获线程内抛出的异常，也就是说甭管我们是否去捕获和处理线程池中工作线程抛出的异常，这个线程都会从线程池中被移除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过文章&lt;a href=&quot;https://luxiaowan.github.io/2020/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx配置RabbitMQ页面bug</title>
    <link href="http://luxiaowan.github.io/2020/05/26/Nginx%E9%85%8D%E7%BD%AERabbitMQ%E9%A1%B5%E9%9D%A2bug/"/>
    <id>http://luxiaowan.github.io/2020/05/26/Nginx配置RabbitMQ页面bug/</id>
    <published>2020-05-25T19:10:00.000Z</published>
    <updated>2020-05-25T19:15:24.686Z</updated>
    
    <content type="html"><![CDATA[<p>当使用Nginx来配置RabbitMQ的Web页面时，查看Exchange、Queue和Channels时，遇到了<code>the object you clicked on was not found it may have been deleted on the server.</code>，百思不得其解，整个代理都没有问题，配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  rabbitmq.xxx.com;</span><br><span class="line">    client_max_body_size   5m;</span><br><span class="line">    access_log acces.log;</span><br><span class="line">    error_log error.log;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        client_max_body_size   20m;</span><br><span class="line">        proxy_pass http://ip:port/;</span><br><span class="line"></span><br><span class="line">        port_in_redirect on;</span><br><span class="line">proxy_redirect  off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好像没问题，页面也可以正常访问，唯独查看不了消息的详细信息</p><h3 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h3><hr><p>最终瞎捣鼓，发现还是配置的问题，把proxy_pass修改为<code>proxy_pass http://ip:port</code>，把最后的<code>/</code>去掉即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当使用Nginx来配置RabbitMQ的Web页面时，查看Exchange、Queue和Channels时，遇到了&lt;code&gt;the object you clicked on was not found it may have been deleted on the se
      
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://luxiaowan.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Bug" scheme="http://luxiaowan.github.io/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器无法停止和删除</title>
    <link href="http://luxiaowan.github.io/2020/05/26/Docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E5%81%9C%E6%AD%A2%E5%92%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://luxiaowan.github.io/2020/05/26/Docker容器无法停止和删除/</id>
    <published>2020-05-25T17:38:00.000Z</published>
    <updated>2020-05-25T17:41:50.885Z</updated>
    
    <content type="html"><![CDATA[<p>1.停止容器</p><p>docker stop xxx-name</p><p>2.强制移除此容器</p><p>docker rm -f xxx-name</p><blockquote><p>如果出现Device or resource busy，则通过ps -ef | grep port查找容器进程pid，然后使用kill -9 pid停止进程</p></blockquote><p>3.清理此容器的网络占用</p><p>格式：docker network disconnect --force 网络模式 容器名称</p><p>示例：docker network disconnect --force bridge xxx-name</p><p>4.简查是否还有同名容器占用</p><p>格式：docker network inspect 网络模式<br>示例：docker network inspect bridge</p><p>5.重新构建容器</p><p>docker run xxx</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.停止容器&lt;/p&gt;
&lt;p&gt;docker stop xxx-name&lt;/p&gt;
&lt;p&gt;2.强制移除此容器&lt;/p&gt;
&lt;p&gt;docker rm -f xxx-name&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果出现Device or resource busy，则通过ps -e
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://luxiaowan.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Jenkins中创建项目时没有Maven项目</title>
    <link href="http://luxiaowan.github.io/2020/05/26/Jenkins%E4%B8%AD%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%B2%A1%E6%9C%89Maven%E9%A1%B9%E7%9B%AE/"/>
    <id>http://luxiaowan.github.io/2020/05/26/Jenkins中创建项目时没有Maven项目/</id>
    <published>2020-05-25T17:36:00.000Z</published>
    <updated>2020-05-25T17:38:10.178Z</updated>
    
    <content type="html"><![CDATA[<p>如果在创建项目时候，没有“创建一个Maven 项目”的选项，则需要安装Maven项目插件：Maven Integration plugin</p><p><img src="/images/image-20200526013750453.png" alt="image-20200526013750453"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果在创建项目时候，没有“创建一个Maven 项目”的选项，则需要安装Maven项目插件：Maven Integration plugin&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/image-20200526013750453.png&quot; alt=&quot;image-20
      
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://luxiaowan.github.io/categories/Jenkins/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker容器中安装vim</title>
    <link href="http://luxiaowan.github.io/2020/05/26/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AE%89%E8%A3%85vim/"/>
    <id>http://luxiaowan.github.io/2020/05/26/docker容器中安装vim/</id>
    <published>2020-05-25T17:35:00.000Z</published>
    <updated>2020-05-25T17:35:56.177Z</updated>
    
    <content type="html"><![CDATA[<p>在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: command not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package vim</span><br></pre></td></tr></table></figure><p>这时候需要敲：apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。</p><p>等更新完毕以后再敲命令：apt-get install vim命令即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: command not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：&lt;/p&gt;
&lt;figure class=&quot;highlight she
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://luxiaowan.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Jekins忘记admin密码</title>
    <link href="http://luxiaowan.github.io/2020/05/25/Jekins%E5%BF%98%E8%AE%B0admin%E5%AF%86%E7%A0%81/"/>
    <id>http://luxiaowan.github.io/2020/05/25/Jekins忘记admin密码/</id>
    <published>2020-05-25T15:59:00.000Z</published>
    <updated>2020-05-25T16:08:15.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-未修改admin的密码"><a class="markdownIt-Anchor" href="#一-未修改admin的密码"></a> 一、未修改admin的密码</h3><p>若未修改过admin的密码，那么我们可以通过查看<code>/var/jenkins_home/secrets/initialAdminPassword</code>文件来获取admin的初始密码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat <span class="regexp">/var/</span>jenkins_home<span class="regexp">/secrets/i</span>nitialAdminPassword</span><br></pre></td></tr></table></figure><h3 id="二-修改过admin的密码"><a class="markdownIt-Anchor" href="#二-修改过admin的密码"></a> 二、修改过admin的密码</h3><p>如果修改过admin的密码，那么就不能使用初始密码来解决了，可以通过以下步骤：</p><ol><li><p>删除Jenkins目录下config.xml文件中下面代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">useSecurity</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useSecurity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">authorizationStrategy</span> <span class="attr">class</span>=<span class="string">"hudson.security.FullControlOnceLoggedInAuthorizationStrategy"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">denyAnonymousReadAccess</span>&gt;</span>true<span class="tag">&lt;/<span class="name">denyAnonymousReadAccess</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizationStrategy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">securityRealm</span> <span class="attr">class</span>=<span class="string">"hudson.security.HudsonPrivateSecurityRealm"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">disableSignup</span>&gt;</span>true<span class="tag">&lt;/<span class="name">disableSignup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">enableCaptcha</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enableCaptcha</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">securityRealm</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>重启Jenkins</p></li><li><p>重新进入Jenkins，然后进入到<code>系统管理</code>-&gt;<code>全局安全配置(configure global security)</code></p><img src="/images/image-20200526000447792.png" alt="image-20200526000447792" style="zoom:50%;"></li><li><p>勾选<code>Jenkins专有用户数据库</code></p><img src="/images/image-20200526000537282.png" alt="image-20200526000537282" style="zoom:50%;"></li><li><p>回到<code>系统管理</code>页面，选择<code>管理用户</code></p><img src="/images/image-20200526000628607.png" alt="image-20200526000628607" style="zoom: 50%;"></li><li><p>选择用户设置</p><img src="/images/image-20200526000726021.png" alt="image-20200526000726021" style="zoom:50%;"></li><li><p>重置密码</p><img src="/images/image-20200526000747350.png" alt="image-20200526000747350" style="zoom:50%;"></li><li><p>重启Jenkins服务</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-未修改admin的密码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-未修改admin的密码&quot;&gt;&lt;/a&gt; 一、未修改admin的密码&lt;/h3&gt;
&lt;p&gt;若未修改过admin的密码，那么我们可以通过查看&lt;code&gt;/var/jenk
      
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://luxiaowan.github.io/categories/Jenkins/"/>
    
    
  </entry>
  
  <entry>
    <title>反序列化报错：Cannot Deserialize From Object Value (No Delegate- or Property-Based Creator)</title>
    <link href="http://luxiaowan.github.io/2020/05/22/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%A5%E9%94%99%EF%BC%9Acannot-deserialize-from-Object-value-(no-delegate--or-property-based-Creator)/"/>
    <id>http://luxiaowan.github.io/2020/05/22/反序列化报错：cannot-deserialize-from-Object-value-(no-delegate--or-property-based-Creator)/</id>
    <published>2020-05-22T15:50:00.000Z</published>
    <updated>2020-05-28T18:51:33.418Z</updated>
    
    <content type="html"><![CDATA[<p>反序列化报错：cannot deserialize from Object value (no delegate- or property-based Creator)</p><p>这个原因最根本的是没有找到无参构造方法，解决办法是给类加一个无参构造方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反序列化报错：cannot deserialize from Object value (no delegate- or property-based Creator)&lt;/p&gt;
&lt;p&gt;这个原因最根本的是没有找到无参构造方法，解决办法是给类加一个无参构造方法&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="BUG" scheme="http://luxiaowan.github.io/categories/BUG/"/>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Cannot Determine Value Type From String &#39;Xxxxxx&#39;</title>
    <link href="http://luxiaowan.github.io/2020/05/21/Cannot-determine-value-type-from-string-xxxxxx/"/>
    <id>http://luxiaowan.github.io/2020/05/21/Cannot-determine-value-type-from-string-xxxxxx/</id>
    <published>2020-05-21T11:40:00.000Z</published>
    <updated>2020-05-21T12:11:07.814Z</updated>
    
    <content type="html"><![CDATA[<p>在使用MyBatis的时候，若实体类上使用了lombok的@Builder注解，那么在查询数据做映射的时候会出现<code>Cannot determine value type from string 'xxxxxx'</code>错误，产生这个错误的原因是当使用了@Builder注解之后会默认把无参构造方法忽略掉，创建一个全参的构造方法，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long   id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被编译之后再反编译，变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    DemoBean(Long id, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DemoBean.<span class="function">DemoBeanBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoBean.DemoBeanBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...忽略setter、getter方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBeanBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        DemoBeanBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DemoBean.<span class="function">DemoBeanBuilder <span class="title">id</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DemoBean.<span class="function">DemoBeanBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DemoBean <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DemoBean(<span class="keyword">this</span>.id, <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DemoBean.DemoBeanBuilder(id="</span> + <span class="keyword">this</span>.id + <span class="string">", name="</span> + <span class="keyword">this</span>.name + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看到是没有默认构造方法，而MyBatis进行映射的时候会需要无参构造方法实例化一个类，所以我们再使用@Builder的时候，即使使用@NoArgsConstructor注解也无济于事，那我们该怎么办？</p><hr><p>在lombok中有一个@Tolerate注解，我们看下它的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Put on any method or constructor to make lombok pretend it doesn't exist,</span></span><br><span class="line"><span class="comment"> * i.e., to generate a method which would otherwise be skipped due to possible conflicts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Tolerate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释上的意思就是让lombok在扫描的时候假装被@Tolerate修饰的方法不存在，也就是会原封不动的被编译到字节码中，不会覆盖它，那么这样的话我们就可以进行骚操作了，修改原代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long   id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Tolerate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用MyBatis的时候，若实体类上使用了lombok的@Builder注解，那么在查询数据做映射的时候会出现&lt;code&gt;Cannot determine value type from string &#39;xxxxxx&#39;&lt;/code&gt;错误，产生这个错误的原因是当使用了@Bu
      
    
    </summary>
    
    
      <category term="BUG" scheme="http://luxiaowan.github.io/categories/BUG/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringCloud启动报错，提示The Following Method Did Not exist:CompositeHealthIndicator</title>
    <link href="http://luxiaowan.github.io/2020/05/21/SpringCloud%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%8C%E6%8F%90%E7%A4%BAThe-following-method-did-not-existCompositeHealthIndicator/"/>
    <id>http://luxiaowan.github.io/2020/05/21/SpringCloud启动报错，提示The-following-method-did-not-existCompositeHealthIndicator/</id>
    <published>2020-05-21T04:02:00.000Z</published>
    <updated>2020-05-21T15:26:49.989Z</updated>
    
    <content type="html"><![CDATA[<p>今天升级SpringBoot的版本，然后启动的时候懵逼了，报了个错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> Error starting Tomcat context. Exception: org.springframework.beans.factory.BeanCreationException. Message: Error creating bean with name 'servletEndpointRegistrar' defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web</span><br><span class="line"> </span><br><span class="line"> The web application [ROOT] appears to have started a thread named [spring.cloud.inetutils] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with <span class="string">'debug'</span> enabled.</span><br><span class="line"></span><br><span class="line">**An attempt was made to call a method that does not exist. The attempt was made from the following location:</span><br><span class="line"></span><br><span class="line">    org.springframework.cloud.client.discovery.health.DiscoveryCompositeHealthIndicator.&lt;init&gt;(DiscoveryCompositeHealthIndicator.java:<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">The following method did not exist:</span><br><span class="line"></span><br><span class="line">    org.springframework.boot.actuate.health.CompositeHealthIndicator.&lt;init&gt;(Lorg/springframework/boot/actuate/health/HealthAggregator;)V**</span><br></pre></td></tr></table></figure><p>翻了一下资料后，发现是SpringBoot和SpringCloud的版本不匹配，修改成一致的就行了</p><table><thead><tr><th style="text-align:left">Release Train</th><th style="text-align:left">Boot Version</th></tr></thead><tbody><tr><td style="text-align:left">Hoxton</td><td style="text-align:left">2.2.x</td></tr><tr><td style="text-align:left">Greenwich</td><td style="text-align:left">2.1.x</td></tr><tr><td style="text-align:left">Finchley</td><td style="text-align:left">2.0.x</td></tr><tr><td style="text-align:left">Edgware</td><td style="text-align:left">1.5.x</td></tr><tr><td style="text-align:left">Dalston</td><td style="text-align:left">1.5.x</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天升级SpringBoot的版本，然后启动的时候懵逼了，报了个错：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL自增主键用完了咋整？</title>
    <link href="http://luxiaowan.github.io/2020/05/19/MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%94%A8%E5%AE%8C%E4%BA%86%E5%92%8B%E6%95%B4/"/>
    <id>http://luxiaowan.github.io/2020/05/19/MySQL自增主键用完了咋整/</id>
    <published>2020-05-18T16:15:00.000Z</published>
    <updated>2020-05-18T16:31:42.594Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL自增主键会用完吗？我们先来看下在MySQL中，int和bigint两种类型的值域是多少，</p><table><thead><tr><th>类型</th><th>最小值</th><th>最大值</th><th>所占字节</th></tr></thead><tbody><tr><td>int(有符号)</td><td>-2^31</td><td>2^31</td><td>4</td></tr><tr><td>int(无符号)</td><td>0</td><td>2^32</td><td>4</td></tr><tr><td>bigint(有符号)</td><td>-2^63</td><td>2^63</td><td>8</td></tr><tr><td>bigint(无符号)</td><td>0</td><td>2^64</td><td>8</td></tr></tbody></table><p>当我们使用int(有符号)类型的时候，创建一张表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table test_ai (</span><br><span class="line">id int(10) auto_increment primary key,</span><br><span class="line">name varchar(11) not null</span><br><span class="line">) engine=InnoDB;</span><br></pre></td></tr></table></figure><p>执行两条SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert test_ai(id, name) values(2147483646, &apos;cc1&apos;);</span><br><span class="line">insert test_ai(name) values(&apos;cc2&apos;);</span><br><span class="line">insert test_ai(name) values(&apos;cc3&apos;);</span><br></pre></td></tr></table></figure><p>当执行到第三句SQL的时候就会报错<code>Duplicate entry '2147483647' for key 'PRIMARY'</code>，也就是说当我们的自增主键用完之后，就无法继续往表中新增数据了</p><h4 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h4><hr><p>我们在正常情况下，不会让单表存储那么大的数据量，所以一般不会出现这个问题，如果真的脑抽抽的在一张表中存储那么多数据，或者当数据迁移的时候造成了自增主键混乱，那么我们可以使用bigint(无符号)类型作为自增主键。</p><p>使用bigint(无符号)类型时，如果我们每秒插入1W条数据，不间断的跑100年，单表的数据量为：10000 * 3600 * 24 * 365 * 100 = 31536000000000，还远远小于2^64，完全不会被用完，如果操作正确的话。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL自增主键会用完吗？我们先来看下在MySQL中，int和bigint两种类型的值域是多少，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;最小值&lt;/th&gt;
&lt;th&gt;最大值&lt;/th&gt;
&lt;th&gt;所占字节&lt;/th&gt;
&lt;/tr&gt;
&lt;/th
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot内置Tomcat启动时间</title>
    <link href="http://luxiaowan.github.io/2020/05/15/SpringBoot%E5%86%85%E7%BD%AETomcat%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    <id>http://luxiaowan.github.io/2020/05/15/SpringBoot内置Tomcat启动时间/</id>
    <published>2020-05-15T10:22:00.000Z</published>
    <updated>2020-05-15T17:58:50.202Z</updated>
    
    <content type="html"><![CDATA[<h4 id="疑惑"><a class="markdownIt-Anchor" href="#疑惑"></a> 疑惑</h4><p>SpringBoot中内置了Tomcat容器，那么Tomcat是在什么时间点启动的？是先扫描包加载类再启动Tomcat？，还是先启动Tomcat再扫描包加载类？</p><p>我们做一下假设：</p><ol><li>先启动Tomcat，再扫描包加载类</li><li>先扫描包加载类，再启动Tomcat</li></ol><p>接下来我们做一下验证。</p><h4 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h4><p>首先创建一个空的SpringBoot工程，然后启动它，查看一下控制台的输出日志：</p><img src="/images/image-20200515183550832.png" alt="image-20200515183550832" style="zoom:50%;"><p>从输出的日志中可以看到②中显示Tomcat进行初始化，并且正在启动中，然后③中进行初始化<code>WebApplicationContext</code>，紧接着就是初始化<code>WebApplicationContext</code>完成，然后是在④中报告我们Tomcat启动完成。</p><p>从日志上看，好像是先启动Tomcat再去扫描包的，具体是怎么回事，我们看一下源码，暂时先不揭晓。</p><ul><li><p>从启动类中进入到<code>SpringApplication.run()</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建启动监控类，监控启动过程用了多久，但是ms</span></span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  <span class="comment">// 开始计时，设置开始时间</span></span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="comment">// 上下文实例</span></span><br><span class="line">  ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 启动异常错误报告</span></span><br><span class="line">  Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 启用headless模式（headless模式是在系统缺少部分硬件支持的时候让服务自力更生）</span></span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line">  <span class="comment">// 获取spring.factories文件中配置的org.springframework.boot.SpringApplicationRunListener列表，原理是Spring的事件机制，所有的类都实现自ApplicationEvent，可以监听启动过程中的任意阶段</span></span><br><span class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">  <span class="comment">// 进入监听启动阶段</span></span><br><span class="line">  listeners.starting();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取JVM运行参数，也就是在使用java -jar xxx.jar命令启动时指定的其他参数</span></span><br><span class="line">    ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">    <span class="comment">// 准备运行环境，传入监听器和运行参数，获取环境变量，绑定到环境中</span></span><br><span class="line">    ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">    <span class="comment">// 配置spring.beaninfo.ignore属性，SpringBoot中默认为true</span></span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line">    <span class="comment">// 输出Banner信息，banner的输出方式有三种：none/console/log，默认为console，通过配置参数spring.main.banner-mode指定</span></span><br><span class="line">    Banner printedBanner = printBanner(environment);</span><br><span class="line">    <span class="comment">// ☆创建一个上下文实例，比较重点的地方☆</span></span><br><span class="line">    context = createApplicationContext();</span><br><span class="line">    <span class="comment">// 获取spring.factories文件中声明的SpringBootExceptionReporter</span></span><br><span class="line">    exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                                                     <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">    <span class="comment">// 创建上下文，设置环境变量和资源加载器，创建bean，加载到所有的listener中</span></span><br><span class="line">    prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">    <span class="comment">// 调用spring的refresh方法，并注册一个ShutdownHook（应用关闭时的动作，可以通过继承AbstractApplicationContext实现自定义）</span></span><br><span class="line">    refreshContext(context);</span><br><span class="line">    <span class="comment">// 空方法</span></span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line">    <span class="comment">// 启动完成，停止计时</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">      <span class="comment">// 输出启动信息，包括计时</span></span><br><span class="line">      <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入监听器的启动完成事件</span></span><br><span class="line">    listeners.started(context);</span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 进入监听器的运行中事件</span></span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中并未看到是在哪里启动了Tomcat容器，那么我们就看一下创建Spring上下文的方法中是否有关键字</p></li><li><p>createApplicationContext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">  <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">        <span class="keyword">case</span> SERVLET:</span><br><span class="line">          <span class="comment">// org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REACTIVE:</span><br><span class="line">          <span class="comment">// org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// org.springframework.context.annotation.AnnotationConfigApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个创建<code>ApplicationContext</code>实例的方法，我们只看Tomcat的<code>AnnotationConfigServletWebServerApplicationContext</code>，他的继承关系如下</p><p><img src="/images/AnnotationConfigServletWebServerApplicationContext.png" alt="AnnotationConfigServletWebServerApplicationContext"></p><p>以上类中并没有在静态代码块中启动Tomcat，则说明不是在这里启动的，这里只是创建一个<code>ApplicationContext</code>上下文实例</p></li><li><p>prepareContext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置环境变量</span></span><br><span class="line">  context.setEnvironment(environment);</span><br><span class="line">  <span class="comment">// 处理上下文</span></span><br><span class="line">  postProcessApplicationContext(context);</span><br><span class="line">  <span class="comment">// 做refresh前的初始化准备</span></span><br><span class="line">  applyInitializers(context);</span><br><span class="line">  <span class="comment">// 进入到监听器的上下文准备阶段</span></span><br><span class="line">  listeners.contextPrepared(context);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">    logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">    logStartupProfileInfo(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建特殊的引导类实例，单例的</span></span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">  beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">  <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建Banner类实例，单例的</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">    ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">    .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">    context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Load the sources</span></span><br><span class="line">  Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">  Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">  load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">  listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法里整个过程都在创建各种类的实例，并未出现对Tomcat的启动操作，看来也不在这个方法中，那么就继续往下看</p></li><li><p>refreshContext()方法</p><p>这个方法最终是调用到<code>AbstractApplicationContext#refresh()</code>中，这就到了Spring基础框架中。我们在分析createApplicationContext()方法的时候，知道Tomcat使用的是<code>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</code>类，这个类继承自<code>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext</code>，在这个类中，重写了父类<code>AbstractApplicationContext</code>中的refresh()、onRefresh()和finishRefresh()方法，而在<code>AbstractApplicationContext#refresh()</code>方法中，调用了onRefresh()和finishRefresh()这两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用的onRefresh()和finishRefresh()实际上是调用了<code>ServletWebServerApplicationContext</code>中的方法，那么我们就来看下这个类中的这两个方法分别做了什么</p><ul><li>onRefresh()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类的onRefresh()方法</span></span><br><span class="line">  <span class="keyword">super</span>.onRefresh();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建WebServer</span></span><br><span class="line">    createWebServer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Unable to start web server"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">  ServletContext servletContext = getServletContext();</span><br><span class="line">  <span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取ServletWebServerFactory的实例，使用Tomcat的话会获取到tomcatServletWebServerFactory</span></span><br><span class="line">    ServletWebServerFactory factory = getWebServerFactory();</span><br><span class="line">    <span class="comment">// 获取WebServer实例，方法内创建Tomcat并准备Tomcat启动所需环境变量</span></span><br><span class="line">    <span class="keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getSelfInitializer().onStartup(servletContext);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化自定义的环境变量，涉及到servletContextInitParams和servletConfigInitParams</span></span><br><span class="line">  initPropertySources();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ServletWebServerFactory <span class="title">getWebServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用bean名称，这样我们就不会考虑层次结构</span></span><br><span class="line">  String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class="line">  <span class="keyword">if</span> (beanNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取Bean实例，这里获取到的就是TomcatServletWebServerFactory类的实例</span></span><br><span class="line">  <span class="keyword">return</span> getBeanFactory().getBean(beanNames[<span class="number">0</span>], ServletWebServerFactory.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码我们知道在onRefresh()方法中主要是创建Tomcat实例，准备Tomcat启动所需参数和配置信息，并未启动Tomcat</p><ul><li>finishRefresh()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.finishRefresh();</span><br><span class="line">  <span class="comment">// 启动WebServer，难道是这里启动的Tomcat？</span></span><br><span class="line">  WebServer webServer = startWebServer();</span><br><span class="line">  <span class="keyword">if</span> (webServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    publishEvent(<span class="keyword">new</span> ServletWebServerInitializedEvent(webServer, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> WebServer <span class="title">startWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">  <span class="keyword">if</span> (webServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 启动WebServer，这里调用的是TomcatWebServer#start()方法</span></span><br><span class="line">    webServer.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> webServer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TomcatWebServer#start()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">  <span class="comment">// 加锁防并发</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.started) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      addPreviouslyRemovedConnectors();</span><br><span class="line">      <span class="comment">// 获取Tomcat的Connector</span></span><br><span class="line">      Connector connector = <span class="keyword">this</span>.tomcat.getConnector();</span><br><span class="line">      <span class="keyword">if</span> (connector != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.autoStart) &#123;</span><br><span class="line">        <span class="comment">// 如果connector不为null，并且自动启动，则启动时执行延迟加载</span></span><br><span class="line">        <span class="comment">// 当端口大于0的时候，autoStart就为true</span></span><br><span class="line">        performDeferredLoadOnStartup();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查Connector是否已启动，若有未启动的Connector则抛异常</span></span><br><span class="line">      checkThatConnectorsHaveStarted();</span><br><span class="line">      <span class="comment">// 修改运行标识属性</span></span><br><span class="line">      <span class="keyword">this</span>.started = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 输出Tomcat启动成功日志</span></span><br><span class="line">      logger.info(<span class="string">"Tomcat started on port(s): "</span> + getPortsDescription(<span class="keyword">true</span>) + <span class="string">" with context path '"</span></span><br><span class="line">                  + getContextPath() + <span class="string">"'"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectorStartFailedException ex) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里好像也仅仅就是检测Tomcat服务是否启动成功了，并没有执行启动这个操作，看来也不在这里。</p><p>这就奇怪了，我们几乎翻遍了整个启动类的代码，都没有Tomcat启动的代码，那么Tomcat是怎么启动的呢？是不是我们遗漏了什么？我们来回顾一下上面的分析，TomcatWebServer实例的获取的地方<code>ServletWebServerFactory#getWebServer()</code>方法内我们好像没有看，是不是在创建TomcatWebServer实例的时候直接就启动了，然后在<code>TomcatWebServer#start()</code>方法中只是去检测启动的状态？我们来看下<code>ServletWebServerFactory#getWebServer()</code>的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebServer <span class="title">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.disableMBeanRegistry) &#123;</span><br><span class="line">    Registry.disableRegistry();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 简单略过</span></span><br><span class="line">  Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">  File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span>) ? <span class="keyword">this</span>.baseDirectory : createTempDir(<span class="string">"tomcat"</span>);</span><br><span class="line">  tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">  Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">  connector.setThrowOnFailure(<span class="keyword">true</span>);</span><br><span class="line">  tomcat.getService().addConnector(connector);</span><br><span class="line">  customizeConnector(connector);</span><br><span class="line">  tomcat.setConnector(connector);</span><br><span class="line">  tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">  configureEngine(tomcat.getEngine());</span><br><span class="line">  <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">    tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">  &#125;</span><br><span class="line">  prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">  <span class="comment">// 获取TomcatWebServer实例</span></span><br><span class="line">  <span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不重要</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TomcatWebServer <span class="title">getTomcatWebServer</span><span class="params">(Tomcat tomcat)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// autoStart = getPort() &gt;= 0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatWebServer</span><span class="params">(Tomcat tomcat, <span class="keyword">boolean</span> autoStart)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(tomcat, <span class="string">"Tomcat Server must not be null"</span>);</span><br><span class="line">  <span class="keyword">this</span>.tomcat = tomcat;</span><br><span class="line">  <span class="keyword">this</span>.autoStart = autoStart;</span><br><span class="line">  <span class="comment">// 最重要的方法</span></span><br><span class="line">  initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>initialize()方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动服务器以触发初始化侦听器</span></span><br><span class="line">      <span class="keyword">this</span>.tomcat.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 所有Tomcat线程都是守护进程线程。我们创建一个阻塞非守护进程来停止立即关闭</span></span><br><span class="line">      startDaemonAwaitThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      stopSilently();</span><br><span class="line">      destroySilently();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> WebServerException(<span class="string">"Unable to start embedded Tomcat"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于找到了，语句<code>this.tomcat.start()</code>就是启动Tomcat容器的关监语句。</p></li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>通过对SpringApplication.run()方法执行顺序的分析来看，先构建Spring上下文加载Bean，也就是扫描包，然后再在refreshContext()方法中创建Tomcat容器并启动容器。</p><p>由此我们可以验证出假设2是正确的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;疑惑&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#疑惑&quot;&gt;&lt;/a&gt; 疑惑&lt;/h4&gt;
&lt;p&gt;SpringBoot中内置了Tomcat容器，那么Tomcat是在什么时间点启动的？是先扫描包加载类再启动Tomcat？，还是先启动Tomcat
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM指针碰撞和空闲列表</title>
    <link href="http://luxiaowan.github.io/2020/05/12/JVM%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8/"/>
    <id>http://luxiaowan.github.io/2020/05/12/JVM指针碰撞和空闲列表/</id>
    <published>2020-05-12T02:40:00.000Z</published>
    <updated>2020-05-12T03:17:43.831Z</updated>
    
    <content type="html"><![CDATA[<p>Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，在堆上为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，将对象放进去。常用的分配方法有指针碰撞和空闲列表两种实现方式。</p><h4 id="指针碰撞"><a class="markdownIt-Anchor" href="#指针碰撞"></a> 指针碰撞</h4><p>适用于堆内存完整的情况，已分配的内存和空闲内存分表在不同的一侧，通过一个指针指向分界点，当需要分配内存时，把指针往空闲的一端移动与对象大小相等的距离即可，用于Serial和ParNew等不会产生内存碎片的垃圾收集器。</p><img src="/images/image-20200512111153143.png" alt="image-20200512111153143" style="zoom:50%;"><h4 id="空闲列表"><a class="markdownIt-Anchor" href="#空闲列表"></a> 空闲列表</h4><p>适用于堆内存不完整的情况，已分配的内存和空闲内存相互交错，JVM通过维护一张内存列表记录可用的内存块信息，当分配内存时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录，最常见的使用此方案的垃圾收集器就是CMS。</p><img src="/images/image-20200512111650404.png" alt="image-20200512111650404" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，在堆上为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，将对象放进去。常用的分配方法有指针碰撞和空闲列表两种实现方式。&lt;/p&gt;
&lt;h4 id=&quot;指针碰撞&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>监听Redis中key过期事件</title>
    <link href="http://luxiaowan.github.io/2020/05/11/%E7%9B%91%E5%90%ACRedis%E4%B8%ADkey%E8%BF%87%E6%9C%9F%E4%BA%8B%E4%BB%B6/"/>
    <id>http://luxiaowan.github.io/2020/05/11/监听Redis中key过期事件/</id>
    <published>2020-05-11T15:20:00.000Z</published>
    <updated>2020-05-11T17:11:16.136Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中偶尔会遇到这样一个场景：用户下单之后，若30分钟内未完成支付，则取消订单。</p><p>做过电商业务的同学，尤其是做统一下单业务的同学一般都会接触过这个场景的需求，一般的处理方式是将订单数据存储到数据库中（MySQL之类的），然后由一个定时Job不断的去扫描符合条件的订单，修改订单状态为已取消。当然这只是其中一个处理办法，我们还可以使用到延时队列来处理。</p><p>那么如果我们使用Redis是否可以实现这一功能？我们知道在使用Redis的过程中，大多是由客户端主动的去操作服务端，比如set、del、get、expire等操作。而当一个key过期被删除的时候，由服务端主动的去通知客户端，这个要怎么做？</p><p>之前在一个项目中，是自己写了一个定时Job不断是去轮询要监听的某些key，然后如果发现Redis中不存在要get的key，则执行一段业务逻辑，我们的扫描频率取决于Job的执行频率，所以并不能保证key在过期时被立即监听到，如果n秒执行一次，则key最大可能会在2n-1秒之后被执行，会有一定的延迟，那么我们能否让Redis主动的在缓存失效的时候通知我们呢？</p><h4 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h4><p>由服务端主动通知客户端，那么就是需要通过一个事件来触发某项通知，事件通过Redis的订阅和发布功能来进行分发，我们查看Redis的配置文件中有一个EVENT NOTIFICATION配置，也名键空间通知</p><p><img src="/images/image-20200512002406401.png" alt="image-20200512002406401"></p><p>注释上说：Redis可以通知发布/订阅客户端关于键空间中发生的事件，如果Redis开启了键空间事件通知，且客户端订阅了某些键的事件，则在相应的键发生变动时，会通过发布/订阅向客户端发送两条消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:foo del</span><br><span class="line">PUBLISH __keyevent@0__:del foo</span><br></pre></td></tr></table></figure><p>客户端可以在一组类中选择Redis的通知事件，每个类都需要由唯一字符进行标识。</p><h5 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h5><p>当开启键空间通知功能时，需要额外的消耗一些CPU，所以此功能默认为关闭状态，可以通过修改redis.conf文件或者使用config set命令来开启或关闭键空间通知功能</p><ul><li>当<code>notify-keyspace-events</code>的值为空字符串时，功能关闭</li><li>当参数的值不是空字符串时，功能开启，且参数的值的取值范围是固定的</li></ul><blockquote><p>参数的可选值</p></blockquote><table><thead><tr><th>字符</th><th>通知事件</th></tr></thead><tbody><tr><td><code>K</code></td><td>键空间通知，所有通知以 <code>__keyspace@__</code> 为前缀</td></tr><tr><td><code>E</code></td><td>键事件通知，所有通知以 <code>__keyevent@__</code> 为前缀</td></tr><tr><td><code>g</code></td><td><code>DEL</code> 、 <code>EXPIRE</code> 、 <code>RENAME</code> 等类型无关的通用命令的通知</td></tr><tr><td><code>$</code></td><td>字符串命令的通知</td></tr><tr><td><code>l</code></td><td>列表命令的通知</td></tr><tr><td><code>s</code></td><td>集合命令的通知</td></tr><tr><td><code>h</code></td><td>哈希命令的通知</td></tr><tr><td><code>z</code></td><td>有序集合命令的通知</td></tr><tr><td><code>x</code></td><td>过期事件：每当有过期键被删除时发送</td></tr><tr><td><code>e</code></td><td>驱逐(evict)事件：每当有键因为 <code>maxmemory</code> 政策而被删除时发送</td></tr><tr><td><code>A</code></td><td>参数 <code>g$lshzxe</code> 的别名</td></tr></tbody></table><p>输入的参数中至少要有一个<code>K</code>或<code>E</code>来指定通知类型，否则配置不会生效</p><h5 id="过期通知事件"><a class="markdownIt-Anchor" href="#过期通知事件"></a> 过期通知事件</h5><p>在Redis中有两种方式将key删除：</p><ol><li>当一个键被访问时，Redis会对这个键进行检查，如果键已经过期，则将该键删除</li><li>Redis后台会定期删除那些已经过期的键</li></ol><p>当过期键被删除时，Redis会产生一个expired通知。在此要理解一点，就是并不是当key的TTL变为0时就会立即被删除，所以Redis产生expired通知的时间为键被删除的时候而不是键的TTL变为0的时候。</p><p>依据上述表格，我们可以将<code>notify-keyspace-events</code>设置为<code>Ex</code>，表示键过期事件通知。</p><h5 id="java应用中通知监控"><a class="markdownIt-Anchor" href="#java应用中通知监控"></a> Java应用中通知监控</h5><p>Spring Data Redis 实现发布订阅功能非常简单，只有这样的几个类：<code>Topic</code>、<code>MessageListener</code>、<code>RedisMessageListenerContainer</code>。下面对它们进行解释：</p><p><code>org.springframework.data.redis.listener.Topic</code>消息发送者与接收者之间的 channel 定义，有两个实现类：</p><ol><li><code>org.springframework.data.redis.listener.ChannelTopic</code>：一个确定的字符串</li><li><code>org.springframework.data.redis.listener.PatternTopic</code>：基于模式匹配</li></ol><p><code>org.springframework.data.redis.connection.MessageListener</code>一个回调接口，消息监听器，用于接收发送到 channel 的消息，接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.redis.connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听Redis的订阅通知</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Costin Leau</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christoph Strobl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当从Redis接收到通知后的回调方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message message must not be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern pattern matching the channel (if specified) - can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, @Nullable <span class="keyword">byte</span>[] pattern)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.data.redis.listener.RedisMessageListenerContainer</code>用于消息监听，需要将 <code>Topic</code>和<code>MessageListener</code>注册到<code>RedisMessageListenerContainer</code>中，当 Topic 上有消息时，由<code>RedisMessageListenerContainer</code>通知<code>MessageListener</code>，客户端通过onMessage()拿到消息后，自行处理。</p><ul><li><p>引入redis的依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>RedisMessageListenerContainer</code>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.RedisMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisListenerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建key过期事件监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.KeyExpirationEventMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.RedisMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpirationListener</span> <span class="keyword">extends</span> <span class="title">KeyExpirationEventMessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisKeyExpirationListener</span><span class="params">(RedisMessageListenerContainer listenerContainer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(listenerContainer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        String key = message.toString();</span><br><span class="line">        System.out.println(<span class="string">"监听到key: "</span> + key + <span class="string">" 过期!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在工作中偶尔会遇到这样一个场景：用户下单之后，若30分钟内未完成支付，则取消订单。&lt;/p&gt;
&lt;p&gt;做过电商业务的同学，尤其是做统一下单业务的同学一般都会接触过这个场景的需求，一般的处理方式是将订单数据存储到数据库中（MySQL之类的），然后由一个定时Job不断的去扫描符合条
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jcmd</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjcmd/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jcmd/</id>
    <published>2020-05-11T10:21:00.000Z</published>
    <updated>2020-05-11T12:21:17.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>在jdk1.7之后，jdk命令家族新增了一个特牛的命令：jcmd，它是一个多功能的根据，汇集了jps、jmap、jstack、jinfo、jstat等多个命令的功能，也就是我们之前要使用多个JVM命令才能达到的目的，现在只需要使用一个jcmd命令即可。</p><p><img src="/images/image-20200511182956340.png" alt="image-20200511182956340"></p><ul><li>jcmd &lt;pid | main class&gt; &lt;command … | PerfCounter.print | -f file&gt;<ul><li>pid：Java进程ID</li><li>main class：Java进程的main类，main类名称可以使用通配符，如果正在运行的进程中有多个进程的main类名称相同，则会将诊断命令请求发送到所有的命中进程中</li><li>command：诊断指令参数，可以通过<code>jcmd pid help</code>查看进程支持的参数</li><li>PerfCounter.print：打印Java进程上可用的性能计数器，该计数器的列表会随着Java进程的不同而发生变化</li><li>-f file：从文件file中读取命令并在目标Java进程上执行这些命令。在文件中，每个命令必须单独的写在一行里，以<code>#</code>开头的行会被忽略，当所有行都被调用完毕之后，或者读取到stop命令，将会终止对file的处理</li></ul></li><li>-l：列出JVM进程</li><li>-h：显示帮助信息</li></ul><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><ol><li><p>jcmd -l</p><p>查看当前机器上所有的jvm进程信息，与<code>jps -l</code>、<code>jcmd</code>命令效果一样</p><p><img src="/images/image-20200511193521904.png" alt="image-20200511193521904"></p></li><li><p>jcmd pid PerfCounter.print</p><p>查看指定进程的性能统计信息，相当于<code>jstat -J-Djstat.showUnsupported=true -snap pid</code>效果一样</p><p><img src="/images/image-20200511193725364.png" alt="image-20200511193725364"></p></li><li><p>jcmd pid help</p><p>查看指定进程支持的操作参数</p><p><img src="/images/image-20200511193818369.png" alt="image-20200511193818369"></p></li><li><p>jcmd pid help command</p><p>查看指定命令的帮助信息</p><p><img src="/images/image-20200511193938227.png" alt="image-20200511193938227"></p></li><li><p>jcmd pid VM.uptime</p><p>查看虚拟机的运行时长</p><p><img src="/images/image-20200511194101355.png" alt="image-20200511194101355"></p></li><li><p>jcmd pid VM.classloader_stats</p><p>查看类加载器信息，等同于<code>jmap -clstats</code>命令</p><p><img src="/images/image-20200511194314593.png" alt="image-20200511194314593"></p></li><li><p>jcmd pid Thread.print</p><p>打印Java进程的线程信息，与<code>jstack</code>效果一样</p><p><img src="/images/image-20200511194510978.png" alt="image-20200511194510978"></p></li><li><p>jcmd pid GC.class_histogram</p><p>查看进程中的类统计信息，与<code>jmap -histo</code>效果一样</p><p><img src="/images/image-20200511194712997.png" alt="image-20200511194712997"></p></li><li><p>jcmd pid GC.heap_dump filepath</p><p>生成堆转储文件，与<code>jmap -dump:format=b,file=a.hprof</code>效果一样</p><p><img src="/images/image-20200511194938288.png" alt="image-20200511194938288"></p></li><li><p>jcmd pid GC.heap_info</p><p>查看JVM的堆信息，与<code>jmap -heap</code>效果一样</p><p><img src="/images/image-20200511195121583.png" alt="image-20200511195121583"></p></li><li><p>jcmd pid GC.finalizer_info</p><p>查看正在等待回收的对象信息，与<code>jmap -finalizerinfo</code>效果一样</p></li><li><p>jcmd pid GC.run</p><p>告诉垃圾收集器进行垃圾收集，等于是对JVM执行了<code>System.gc()</code></p></li><li><p>jcmd pid VM.version</p><p>查看JVM当前版本，和<code>jinfo pid | grep version</code>效果一样</p><p><img src="/images/image-20200511200800384.png" alt="image-20200511200800384"></p></li><li><p>jcmd pid VM.system_properties</p><p>查看JVM系统属性信息，和<code>jinfo</code>效果一样</p><p><img src="/images/image-20200511200911867.png" alt="image-20200511200911867"></p></li><li><p>jcmd pid VM.flags</p><p>查看JVM的启动参数，与<code>jinfo -flags</code>效果一样</p><p><img src="/images/image-20200511202039543.png" alt="image-20200511202039543"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;在jdk1.7之后，jdk命令家族新增了一个特牛的命令：jcmd，它是一个多功能的根据，汇集了jps、jmap、jstack、jinfo、jst
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jmap</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjmap/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jmap/</id>
    <published>2020-05-11T07:40:00.000Z</published>
    <updated>2020-05-11T10:02:02.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>jmap是一个多功能命令，它可以生成Java应用的dump文件，也可以查看堆内对象的统计信息、查看ClassLoader信息和finalizer队列等，但是jmap会将整个JVM的线程全部暂停，所以在生产环境中慎重jmap命令。</p><img src="/images/image-20200511155155703.png" alt="image-20200511155155703" style="zoom:50%;"><blockquote><p>参数</p></blockquote><ul><li>option：选项参数</li><li>pid：进程ID</li><li>executable：生成核心dump的Java可执行文件</li><li>core：需要打印配置信息的核心文件</li><li>server_id：唯一服务ID，若一台主机上开启了多个远程debug服务</li><li>remote server IP or hostname：远程debug服务的主机名或IP</li></ul><blockquote><p>option选项</p></blockquote><ul><li>none：查看进程的内存映像信息，和Solaris的pmap命令类似</li><li>heap：显示JVM堆详细信息</li><li>histo[:live]：打印堆中对象的统计信息，<code>:live</code>子选项是指定仅打印出存活的对象</li><li>clstats：打印类加载器信息</li><li>finalizerinfo：显示正在准备被回收的对象信息</li><li>dump:&lt;dump-options&gt;：生成堆转储快照<ul><li>live：仅转储堆中存活的对象</li><li>format=b：二进制方式</li><li>file：堆转储快照文件</li></ul></li><li>F：当dump或histo没有响应时，使用该参数可以强制执行，但是若子选项是<code>:live</code>则使用-F也无效</li><li>h | help：显示命令的帮助信息</li><li>j&lt;flag&gt;：给运行中的JVM传参数给jmap</li></ul><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><blockquote><p>准备：启动一个死循环的main方法</p><p>通过jps命令查看应用的pid</p><p>pid：10456</p></blockquote><ol><li><p>jmap pid</p><p>查看进程的内存映像信息</p><img src="/images/image-20200511162040121.png" alt="image-20200511162040121" style="zoom:50%;"></li><li><p>jmap -heap pid</p><p>显示JVM堆详细信息</p><p><img src="/images/image-20200511162552365.png" alt="image-20200511162552365"></p></li><li><p>jmap -histo:live pid</p><p>显示堆中存活的对象的统计信息，信息包含每个存活的Java类、对象数量、内存大小（从大到小排列，单位：字节）、类全限定名</p><p><img src="/images/image-20200511173916727.png" alt="image-20200511173916727"></p></li><li><p>jmap -clstats pid</p><p>打印类加载器信息，信息包含类加载器名称、所加载的类的数量、所加载的类的大小、父加载器、存活状态、加载器地址等</p><p><img src="/images/image-20200511174142448.png" alt="image-20200511174142448"></p></li><li><p>jmap -finalizerinfo pid</p><p>打印正在等待被回收的对象信息</p><p><img src="/images/image-20200511174414285.png" alt="image-20200511174414285"></p><p>表示当前并无待回收对象</p></li><li><p>jmap -dump:format=b,file=heapdump.hprof pid</p><p>生成堆转储快照dump文件，以hprof二进制格式转储Java堆信息到指定的文件中，可以使用live子选项指定只将堆中存活的对象转储出来，生成的文件可以使用jhat命令或者MAT工具解析</p><p><img src="/images/image-20200511175932610.png" alt="image-20200511175932610"></p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>在jmap执行时，JVM为了保证dump的信息的可靠性，会暂停应用的所有线程，如果堆内对象过大的话，这个过程会非常耗时，在生产环境慎用。</p><p>但是当生产服务处了问题，这个时候不得不使用的话，那就用吧，应用都出问题了，还在意会不会STW干啥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h3&gt;
&lt;p&gt;jmap是一个多功能命令，它可以生成Java应用的dump文件，也可以查看堆内对象的统计信息、查看ClassLoader信息和finalizer
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jstack</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjstack/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jstack/</id>
    <published>2020-05-10T16:11:00.000Z</published>
    <updated>2020-05-11T18:15:48.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h3><p>jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出Java应用中线程堆栈信息，主要用法：</p><img src="/images/image-20200511001238117.png" alt="image-20200511001238117" style="zoom:50%;"><ul><li>-F：强制打印线程堆栈信息，当<code>jstack [-l] &lt;pid&gt;</code>无响应时使用</li><li>-m：打印Java和native框架的所有堆栈信息</li><li>-l：长列表，打印关于锁的附加信息</li><li>-h or -help：打印帮助信息</li></ul><p><code>pid</code>是需要被打印堆栈信息的Java进程id，可以使用jps查看，通过jstack命令可以获取当前进程的所有线程信息，每个线程堆信息中可以看到线程ID、线程状态、是否持有锁等信息。</p><h3 id="死锁排查"><a class="markdownIt-Anchor" href="#死锁排查"></a> 死锁排查</h3><p>线程死锁的情况很简单，我们通过一张图即可理解：</p><img src="/images/image-20200511011015785.png" alt="image-20200511011015785" style="zoom:50%;"><p>首先我们写一段死锁代码，代码逻辑很简单，写两个线程，提供两个ReentrantLock对象，在线程1中先对lock1加锁，然后再对lock2加锁，而在线程2中先对lock2加锁，再对lock1加锁，使这两个线程互相竞争锁lock1和lock2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Lock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock1.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc1获取到lock1"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock2.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc1获取到lock2"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"cc1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock2.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc2获取到lock2"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock1.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc2获取到lock1"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"cc2"</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序之后，控制台输出内容：</p><img src="/images/image-20200511004249590.png" alt="image-20200511004249590" style="zoom:50%;"><p>然后就一直停顿在这里，下面我们使用jstack排查一下：</p><ol><li><p>使用jps查看进程pid</p><img src="/images/image-20200511004456408.png" alt="image-20200511004456408" style="zoom:50%;"><p>我们看到进程的pid为75169，接下来就可以根据该pid打印出堆栈信息</p></li><li><p>通过jstack查看进程的堆栈信息</p><p>执行命令<code>jstack -l 75169</code>，查看控制台输出的信息</p><img src="/images/image-20200511005029659.png" alt="image-20200511005029659" style="zoom:50%;"></li><li><p>排查死锁</p><ul><li>直接方法</li></ul><p>查看红框内的信息，发现在堆栈信息中已经告诉了我们死锁的信息，及发生死锁的线程名称和正在等待的锁，以及等待的锁的当前拥有者的线程名称。</p><p>查看黄框内的信息，这是我们排查代码问题的关键所在，也就是在堆栈信息中，会告诉我们发生死锁的代码位置，便于我们定位发生死锁的代码。</p><ul><li>间接方法</li></ul><p>如果堆栈中未告诉我们死锁的关联线程，那么我们可以通过线程正在等待的锁的信息在堆栈信息中进行搜索，本示例中，线程cc2的堆栈信息中<code>- parking to wait for &lt;0x000000076b2839a8&gt;</code>告诉我们当前线程cc2正在等待锁0x000000076b2839a8，并且当前已经霸占了锁0x000000076b2839d8；</p><img src="/images/image-20200511005806128.png" alt="image-20200511005806128" style="zoom:50%;"><p>而线程cc1的堆栈信息中<code>- parking to wait for &lt;0x000000076b2839d8&gt;</code>告诉我们它正在等待锁0x000000076b2839d8，且当前已经持有了锁0x000000076b2839a8。</p><img src="/images/image-20200511005950037.png" alt="image-20200511005950037" style="zoom:50%;"><p>通过线程cc1和cc2的堆栈信息我们能够直观的分析出它们相互霸占了对方想要获取的锁，并且在未获得所需要的锁之前，相互之间都不会释放已经持有的锁，因此导致了程序出现了死锁。</p></li></ol><h5 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h5><p>以上就是我们通常情况下排查线程死锁的基本操作，主要操作顺序为：</p><ol><li>使用jps查看进程pid</li><li>使用<code>jstack -l pid</code>查看线程堆栈信息</li><li>通过堆栈信息分析死锁情况</li></ol><h3 id="排查cpu过高"><a class="markdownIt-Anchor" href="#排查cpu过高"></a> 排查CPU过高</h3><p>当运行中的线程过多时，CPU负载会极速飙升，如果我们不及时解决就会导致因CPU过高而唤醒的系统的自我保护，将进程杀死。在实际工作当中，我们经常会遇到此种情况，当然我们不能看到CPU达到100%或者300%了就认为是CPU负载过高，这要根据我们服务器的CPU个数和每个CPU的负载来判断CPU是否过高。</p><blockquote><p>查看服务器负载：使用top命令查看机器负载</p><p><img src="/images/image-20200511013557261.png" alt="image-20200511013557261"></p><ul><li>load average后面分表代表1分钟、5分钟、15分钟的系统平均负载情况，一般不超过CPU个数*0.7即可认为是正常，使用uptime命令也可以查看该属性</li><li>按键1可以查看每个CPU的负载情况，若有一个CPU使用量超过75%，那么就需要排查了</li></ul></blockquote><p>我们写一个死循环来将CPU吃满：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullCpuTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>运行程序之后，通过top命令查看CPU负载</p><img src="/images/image-20200511021314252.png" alt="image-20200511021314252" style="zoom:50%;"><p>我们看到load average并不是很高，因为刚启动，待会就飙起来了，但是CPU0的usage已经达到了94.7%，我们的Java进程的pid为23731。</p></li><li><p>通过<code>top -Hp 23731</code>查看进程内的线程负载情况</p><p><img src="/images/image-20200511021510357.png" alt="image-20200511021510357"></p><p>发现pid为23732的线程占用的CPU最高，那么我们就找到了问题所在</p></li><li><p>查看线程的堆栈信息</p><ul><li><p>通过<code>jstack hpid</code>查看线程中处于RUNNABLE状态的线程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 23732是线程的pid</span></span><br><span class="line">jstack 23732</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200511021836792.png" alt="image-20200511021836792"></p></li><li><p>通过<code>jstack pid</code>定位具体的线程</p><ol><li><p>打印线程23732的16进制数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf '%x\n' 23732</span><br></pre></td></tr></table></figure></li><li><p>通过jstack排查具体的线程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 23731是进程的pid</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5cb4是线程pid的十六进制数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C2是输出命中行的上下行数，-C2表示上下各打印两行</span></span><br><span class="line">jstack 23731 | grep '0x5cb4' -C2 --color</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200511022609016.png" alt="image-20200511022609016"></p></li></ol></li><li><p>通过<code>kill -3 pid</code>查看线程堆栈信息</p></li></ul></li></ol><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><p>一般生产环境不会让直接在服务器上操作，所以可以将堆栈信息输出到文件中，然后再详细分析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt; 简述&lt;/h3&gt;
&lt;p&gt;jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出Java应用中线程堆栈信息，主要用法：&lt;/p&gt;
&lt;img src=&quot;/ima
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
</feed>
