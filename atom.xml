<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2020-05-11T12:21:17.456Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM命令之jcmd</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjcmd/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jcmd/</id>
    <published>2020-05-11T10:21:00.000Z</published>
    <updated>2020-05-11T12:21:17.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>在jdk1.7之后，jdk命令家族新增了一个特牛的命令：jcmd，它是一个多功能的根据，汇集了jps、jmap、jstack、jinfo、jstat等多个命令的功能，也就是我们之前要使用多个JVM命令才能达到的目的，现在只需要使用一个jcmd命令即可。</p><p><img src="/images/image-20200511182956340.png" alt="image-20200511182956340"></p><ul><li>jcmd &lt;pid | main class&gt; &lt;command … | PerfCounter.print | -f file&gt;<ul><li>pid：Java进程ID</li><li>main class：Java进程的main类，main类名称可以使用通配符，如果正在运行的进程中有多个进程的main类名称相同，则会将诊断命令请求发送到所有的命中进程中</li><li>command：诊断指令参数，可以通过<code>jcmd pid help</code>查看进程支持的参数</li><li>PerfCounter.print：打印Java进程上可用的性能计数器，该计数器的列表会随着Java进程的不同而发生变化</li><li>-f file：从文件file中读取命令并在目标Java进程上执行这些命令。在文件中，每个命令必须单独的写在一行里，以<code>#</code>开头的行会被忽略，当所有行都被调用完毕之后，或者读取到stop命令，将会终止对file的处理</li></ul></li><li>-l：列出JVM进程</li><li>-h：显示帮助信息</li></ul><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><ol><li><p>jcmd -l</p><p>查看当前机器上所有的jvm进程信息，与<code>jps -l</code>、<code>jcmd</code>命令效果一样</p><p><img src="/images/image-20200511193521904.png" alt="image-20200511193521904"></p></li><li><p>jcmd pid PerfCounter.print</p><p>查看指定进程的性能统计信息，相当于<code>jstat -J-Djstat.showUnsupported=true -snap pid</code>效果一样</p><p><img src="/images/image-20200511193725364.png" alt="image-20200511193725364"></p></li><li><p>jcmd pid help</p><p>查看指定进程支持的操作参数</p><p><img src="/images/image-20200511193818369.png" alt="image-20200511193818369"></p></li><li><p>jcmd pid help command</p><p>查看指定命令的帮助信息</p><p><img src="/images/image-20200511193938227.png" alt="image-20200511193938227"></p></li><li><p>jcmd pid VM.uptime</p><p>查看虚拟机的运行时长</p><p><img src="/images/image-20200511194101355.png" alt="image-20200511194101355"></p></li><li><p>jcmd pid VM.classloader_stats</p><p>查看类加载器信息，等同于<code>jmap -clstats</code>命令</p><p><img src="/images/image-20200511194314593.png" alt="image-20200511194314593"></p></li><li><p>jcmd pid Thread.print</p><p>打印Java进程的线程信息，与<code>jstack</code>效果一样</p><p><img src="/images/image-20200511194510978.png" alt="image-20200511194510978"></p></li><li><p>jcmd pid GC.class_histogram</p><p>查看进程中的类统计信息，与<code>jmap -histo</code>效果一样</p><p><img src="/images/image-20200511194712997.png" alt="image-20200511194712997"></p></li><li><p>jcmd pid GC.heap_dump filepath</p><p>生成堆转储文件，与<code>jmap -dump:format=b,file=a.hprof</code>效果一样</p><p><img src="/images/image-20200511194938288.png" alt="image-20200511194938288"></p></li><li><p>jcmd pid GC.heap_info</p><p>查看JVM的堆信息，与<code>jmap -heap</code>效果一样</p><p><img src="/images/image-20200511195121583.png" alt="image-20200511195121583"></p></li><li><p>jcmd pid GC.finalizer_info</p><p>查看正在等待回收的对象信息，与<code>jmap -finalizerinfo</code>效果一样</p></li><li><p>jcmd pid GC.run</p><p>告诉垃圾收集器进行垃圾收集，等于是对JVM执行了<code>System.gc()</code></p></li><li><p>jcmd pid VM.version</p><p>查看JVM当前版本，和<code>jinfo pid | grep version</code>效果一样</p><p><img src="/images/image-20200511200800384.png" alt="image-20200511200800384"></p></li><li><p>jcmd pid VM.system_properties</p><p>查看JVM系统属性信息，和<code>jinfo</code>效果一样</p><p><img src="/images/image-20200511200911867.png" alt="image-20200511200911867"></p></li><li><p>jcmd pid VM.flags</p><p>查看JVM的启动参数，与<code>jinfo -flags</code>效果一样</p><p><img src="/images/image-20200511202039543.png" alt="image-20200511202039543"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;在jdk1.7之后，jdk命令家族新增了一个特牛的命令：jcmd，它是一个多功能的根据，汇集了jps、jmap、jstack、jinfo、jst
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jmap</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjmap/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jmap/</id>
    <published>2020-05-11T07:40:00.000Z</published>
    <updated>2020-05-11T10:02:02.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>jmap是一个多功能命令，它可以生成Java应用的dump文件，也可以查看堆内对象的统计信息、查看ClassLoader信息和finalizer队列等，但是jmap会将整个JVM的线程全部暂停，所以在生产环境中慎重jmap命令。</p><img src="/images/image-20200511155155703.png" alt="image-20200511155155703" style="zoom:50%;"><blockquote><p>参数</p></blockquote><ul><li>option：选项参数</li><li>pid：进程ID</li><li>executable：生成核心dump的Java可执行文件</li><li>core：需要打印配置信息的核心文件</li><li>server_id：唯一服务ID，若一台主机上开启了多个远程debug服务</li><li>remote server IP or hostname：远程debug服务的主机名或IP</li></ul><blockquote><p>option选项</p></blockquote><ul><li>none：查看进程的内存映像信息，和Solaris的pmap命令类似</li><li>heap：显示JVM堆详细信息</li><li>histo[:live]：打印堆中对象的统计信息，<code>:live</code>子选项是指定仅打印出存活的对象</li><li>clstats：打印类加载器信息</li><li>finalizerinfo：显示正在准备被回收的对象信息</li><li>dump:&lt;dump-options&gt;：生成堆转储快照<ul><li>live：仅转储堆中存活的对象</li><li>format=b：二进制方式</li><li>file：堆转储快照文件</li></ul></li><li>F：当dump或histo没有响应时，使用该参数可以强制执行，但是若子选项是<code>:live</code>则使用-F也无效</li><li>h | help：显示命令的帮助信息</li><li>j&lt;flag&gt;：给运行中的JVM传参数给jmap</li></ul><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><blockquote><p>准备：启动一个死循环的main方法</p><p>通过jps命令查看应用的pid</p><p>pid：10456</p></blockquote><ol><li><p>jmap pid</p><p>查看进程的内存映像信息</p><img src="/images/image-20200511162040121.png" alt="image-20200511162040121" style="zoom:50%;"></li><li><p>jmap -heap pid</p><p>显示JVM堆详细信息</p><p><img src="/images/image-20200511162552365.png" alt="image-20200511162552365"></p></li><li><p>jmap -histo:live pid</p><p>显示堆中存活的对象的统计信息，信息包含每个存活的Java类、对象数量、内存大小（从大到小排列，单位：字节）、类全限定名</p><p><img src="/images/image-20200511173916727.png" alt="image-20200511173916727"></p></li><li><p>jmap -clstats pid</p><p>打印类加载器信息，信息包含类加载器名称、所加载的类的数量、所加载的类的大小、父加载器、存活状态、加载器地址等</p><p><img src="/images/image-20200511174142448.png" alt="image-20200511174142448"></p></li><li><p>jmap -finalizerinfo pid</p><p>打印正在等待被回收的对象信息</p><p><img src="/images/image-20200511174414285.png" alt="image-20200511174414285"></p><p>表示当前并无待回收对象</p></li><li><p>jmap -dump:format=b,file=heapdump.hprof pid</p><p>生成堆转储快照dump文件，以hprof二进制格式转储Java堆信息到指定的文件中，可以使用live子选项指定只将堆中存活的对象转储出来，生成的文件可以使用jhat命令或者MAT工具解析</p><p><img src="/images/image-20200511175932610.png" alt="image-20200511175932610"></p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>在jmap执行时，JVM为了保证dump的信息的可靠性，会暂停应用的所有线程，如果堆内对象过大的话，这个过程会非常耗时，在生产环境慎用。</p><p>但是当生产服务处了问题，这个时候不得不使用的话，那就用吧，应用都出问题了，还在意会不会STW干啥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h3&gt;
&lt;p&gt;jmap是一个多功能命令，它可以生成Java应用的dump文件，也可以查看堆内对象的统计信息、查看ClassLoader信息和finalizer
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jstack</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjstack/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jstack/</id>
    <published>2020-05-10T16:11:00.000Z</published>
    <updated>2020-05-10T18:34:10.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h3><p>jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出Java应用中线程堆栈信息，主要用法：</p><img src="/images/image-20200511001238117.png" alt="image-20200511001238117" style="zoom:50%;"><ul><li>-F：强制打印线程堆栈信息，当<code>jstack [-l] &lt;pid&gt;</code>无响应时使用</li><li>-m：打印Java和native框架的所有堆栈信息</li><li>-l：长列表，打印关于锁的附加信息</li><li>-h or -help：打印帮助信息</li></ul><p><code>pid</code>是需要被打印堆栈信息的Java进程id，可以使用jps查看，通过jstack命令可以获取当前进程的所有线程信息，每个线程堆信息中可以看到线程ID、线程状态、是否持有锁等信息。</p><h3 id="死锁排查"><a class="markdownIt-Anchor" href="#死锁排查"></a> 死锁排查</h3><p>线程死锁的情况很简单，我们通过一张图即可理解：</p><img src="/images/image-20200511011015785.png" alt="image-20200511011015785" style="zoom:50%;"><p>首先我们写一段死锁代码，代码逻辑很简单，写两个线程，提供两个ReentrantLock对象，在线程1中先对lock1加锁，然后再对lock2加锁，而在线程2中先对lock2加锁，再对lock1加锁，使这两个线程互相竞争锁lock1和lock2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Lock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock1.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc1获取到lock1"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock2.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc1获取到lock2"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"cc1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock2.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc2获取到lock2"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock1.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc2获取到lock1"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"cc2"</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序之后，控制台输出内容：</p><img src="/images/image-20200511004249590.png" alt="image-20200511004249590" style="zoom:50%;"><p>然后就一直停顿在这里，下面我们使用jstack排查一下：</p><ol><li><p>使用jps查看进程pid</p><img src="/images/image-20200511004456408.png" alt="image-20200511004456408" style="zoom:50%;"><p>我们看到进程的pid为75169，接下来就可以根据该pid打印出堆栈信息</p></li><li><p>通过jstack查看进程的堆栈信息</p><p>执行命令<code>jstack -l 75169</code>，查看控制台输出的信息</p><img src="/images/image-20200511005029659.png" alt="image-20200511005029659" style="zoom:50%;"></li><li><p>排查死锁</p><ul><li>直接方法</li></ul><p>查看红框内的信息，发现在堆栈信息中已经告诉了我们死锁的信息，及发生死锁的线程名称和正在等待的锁，以及等待的锁的当前拥有者的线程名称。</p><p>查看黄框内的信息，这是我们排查代码问题的关键所在，也就是在堆栈信息中，会告诉我们发生死锁的代码位置，便于我们定位发生死锁的代码。</p><ul><li>间接方法</li></ul><p>如果堆栈中未告诉我们死锁的关联线程，那么我们可以通过线程正在等待的锁的信息在堆栈信息中进行搜索，本示例中，线程cc2的堆栈信息中<code>- parking to wait for &lt;0x000000076b2839a8&gt;</code>告诉我们当前线程cc2正在等待锁0x000000076b2839a8，并且当前已经霸占了锁0x000000076b2839d8；</p><img src="/images/image-20200511005806128.png" alt="image-20200511005806128" style="zoom:50%;"><p>而线程cc1的堆栈信息中<code>- parking to wait for &lt;0x000000076b2839d8&gt;</code>告诉我们它正在等待锁0x000000076b2839d8，且当前已经持有了锁0x000000076b2839a8。</p><img src="/images/image-20200511005950037.png" alt="image-20200511005950037" style="zoom:50%;"><p>通过线程cc1和cc2的堆栈信息我们能够直观的分析出它们相互霸占了对方想要获取的锁，并且在未获得所需要的锁之前，相互之间都不会释放已经持有的锁，因此导致了程序出现了死锁。</p></li></ol><h5 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h5><p>以上就是我们通常情况下排查线程死锁的基本操作，主要操作顺序为：</p><ol><li>使用jps查看进程pid</li><li>使用<code>jstack -l pid</code>查看线程堆栈信息</li><li>通过堆栈信息分析死锁情况</li></ol><h3 id="排查cpu过高"><a class="markdownIt-Anchor" href="#排查cpu过高"></a> 排查CPU过高</h3><p>当运行中的线程过多时，CPU负载会极速飙升，如果我们不及时解决就会导致因CPU过高而唤醒的系统的自我保护，将进程杀死。在实际工作当中，我们经常会遇到此种情况，当然我们不能看到CPU达到100%或者300%了就认为是CPU负载过高，这要根据我们服务器的CPU个数和每个CPU的负载来判断CPU是否过高。</p><blockquote><p>查看服务器负载：使用top命令查看机器负载</p><p><img src="/images/image-20200511013557261.png" alt="image-20200511013557261"></p><ul><li>load average后面分表代表1分钟、5分钟、15分钟的系统平均负载情况，一般不超过CPU个数*0.7即可认为是正常，使用uptime命令也可以查看该属性</li><li>按键1可以查看每个CPU的负载情况，若有一个CPU使用量超过75%，那么就需要排查了</li></ul></blockquote><p>我们写一个死循环来将CPU吃满：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullCpuTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>运行程序之后，通过top命令查看CPU负载</p><img src="/images/image-20200511021314252.png" alt="image-20200511021314252" style="zoom:50%;"><p>我们看到load average并不是很高，因为刚启动，待会就飙起来了，但是CPU0的usage已经达到了94.7%，我们的Java进程的pid为23731。</p></li><li><p>通过<code>top -Hp 23731</code>查看进程内的线程负载情况</p><p><img src="/images/image-20200511021510357.png" alt="image-20200511021510357"></p><p>发现pid为23732的线程占用的CPU最高，那么我们就找到了问题所在</p></li><li><p>查看线程的堆栈信息</p><ul><li><p>通过<code>jstack hpid</code>查看线程中处于RUNNABLE状态的线程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 23732是线程的pid</span></span><br><span class="line">jstack 23732</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200511021836792.png" alt="image-20200511021836792"></p></li><li><p>通过<code>jstack pid</code>定位具体的线程</p><ol><li><p>打印线程23732的16进制数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf '%x\n' 23732</span><br></pre></td></tr></table></figure></li><li><p>通过jstack排查具体的线程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 23731是进程的pid</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5cb4是线程pid的十六进制数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C2是输出命中行的上下行数，-C2表示上下各打印两行</span></span><br><span class="line">jstack 23731 | grep '0x5cb4' -C2 --color</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200511022609016.png" alt="image-20200511022609016"></p></li></ol></li><li><p>通过<code>kill -3 pid</code>查看线程堆栈信息</p></li></ul></li></ol><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><p>一般生产环境不会让直接在服务器上操作，所以可以将堆栈信息输出到文件中，然后再详细分析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt; 简述&lt;/h3&gt;
&lt;p&gt;jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出Java应用中线程堆栈信息，主要用法：&lt;/p&gt;
&lt;img src=&quot;/ima
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java垃圾回收名词</title>
    <link href="http://luxiaowan.github.io/2020/05/10/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%8D%E8%AF%8D/"/>
    <id>http://luxiaowan.github.io/2020/05/10/Java垃圾回收名词/</id>
    <published>2020-05-10T14:50:00.000Z</published>
    <updated>2020-05-10T15:17:07.978Z</updated>
    
    <content type="html"><![CDATA[<p>我们在学习JVM的GC相关知识时，必定会接触到几个GC的专有名词：Minor GC、Major GC、Young GC、Old GC、Full GC、Stop The World（STW），现在我们来了解一下这些名词具体指的是什么。</p><h4 id="minor-gc-young-gc"><a class="markdownIt-Anchor" href="#minor-gc-young-gc"></a> Minor GC &amp;&amp; Young GC</h4><p>Minor GC和Young GC都是指新生代的内存回收，两个名词指的是同一件事情，我们都知道现在的商业化虚拟机中，新生代被分为Eden和Survivor区，关于Minor GC我们需要知道以下几点：</p><ol><li>当Eden区无法为新创建的对象分配空间时，会触发Minor GC。Eden区空间越小，Minor GC的频率越高</li><li>当Eden区空间不足触发Minor GC时，新生代中会有部分对象晋升到老年代，所以Minor GC之后，老年代的空间使用量通常会有所升高</li><li>新生代的大部分垃圾收集器都会触发STW，但是新生代的大部分对象通常情况下都是朝生夕死的，所以Eden区的大部分对象都可以认为是垃圾对象，只有很少的一部分对象会被复制到Survivor区和老年代，这种情况下STW的时间会很短；而当Minor GC之后Eden区仍存活非常多的对象，那么垃圾收集器就会将这些对象复制到Survivor区或老年代，此时STW的时间就会变的很长，因为复制大量对象相比复制少量对象更耗时。</li></ol><h4 id="major-gc-old-gc"><a class="markdownIt-Anchor" href="#major-gc-old-gc"></a> Major GC &amp;&amp; Old GC</h4><p>这两个名词都指的是老年代空间回收，也属于是同一件事。很多情况下，Major GC是由Minor GC触发的，比如当发生Minor GC时，会将新生代的部分满足条件的对象晋升到老年代，如果此时老年代的可用空间不足，那么就会触发Major GC，因此说在大部分情况下Major GC都是由Minor GC触发的。</p><h4 id="full-gc"><a class="markdownIt-Anchor" href="#full-gc"></a> Full GC</h4><p>Full GC是比较特殊的一种，它等于是Minor GC和Major GC的结合，主要用于回收新生代、老年代和永久代。</p><ol><li>当老年代空间不足时，会触发Full GC</li><li>在代码中显式调用<code>System.gc()</code>时，JVM会建议执行Full GC</li><li>方法区空间不足时，会触发Full GC，但是在jdk1.8之后采用Metaspace来代替方法区，所以在此之后一般不会因为方法区空间不足而触发Full GC</li><li>通过Minor GC之后存活的对象大于之前每次晋升时老年代的平均可用空间时，会自动触发Full GC</li></ol><h4 id="stop-the-worldstw"><a class="markdownIt-Anchor" href="#stop-the-worldstw"></a> Stop-The-World（STW）</h4><p>STW意为停止全世界，对于JVM来说，它的世界里存活的都是一个个线程，所以意思也就是在进行GC时，会将虚拟机中其他的工作线程全部暂停，当GC结束之后，再继续恢复工作。</p><p>所以对于一个垃圾收集器来说，STW的时间是一个非常重要的性能指标，并且STW直接影响的是虚拟机的吞吐量（吞吐量 = 虚拟机运行时间 / (STW时间 + 虚拟机运行时间)），也就是STW时间越短，虚拟机吞吐量越高，执行效率越高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在学习JVM的GC相关知识时，必定会接触到几个GC的专有名词：Minor GC、Major GC、Young GC、Old GC、Full GC、Stop The World（STW），现在我们来了解一下这些名词具体指的是什么。&lt;/p&gt;
&lt;h4 id=&quot;minor-gc
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Synchronized作用在静态和非静态方法上的区别</title>
    <link href="http://luxiaowan.github.io/2020/05/09/Synchronized%E4%BD%9C%E7%94%A8%E5%9C%A8%E9%9D%99%E6%80%81%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://luxiaowan.github.io/2020/05/09/Synchronized作用在静态和非静态方法上的区别/</id>
    <published>2020-05-09T15:21:00.000Z</published>
    <updated>2020-05-10T14:33:04.503Z</updated>
    
    <content type="html"><![CDATA[<p>synchronized关键字的用法主要有以下几种：</p><ol><li><p>作用在非静态方法上</p><p>非静态方法是只能提供类的实例进行调用，所以实际上就是对调用方法的对象加锁，俗称对象锁</p></li><li><p>作用在静态方法上</p><p>静态方法是可以通过类名直接调用，所以实际上就是对调用方法的类加锁，俗称类锁</p></li><li><p>作用在代码块</p><p>根据传入的是类对象或类实例判断加锁方式</p></li></ol><h4 id="场景分析"><a class="markdownIt-Anchor" href="#场景分析"></a> 场景分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态同步方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncStaticClazz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static---method1--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static---method2--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static---method3--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非静态同步方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncNormalClazz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"normal---method1--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类级别的同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncNormalClazz.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"normal---method2--"</span> + Thread.currentThread());</span><br><span class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类级别的同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncNormalClazz.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"normal---method3--"</span> + Thread.currentThread());</span><br><span class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类实例级别的同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"normal---method4--"</span> + Thread.currentThread());</span><br><span class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>场景1</p><ul><li><p>描述：使用类对象在不同线程中访问不同的静态同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz.method1();</span><br><span class="line">&#125;, <span class="string">"ssc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz.method2();</span><br><span class="line">&#125;, <span class="string">"ssc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：静态同步方法的加锁范围是整个类，所以无论是使用对象或类去访问静态同步方法，锁都会加到类对象上。就好比是房子的大门，房子内不论有多少房间，只要有一个人打开大门进入到房子里，其他人就只能等他出来之后再进去，而已经进去的人拥有所有房间的使用权。</p></li></ul></li><li><p>场景2</p><ul><li><p>描述：在不同线程中用不同的类实例访问相同静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz c = <span class="keyword">new</span> SyncStaticClazz();</span><br><span class="line">    c.method1();</span><br><span class="line">&#125;, <span class="string">"ssc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz c = <span class="keyword">new</span> SyncStaticClazz();</span><br><span class="line">    c.method1();</span><br><span class="line">&#125;, <span class="string">"ssc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：和场景1相同，静态方法虽然可以被类实例访问，但锁依然是类锁</p></li></ul></li><li><p>场景3</p><ul><li><p>描述：同一个对象在不同线程中访问不同的非静态同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method1();</span><br><span class="line">&#125;, <span class="string">"snc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：非静态方法上加的是对象锁，当对象调用一个非静态的同步方法时，其他的非静态同步方法需要等待被执行。</p></li></ul></li><li><p>场景4</p><ul><li><p>描述：不同对象在不同线程中访问同一个非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method1();</span><br><span class="line">&#125;, <span class="string">"snc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method1();</span><br><span class="line">&#125;, <span class="string">"snc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：不互斥</p></li><li><p>解析：因为通过不同的对象调用的是非静态方法，虽然调用的是同一个方法，但是非静态方法加的锁是对象锁，针对的是对象并不是方法，所以可以并发执行，不会互斥。如果像场景1中的比喻的话，就是两个对象是两套房子，户型相同而已。</p></li></ul></li><li><p>场景5</p><ul><li><p>描述：不同对象在不同线程中访问同一个非静态非同步方法，方法内通过synchronized锁定代码块，且锁定对象为类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc3"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc4"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：因为方法<code>method2()</code>内的synchronized锁的是<code>SyncNormalClazz.class</code>，也就是锁定的是类对象，所以与场景2相同</p></li></ul></li><li><p>场景6</p><ul><li><p>描述：同一个对象在不同线程中访问不同的非静态非同步方法，方法内通过synchronized锁定代码块，且锁定对象为类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc2"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method3();</span><br><span class="line">&#125;, <span class="string">"snc3"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：因为方法<code>method2()</code>内的synchronized锁的是<code>SyncNormalClazz.class</code>，也就是锁定的是类对象，所以与场景2相同</p></li></ul></li><li><p>场景7</p><ul><li><p>描述：同一个对象在不同线程中访问不同方法，一个调用静态方法，一个调用非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncStaticClazz ssc = <span class="keyword">new</span> SyncStaticClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method2();</span><br><span class="line">&#125;, <span class="string">"ssc2"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method3();</span><br><span class="line">&#125;, <span class="string">"ssc3"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：不互斥</p></li><li><p>解析：虽然是同一个对象调用，但是两个方法的锁类型不同，静态方法是类锁，非静态方法是对象锁，所以不会互斥</p></li></ul></li><li><p>场景8</p><ul><li><p>描述：同一个对象在不同线程中访问不同synchronized代码块方法，一个调用类对象同步，一个调用类实例同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncNormalClazz ssc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method3();</span><br><span class="line">&#125;, <span class="string">"snc3"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method4();</span><br><span class="line">&#125;, <span class="string">"snc4"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：不互斥</p></li><li><p>解析：与场景8相同</p></li></ul></li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ul><li>对象锁仅锁当前对象，不同对象之间不会互斥</li><li>静态方法上的锁是类锁，非静态方法上的锁是对象锁</li><li>所有静态同步方法互斥，无论是通过类调用还是对象调用</li><li>静态方法上加synchronized与在非静态方法内加synchronized(Xxx.class)效果一致，都是类锁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;synchronized关键字的用法主要有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;作用在非静态方法上&lt;/p&gt;
&lt;p&gt;非静态方法是只能提供类的实例进行调用，所以实际上就是对调用方法的对象加锁，俗称对象锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作用在静态方法上&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM参数介绍</title>
    <link href="http://luxiaowan.github.io/2020/05/09/JVM%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
    <id>http://luxiaowan.github.io/2020/05/09/JVM参数介绍/</id>
    <published>2020-05-09T01:30:00.000Z</published>
    <updated>2020-05-09T03:54:43.355Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-jvm常用参数"><a class="markdownIt-Anchor" href="#1-jvm常用参数"></a> 1. JVM常用参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th><strong>默认值</strong></th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小</td><td></td><td>此处的大小是Eden + Survivor，和jmap -heap中显示的New Gen是不同的。 整个堆大小=年轻代大小 + 老年代大小 + 持久代大小(1.7及之前)，增大年轻代后，将会减小老年代大小，此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>年轻代大小</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td>jdk1.7及之前</td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td>jdk1.7及之前</td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5以后每个线程堆栈大小为1M，之前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右 一般小的应用， 如果栈不是很深， 应该是128k够用的，大的应用建议使用256k。</td></tr><tr><td>-XX:ThreadStackSize</td><td>Thread Stack Size</td><td></td><td></td></tr><tr><td>-XX:NewRatio</td><td>年轻代与老年代的比值</td><td></td><td>-XX:NewRatio=4表示年轻代与老年代所占比值为1:4，年轻代占整个堆栈的1/5，Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:LargePageSizeInBytes</td><td>内存页的大小不可设置过大， 会影响Perm的大小</td><td></td><td>=128m</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td>原始类型的快速优化</td><td></td><td></td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄</td><td>15</td><td>如果设置为0的话，则年轻代对象不经过Survivor区，直接进入老年代. 对于老年代比较多的应用，可以提高效率。此值默认为15，取值范围为0~15</td></tr><tr><td>-XX:+AggressiveOpts</td><td>加快编译</td><td></td><td></td></tr><tr><td>-XX:+UseBiasedLocking</td><td>锁机制的性能改善</td><td></td><td></td></tr><tr><td>-Xnoclassgc</td><td>禁用垃圾回收</td><td></td><td></td></tr><tr><td>-XX:SoftRefLRUPolicyMSPerMB</td><td>每兆堆空闲空间中SoftReference的存活时间</td><td>1s</td><td></td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效 另一种直接在旧生代分配的情况是大的数组对象，且数组中无外部引用对象.</td></tr><tr><td>-XX:+UseTLAB</td><td>开启TLAB</td><td></td><td>默认开启</td></tr><tr><td>-XX:TLABSize</td><td>TLAB大小</td><td></td><td>手动指定TLAB的大小</td></tr><tr><td>-XX:TLABWasteTargetPercent</td><td>TLAB占eden区的百分比</td><td>1%</td><td></td></tr><tr><td>-XX:TLABRefillWasteFraction</td><td>TLAB允许浪费的大小比例</td><td>64</td><td>默认TLAB空间的1/64空间</td></tr><tr><td>-XX:-ResizeTLAB</td><td>禁用ResizeTLAB</td><td></td><td></td></tr><tr><td>-XX:+CollectGen0First</td><td>FullGC时是否先YGC</td><td>false</td><td></td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>在发生OOM时到处堆栈信息</td><td></td><td></td></tr><tr><td>-XX:HeapDumpPath</td><td>堆栈信息输出地址</td><td></td><td></td></tr></tbody></table><h4 id="2-parallel收集器参数"><a class="markdownIt-Anchor" href="#2-parallel收集器参数"></a> 2. Parallel收集器参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th>说明</th></tr></thead><tbody><tr><td>-XX:+UseParallelGC</td><td>Full GC采用parallel MSC</td><td>选择垃圾收集器为并行收集器。此配置仅对年轻代有效，即上述配置下，年轻代使用并发收集，而老年代仍旧使用串行收集</td></tr><tr><td>-XX:+UseParNewGC</td><td>设置年轻代为并行收集</td><td>可与CMS收集同时使用，JVM会根据系统配置自行设置，所以无需再设置此值</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td>此值最好配置与处理器数目相等</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>老年代垃圾收集方式为并行收集(Parallel Compacting)</td><td></td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td>如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值.</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>自动选择年轻代区大小和相应的Survivor区比例</td><td>设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开.</td></tr><tr><td>-XX:GCTimeRatio</td><td>设置垃圾回收时间占程序运行时间的百分比</td><td>公式为1/(1+n)</td></tr><tr><td>-XX:+ScavengeBeforeFullGC</td><td>Full GC前调用YGC</td><td>=true</td></tr></tbody></table><h4 id="3-cms收集器参数"><a class="markdownIt-Anchor" href="#3-cms收集器参数"></a> 3. CMS收集器参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th>说明</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>使用Serial收集器</td><td>年轻代</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>使用CMS收集器</td><td></td></tr><tr><td>-XX:+AggressiveHeap</td><td></td><td>试图是使用大量的物理内存 长时间大内存使用的优化，能检查计算资源（内存， 处理器数量） 至少需要256MB内存 大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td></tr><tr><td>-XX:CMSFullGCsBeforeCompaction</td><td>多少次后进行内存压缩</td><td>由于CMS收集器不对内存空间进行压缩，整理，所以运行一段时间以后会产生&quot;碎片&quot;，使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩，整理.</td></tr><tr><td>-XX:+CMSParallelRemarkEnabled</td><td>降低标记停顿</td><td></td></tr><tr><td>-XX+UseCMSCompactAtFullCollection</td><td>在FULL GC的时候， 对老年代的压缩</td><td>CMS是不会移动内存的，会产生内存碎片， 增加这个参数可以消除碎片</td></tr><tr><td>-XX:+UseCMSInitiatingOccupancyOnly</td><td>使用手动定义初始化定义开始CMS收集</td><td>禁止hostspot自行触发CMS GC</td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction=70</td><td>使用cms作为垃圾回收 使用70％后开始CMS收集</td><td>=92。为了保证不出现promotion failed错误</td></tr><tr><td>-XX:CMSInitiatingPermOccupancyFraction</td><td>设置Perm Gen使用到达多少比率时触发</td><td>=92</td></tr><tr><td>-XX:+CMSIncrementalMode</td><td>设置为增量模式</td><td>用于单CPU情况</td></tr><tr><td>-XX:+CMSClassUnloadingEnabled</td><td></td><td></td></tr></tbody></table><h4 id="4-其他参数"><a class="markdownIt-Anchor" href="#4-其他参数"></a> 4. 其他参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th>说明</th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td>输出GC基本信息</td><td>输出形式：[GC (Allocation Failure)  1024K-&gt;612K(5632K)， 0.0021628 secs]</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出GC详细信息</td><td>输出形式：[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;492K(1536K)] 1024K-&gt;556K(5632K)， 0.0024829 secs] [Times: user=0.00 sys=0.00， real=0.00 secs]</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>在GC信息上输出系统运行时间</td><td>输出形式：0.185: [GC (Allocation Failure)  1620K-&gt;853K(5632K)， 0.0008322 secs]</td></tr><tr><td>-XX:+PrintGCApplicationStoppedTime</td><td>打印垃圾回收期间程序暂停的时间.可与上面混合使用</td><td>输出形式：Total time for which application threads were stopped: 0.0006927 seconds， Stopping threads took: 0.0000094 seconds</td></tr><tr><td>-XX:+PrintGCApplicationConcurrentTime</td><td>打印每次垃圾回收前，程序未中断的执行时间.可与上面混合使用</td><td>输出形式：Application time: 0.0183349 seconds</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>打印GC前后的详细堆栈信息，可单独使用</td><td></td></tr><tr><td>-Xloggc:filepath</td><td>把相关日志信息记录到文件以便分析. 与上面几个配合使用</td><td></td></tr><tr><td>-XX:+PrintClassHistogram</td><td>garbage collects before printing the histogram.</td><td>等同于jmap -histo</td></tr><tr><td>-XX:+PrintTLAB</td><td>查看TLAB空间的使用情况</td><td>输出：TLAB: gc thread: 0x00007fe8d4008800 [id: 3331] desired_size: 20KB slow allocs: 8  refill waste: 320B alloc: 0.99983     1024KB refills: 42 waste  0.5% gc: 0B slow: 4576B fast: 0B<br>TLAB totals: thrds: 1  refills: 42 max: 42 slow allocs: 8 max 8 waste:  0.5% gc: 0B max: 0B slow: 4576B max: 4576B fast: 0B max: 0B</td></tr><tr><td>-XX:+PrintTenuringDistribution</td><td>查看每次minor GC后新的存活周期的阈值</td><td>输出：Desired survivor size 524288 bytes， new threshold 5 (max 15)</td></tr></tbody></table><h4 id="5-常用配置"><a class="markdownIt-Anchor" href="#5-常用配置"></a> 5. 常用配置</h4><ul><li>堆设置<ul><li>-Xms：堆初始大小，-Xms10m</li><li>-Xmx：堆最大大小，-Xmx20m</li><li>-Xmn：新生代大小，-Xmn5m：NewSize=MaxNewSize=5m</li><li>-XX:NewSize：新生代初始大小 ，-XX:NewSize=5m</li><li>-XX:MaxNewSize：新生代最大大小，-XX:MaxNewSize=10m</li><li>-XX:NewRatio：新生代和老年代大小比值，-XX:NewRatio=4：新生代和老年代比值为1:4，新生代占堆的1/5</li><li>-XX:ServivorRatio：新生代中Eden和Survivor大小比值，-XX:SurvivorRatio=8：Eden和Survivor的比例为2:8，一个Survivor区占整个新生代大小的1/10</li><li>-XX:MaxTenuringThreshold：新生代对象转移到老年代的年龄，默认为15，值域0~15，设置为0的话就表示新生代对象从Eden不经过Survivor区而直接转移到老年代，-XX:MaxTenuringThreshold=10：新生代对象年龄达到10时，也就是经历10次YGC之后，转移到老年代</li></ul></li><li>垃圾收集器设置<ul><li>-XX:+UseSerialGC：新生代使用Serial收集器，可与CMS和Serial Old搭配使用</li><li>-XX:+UseParNewGC：新生代使用ParNew收集器</li><li>-XX:+UseParallelGC：新生代使用Parallel Scavenge收集器<ul><li>-XX:+ParallelGCThreads：设置并行收集器收集时使用的线程数，可以设置为CPU个数，-XX:+ParallelGCThreads=8：使用8个线程进行垃圾收集</li><li>-XX:MaxGCPauseMillis：设置并行收集的最大暂停时间，-XX:MaxGCPauseTime=20，单位：毫秒</li><li>-XX:GCTimeRatio：设置垃圾回收占用运行时间的百分比，-XX:GCTimeRatio=9：垃圾回收占用总运行时间的1/10</li></ul></li><li>-XX:+UseParallelOldGC：老年代使用Parallel Old收集器</li><li>-XX:+UseConcMarkSweepGC：老年代使用CMS收集器<ul><li>-XX:+CMSIncrementalMode：设置为增量模式，适用于单CPU环境</li><li>-XX:+UseCMSCompactAtFullCollection：在发生FGC时对老年代进行压缩</li><li>-XX:CMSFullGCsBeforeCompaction：设置在多少次FGC后，对老年代进行压缩，依赖于-XX:+UseCMSCompactAtFullCollection，-XX:CMSFullGCsBeforeCompaction=5：5次FGC后对老年代进行压缩</li></ul></li><li>-XX:+UseSerialOldGC：老年代使用Serial Old收集器</li></ul></li><li>垃圾收集信息<ul><li>-XX:+PrintGC：输出GC信息</li><li>-XX:+PrintGCDetails：输出GC详细信息</li><li>-XX:+PrintGCTimeStamps：输出GC执行时间点（虚拟机启动之后的时间点）</li><li>-Xloggc:filepath：将GC信息输出到某个文件中，不在控制台输出</li></ul></li><li>TLAB设置<ul><li>-XX:+UseTLAB：启用TLAB</li><li>-XX:+PrintTLAB：输出TLAB使用信息</li><li>-XX:-ResizeTLAB：禁用resizeTLAB</li><li>-XX:TLABSize：指定TLAB大小</li><li>-XX:TLABWasteTargetPrecent：设置TLAB空间占Eden区的比例大小，默认为1%</li><li>-XX:TLABRefillWasteFraction：设置TLAB空间允许被浪费的最大空间比例，默认TLAB空间的1/64空间</li></ul></li><li>OOM设置<ul><li>-XX:+HeapDumpOnOutOfMemoryError：当发生OOM时自动生成堆栈信息</li><li>-XX:HeapDumpPath：当发生OOM时堆栈信息文件输出路径，-XX:HeapDumpPath=/var/data/heapd/</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-jvm常用参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-jvm常用参数&quot;&gt;&lt;/a&gt; 1. JVM常用参数&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;参数名称&lt;/strong&gt;&lt;/th&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>J.U.C之Condition详解</title>
    <link href="http://luxiaowan.github.io/2020/05/08/J.U.C%E4%B9%8BCondition%E8%AF%A6%E8%A7%A3/"/>
    <id>http://luxiaowan.github.io/2020/05/08/J.U.C之Condition详解/</id>
    <published>2020-05-07T16:44:00.000Z</published>
    <updated>2020-05-08T16:36:57.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-由一道算法题开聊"><a class="markdownIt-Anchor" href="#一-由一道算法题开聊"></a> 一、由一道算法题开聊</h3><p>我们提供一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      System.out.print(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      System.out.print(<span class="string">"bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个不同的线程将会共用一个<code>FooBar</code>实例。其中一个线程将会调用<code>foo()</code>方法，另一个线程将会调用<code>bar()</code>方法。请设计修改程序，以确保 “foobar” 被输出 n 次。</p><p><strong>示例 1:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">1</span></span><br><span class="line">输出: <span class="string">"foobar"</span></span><br><span class="line">解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 <span class="keyword">bar() </span>方法，<span class="string">"foobar"</span> 将被输出一次。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="symbol">:</span> <span class="built_in">n</span> = <span class="number">2</span></span><br><span class="line">输出<span class="symbol">:</span> <span class="string">"foobarfoobar"</span></span><br><span class="line">解释<span class="symbol">:</span> <span class="string">"foobar"</span> 将被输出两次。</span><br></pre></td></tr></table></figure><hr><ul><li><em><strong>解析1</strong></em>——方法互调</li></ul><p>由题意可以知道，两个线程分别调用foo()和bar()方法，按照输出要求需要使的foo()方法在bar()方法之前执行，这样我们能否在foo()方法中调用bar()方法，然后再bar()方法中调用foo()方法？我们试一下，修改代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>     n;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      System.out.print(<span class="string">"foo"</span>);</span><br><span class="line">      bar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      System.out.print(<span class="string">"bar"</span>);</span><br><span class="line">      foo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   FooBar fooBar = <span class="keyword">new</span> FooBar(<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">new</span> Thread(() -&gt; fooBar.foo()).start();</span><br><span class="line">   <span class="keyword">new</span> Thread(() -&gt; fooBar.bar()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="/images/image-20200508010813617.png" alt="image-20200508010813617" style="zoom: 40%;"><p>发生了栈溢出，这是因为我们在两个方法之间互相调用，不断的将方法压入栈中，最终造成栈溢出，整个过程如下：</p><img src="/images/image-20200508012241430.png" alt="image-20200508012241430" style="zoom:40%;"><p>可见此办法不可行。</p><ul><li><em><strong>解析2</strong></em>——循环阻塞</li></ul><p>使用一个临时变量来控制方法的执行进度，然后通过死循环来临时中断方法的执行，修改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;&#125;</span><br><span class="line">            System.out.print(<span class="string">"foo"</span>);</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;&#125;</span><br><span class="line">            System.out.print(<span class="string">"bar"</span>);</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">foobarfoobar</span></span><br></pre></td></tr></table></figure><p>好像执行成功了，但是当我们把<code>n</code>放大时，会出现两个线程都进入到while循环之中，之所以出现这种情况是因为变量<code>flag</code>在线程之间出现了数据不同步的问题。针对这个问题，Java提供了关键字<code>volatile</code>来保证变量在线程之间的修改同步，这里就不介绍volatile了，只要我们把变量flag修改为<code>private volatile boolean flag = true;</code>即可解决。</p><ul><li><em><strong>解析3</strong></em>——Lock+Condition+临时变量</li></ul><p>以上方案我们都没有使用到锁，因为题目已经定义好了方法，所以我们给方法加<code>synchronized</code>方案不可取，并且我们在输出的时候要保证foo()方法先执行，仅通过<code>synchronized</code>来保证顺序，实现上有些困难，所以我们采用J.U.C包下的Lock类，通过Condition类来控制方法的执行和等待，然后通过一个临时变量<code>flag</code>控制方法的执行顺序，修改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>       n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock      lock      = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>   flag      = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printFoo.run();</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printBar.run();</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">foobarfoobar</span></span><br></pre></td></tr></table></figure><p>此方案中的参数flag并没有被<code>volatile</code>关键字修饰，且未出现方案2中的修改不同步的问题，这是因为我们在修改flag的时候被加锁了，所以同时只能被一个线程修改。在for循环中通过while循环来控制线程的状态，这里其实只要判断flag的值来决定是否需要将线程挂起，那么我们用if来判断是否可以？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>       n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock      lock      = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>   flag      = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"foo"</span>);</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"bar"</span>);</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果正常，所以这里我们不论是用while还是用if都可以，只要控制好flag的值即可。</p><h3 id="二-condition概述"><a class="markdownIt-Anchor" href="#二-condition概述"></a> 二、Condition概述</h3><p>在上述方案3中，我们使用到了Lock和Condition两个类，Lock我们都知道，它是控制多线程访问共享资源的一个工具，此类在jdk1.5之后提供，它在使用上有几个原则：</p><ul><li>要访问共享资源，必须先获得锁</li><li>同一时刻只能有一个线程获取到锁</li><li>一般情况下Lock是排它锁</li><li>但是也可以使用ReadWriteLock对共享资源进行并发访问</li></ul><p>Lock的使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//TODO 访问共享资源</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//释放锁</span></span><br><span class="line">      l.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁.调用该方法的线程会得到锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可中断的获取锁，该方法可以响应中断(可以中断当前线程)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试非阻塞地获取锁</span></span><br><span class="line"><span class="comment">     * 调用后方法立即返回:</span></span><br><span class="line"><span class="comment">     *如果能正常获取到锁，则立即返回true</span></span><br><span class="line"><span class="comment">     *如果没能正常获取到锁，则立即返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定的超时时间内获取锁</span></span><br><span class="line"><span class="comment">     * 如果锁可以立即获得，则直接返回true，否则，在以下三种情况下会返回:</span></span><br><span class="line"><span class="comment">     * 1. 在指定的超时时间内获取到了锁(true)</span></span><br><span class="line"><span class="comment">     * 2. 在指定的超时时间内线程被interrupt()了(false)</span></span><br><span class="line"><span class="comment">     * 3. 超时(false)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回和当前Lock对象绑定的Condition实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jdk1.5之前，我们如果想要实现线程的等待和恢复只能通过Object的相关wait和notify方法与synchronized关键字配合使用，Object类中提供的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object.wait()</span><br><span class="line">java.lang.Object.wait(<span class="keyword">long</span>)</span><br><span class="line">java.lang.Object.wait(<span class="keyword">long</span>, <span class="keyword">int</span>)</span><br><span class="line">java.lang.Object.notify()</span><br><span class="line">java.lang.Object.notifyAll()</span><br></pre></td></tr></table></figure><p>而从jdk1.5开始，我们通过<code>java.util.concurrent.locks.Condition</code>接口来替代Object来实现类似功能。在整个juc中的锁世界中，AQS是所有锁的基础，主要的实现在AQS中的ConditionObject类，ConditionObject的等待队列是一个FIFO队列，队列的每个节点都是等待在Condition对象上的线程的引用，在调用Condition的await()方法之后，线程释放锁，构造成相应的节点进入等待队列等待</p><p>Condition源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使当前线程进入等待状态并释放锁，直到接收到唤醒信号或线程被中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使当前线程进入等待状态并释放锁，直到接收到唤醒信号，</span></span><br><span class="line"><span class="comment">     * 如果在等待过程中线程被中断，此方法会继续执行，线程扔处于等待状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和wait()方法相同，但是在等待时间（纳秒）内未收到通知，则终止等待并返回0或负数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和wait()方法相同，但是在等待时间（指定时间和单位）内未收到通知，则终止等待并返回0或负数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和wait()方法相同，但是在指定某个时间点未收到通知，则终止等待并返回0或负数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唤醒一个在await()等待队列中的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唤醒所有在await()等待队列中的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-由一道算法题开聊&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-由一道算法题开聊&quot;&gt;&lt;/a&gt; 一、由一道算法题开聊&lt;/h3&gt;
&lt;p&gt;我们提供一个类：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>统计Java代码行数</title>
    <link href="http://luxiaowan.github.io/2020/05/05/%E7%BB%9F%E8%AE%A1Java%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/"/>
    <id>http://luxiaowan.github.io/2020/05/05/统计Java代码行数/</id>
    <published>2020-05-05T06:13:00.000Z</published>
    <updated>2020-05-05T06:15:17.718Z</updated>
    
    <content type="html"><![CDATA[<p>统计Java应用中的代码行数，仅除去注释，非有效代码行数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeStatics</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 总文件数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sumFile = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 总行数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sumLine = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeStatics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计代码行数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inFile</span></span><br><span class="line"><span class="comment">     *            输入的文件，包含子文件和子文件夹</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bw</span></span><br><span class="line"><span class="comment">     *            缓冲输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">codeStatics</span><span class="params">(File inFile, BufferedWriter bw)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (File file : inFile.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">".java"</span>)) &#123;<span class="comment">//为java 文件时</span></span><br><span class="line">                <span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file), <span class="string">"utf-8"</span>));<span class="comment">//以utf-8 格式读入，若文件编码为gkb 则改为gbk</span></span><br><span class="line">                String s = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    s = s.replaceAll(<span class="string">"\\s"</span>, <span class="string">""</span>);<span class="comment">// \\s表示 空格,回车,换行等空白符,</span></span><br><span class="line">                    <span class="comment">// 将空白符替换为空字符""</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">""</span>.equals(s) || s.startsWith(<span class="string">"//"</span>) || s.startsWith(<span class="string">"/*"</span>) || s.startsWith(<span class="string">"/**"</span>)</span><br><span class="line">                            || s.startsWith(<span class="string">"*"</span>)) &#123;<span class="comment">//过滤掉注释</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        line++;</span><br><span class="line">                        System.out.println(line + <span class="string">"："</span> + s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                br.close();<span class="comment">//关闭读入流</span></span><br><span class="line">                System.out.println(file.getName() + <span class="string">"\t\t"</span> + line);<span class="comment">// \t制表符(TAB)</span></span><br><span class="line"></span><br><span class="line">                bw.newLine();<span class="comment">// 写入换行符</span></span><br><span class="line">                bw.write(file.getName() + <span class="string">"\t\t"</span> + line);<span class="comment">// 写入类名称</span></span><br><span class="line">                bw.newLine();<span class="comment">// 换行</span></span><br><span class="line">                bw.flush();<span class="comment">// 把缓冲区的数据强行写出</span></span><br><span class="line"></span><br><span class="line">                sumFile++;</span><br><span class="line">                sumLine += line;</span><br><span class="line">                System.out.println(<span class="string">"统计:"</span> + sumFile + <span class="string">"个类\t"</span> + sumLine + <span class="string">"行"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isDirectory()) &#123;<span class="comment">// 当file 为目录时，递归遍历</span></span><br><span class="line"></span><br><span class="line">                codeStatics(file, bw);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File inFile = <span class="keyword">new</span> File(<span class="string">"/Users/cc/Documents/projects/project/demo"</span>);<span class="comment">// 要统计的项目</span></span><br><span class="line">            FileOutputStream ps = <span class="keyword">new</span> FileOutputStream(<span class="string">"/Users/cc/Documents/result.txt"</span>);<span class="comment">// 将统计结果输出到txt文件</span></span><br><span class="line">            BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(ps, <span class="string">"utf-8"</span>));</span><br><span class="line">            bw.write(<span class="string">"类名\t\t行数"</span>);</span><br><span class="line"></span><br><span class="line">            codeStatics(inFile, bw);<span class="comment">// 递归入口</span></span><br><span class="line"></span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.write(<span class="string">"一共："</span> + sumFile + <span class="string">"个类\t\t"</span> + sumLine + <span class="string">"行代码！"</span>);</span><br><span class="line"></span><br><span class="line">            bw.flush();</span><br><span class="line">            bw.close();<span class="comment">//关闭输出流</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;统计Java应用中的代码行数，仅除去注释，非有效代码行数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器介绍</title>
    <link href="http://luxiaowan.github.io/2020/05/02/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://luxiaowan.github.io/2020/05/02/JVM垃圾收集器介绍/</id>
    <published>2020-05-02T08:30:00.000Z</published>
    <updated>2020-05-06T17:01:17.377Z</updated>
    
    <content type="html"><![CDATA[<p>曾经看到过一句话：如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。目前商业化虚拟机中常用的垃圾收集器有8种：新生代：Serial、ParNew、Parallel Scavenge，老年代：CMS、Serial Old、Parallel Old，整堆：G1、ZGC。</p><img src="/images/image-20200506000424241.png" alt="image-20200506000424241" style="zoom:50%;"><p>图中连线的两个收集器是可以搭配使用，其所处区域表示收集器的作用域。</p><h4 id="1-垃圾收集器运行方式"><a class="markdownIt-Anchor" href="#1-垃圾收集器运行方式"></a> 1. 垃圾收集器运行方式</h4><p>垃圾收集器在运行方式上又细分为串行、并行、并发三种。</p><ul><li>串行收集器：GC线程和其他用户线程是串行的，也就是在进行垃圾回收的时候，其他的线程需要排队等待，直到收集器的线程完成工作，这类收集器停顿时间长、吞吐量低，适用于单C机器使用，使用JVM参数<code>-XX:+UseSerialGC</code>开启，</li><li>并行收集器是采用多线程串行的方式进行垃圾回收，适用于多C机器，在多个线程执行垃圾检测回收时，可能会因为线程之间竞争CPU资源而发生长时间的停顿，体验极差，不推荐使用，可以使用JVM参数<code>-XX:+UseParallelGC</code>、<code>-XX:+UseParallelOldGC</code>开启，并且可以使用<code>-XX:ParallelGCThreads=&lt;thread_nums&gt;</code>指定GC的线程数量，一般不要高于CPU数量，否则就容易gg；是jdk1.8中默认使用的垃圾收集器；</li><li>并发收集器是目前使用较多的一类收集器，与并行收集器不同的是它采用多个线程并行执行去进行垃圾检测和回收，停顿时间短，吞吐量大，可以使用JVM参数<code>-XX:+UseConcMarkSweepGC</code>开启，可以搭配<code>-XX:+UseParNewGC</code>一同使用；</li></ul><h4 id="2-吞吐量"><a class="markdownIt-Anchor" href="#2-吞吐量"></a> 2. 吞吐量</h4><p>说到垃圾收集就不得不提吞吐量这个概念，吞吐量是指用户代码运行时间与虚拟机总运行时间的比值：吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，比如虚拟机总共运行了100分钟，期间进行了一次垃圾收集，耗时0.01分钟，那么吞吐量就是99.99%。</p><p>吞吐量越高则表示GC总耗时越少，服务性能则越高。</p><h4 id="3-gc类型"><a class="markdownIt-Anchor" href="#3-gc类型"></a> 3. GC类型</h4><ol><li><p>Minor GC：也叫作Young GC，只作用于新生代</p><p>我们知道新生代分为一个Eden区和两个Survivor区，常规对象被创建之后都会有限分配到Eden区，但是Eden区的空间大小是有限的，当Eden可用空间不足时，就会触发Minor GC，Minor GC之后在Eden区仍存活的对象会被移动到Survivor区。</p><p>在发生Minor GC时，Eden区和Survivor的from区存活的对象全部被复制到当前Survivor的to区，然后将Survivor的from和to区指针互换。</p><ul><li><p>在发生Minor GC的时候，若from区内对象年龄达到了晋升老年代的条件<code>-XX:MaxTurningThreshold</code>，则将这部分对象转移到老年代；</p></li><li><p>若在Minor GC后，Eden区和Survivor的from区存活对象的总空间大于Survivor的to区的大小，则优先将对象复制到to区，待to区存满之后，将剩余的对象转移到老年代，这叫过早提升。</p></li></ul></li><li><p>Old GC：只有CMS的concurrent collection这个模式，只作用于老年代</p><p>CMS是一款基于并发、使用标记清楚算法的垃圾收集算法， 只针对老年代进行垃圾回收，</p></li><li><p>Mixed GC：混合GC模式，同时收集新生代和老年代，目前只有G1是这种模式</p></li><li><p>Full GC：收集整个堆，包括新生代、老年代和永久代(Metaspace)</p></li></ol><h4 id="4-垃圾收集器介绍"><a class="markdownIt-Anchor" href="#4-垃圾收集器介绍"></a> 4. 垃圾收集器介绍</h4><h6 id="新生代收集器"><a class="markdownIt-Anchor" href="#新生代收集器"></a> 新生代收集器</h6><ul><li><p>Serial收集器</p><p>Serial收集器是初代收集器，历史最为悠久。它是一个采用了复制算法的单线程收集器，非常适用于单个CPU的环境，它会导致STW（Stop The World），在进行垃圾收集时必须暂停其他所有的工作线程，直至垃圾收集结束为止。收集工作由虚拟机在后台自动发起和完成，用户不可见。由于每次垃圾回收时都要暂停，若垃圾对象过多，那么进程暂停时间可能过长，这对很多应用来说是很不能接受的。</p><p>Serial收集器的运行过程（Serial + Serial Old）：</p><p><img src="/images/image-20200505034217123.png" alt="image-20200505034217123"></p><p>Serial可以与老年代的CMS和Serial Old收集器配合工作，可以使用JVM参数<code>-XX:+UseSerialGC</code>开启。</p><p>🌰：<code>java -jar -XX:+UseSerialGC -XX:+UseConcMarkSweepGC xxx.jar</code></p></li><li><p>ParNew收集器</p><p>ParNew是Serial的多线程版本，拥有Serial的所有功能（控制参数、收集算法、STW、对象分配规则、回收策略等），可以与老年代的CMS和Serial Old收集器配合工作。</p><p>在单CPU环境中，ParNew不会比Serial更高效；在多CPU环境下，随着CPU的数量增加，GC线程数增加，STW的时间会大大缩小。</p><p>ParNew默认开启的GC线程数与CPU的数量相同，可以使用JVM参数<code>-XX:+UseParNewGC</code>开启，并可以使用JVM参数<code>-XX:ParallelGCThreads</code>指定GC线程数</p><p>ParNew收集器的运行过程（ParNew + Serial Old）：</p><p><img src="/images/image-20200505034308215.png" alt="image-20200505034308215"></p><p>🌰：<code>java -jar -XX:+UseParNewGC -XX:ParallelGCThreads=2 -XX:+UseConcMarkSweepGC xxx.jar</code></p></li><li><p>Parallel Scavenge收集器</p><p>Parallel Scavenge收集器是一款并行的多线程新生代收集器，也是使用的复制算法，强关注吞吐量， 高吞吐量可以更高效的利用CPU，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。吞吐量=运行用户代码时间/(运行用户代码时间+GC时间)。</p><p>Parallel Scavenge是jdk1.8的默认新生代垃圾收集器，只能与老年代的Serial Old和Parallel Old两款收集器配合工作，不可与CMS搭配使用。</p><p>收集器通过JVM参数<code>-XX:MaxGCPauseMillis</code>和<code>-XX:GCTimeRatio</code>来控制最大GC停顿时间及吞吐量大小，另外还可以使用JVM参数<code>-XX:+UseAdaptiveSizePolicy</code>打开GC自适应调节策略。</p><ul><li><code>-XX:MaxGCPauseMillis</code>：参数值必须大于0，单位毫秒，但是这个值只能提醒收集器尽可能的保证在这个毫秒内完成GC，并不能一定保证每次GC都在这个时间内，系统会动态调小新生代内存，并缩小GC间隔，以降低吞吐量来保证STW的时间。为什么说是降低吞吐量，因为GC频率高了，GC总时间就长了，所以吞吐量就低了。</li><li><code>-XX:GCTimeRatio</code>：参数值范围是0~100的整数，表示GC总时间占虚拟机运行时间的比率，比如将值设置为49，那么允许的最大GC时间占总时间的2%（1/(1+49)）。</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：GC自适应调节策略，当打开这个参数之后，就不需要指定新生代的大小(<code>-Xmn</code>)、Eden与Survivor的比例(<code>-XX:SurvivorRatio</code>)、晋升了老年代对象年龄(<code>-XX:PretenureSizeThreshold</code>)等参数，虚拟机会根据当前虚拟机的运行情况收集性能监控信息，动态调整这些参数寻找最优的停顿时间和吞吐量。</li></ul></li></ul><h6 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h6><p>从上文中我们发现新生代的三个GC收集器都是使用的复制算法，这样可以提高回收效率，并且这也是以新生代的区域划分为基础的，我们知道新生代分为1个Eden区和2个Survivor区，每次Minor GC之后都会将Eden区存活的对象复制到Survivor区，然后将Survivor的from区存活的对象复制到to区，然后清空Eden和Survivor的from区，将Survivor的to区和from区切换身份，所以使用复制算法简单高效。</p><h6 id="老年代收集器"><a class="markdownIt-Anchor" href="#老年代收集器"></a> 老年代收集器</h6><ul><li><p>CMS收集器</p><p>CMS(Concurrent Mark Sweep)收集器是一款以获取最短回收停顿时间为目标的收集器，注重虚拟机的响应速度，收集器基于“标记-清除”算法，特别容易产生内存碎片。</p><p>CMS收集器工作流程大概分为以下4个步骤：</p><ol><li>初始化标记（CMS initial mark）：会导致STW，仅仅只标记一下存活对象（从GC Roots能直接关联到的对象）</li><li>并发标记（CMS Concurrent mark）：不会STW，进行GC Roots Tracing的过程，耗时最长</li><li>重新标记（CMS remark）：会导致STW，再次标记主要是修正并发标记期间因为用户线程运行而导致标记的对象发生的变动，这一阶段的停顿时间也较长，但是比并发标记短很多</li><li>并发清除（CMS Concurrent Sweep）</li></ol><p><img src="/images/image-20200505040204157.png" alt="image-20200505040204157"></p><ul><li>优点<ol><li>并发收集</li><li>低停顿</li></ol></li><li>缺点<ol><li>对CPU资源敏感</li><li>无法处理浮动垃圾</li><li>会产生内存碎片</li></ol></li></ul></li><li><p>Serial Old收集器</p><p>Serial Old是Serial收集器的老年代收集器，它是一个单线程收集器，使用“标记-整理”算法，起初此款收集器主要用于client模式下的虚拟机，在server模式下，可以与新生代的Parallel Scavenge收集器搭配使用，并且也可以作为CMS收集器的备用方案，在发生Concurrent Mode Failure时自动切换到Serial Old收集器。</p><p>工作流程与Serial相同，Serial+Serial Old：</p><p><img src="/images/image-20200505034217123.png" alt="image-20200505034217123"></p></li><li><p>Parallel Old收集器</p><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在jdk1.6才开始出现，在此之前如果新生代使用Parallel Scavenge收集器的话，老年代就只能选择Serial Old这一个收集器，而在Parallel Old出现之后，在注重吞吐量以及CPU资源敏感的场景下，都可以优先考虑Parallel Scavenge+Parallel Old</p></li></ul><h6 id="整堆收集器"><a class="markdownIt-Anchor" href="#整堆收集器"></a> 整堆收集器</h6><p>说到整堆收集器就只有说说G1收集器了，G1收集器具有并行与并发、分代收集、空间整合和可预测的停顿等特点。</p><ul><li>收集器既并行又并发，能够充分利用多CPU，缩短STW的停顿时间</li><li>因为G1能够管理整个堆，而不需要和其他的收集器搭配使用，虽然依然采用了分代模式，但它把堆分成了大小相等的若干个独立区域，相邻区域很可能是一个是新生代，一个是老年代。</li><li>整个过程中不会产生内存碎片，整体使用的“标记-整理”算法，局部使用的是复制算法，这两种算法都不会产生内存碎片，适合长时间运行。</li><li>低停顿的同时实现高吞吐量；G1除了追求低停顿处，还能建立可预测的停顿时间模型；可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒</li></ul><h4 id="5-减少gc次数的手段"><a class="markdownIt-Anchor" href="#5-减少gc次数的手段"></a> 5. 减少GC次数的手段</h4><ol><li>对象不使用时将其置为null</li><li>尽量不用System.gc()</li><li>尽量少用静态变量</li><li>使用StringBuffer代替String拼装字符串</li><li>分散对象创建和删除的时间</li><li>尽量少勇finallize方法</li><li>使用基本类型替代基本类型封装类</li><li>加大堆内存</li><li>慎用软引用、弱引用和虚引用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;曾经看到过一句话：如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。目前商业化虚拟机中常用的垃圾收集器有8种：新生代：Serial、ParNew、Parallel Scavenge，老年代：CMS、Serial Old、Parallel Old，整
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://luxiaowan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集算法浅谈</title>
    <link href="http://luxiaowan.github.io/2020/05/02/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%B5%85%E8%B0%88/"/>
    <id>http://luxiaowan.github.io/2020/05/02/JVM垃圾收集算法浅谈/</id>
    <published>2020-05-02T03:15:00.000Z</published>
    <updated>2020-05-09T14:40:10.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>JVM是做Java的同学都必须要了解的东西，为什么这么说，因为我们只有知道了Java程序运行环境的配置和工作逻辑，才能对运行环境进行相关的优化和配置修改，让JVM在不同的服务器环境使用不同的配置，从而达到JVM环境最优化。</p><p>说到JVM就不得不说一下GC（garbage collection），垃圾收集的意思是找到垃圾对象并回收掉它们，然后释放这些对象占用的内存。但是常规的垃圾收集器基本是找到正在被使用的对象，然后把其他的对象全部当作是垃圾对象清理掉。</p><p>写过C语言的同学都知道，在C语言中，我们需要手动的去管理内存，在使用内存之前我们需要先申请（malloc）一定大小的内存，使用完成之后需要手动的把使用的内存释放掉（free），如果忘记释放内存则很快会导致内存溢出。而Java将这份操作内存的工作交给了JVM，减少开发者的编码复杂度，降低发生内存溢出的概率。</p><h2 id="gc算法"><a class="markdownIt-Anchor" href="#gc算法"></a> GC算法</h2><ol><li><p>引用计数法</p><p>为每个对象添加一个引用计数器，在对象被引用时，计数器+1，引用结束后，计数器-1，最终清除掉引用计数器为0的对象，并级联删除该对象引用的所有的对象，只保留引用计数不为0的对象。</p><p>这种算法看起来是不是很屌，是的，非常简单，只需要在对象被引用的时候串行修改引用计数器的值即可，但也容易出现一种问题：循环引用！循环引用就是几个废对象之间循环引用，尽管他们的引用计数器都不为0，但是在整个程序中却没有被使用，但是他们永远不会被回收，这样的对象多了之后很容易造成内存泄漏。</p><img src="/images/image-20200506220501980.png" alt="image-20200506220501980" style="zoom:50%;"><p>正是因为循环引用的存在，JVM放弃了使用引用计数法。</p></li><li><p>标记-清除</p><p>标记-清理算法的基本思想是先STW，然后将存活的对象标记出来，接着清理掉未被标记的对象，整个过程都需要STW，效率很低，并且如果未被标记的对象比较分散，那么垃圾对象在被清理之后会造成大量的堆内存碎片，最终会导致无法给大对象分配内存。</p><img src="/images/image-20200506223517154.png" alt="image-20200506223517154" style="zoom:50%;"></li><li><p>标记-整理</p><p>标记-整理算法和标记-清除算法类似，只不过比标清多了一个步骤：在将所有存活的对象标记并清除完成之后，会将尚存活的对象全部都移动到堆内存的一端，并更新引用存活对象的指针。</p><img src="/images/image-20200506225506971.png" alt="image-20200506225506971" style="zoom:50%;"><p>引用指针更新：</p><img src="/images/image-20200506225749565.png" alt="image-20200506225749565" style="zoom:50%;"><p>标记-整理算法解决了标记-清除会造成内存碎片的缺点</p></li><li><p>复制</p><p>复制算法使用频率较高，算法思想也比较前倾，主要思想是将内存划分为相等大小的两块，每次只使用其中一块，当这一块内存不足时，就将其中存活的对象复制到另外一块内存中，且从其一端排列，并更新对象的引用指针，当存活对象全部都复制完成之后，将这块内存清空，然后激活被复制的这块内存空间，此后新创建的对象均分配到这块内存中，直到这块内存不足，重复使然。</p><p>复制算法将内存分为两块，每次只能使用其中一块，所以在使用过程中会一直浪费一半的内存无法使用，当虚拟机内存较小时，会频繁的发生GC，目前仅被使用在回收新生代内存。</p><img src="/images/image-20200506232601238.png" alt="image-20200506232601238" style="zoom:50%;"></li><li><p>可达性分析法</p><p>可达性的思想是通过一批“GC Roots”的对象作为起点，然后依次向下遍历，遍历到的对象均视为是存活的，遍历所走过的路径称为是引用链，最终将未遍历到的对象全部回收。</p><img src="/images/image-20200507003626531.png" alt="image-20200507003626531" style="zoom:50%;"><p>算法的本质是通过“GC Roots”找出所有存活的对象，然后把其他的对象全部认定为“垃圾对象”（这里有很多人认为是找到垃圾对象并回收，这是错误的）。此算法最重要的一步就是必须能够枚举出所有的“GC Roots”，否则就可能会将还存活的对象回收掉。</p><p>虚拟机内存中可以作为“GC Roots”的对象有以下几种：</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中的静态变量引用的对象</li><li>方法区中常量引用的对象</li></ul><p>在实际的开发中要特别注意这些对象，不要让无关紧要的大对象浪费了资源。</p></li><li><p>分代收集</p><p>根据对象的生存周期将内存划分为不同的区域，目前较流行的是分为新生代和老年代，然后根据各个年代的特点采用最适合的收集算法</p><ul><li>新生代：大部分对象都是朝生夕死，每次进行GC时都会被回收掉大量的对象，只有少量的对象会存活下来，这种适合复制算法，将新生代内存再划分为Eden区和两个Survivor区，Eden到Survivor和Survivor之间均采用复制算法，Eden区比较大，适合存储大量生命周期较短的对象，YGC后存活下来的少量对象被复制到Survivor区，Survivor区很小，每次复制仅需要付出少量存活对象的复制成本就可以完成收集</li><li>老年代中存储的对象大多是经历了多次GC之后存活下来的，并且还会存储部分大对象，这类对象被回收的概率较小，频次也较低，并且没有额外的内存空间为这块内存中的对象做分配担保，所以这个空间不应该出现内存碎片，否则很快就会没有内存可分配给新进入的对象，所以此块内存适用于“标记-整理”算法进行回收。</li></ul><img src="/images/image-20200509223555901.png" alt="image-20200509223555901" style="zoom:50%;"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;JVM是做Java的同学都必须要了解的东西，为什么这么说，因为我们只有知道了Java程序运行环境的配置和工作逻辑，才能对运行环境进行相关的优化和
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="GC" scheme="http://luxiaowan.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>MacBook突然没了声音</title>
    <link href="http://luxiaowan.github.io/2020/05/02/MacBook%E7%AA%81%E7%84%B6%E6%B2%A1%E4%BA%86%E5%A3%B0%E9%9F%B3/"/>
    <id>http://luxiaowan.github.io/2020/05/02/MacBook突然没了声音/</id>
    <published>2020-05-01T18:10:00.000Z</published>
    <updated>2020-05-02T07:49:49.276Z</updated>
    
    <content type="html"><![CDATA[<p>甭想了，这是Mac OS X的一个bug，可以通过重启解决，但是重启大法毕竟是不到万不得已的时候才使用的。</p><ol><li>打开活动监视器（不知道咋打开的就在【应用程序】中搜吧）</li><li>在活动监视器中搜索audio，然后找到coreaudiod，点击退出</li><li>退出之后会自动重启，然后就好了</li></ol><p><img src="/images/image-20200502021755810.png" alt="image-20200502021755810"></p><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo killall coreaudiod</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;甭想了，这是Mac OS X的一个bug，可以通过重启解决，但是重启大法毕竟是不到万不得已的时候才使用的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开活动监视器（不知道咋打开的就在【应用程序】中搜吧）&lt;/li&gt;
&lt;li&gt;在活动监视器中搜索audio，然后找到coreaudiod，点击退
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中什么样的对象有资格进入老年代</title>
    <link href="http://luxiaowan.github.io/2020/05/02/Java%E4%B8%AD%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E8%B5%84%E6%A0%BC%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3/"/>
    <id>http://luxiaowan.github.io/2020/05/02/Java中什么样的对象有资格进入老年代/</id>
    <published>2020-05-01T17:33:00.000Z</published>
    <updated>2020-05-02T07:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>当前我们使用的JVM的垃圾收集算法都是采用“分代”算法，将Java堆逻辑划分为年轻代（新生代）和老年代，并将对象按照其生命周期分配到对应的内存区域。那么什么对象会被分配到年轻代，什么对象被分配到老年代？</p><ol><li><p>一定次数的minor gc后</p><p>常规对象被创建之后是存储在年轻代的Eden区，每一个对象都有年龄，在YGC后，survivor1区还存活的对象的年龄全部+1，当对象年龄达到15时，被移交到老年代，15是系统默认的，我们可以通过JVM参数<code>-XX:MaxTenuringThreshold</code>来设置</p></li><li><p>minor gc后survivor放不下</p><p>在MinorGC之后存活的对象超过了survivor区的大小，会将这些对象直接转移到老年代</p></li><li><p>survivor内同年龄对象大小</p><p>如果再survivor区，有某一年龄的对象的总大小超过了survivor区大小的50%，则将这个年龄以上的对象全部转移到老年代</p></li><li><p>大对象</p><p>所谓大对象就是指需要比较大的连续内存空间的Java对象，比如很长的字符串或数组，我们可以通过JVM参数<code>-XX:PretenureSizeThreshold</code>指定大对象的容量，单位是字节。</p></li><li><p>老年代分配担保规则</p><p>在每一次执行Minor GC前，JVM都会检查一下老年代的剩余内存空间是否大于年轻代所有对象的总大小，目的是为了防止年轻代的对象在GC之后全部满足进入到老年代的条件，然后全部转移到老年代把老年代撑爆。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启是否允许冒险进行MinorGC，在jdk1.6 update24版本之后取消该参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只要老年代的连续空间大于年轻代对象总大小或历次晋升到来年代对象的平均大小就进行YGC(MinorGC)，否则进行FGC(MajorGC)</span></span><br><span class="line">-XX:-HandlePromotionFailure</span><br></pre></td></tr></table></figure><img src="/images/image-20200502154756565.png" alt="image-20200502154756565" style="zoom:50%;"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当前我们使用的JVM的垃圾收集算法都是采用“分代”算法，将Java堆逻辑划分为年轻代（新生代）和老年代，并将对象按照其生命周期分配到对应的内存区域。那么什么对象会被分配到年轻代，什么对象被分配到老年代？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一定次数的minor gc后&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>聊聊Java中的TLAB</title>
    <link href="http://luxiaowan.github.io/2020/04/29/%E8%81%8A%E8%81%8AJava%E4%B8%AD%E7%9A%84TLAB/"/>
    <id>http://luxiaowan.github.io/2020/04/29/聊聊Java中的TLAB/</id>
    <published>2020-04-29T11:15:00.000Z</published>
    <updated>2020-05-01T14:55:35.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-tlab介绍"><a class="markdownIt-Anchor" href="#一-tlab介绍"></a> 一、TLAB介绍</h3><p>TLAB（Thread Local Allocation Buffer）是在Hotspot1.6引入的新技术，目的是提升在堆上创建对象的性能。</p><p>如果一个对象被创建到堆上时，需要在堆上申请指定大小的内存供新创建的对象使用，在这个过程中，堆会通过加锁或指针碰撞的方式防止同一块被重复申请，在JVM中，内存分配是一个非常频繁的动作，而给堆加锁或者校验碰撞指针的方式必定会影响内存创建效率，TLAB的出现就是为了优化这个问题。</p><h3 id="二-tlab细节"><a class="markdownIt-Anchor" href="#二-tlab细节"></a> 二、TLAB细节</h3><p>TLAB是线程的一块私有内存，这块内存在堆中，可以通过JVM参数-XX:+UseTLAB开启。</p><ul><li><p>在线程启动的时候会在堆中为其申请一块指定大小的内存，这块内存只给当前线程使用，属于线程私有的，如果线程需要为线程内的对象分配内存，就再自己的空间上分配，这样就不存在内存竞争的情况了，大大的提升了分配效率；</p><p><img src="/images/image-20200430000859329.png" alt="image-20200430000859329"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize_tlab</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">    tlab().initialize();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当TLAB空间容量不足时，就新申请一个TLAB，原来的那个TLAB区里的对象还维持现状，因为对象只能感知到自己在Eden区。</p></li><li><p>TLAB空间的内存非常小，默认大小仅有Eden区的1%，也可以通过JVM参数-XX:TLABWasteTargetPercent设置TLAB空间占Eden空间的百分比大小，一般用默认的就可以。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启TLAB</span></span><br><span class="line">-XX:+UseTLAB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭TLAB</span></span><br><span class="line">-XX:-UseTLAB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置每个TLAB区域占Eden区的大小比例</span></span><br><span class="line">-XX:TLABWasteTargetPercent</span><br></pre></td></tr></table></figure></li></ul><h3 id="三-tlab规则"><a class="markdownIt-Anchor" href="#三-tlab规则"></a> 三、TLAB规则</h3><ol><li><p>我们下载openjdk，到查看文件<code>hotspot/src/share/vm/memory/threadLocalAllocBuffer.hpp</code>，这是TLAB的源码实现，看一下类中的属性：</p><p><img src="/images/image-20200429221957003.png" alt="image-20200429221957003"></p><p>从类中我们看到四个HeapWord实例，对于我们来说只需要关心start、top和end，我们结合和源码分析一下每个变量的用途。</p><ul><li><p>根据它们的注释我们可以知道start是TLAB的地址，end是申请的TLAB空间的尾部，也就是通过start和end就可以标识出这个TLAB所管理的区域，防止其他线程再来分配这块空间。</p></li><li><p>top是归属线程最后一次申请空间的尾位置，当top撞上end的时候就表示这个TLAB的空间用完了，这时会申请一个新的TLAB。</p></li></ul></li><li><p>每一个TLAB空间大小都是固定的，默认的是Eden区大小的的1%，既然大小是固定的，那么肯定会出现空间浪费的情况，比如TLAB大小是100kb，已经被使用了90kb，此时有一个12kb的对象来申请空间，但是TLAB的剩余空间已经不足以分配给这个对象了，此时怎么办？是新申请一个TLAB，还是直接分配到Eden区？在设计TLAB的时候就已经考虑到这种情况了，使用变量<code>refill_waste_limit</code>来控制一个TLAB允许被浪费的空间大小。</p><ul><li><p>如果<code>refill_waste_limit</code>的值是5kb的话，那么一个TLAB允许浪费的最大空间就是5kb，但是上述情况下TLAB还剩10kb的空间，不满足浪费条件，那么这个TLAB就不能被遗弃，还需要继续使用，所以不能申请新的TLAB，那么这个12kb的对象就只能被分配到Eden区；</p></li><li><p>如果<code>refill_waste_limit</code>的值是10kb，那么上述情况已经满足了空间可浪费的大小限制，此时就会直接遗弃当前的TLAB，重新申请一个新的来存放申请对象；</p></li><li><p>如果对象需要的空间特别大，超过了整个TLAB的大小，那么就会被直接放到Eden区。</p></li></ul></li><li><p>TLAB是允许浪费一部分空间的，这会导致在大量TLAB都浪费了部分空间的时候Eden区空间不连续，影响整个Eden区的使用。</p></li></ol><img src="/images/image-20200501225512825.png" alt="image-20200501225512825" style="zoom:50%;"><h3 id="四-总结"><a class="markdownIt-Anchor" href="#四-总结"></a> 四、总结</h3><p>基本上TLAB介绍到这里就可以了，再深入一点的话就要到C++代码层面了。</p><p><img src="/images/image-20200429003839422.png" alt="image-20200429003839422"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-tlab介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-tlab介绍&quot;&gt;&lt;/a&gt; 一、TLAB介绍&lt;/h3&gt;
&lt;p&gt;TLAB（Thread Local Allocation Buffer）是在Hotspot1.6引入的新技术
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>一道面试题引发的逃逸分析</title>
    <link href="http://luxiaowan.github.io/2020/04/29/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>http://luxiaowan.github.io/2020/04/29/一道面试题引发的逃逸分析/</id>
    <published>2020-04-29T02:27:00.000Z</published>
    <updated>2020-04-29T05:54:55.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试题"><a class="markdownIt-Anchor" href="#面试题"></a> 面试题</h3><p>在Java中，通过new创建的对象一定分配在堆上吗？</p><h3 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h3><p>是不是很想回答：是的！然后看到题中的“一定”二字犹豫了？这是一个开放性的面试题，你可以回答一定是的，但是要有个前提，这个前提先不揭秘，下面我们先来看几个概念性的东西：逃逸分析、栈上分配和TLAB(Thread Local Allocation Buffer)。</p><h4 id="1-逃逸分析是什么"><a class="markdownIt-Anchor" href="#1-逃逸分析是什么"></a> 1. 逃逸分析是什么</h4><p>逃逸分析（Escape Analysis）是一种可以通过分析对象的作用域来决定将其分配到何处的性能优化技术，为什么说是性能优化技术，因为通过开启逃逸分析，可以节省堆的使用，看到这里的小朋友是不是有很多问号？？？？别急，先来看看逃逸分析是怎么工作的。</p><p>在Java中，我们很少提到指针这个概念，那是因为所有的指针相关的东西都被JVM帮我们做了，而分析指针动态范围的方法就称之为逃逸分析，简单来说就是当一个对象的指针被多个方法或线程引用时，我们就称这个指针发生了逃逸。逃逸是指逃出了当前代码块的作用域，被其他的代码块引用了。</p><h4 id="2-对象如何逃逸"><a class="markdownIt-Anchor" href="#2-对象如何逃逸"></a> 2. 对象如何逃逸</h4><p>在实际开发中，一个对象的作用域主要包括：全局变量、方法返回值、引用参数、方法体内等，这三个不同作用域的对象在经过逃逸分析之后，会得出三种不同的分析结果。</p><ul><li>全局逃逸（Global Escape）：当一个对象的作用范围跳出了当前方法或者当前线程，则可以判定该对象发生了全局逃逸，比如全局变量、方法返回值等。</li><li>参数逃逸（Arg Escape）：当一个对象被作为方法参数进行传递或被参数引用时。</li><li>没有逃逸（NoEscape）：对象的作用范围在一个方法体内。</li></ul><h4 id="3-编译器如何优化逃逸的对象"><a class="markdownIt-Anchor" href="#3-编译器如何优化逃逸的对象"></a> 3. 编译器如何优化逃逸的对象</h4><p>对象发生了逃逸，也就是被多个线程或方法共享了，那么这个对象必定要分配到能够被线程共享的内存区域，否则这个对象无法被其他线程读取使用。纵观JVM内存模型，官方规定的被线程共享的内存模块有堆和元空间（低版本中有方法区），而被用来存储对象的内存区域就是堆了，所以要是想让对象被线程共享，那么将其放在堆中就可以实现。反而之就是这个对象是线程私有的，那么将其放在虚拟机栈中即可，而对象是一个聚合量（由基础类型和对象的引用等标量聚合而成），它又可以被再次分解成标量，这又叫作标量替换，如果没有发生逃逸的对象在分析之后发现可以不用连续的为其分配空间，对象内的变量可以单独的分析和优化，那么就会使用标量替换将一个对象拆分成若干个部分分别在栈或寄存器上分配空间；并且线程私有的对象不存在资源竞争的情况，所以给这个对象加锁就完全没必要了，这种情况下，虚拟机会自动消除这个对象上的锁。</p><p>综上我们可以整理为：</p><ul><li>没有发生逃逸的对象可以直接分配在虚拟机栈上，随着线程的结束一并回收；</li><li>若开启了标量替换规则，且逃逸分析后判定不需要为某个对象分配连续的存储空间，则会将对象进行标量拆分，然后分别存储在栈或寄存器上；</li><li>未发生逃逸的对象是线程私有的，不会出现并发竞争资源的情况，所以不需要为对象加锁，对象上的锁会被虚拟机忽略。</li></ul><h4 id="4-栈上分配"><a class="markdownIt-Anchor" href="#4-栈上分配"></a> 4. 栈上分配</h4><p>上面说到没有发生逃逸的对象可以直接被分配在线程私有的虚拟机栈上，那么方法栈上的对象在方法执行结束之后，栈帧弹出，对象就被自动回收了，这样做的好处是JVM内存回收效率提高，也减少了GC的的频率。</p><h4 id="5-如何开启逃逸分析和标量替换"><a class="markdownIt-Anchor" href="#5-如何开启逃逸分析和标量替换"></a> 5. 如何开启逃逸分析和标量替换</h4><p>在jdk1.8 Server模式下，逃逸分析是默认开启的（其他版本待测试），我们可以通过JVM参数手动的开启和关闭。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis：开启逃逸分析，默认</span><br><span class="line">-XX:-DoEscapeAnalysis：关闭逃逸分析</span><br><span class="line">-XX:+EliminateAllocations：开启标量替换，允许将对象打散分配到栈或寄存器上，默认</span><br><span class="line">-XX:-EliminateAllocations：关闭标量替换</span><br></pre></td></tr></table></figure><h4 id="6-小"><a class="markdownIt-Anchor" href="#6-小"></a> 6. 小🌰</h4><ul><li><p>非栈上分配</p><p>JVM参数：<code>-server -Xmx50m -Xms50m -XX:+PrintGC -XX:-DoEscapeAnalysis -XX:-EliminateAllocations</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocOnJVM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="/images/image-20200429131241750.png" alt="image-20200429131241750" style="zoom:50%;"><p>发生了多次GC，且最终执行时间为15毫秒，从GC的情况来看，对象b是被分配到了堆上，且因为堆空间不足而引起的GC。</p></li><li><p>栈上分配</p><p>JVM参数：<code>-server -Xmx50m -Xms50m -XX:+PrintGC -XX:+DoEscapeAnalysis -XX:+EliminateAllocations</code></p><p>代码和上面一致，我们来看下执行结果：</p><img src="/images/image-20200429131322123.png" alt="image-20200429131322123" style="zoom: 67%;"><p>整个代码执行完只用了5毫秒，且未发生GC，同样的配置，同样的代码，执行的结果却不相同，说明栈上分配确实可以提升代码的执行效率。</p></li><li><p>同步锁消除</p><p>在上文中我们提到栈上分配会将对象上的同步锁消除掉，在jdk1.8中，同步锁消除是默认开启的，我们可以使用命令关闭，同步锁消除必须在开启逃逸分析的前提下才有效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+EliminateLocks：开启同步锁消除，默认</span><br><span class="line">-XX:-EliminateLocks：关闭同步锁消除</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocOnJVM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">            b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开启逃逸分析且关闭锁消除的情况下执行结果：</p><p>JVM参数：<code>-server -Xmx50m -Xms50m -XX:+PrintGC -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks</code></p><p><img src="/images/image-20200429132238656.png" alt="image-20200429132238656"></p><p>在开启逃逸分析且开启锁消除的情况下执行结果：</p><p>JVM参数：<code>-server -Xmx50m -Xms50m -XX:+PrintGC -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks</code></p><p><img src="/images/image-20200429131833250.png" alt="image-20200429131833250"></p><p>两种情况下对比发现，在开启同步锁消除之后，synchronized好像没有生效，验证成功。</p></li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>通过我们对这个面试题的解析，发现并不是所有的对象都被分配到堆上，虚拟机为了加快程序运行效率，减少GC带来的额外开销，推出了栈上分配，而栈上分配又是基于逃逸分析的分析结果来决定是否执行的，被分配到栈上的对象如果带有同步锁，可以通过JVM参数配置让同步锁失效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面试题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面试题&quot;&gt;&lt;/a&gt; 面试题&lt;/h3&gt;
&lt;p&gt;在Java中，通过new创建的对象一定分配在堆上吗？&lt;/p&gt;
&lt;h3 id=&quot;解析&quot;&gt;&lt;a class=&quot;markdownIt-Ancho
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java对象创建过程</title>
    <link href="http://luxiaowan.github.io/2020/04/28/Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://luxiaowan.github.io/2020/04/28/Java对象创建过程/</id>
    <published>2020-04-28T09:10:00.000Z</published>
    <updated>2020-04-28T16:40:09.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、概述</h3><p>在Java中，一个对象只要被正确的实例化之后才能被使用，在对象实例化的时候，会先检查相关的类信息是否已经被加载并初始化，在类初始化完毕之后才会继续完成对象的实例化，类的一生主要经历加载、连接（验证、准备、解析）、初始化、使用和卸载五个过程，创建类的对象就是在使用这个阶段。</p><img src="/images/image-20200428213918172.png" alt="image-20200428213918172" style="zoom:50%;"><blockquote><p>加载（Loading）：通过类的全限定名查找和读取class文件，将读取的字节流所代表的静态存储结构转化为方法区的运行时数据结构，然后在内存中生成一个代表这个类的Class对象，作为方法区这个类的访问入口，并将这个Class对象存放在方法区中（方法区主要存储类信息、常量、静态变量）。这个过程可以通过自定义的类加载器进行操作。</p><p>连接（Linking）：把类的二进制数据合并入JRE中，这个过程包括三个阶段：</p><ol><li>验证：该阶段验证被加载后的类的结构是否正确，类数据是否符合虚拟机的规定，保证该类不会危险到虚拟机的安全。</li><li>准备：验证完成之后立即为类的静态变量(static)在方法区分配内存，并给变量赋默认值（o、false、0.0f、’’、null或指定的值等），比如<code>static boolean flag = true;</code>，在准备阶段就会给变量flag赋默认值false，然后在初始化阶段将变量flag赋值于true；但是对于静态常量(static final)来说，会在此阶段将常量赋予最终值，比如<code>static final int num = 10;</code>，在该阶段之后，静态常量num的值就一直是10了。</li><li>解析：将类的二进制数据中的符号引用转换为直接饮用。符号引用是以一组符号来描述所引用的目标，与虚拟机实现的内存布局无关，引用的目标不一定已经存在于内存中；直接饮用是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，与虚拟机实现的内存布局有关，引用的目标必定已经存在于内存中。</li></ol><p>初始化（Initialization）：类初始化的主要工作是为静态变量赋代码设定的值，如上面讲到的<code>static boolean flag = true;</code>，在连接的准备阶段，静态变量flag的值被设置为false，但是在初始化阶段会将flag的值设置为true，也就是我们代码中设定的初始值。初始化节点会调用类构造器&lt;cInit&gt;()，该构造器是由编译器自动收集类中的所有类变量的赋值和静态代码块中的语句合并生成的，编译器收集的顺序由代码语句在源文件中的顺序决定的。</p><p>☆除了加载阶段可以用户自定义之外，其他阶段的动作完全由虚拟机主导控制。</p></blockquote><h3 id="二-对象的创建方式"><a class="markdownIt-Anchor" href="#二-对象的创建方式"></a> 二、对象的创建方式</h3><p>在Java代码中可以通过多种方式完成对象的创建，最常用也是最直观的一种方式就是通过new关键字来调用类的构造器显示的创建对象，在Java规范中称此方式为：由执行类实例创建表达式而引起的对象创建。另外我们还可以通过使用反射、clone方法、序列化等方式去创建对象。</p><ol><li><p>使用new关键字</p><p>该方式是我们最常见也是最简单的一种方式，我们可以调用一个类的任意构造器(无参或有参)去创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cc c = <span class="keyword">new</span> Cc();</span><br><span class="line">或</span><br><span class="line">Cc c = <span class="keyword">new</span> Cc(<span class="string">"cc"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>当虚拟机执行到new指令时，首先在常量池中查找Cc的符号引用，若能定位到Cc类的符号引用，说明这个类已经被加载到方法区了，若没有找到则先去加载Cc这个类。</p></li><li><p>使用反射</p><ul><li><p>使用Class类的newInstance方法</p><p>可以利用反射机制通过调用Class类的newInstance方法来创建对象，并且这个newInstance方法调用的是目标类无参的构造器，所以要是想使用该方式创建某个类的对象，就必须要保证这个类要有一个无参的构造器，否则会报错<code>NoSuchMethodException: cc.kevinlu.ccspringbootwar.Cc.&lt;init&gt;()</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cc c = (Cc) Class.forName(<span class="string">"cc.lu.clazz.ni.Cc"</span>).newInstance();</span><br><span class="line">或</span><br><span class="line">Cc cc = Cc.class.newInstance();</span><br></pre></td></tr></table></figure><p>我们会发现在使用<code>Class.forName().newInstance()</code>的时候需要进行一次强制类型转换，Class类的newInstance方法内部也是通过调用Constructor的newInstance无参构造器。</p></li><li><p>使用Constructor类的newInstance方法</p><p><code>java.lang.reflect.Constructor</code>类中也有一个newInstance方法可以用来创建对象，该方法与Class类的newInstance方法类似，但是Constructor中的newInstance方法更加强大，因为它既可以调用无参的构造器也可以调用有参数的构造器，通吃。并且Constructor是一个泛型类，不需要我们再进行对象的强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 调用无参构造器</span></span><br><span class="line">      Constructor&lt;Cc&gt; c1 = Cc.class.getConstructor();</span><br><span class="line">        Cc cc1 = c1.newInstance();</span><br><span class="line">        System.out.println(cc1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用有参构造器</span></span><br><span class="line">        Constructor&lt;Cc&gt; constructor = Cc.class.getConstructor(String.class);</span><br><span class="line">        Cc ccc = constructor.newInstance(<span class="string">"cc"</span>);</span><br><span class="line">        System.out.println(ccc);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cc&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用clone方法</p><p>我们可以调用一个对象的clone方法进行对象的深拷贝或浅拷贝，并且如果我们想要使用clone方法，必须实现接口<code>java.lang.Cloneable</code>，这是一个标识性质的接口，告诉虚拟机这个类的实例对象支持克隆，就像接口<code>java.io.Serializable</code>用来标识类的实例对象可以被序列化一样，没有实现Cloneable的类的对象在调用clone方法的时候会报<code>java.lang.CloneNotSupportedException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Constructor&lt;Cc&gt; constructor = Cc.class.getConstructor(String.class);</span><br><span class="line">        Cc c = constructor.newInstance(<span class="string">"cc"</span>);</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        Cc cc = (Cc) c.clone();</span><br><span class="line">        System.out.println(cc);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重点：必须实现java.lang.Cloneable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cc&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用序列化</p><p>当我们反序列化一个对象时，虚拟机会帮我们创建一个单独的对象，过程中不会调用任何的构造器，被序列化和反序列化的类必须实现接口<code>java.io.Serializable</code>，目的是告诉虚拟机这个类的实例对象可以被序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Constructor&lt;Cc&gt; constructor = Cc.class.getConstructor(String.class);</span><br><span class="line">        Cc c = constructor.newInstance(<span class="string">"cc"</span>);</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cc.bf"</span>));</span><br><span class="line">        oos.writeObject(c);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cc.bf"</span>));</span><br><span class="line">        Cc cc = (Cc) ois.readObject();</span><br><span class="line">        System.out.println(cc);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cc&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.lu.clazz.ni;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Class的newInstance方式一</span></span><br><span class="line">        Cc c = (Cc) Class.forName(<span class="string">"cc.lu.clazz.ni.Cc"</span>).newInstance();</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Class的newInstance方式二</span></span><br><span class="line">        Cc cc = Cc.class.newInstance();</span><br><span class="line">        System.out.println(cc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Constructor无参构造器</span></span><br><span class="line">        Constructor&lt;Cc&gt; c1 = Cc.class.getConstructor();</span><br><span class="line">        Cc cc1 = c1.newInstance();</span><br><span class="line">        System.out.println(cc1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Constructor有参构造器</span></span><br><span class="line">        Constructor&lt;Cc&gt; constructor = Cc.class.getConstructor(String.class);</span><br><span class="line">        Cc ccc = constructor.newInstance(<span class="string">"cc"</span>);</span><br><span class="line">        System.out.println(ccc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clone</span></span><br><span class="line">        Cc cm = (Cc) ccc.clone();</span><br><span class="line">        System.out.println(cm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cc.bf"</span>));</span><br><span class="line">        oos.writeObject(ccc);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cc.bf"</span>));</span><br><span class="line">        Cc c3 = (Cc) ois.readObject();</span><br><span class="line">        System.out.println(c3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cc&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-对象的创建过程"><a class="markdownIt-Anchor" href="#三-对象的创建过程"></a> 三、对象的创建过程</h3><ol><li><p>实例变量与实例代码块的初始化</p><p>对象被创建时，虚拟机为其分配内存来存放实例变量（自己的和继承而来的），在分配内存的同时会对实例变量进行默认值设置，默认值有两种设置方式，一种是直接赋值，另一种是使用实例代码块赋值，编译后查看字节码会发现实例代码块会按照声明的顺序对实例变量赋值操作去重之后，将最后实例代码块中的语句放到类的构造器中，例如下方代码，最终实例变量的值为：name=“cc”,sex=“男1”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        sex = <span class="string">"男"</span>;</span><br><span class="line">        name = <span class="string">"cc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        sex = <span class="string">"男1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例代码块中如果使用一个实例变量赋值给另外一个实例变量的话，那么作为值的这个实例变量的声明必须要在实例代码块之前，否则会在编译的时候就报错<code>Illegal forward reference</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">"cc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 此处sex1会报错</span></span><br><span class="line">        sex = sex1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String sex1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要绕过这种检查，可以创建sex1的getter方法，在代码块中调用这个getter方法，但是会出现另外一种情况：sex会获取到sex1在连接阶段设置的默认值，所以慎用。</p></li><li><p>构造器初始化</p><p>Java的类是具有继承关系的，所有类的超类都是Object，在字节码中，构造器会被命名为&lt;init&gt;()方法，参数和代码中声明的一致，没有我们没有在类中显式定义构造器的话，虚拟机会为类创建一个默认的无参构造器。Java规则规定在实例化类之前，必须先要实例化其父类，以保证实例的完整性。Java强制要求除Object之外的所有类的构造器的第一句必须是父类的构造器调用语句（super(…)），如果把super()语句放到其他行，那么编译的时候就会提示错误<code>Call to 'super()' must be first statement in constructor body</code>。</p><p>我们分析一个情景：看如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ① super();</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"cc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ②</span></span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种情况，Java只允许在构造器Cc(String name)内调用超类的构造器，①处的代码会报错。</p></li></ol><h3 id="四-小结"><a class="markdownIt-Anchor" href="#四-小结"></a> 四、小结</h3><p>类实例化的过程可以总结为：</p><ol><li>首先在常量池中定位类的符号引用</li><li>判定是否需要进行类加载</li><li>虚拟机为新生对象分配内存（对象所需要的内存大小在类加载完就可以确定）</li><li>初始化实例变量</li><li>虚拟机设置对象头信息</li><li>执行代码块进行自定义初始化</li><li>完成</li></ol><img src="/images/image-20200429002706141.png" alt="image-20200429002706141" style="zoom:50%;"><h3 id="五-对象创建过程中内存的分配"><a class="markdownIt-Anchor" href="#五-对象创建过程中内存的分配"></a> 五、对象创建过程中内存的分配</h3><p>文字理解起来不如看图，直接看图理解吧：</p><p><img src="/images/image-20200429003839422.png" alt="image-20200429003839422"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-概述&quot;&gt;&lt;/a&gt; 一、概述&lt;/h3&gt;
&lt;p&gt;在Java中，一个对象只要被正确的实例化之后才能被使用，在对象实例化的时候，会先检查相关的类信息是否已经被加载并初始化，在类初始化完
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac上怎么配置MySQL</title>
    <link href="http://luxiaowan.github.io/2020/04/28/Mac%E4%B8%8A%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AEMySQL/"/>
    <id>http://luxiaowan.github.io/2020/04/28/Mac上怎么配置MySQL/</id>
    <published>2020-04-28T08:05:00.000Z</published>
    <updated>2020-04-28T08:39:29.530Z</updated>
    
    <content type="html"><![CDATA[<p>在Mac上可以通过官方dmg文件或者Homebrew的方式安装MySQL，具体方式就不介绍了，可以谷歌一下，安装完成之后，在电脑上却找不到MySQL的配置文件my.cnf，可以通过命令<code>find / -iname my.cnf</code>进行全盘查找。难道我们Mac上的MySQL不需要配置文件？</p><p>我们进入到MySQL的安装路径下，查看<code>support-files/mysql.server</code>文件内容，在文件中有一块说明了my.cnf文件的默认位置：</p><img src="/images/image-20200428162211287.png" alt="image-20200428162211287" style="zoom:50%;"><p>大致意思就是如果mysql没有安装在<code>/usr/local/mysql</code>目录下的话，需要手动在<code>/etc</code>目录下创建my.cnf文件来配置安装的MySQL，并且在服务启动的时候会默认先去读取<code>/etc/my.cnf</code>，若文件存在则直接使用该文件中的配置，从这条规则来看，我们只需要在<code>/etc</code>目录下创建一个my.cnf文件，并将我们需要自定义的配置写到里面即可</p><img src="/images/image-20200428163629688.png" alt="image-20200428163629688" style="zoom:50%;"><p>附赠一份官方的my.cnf配置文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Example MySQL config file <span class="keyword">for</span> medium systems.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is <span class="keyword">for</span> a system with little memory (32M - 64M) <span class="built_in">where</span> MySQL plays</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> an important part, or systems up to 128M <span class="built_in">where</span> MySQL is used together with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> other programs (such as a web server)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MySQL programs look <span class="keyword">for</span> option files <span class="keyword">in</span> a <span class="built_in">set</span> of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> locations <span class="built_in">which</span> depend on the deployment platform.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can copy this option file to one of those</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> locations. For information about these locations, see:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://dev.mysql.com/doc/mysql/en/option-files.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> In this file, you can use all long options that a program supports.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you want to know <span class="built_in">which</span> options a program supports, run the program</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> with the <span class="string">"--help"</span> option.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The following options will be passed to all MySQL clients</span></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash">password = your_password</span></span><br><span class="line">port= 3306</span><br><span class="line">socket= /tmp/mysql.sock </span><br><span class="line"><span class="meta">#</span><span class="bash"> Here follows entries <span class="keyword">for</span> some specific programs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The MySQL server</span></span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">init_connect='SET NAMES utf8</span><br><span class="line">port= 3306</span><br><span class="line">socket= /tmp/mysql.sock</span><br><span class="line">skip-external-locking</span><br><span class="line">key_buffer_size = 16M</span><br><span class="line">max_allowed_packet = 1M</span><br><span class="line">table_open_cache = 64</span><br><span class="line">sort_buffer_size = 512K</span><br><span class="line">net_buffer_length = 8K</span><br><span class="line">read_buffer_size = 256K</span><br><span class="line">read_rnd_buffer_size = 512K</span><br><span class="line">myisam_sort_buffer_size = 8M</span><br><span class="line">character-set-server=utf8</span><br><span class="line">init_connect='SET NAMES utf8' </span><br><span class="line"><span class="meta">#</span><span class="bash"> Don<span class="string">'t listen on a TCP/IP port at all. This can be a security enhancement,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> all processes that need to connect to mysqld run on the same host.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> All interaction with mysqld must be made via Unix sockets or named pipes.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that using this option without enabling named pipes on Windows</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (via the <span class="string">"enable-named-pipe"</span> option) will render mysqld useless!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">skip-networking</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication Master Server (default)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> binary logging is required <span class="keyword">for</span> replication</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> binary logging format - mixed recommended</span></span><br><span class="line">binlog_format= MIXED</span><br><span class="line"><span class="meta">#</span><span class="bash">mixed</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> required unique id between 1 and 2^32 - 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> defaults to 1 <span class="keyword">if</span> master-host is not <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> but will not <span class="keyword">function</span> as a master <span class="keyword">if</span> omitted</span></span><br><span class="line">server-id = 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication Slave (comment out master section to use this)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To configure this host as a replication slave, you can choose between</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> two methods :</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1) Use the CHANGE MASTER TO <span class="built_in">command</span> (fully described <span class="keyword">in</span> our manual) -</span></span><br><span class="line"><span class="meta">#</span><span class="bash">the syntax is:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">where</span> you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;port&gt; by the master<span class="string">'s port number (3306 by default).</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Example:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">CHANGE MASTER TO MASTER_HOST=<span class="string">'125.564.12.1'</span>, MASTER_PORT=3306,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">MASTER_USER=<span class="string">'joe'</span>, MASTER_PASSWORD=<span class="string">'secret'</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) Set the variables below. However, <span class="keyword">in</span> <span class="keyword">case</span> you choose this method, <span class="keyword">then</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">start replication <span class="keyword">for</span> the first time (even unsuccessfully, <span class="keyword">for</span> example</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> you mistyped the password <span class="keyword">in</span> master-password and the slave fails to</span></span><br><span class="line"><span class="meta">#</span><span class="bash">connect), the slave will create a master.info file, and any later</span></span><br><span class="line"><span class="meta">#</span><span class="bash">change <span class="keyword">in</span> this file to the variables<span class="string">' values below will be ignored and</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">overridden by the content of the master.info file, unless you shutdown</span></span><br><span class="line"><span class="meta">#</span><span class="bash">the slave server, delete master.info and restart the slaver server.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">For that reason, you may want to leave the lines below untouched</span></span><br><span class="line"><span class="meta">#</span><span class="bash">(commented) and instead use CHANGE MASTER TO (see above)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> required unique id between 2 and 2^32 - 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (and different from the master)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> defaults to 2 <span class="keyword">if</span> master-host is <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> but will not <span class="keyword">function</span> as a slave <span class="keyword">if</span> omitted</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server-id = 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The replication master <span class="keyword">for</span> this slave - required</span></span><br><span class="line"><span class="meta">#</span><span class="bash">master-host = &lt;hostname&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The username the slave will use <span class="keyword">for</span> authentication when connecting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to the master - required</span></span><br><span class="line"><span class="meta">#</span><span class="bash">master-user = &lt;username&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The password the slave will authenticate with when connecting to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the master - required</span></span><br><span class="line"><span class="meta">#</span><span class="bash">master-password = &lt;password&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The port the master is listening on.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> optional - defaults to 3306</span></span><br><span class="line"><span class="meta">#</span><span class="bash">master-port =&lt;port&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> binary logging - not required <span class="keyword">for</span> slaves, but recommended</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">log</span>-bin=mysql-bin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Uncomment the following <span class="keyword">if</span> you are using InnoDB tables</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_data_home_dir = /usr/<span class="built_in">local</span>/mysql/data</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_data_file_path = ibdata1:10M:autoextend</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_log_group_home_dir = /usr/<span class="built_in">local</span>/mysql/data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can <span class="built_in">set</span> .._buffer_pool_size up to 50 - 80 %</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of RAM but beware of setting memory usage too high</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_buffer_pool_size = 16M</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_additional_mem_pool_size = 2M</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set .._log_file_size to 25 % of buffer pool size</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_log_file_size = 5M</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_log_buffer_size = 8M</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_flush_log_at_trx_commit = 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_lock_wait_timeout = 50</span></span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">max_allowed_packet = 16M</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line"><span class="meta">#</span><span class="bash"> Remove the next comment character <span class="keyword">if</span> you are not familiar with SQL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">safe-updates</span></span><br><span class="line">default-character-set=utf8 </span><br><span class="line"></span><br><span class="line">[myisamchk]</span><br><span class="line">key_buffer_size = 20M</span><br><span class="line">sort_buffer_size = 20M</span><br><span class="line">read_buffer = 2M</span><br><span class="line">write_buffer = 2M</span><br><span class="line"></span><br><span class="line">[mysqlhotcopy]</span><br><span class="line">interactive-timeout</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Mac上可以通过官方dmg文件或者Homebrew的方式安装MySQL，具体方式就不介绍了，可以谷歌一下，安装完成之后，在电脑上却找不到MySQL的配置文件my.cnf，可以通过命令&lt;code&gt;find / -iname my.cnf&lt;/code&gt;进行全盘查找。难道我们M
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>聊一聊MySQL事务</title>
    <link href="http://luxiaowan.github.io/2020/04/27/%E8%81%8A%E4%B8%80%E8%81%8AMySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>http://luxiaowan.github.io/2020/04/27/聊一聊MySQL事务/</id>
    <published>2020-04-27T07:30:00.000Z</published>
    <updated>2020-04-27T15:30:46.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-事务为何物"><a class="markdownIt-Anchor" href="#一-事务为何物"></a> 一、事务为何物</h3><p>事务（Transaction）是保障程序中一组操作的原子性的约束，它使事务中的所有操作都指向同一个结果，也就是要么所有的操作都执行成功，要么所有的操作都执行失败，不允许出现其他结果。例如银行转账，从A账户扣除金额，向B账户添加金额，这两个数据库操作的总和构成一个完整的逻辑过程，不可拆分，这个过程被称为一个事务。在MySQL中，目前只有InnoDB引擎支持事务。</p><h3 id="二-事务的特性"><a class="markdownIt-Anchor" href="#二-事务的特性"></a> 二、事务的特性</h3><p>数据库管理系统在写入或更新数据的过程中，为保证事务是正确可靠的，需要具备四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p><ul><li>原子性（Atomicity）：一个事物中的所有操作，要么全部完成，要么全部失败，不会在中间某个环节结束。若事务在执行过程中发生异常，所有的操作都会被回滚到事务开始前的状态，就像这个事务从没执行过一样。</li><li>一致性（Consistency）：事务操作的数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定，也就是在事务开始之前和结束之后，数据库的完整性没有被破坏。</li><li>隔离性（Isolation）：数据库允许多个事务并发执行，隔离性是为了防止多个事务并发执行导致数据的不一致，事务之间是相互隔离的。事务隔离有四种级别：未提交读（Read UnCommitted）、已提交读（Read Commited）、可重复读（Repeatable Read）、串行化（Serializable）</li><li>持久性：事务成功提交之后，对数据的修改是永久性的，即便系统故障也不会丢失。</li></ul><h3 id="三-为什么要有四种隔离级别"><a class="markdownIt-Anchor" href="#三-为什么要有四种隔离级别"></a> 三、为什么要有四种隔离级别</h3><p>SQL标准定义了4种隔离级别用来限定不同的事务场景，按照隔离级别从低到高为：读未提交、读已提交、可重复读、串行化，级别越高，所支持的并发度越低。</p><blockquote><p>不同的隔离级别会造成不同的影响，体现在数据上就是脏读、不可重复读和幻读。</p></blockquote><ul><li>脏读：A事务读取了B事务中未提交的数据，在A事务提交之前，B事务进行了回滚，此时A事务中的数据就不正确了，所以被定义为脏数据。</li><li>不可重复读：A事务在第一次读取之后到第二次读取之前，B事务对该数据进行了修改，导致A事务两次读取的数据不一致，这就是不可重复读</li><li>幻读：幻读一般发生在范围查询的情况下，A事务第一次读取一批数据，在第二次读取之前，B事务向数据库中插入了新的符合A事务查询条件的数据，此时A事务第二次读取出来的数据条数不一致，这种情况对于A事务来说就是出现了幻读。</li></ul><blockquote><p>事务隔离级别</p></blockquote><ul><li>读未提交（Read UnCommitted）：该隔离级别下的事务可以看到其他事务未提交的执行结果，会引起脏读、不可重复读和幻读，在实际应用中几乎不会使用该级别的事务。</li><li>读已提交（Read Committed）：这是大多数数据库系统的默认隔离级别（如Oracle、阿里云的MySQL）等，但不是官方MySQL默认的。它不允许事务看到未提交的事务中的数据，使事务只能看见已经提交的事务所做的改变。该隔离级别会引起不可重复读和幻读。</li><li>可重复读（Repeatable Read）：这是官方MySQL的默认事务隔离级别，它确保同一事务多次读取的数据的一致性，解决了不可重复读的问题。该隔离级别解决的主要是对数据库进行UPDATE操作造成的数据改变，但还是会引起幻读的情况发生，在InnoDB存储引擎下默认提供MVCC（多版本并发控制）机制解决了幻读的问题。</li><li>串行化（Serializable）：这是最高的隔离级别，串行的意思也就是每次只允许一个事务对数据进行操作，事务按照先来后到的规则进行排队一次执行，这样在事务之间就不会相互冲突，从而解决了幻读的问题。但是串行化执行事务的方式会严重影响事务的执行效率，高并发操作下会造成事务堆积和超时，一般在实际应用中很少使用，虽然它很安全。</li></ul><p>通过上面我们了解了事务隔离级别，也知道每种隔离级别所解决的事情，做一下汇总：</p><table><thead><tr><th style="text-align:center">事务隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">读已提交</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">串行化</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><h3 id="四-如何查看和设置数据库的隔离级别"><a class="markdownIt-Anchor" href="#四-如何查看和设置数据库的隔离级别"></a> 四、如何查看和设置数据库的隔离级别</h3><ol><li><p>查看数据库当前的事务隔离级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200427173518185.png" alt="image-20200427173518185"></p></li><li><p>修改数据库的事务隔离级别</p><p>修改语句格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set [global | session] transaction isolation level [read uncommitted | read committed | repeatable read | serializable]</span><br></pre></td></tr></table></figure><p><code>session</code>：当前session内的事务</p><p><code>global</code>：应用于之后新创建的session，已经存在的session不受影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed</span><br></pre></td></tr></table></figure><p>修改成功之后，我们再看一下当前的隔离级别已经被修改为RC了。</p><p><img src="/images/image-20200427174522929.png" alt="image-20200427174522929"></p></li></ol><h3 id="五-小"><a class="markdownIt-Anchor" href="#五-小"></a> 五、小🌰</h3><ol><li><p>创建一张表备用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table cc_isolation_test</span><br><span class="line">(</span><br><span class="line">    id   int auto_increment primary key,</span><br><span class="line">    name varchar(30) null</span><br><span class="line">) engine=innodb default charset=utf8</span><br><span class="line">    comment &apos;事务隔离级别测试表&apos;;</span><br><span class="line"></span><br><span class="line"># 插入一条数据</span><br><span class="line">insert into cc_isolation_test(name) values(&apos;cc&apos;);</span><br></pre></td></tr></table></figure></li><li><p>RU级别</p><ul><li><p>修改session的事务隔离级别为RU</p><p>打开两个session窗口，将事务隔离级别均修改为RU。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别为RU</span><br><span class="line">set session transaction isolation level read uncommitted ;</span><br><span class="line"># 验证</span><br><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200427184245389.png" alt="image-20200427184245389"></p></li><li><p>脏读验证</p><ol><li><p>在两个窗口中均开启一个事务，在A事务中进行查询操作，在B事务中进行更新操作但不提交</p></li><li><p>A事务：进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><p>这时查到的数据为正常数据：</p><img src="/images/image-20200427185221292.png" alt="image-20200427185221292" style="zoom:50%;"></li><li><p>B事务：进行更新操作但不提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update cc_isolation_test set name=&apos;cc1&apos; where id=1;</span><br></pre></td></tr></table></figure><p>执行完之后可以看一下我们的表中，数据是未被修改的，因为B事务尚未提交</p><img src="/images/image-20200427190836436.png" alt="image-20200427190836436" style="zoom:50%;"></li><li><p>A事务：再次进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427190607659.png" alt="image-20200427190607659" style="zoom:50%;"><p>查询出来的数据中，name竟然变成了cc1，也就是说A事务中读取到了B事务中尚未提交的数据，如果此时B事务回滚，A事务中name的值仍然是读到的cc1，也就出现了脏数据，所以RU级别下会出现脏读的问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>update cc_isolation_test set name=‘cc1’ where id=1;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>rollback;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li><li><p>不可重复读验证</p><p>上面演示脏读的过程中，在A事务中对数据进行了两次读取，且两次读取到的name的值不一致，所以RU也造成了不可重复读的问题。</p></li><li><p>幻读验证</p><ol><li><p>A事务：进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427185221292.png" alt="image-20200427185221292" style="zoom:50%;"></li><li><p>B事务：进行插入操作但不提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into cc_isolation_test(name) values(&apos;cc1&apos;);</span><br></pre></td></tr></table></figure><p>事务未提交，我们的表中还没出现插入的新数据</p><img src="/images/image-20200427190836436.png" alt="image-20200427190836436" style="zoom:50%;"></li><li><p>A事务：再次进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><p>查询出来两条数据，和之前查询的条数不一样，但是我们数据库中仅仅只有一条数据，这就是所谓的幻读，此时若将B事务回滚掉，A事务拿着B事务未提交的数据继续操作，定会出现问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(name) values(‘cc1’);</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>rollback;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li></ul></li><li><p>RC级别</p><ul><li><p>修改session的事务隔离级别为RC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别为RC</span><br><span class="line">set session transaction isolation level read committed ;</span><br><span class="line"># 验证</span><br><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure></li></ul><img src="/images/image-20200427215936571.png" alt="image-20200427215936571" style="zoom:50%;"><ul><li><p>脏读验证</p><p>操作步骤和RU的一致，但是结果却不相同，我们在B事务中对<code>id=1</code>的数据进行修改但是不提交事务，在A事务中是读取不到B事务对该条数据的修改，所以RC级别不会出现脏读的问题。</p></li><li><p>不可重复读验证</p><ol><li><p>A事务：第一次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193013689.png" alt="image-20200427193013689" style="zoom:50%;"></li><li><p>B事务：修改数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">update cc_isolation_test set name=&apos;cc1&apos; where id=1;</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：第二次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193112958.png" alt="image-20200427193112958" style="zoom:50%;"><p>在A事务中读取到了B事务提交的数据，与第一次读取到的数据不一致，也就是说每次读取都是从数据库中读取最新的数据，这也证明了再RC级别下会出现不可重复读的问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td></td><td>update cc_isolation_test set name=‘cc1’ where id=1;</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li><li><p>幻读验证</p><ol><li><p>A事务：第一次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193423746.png" alt="image-20200427193423746" style="zoom:50%;"></li><li><p>B事务：修改数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">insert into cc_isolation_test(name) values(&apos;cc2&apos;);</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：第二次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193523968.png" alt="image-20200427193523968" style="zoom:50%;"><p>两次查询的数据条数不同，在A事务中读取到了B事务新插入的数据，相对于第一次查询结果来说，出现了幻读的问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(name) values(‘cc2’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li></ul></li><li><p>RR级别</p><ul><li><p>修改session的事务隔离级别为RR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别为RC</span><br><span class="line">set session transaction isolation level read committed ;</span><br><span class="line"># 验证</span><br><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427210838009.png" alt="image-20200427210838009" style="zoom:50%;"></li><li><p>脏读验证</p><p>操作步骤和RC的一致，但是结果却不相同，我们在B事务中对<code>id=1</code>的数据进行修改但是不提交事务，在A事务中是读取不到B事务对该条数据的修改，所以RR级别不会出现脏读的问题。</p></li><li><p>不可重复读验证</p><ol><li><p>A事务：第一次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193112958.png" alt="image-20200427193112958" style="zoom:50%;"></li><li><p>B事务：修改数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">update cc_isolation_test set name=&apos;cc2&apos; where id=1;</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：第二次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193112958.png" alt="image-20200427193112958" style="zoom:50%;"><p>通过两次读取之后发现在B事务提交前后读取到的数据是一致的，这样证明了RR级别是支持重复读的，nice~</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td></td><td>update cc_isolation_test set name=‘cc2’ where id=1;</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li><li><p>幻读验证</p><ol><li><p>A事务：进行查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure></li><li><p>B事务：插入数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">insert into cc_isolation_test(id, name) values(1, &apos;cc2&apos;);</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into cc_isolation_test(id, name) values(1, &apos;cc2&apos;);</span><br></pre></td></tr></table></figure><p>主键冲突了，但是在A事务中确实没查询到id=1的数据，其实这个时候数据库中已经有了id=1的数据，但在A事务中却没有查询到，这就是幻读。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(id, name) values(1, ‘cc2’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>insert into cc_isolation_test(id, name) values(1, ‘cc2’);</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li></ul></li><li><p>Serializable级别</p><ul><li><p>修改session的事务隔离级别为Serializable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427215912469.png" alt="image-20200427215912469" style="zoom:50%;"></li><li><p>操作</p><p>先开启事务A，进行查询，但不提交；再开启事务B，然后进行插入操作，会发现操作被阻塞了，如下图中insert语句最后的时间就是等待的时间，事务B必须在事务A提交或回滚之后才能继续执行，这也就是串行化的意义：同时只能有一个事务处于执行中，其他线程都要等待。并发度最低但安全性最高。</p><img src="/images/image-20200427215828454.png" alt="image-20200427215828454" style="zoom:50%;"><p>图解：</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(name) values(‘cc2’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-事务为何物&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-事务为何物&quot;&gt;&lt;/a&gt; 一、事务为何物&lt;/h3&gt;
&lt;p&gt;事务（Transaction）是保障程序中一组操作的原子性的约束，它使事务中的所有操作都指向同一个结果，也就是要么
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot如何以war包形式运行</title>
    <link href="http://luxiaowan.github.io/2020/04/26/SpringBoot%E5%A6%82%E4%BD%95%E4%BB%A5war%E5%8C%85%E5%BD%A2%E5%BC%8F%E8%BF%90%E8%A1%8C/"/>
    <id>http://luxiaowan.github.io/2020/04/26/SpringBoot如何以war包形式运行/</id>
    <published>2020-04-26T09:50:00.000Z</published>
    <updated>2020-04-26T14:40:37.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-简介"><a class="markdownIt-Anchor" href="#一-简介"></a> 一、简介</h3><p>SpringBoot应用默认打包成可执行jar模式方便我们的快速部署，如果是web应用的话，则默认使用内置的tomcat作为servlet容器，但是如果我们需要根据业务特性对容器做一些特殊配置，那么SpringBoot内置的tomcat容器就无法满足我们了，因此我们就需要把SpringBoot应用打包成war包，让其能够在外部tomcat中运行。</p><p>那我们直接打成war包然后部署到tomcat是否可行？我们来试下，看看会发生什么。</p><h3 id="二-直接将springboot打成war包"><a class="markdownIt-Anchor" href="#二-直接将springboot打成war包"></a> 二、直接将SpringBoot打成war包</h3><ol><li><p>创建一个SpringBoot web项目，并修改打包方式和端口</p><ul><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcSpringBootWarApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CcSpringBootWarApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.lu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cc-spring-boot-war<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加packaging并指明方式为war --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改端口，不要和tomcat的8080冲突，修改tomcat的也可以</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8990</span></span><br></pre></td></tr></table></figure></li></ul><p>以上就是我们创建的一个简单的SpringBoot应用所具有的东西</p></li><li><p>创建一个API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"cc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure></li><li><p>放到tomcat中启动，查看控制台信息</p><p><img src="/images/image-20200426212704488.png" alt="image-20200426212704488"></p><p>没有报错，那么我们访问一下接口http://127.0.0.1/boot-war/cc，报了404，说明我们项目未被部署成功。</p><p><img src="/images/image-20200426212841507.png" alt="image-20200426212841507"></p></li></ol><p>未部署成功，是因为我们在打包的时候，将内置的tomcat的jar包一并打到war包中了，这时和外部的tomcat冲突了。</p><h3 id="三-优化后的springboot打war包"><a class="markdownIt-Anchor" href="#三-优化后的springboot打war包"></a> 三、优化后的SpringBoot打war包</h3><ol><li><p>修改依赖的tomcat包的scope</p><ul><li><p>第一种方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接屏蔽掉<code>spring-boot-starter-web</code>中向下传递的<code>spring-boot-starter-tomcat</code>包，并引入<code>javax.servlet-api</code>包，并将scope设置为<code>provided</code>，不然打包的时候会报错。</p></li><li><p>第二种方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将<code>spring-boot-starter-tomcat</code>和<code>javax.servlet-api</code>的jar包的scope设置为<code>provided</code>便于打包。</p></li></ul></li><li><p>修改启动类，设置启动配置</p><p>发布到独立的Tomcat需要继承SpringBootServletInitializer类并重写configure方法，在war包部署解压后的文件夹中没有普通web项目的web.xml，但是仍然能启动，就是因为SpringConfig继承了SpringBootServletInitializer，所以打包的时候SpringBoot做了初始化工作，这个类就是用于代替传统MVC模式中的web.xml。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcSpringBootWarApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CcSpringBootWarApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(CcSpringBootWarApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure></li><li><p>部署</p><p>将war包放到外部tomcat的webapps目录下，然后启动tomcat后访问http://127.0.0.1/boot-war/cc，访问正常。</p><p><img src="/images/image-20200426215949343.png" alt="image-20200426215949343"></p></li></ol><h3 id="四-直接创建war项目"><a class="markdownIt-Anchor" href="#四-直接创建war项目"></a> 四、直接创建war项目</h3><p>在创建应用的时候，packaging选择War（目前只有Jar和War两个选项），就能直接创建出符合条件的应用，不需要再进行任何修改就可以直接打成war包。</p><img src="/images/image-20200426220404239.png" alt="image-20200426220404239" style="zoom: 35%;"><p>创建的应用内容如下：</p><img src="/images/image-20200426220312800.png" alt="image-20200426220312800" style="zoom:35%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-简介&quot;&gt;&lt;/a&gt; 一、简介&lt;/h3&gt;
&lt;p&gt;SpringBoot应用默认打包成可执行jar模式方便我们的快速部署，如果是web应用的话，则默认使用内置的tomcat作为serv
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>使用LockSupport实现线程交替打印1-100</title>
    <link href="http://luxiaowan.github.io/2020/04/25/%E4%BD%BF%E7%94%A8LockSupport%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/"/>
    <id>http://luxiaowan.github.io/2020/04/25/使用LockSupport实现线程交替打印1-100/</id>
    <published>2020-04-25T08:30:00.000Z</published>
    <updated>2020-04-25T12:15:18.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>LockSupport是JDK底层的基于<code>sun.misc.Unsafe</code>来实现的类，用来创建锁和其他同步工具类的基本线程阻塞原语，在AQS中，就是通过调用LockSupport.park()和LockSupport.unpark()来实现线程的阻塞和唤醒的，不清楚的可以先了解一下<a href="https://luxiaowan.github.io/2020/04/24/AQS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/">AQS基本概况</a>。每一个使用LockSupport的线程都会与一个许可关联，如果许可证在线程中可用，则调用park()将会立即返回，否则可能堵塞；若许可证不可用，则调用unpark()将其转为可用状态。调用park()的次数要少于等于调用unpark()的次数，否则将会导致许可不可用引起阻塞。</p><h3 id="locksupport方法介绍"><a class="markdownIt-Anchor" href="#locksupport方法介绍"></a> LockSupport方法介绍</h3><p>LockSupport提供的方法不多，且都是类方法，来看下：</p><ul><li>阻塞线程<ol><li>park()：阻塞当前线程，需要在线程内调用，如果调用unpark()或者将线程中断，则从park()方法中返回</li><li>park(Object blocker)：功能与park()相同，入参是一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查</li><li>parkNanos(long nanos)：阻塞当前线程，阻塞时长不超过nanos纳秒，超时自动返回</li><li>parkNanos(Object blocker, long nanos)：功能同parkNanos(long nanos)，在其基础上增加了Object对象，等同于是park(Object blocker)+parkNanos(long nanos)的组合</li><li>parkUtil(long deadline)：阻塞当前线程，直到deadline后自动返回</li><li>parkUtil(Object blocker, long deadline)：：等同于park(Object blocker)+parkUtil(long deadline)的组合</li></ol></li><li>唤醒线程<ol><li>unpar(Thread thread)：唤醒处于阻塞状态的指定线程</li></ol></li></ul><p>以上就是LockSupport的主要方法，每一种park方法都提供了一个Object对象的入参，目的是为了方便进行问题排查，那我们来看下是怎么方便的</p><ol><li><p>park()的线程栈</p><p><img src="/images/image-20200425175946604.png" alt="image-20200425175946604"></p></li><li><p>park(Object blocker)的线程栈</p><p><img src="/images/image-20200425180113595.png" alt="image-20200425180113595"></p></li></ol><p>使用Object入参的方法之后，线程栈中出现了<code>parking to wait for</code>提示，告诉我们因为哪个对象发生的阻塞，方便我们查找阻塞源头。</p><h3 id="例子1"><a class="markdownIt-Anchor" href="#例子1"></a> 例子1</h3><ol><li><p>使用两个线程交替打印1-100</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintNumTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Print p1 = <span class="keyword">new</span> Print();</span><br><span class="line">        Print p2 = <span class="keyword">new</span> Print();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(p2);</span><br><span class="line">        t1.setName(<span class="string">"thread-cc-1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"thread-cc-2"</span>);</span><br><span class="line">        p1.setT(t2);</span><br><span class="line">        p2.setT(t1);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">      <span class="comment">// 唤醒线程t1打印奇数，线程1打印奇数，线程2打印偶数</span></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">      <span class="comment">// 唤醒线程t2打印奇数，线程1打印偶数，线程2打印奇数</span></span><br><span class="line">      <span class="comment">// LockSupport.unpark(t1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Thread t;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="comment">// 进入之后立即阻塞</span></span><br><span class="line">                LockSupport.park();</span><br><span class="line">                <span class="keyword">if</span> (num.get() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + num.getAndIncrement());</span><br><span class="line">              <span class="comment">// 奇数唤醒偶数线程，偶数唤醒奇数线程</span></span><br><span class="line">                LockSupport.unpark(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程使用死循环来保持运行状态，然后使用return来终止运行，进入循环之后立即调用LockSupport.park()阻塞当前线程，在调用线程的start()方法之后两个线程都堵塞在run()方法开始位置，在线程1中打开线程2的许可证，在线程2中打开线程1的许可证，达到交替执行的目的。此时线程都堵塞了，那么我们就可以在主线程中控制先打开哪一个线程的许可证了，如果想让线程1打印奇数，线程2打印偶数，就先把线程1阻塞的许可证打开，让线程1先执行；如果想让线程1打印偶数，线程2打印奇数，就先把线程2阻塞的许可证打开，让线程2先执行。</p><ul><li>t1打印奇数，t2打印偶数</li></ul><img src="/images/image-20200425194737366.png" alt="image-20200425194737366" style="zoom:50%;"><ul><li><p>t1打印偶数，t2打印奇数</p><img src="/images/image-20200425194937392.png" alt="image-20200425194937392" style="zoom:50%;"></li></ul></li><li><p>使用三个线程交替打印1-100</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintNumTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Print p1 = <span class="keyword">new</span> Print();</span><br><span class="line">        Print p2 = <span class="keyword">new</span> Print();</span><br><span class="line">        Print p3 = <span class="keyword">new</span> Print();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(p2);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(p3);</span><br><span class="line">        t1.setName(<span class="string">"thread-cc-1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"thread-cc-2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"thread-cc-3"</span>);</span><br><span class="line">        p1.setT(t2);</span><br><span class="line">        p2.setT(t3);</span><br><span class="line">        p3.setT(t1);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Thread t;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                <span class="keyword">if</span> (num.get() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + num.getAndIncrement());</span><br><span class="line">                LockSupport.unpark(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h3&gt;
&lt;p&gt;LockSupport是JDK底层的基于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;来实现的类，用来创建锁和其他同步工具类的基本线程
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>AQS基本概况</title>
    <link href="http://luxiaowan.github.io/2020/04/24/AQS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/"/>
    <id>http://luxiaowan.github.io/2020/04/24/AQS基本概况/</id>
    <published>2020-04-24T04:20:00.000Z</published>
    <updated>2020-04-24T18:38:23.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-简介"><a class="markdownIt-Anchor" href="#一-简介"></a> 一、简介</h3><p>在Java中，谈到并发就不得不说到jdk中的J.U.C包，而说到此包必定要说到AQS(AbstractQueuedSynchronizer)，从类名上可以看出这是一个抽象的、使用队列实现的同步器，AQS提供了一个FIFO队列，可以用于构建同步锁的基础框架，内部通过volatile的变量state来表示锁的状态，当state=0时表示锁空闲，当state&gt;0时表示锁被占用，如果锁是可重入的，比如ReentrantLock，state的值会随着重入次数不断的+1，在锁释放的时候需要将state进行-1直到等于0，所以对于重入锁来说，重入多少次就要释放多少次，否则会一直占着锁导致其他线程无法申请到锁而一直等待，最终撑爆CPU。</p><p>AQS的核心思想是如果被请求的共享资源空闲，则将资源分配给当前请求资源的线程，并将共享资源设置为锁定状态，如果此时有其他线程过来请求此共享资源，会发现共享资源已经被占用，则阻塞该线程，将其放入到等待队列中。</p><p>AQS的等待队列又叫CLH队列，是一个FIFO性质的，CLH的名字来自于它的创建者，三位老前辈的名字的首字母(Craig, Landin, Hagersten)，CLH队列是一个双向队列，AQS将每个请求共享资源但未成功的线程封装成一个CLH队列的Node节点并放入队列中等待分配。</p><p><img src="/images/image-20200424221846794.png" alt="image-20200424221846794"></p><h3 id="二-aqs锁方式"><a class="markdownIt-Anchor" href="#二-aqs锁方式"></a> 二、AQS锁方式</h3><p>AQS提供了独占锁和共享锁两种锁的声明，在其内部并未对锁进行具体实现，仅仅提供了一些模板方法，由具体的实现类决定如何实现。</p><ul><li><p>独占锁</p><p>独占锁意思就是同一时刻只能有一个线程霸占共享资源，其他请求的线程全部等待，比如ReentrantLock。看一下大致的流程：</p><img src="/images/image-20200424155241273.png" alt="image-20200424155241273" style="zoom:40%;"></li><li><p>共享锁</p><p>共享锁设计的初衷是允许一个或多个线程等待一组事件完成，主要实现为CountDownLatch，主要原理是在创建的时候给state设定一个数值， 表示需要等待的事件数量，这个值需要和要等待执行的线程数一致，每个线程执行完成后，对state减一，在state不等于0之前，应该一直等待，除非遇到线程中断或等待超时。</p><img src="/images/image-20200424203513738.png" alt="image-20200424203513738" style="zoom:40%;"></li></ul><h3 id="三-aqs等待队列"><a class="markdownIt-Anchor" href="#三-aqs等待队列"></a> 三、AQS等待队列</h3><p>当共享资源被占用时，其他请求该资源的线程将会阻塞，然后被加入到同步队列。就数据结构而言，队列的实现方式一种是数组，一种是链表，AQS中的等待队列是通过链表的方式来实现的，名字叫做CLH队列。</p><ul><li><p>CLH队列节点是通过AQS内部Node类来封装的，一个节点表示一个线程，保存着线程的引用(<code>volatile Thread thread</code>)、状态(<code>volatile int waitStatus</code>)、前驱节点(<code>volatile Node prev</code>)、后继节点(<code>volatile Node next</code>)，这些变量全部都是volatile关键字修饰的，保证了节点的原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 共享 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 独占 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示下一次共享式同步状态获取将会无条件地传播下去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 等待状态 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前驱节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 后继节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取同步状态的线程 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 返回前置节点 */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>入列</p><p>CLH队列是双向链表的FIFO队列，知道了这个特性之后，对于它的入列就基本能明了了，每次入列均放在队列最后，我们来看看AQS的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建CLH队列节点</span></span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  <span class="comment">// 获取当前的尾结点</span></span><br><span class="line">  Node pred = tail;</span><br><span class="line">  <span class="comment">// 如果尾结点不为null，说明队列已完成了初始化</span></span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前节点的前置节点设置为原尾结点</span></span><br><span class="line">    node.prev = pred;</span><br><span class="line">    <span class="comment">// 将当前节点通过CAS设置为尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">      <span class="comment">// 将原尾结点的后置节点设置为当前节点</span></span><br><span class="line">      pred.next = node;</span><br><span class="line">      <span class="comment">// 返回当前节点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 队列为空的处理</span></span><br><span class="line">  enq(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 无限循环入队，直到成功</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 获取尾结点</span></span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="comment">// 尾结点为空，说明队列尚未被初始化</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 设置头结点</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">        <span class="comment">// 设置尾结点，头尾相等则表示队列为空</span></span><br><span class="line">        tail = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当前节点的前置节点设置为原尾结点</span></span><br><span class="line">      node.prev = t;</span><br><span class="line">      <span class="comment">// 将当前节点通过CAS设置为尾结点</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        <span class="comment">// 将原尾结点的后置节点设置为当前节点</span></span><br><span class="line">        t.next = node;</span><br><span class="line">        <span class="comment">// 返回原尾结点</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中看到两个方法都是通过CAS方法<code>compareAndSetHead(Node update)</code>和<code>compareAndSetTail(Node expect, Node update)</code>来设置头尾节点，确保节点的添加是线程安全的，在enq(Node node)方法中通过无限循环来保证节点可用被正确添加，只有在成功之后才会返回。</p></li><li><p>出列</p><p>CLH队列遵循FIFO规则，首节点先占用共享资源，在线程释放同步状态后，将会唤醒它的后继节点(next)，后继节点在获取同步状态成功之后将自己设置为首节点，这个过程其实就是双向链表的移动，将头结点的next指向原首节点的next，然后这个next节点的前置节点设置为null，这个过程不需要使用CAS来保证，因为同时只有一个线程能够成功获取到同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取当前节点的前置节点</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="comment">// 当前节点的前置节点是head的话，则表明轮到它来获取同步状态了</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        <span class="comment">// 加锁成功，将当前节点设置为头结点</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当前节点不是第二个节点 或者再次获取锁失败</span></span><br><span class="line">      <span class="comment">// 判断是否需要挂起，在挂起后，判断线程是否中断</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  head = node;</span><br><span class="line">  node.thread = <span class="keyword">null</span>;</span><br><span class="line">  node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">  Node p = prev;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"><span class="comment">// 当前节点已经被设置为等待唤醒的状态，可以安全的挂起了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点node的前任节点被取消，那么跳过这些取消的节点，当跳过之后，重新尝试获取锁</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过前面的判断，waitStatus一定不是 SIGNAL 或 CANCELLED。</span></span><br><span class="line"><span class="comment">         * 推断出一定是 0 or PROPAGATE</span></span><br><span class="line"><span class="comment">         * 调用者需要再次尝试，在挂起之前能不能获取到锁，</span></span><br><span class="line"><span class="comment">         * 因此，将当前pred的状态设为SIGNAL，再次尝试获取锁之后，如果还没有得到锁那么挂起</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个线程对于锁的一次竞争的结果有两种：</p><ul><li>要么成功获取到锁(不用进入到CLH队列)</li><li>要么获取失败被挂起，等待下次唤醒后继续循环尝试获取锁</li></ul><blockquote><p>因为AQS的队列是FIFO的，所以每次被CPU唤醒之后，如果当前线程不是头结点，则会被挂起，通过这种方式实现了竞争的排队策略。</p></blockquote></li></ul><h3 id="四-独占锁reentrantlock"><a class="markdownIt-Anchor" href="#四-独占锁reentrantlock"></a> 四、独占锁ReentrantLock</h3><ol><li><p>独占锁的实现类有ReentrantLock、ReentrantReadWriteLock、ThreadPoolExecutor等，我们拿ReentrantLock学习一下独占锁的使用。先来看一下ReentrantLock的基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock会保证在lock.lock()和lock.unlock()之间的代码块在同一时间只有一个线程访问，其余线程会被挂起，直至获取到锁。</p></li><li><p>ReentrantLock的基本原理</p><p>ReentrantLock内部有公平锁(FairSync)和非公平锁(NonfairSync)，默认采用非公平锁。</p><ul><li>公平锁：每个线程抢占锁的顺序按照调用lock方法的顺序依次获取锁</li><li>非公平锁：每个线程抢占锁的顺序和调用lock方法的顺序无关，每一个线程到来之后都先获取锁，获取不到的话再加入到队列中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ReentrantLock，公平锁or非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加锁解锁，使用sync完成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了ReentrantLock的锁竞争机制之后，我们来看下它到底是怎么实现独占锁的。既然ReentrantLock的锁是通过公平锁和非公平锁来实现的，那么加锁和释放锁的实现逻辑也都在这两把锁中了。</p><ul><li><p>同步锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非公平锁加锁</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取AQS的state的值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果state=0表示当前共享资源空闲</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 将当前线程设置为独占锁的拥有者</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程已经是锁的拥有者，则增加state的值，重入锁的概念</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取state的值并减去要释放的锁数量</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 判断当前线程是否为锁的拥有者，其实可以替换为if(!isHeldExclusively())</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// state==0，锁释放</span></span><br><span class="line">      free = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 设置拥有者为空</span></span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前线程是否为锁的拥有者</span></span><br><span class="line">    <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Condition控制对象，提供lock.newCondition()方法调用</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前锁的拥有者线程</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取锁的重入次数，如果当前线程不是锁的拥有者，则返回0</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁是否被占用了</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync类是公平锁和非公平锁的基类，默认提供了非公平锁的加锁逻辑，也提供了通用的一些方法，大部分的方法也都被final修饰，不允许被重载和重写。</p></li><li><p>公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现Sync的lock()抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// state设置为1，调用到AQS中的acquire方法</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公平锁加锁，由AQS的acquire方法调用过来</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取state的值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 锁未被占用</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 首先判断队列中是否有等待的线程</span></span><br><span class="line">      <span class="comment">// 队列不为空则加锁失败，并放入队列中</span></span><br><span class="line">      <span class="comment">// 等待队列为空的情况下，使用CAS修改state的值，成功后就是加锁成功</span></span><br><span class="line">      <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">          compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 当前线程设置为锁的拥有者</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁被占有，判断当前线程是否为当前锁的拥有者</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="comment">// 重入锁机制</span></span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非公平的关键</span></span><br><span class="line">    <span class="comment">// 线程调用lock()后，不论等待队列中有没有等待中的线程，都申请一次加锁，CAS操作设置state=1，在原线程拥有者释放锁到队列中头结点加锁成功之间可能会加锁成功，这可以理解为排队的过程中遇到插队的</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">      setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 调用AQS的acquire方法</span></span><br><span class="line">      acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由AQS中的acquire方法调用回来</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为Sync中默认实现了非公平锁，所以只要调用父类的方法即可</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>小总结:</p><ol><li>公平锁与非公平锁的锁释放步骤是一致的</li><li>获取锁的过程不一致，公平锁优先执行等待时间最长的线程，非公平锁让当前线程抢占，如果一直被抢占的话，队列中的等待线程可能一直都执行不了。</li></ol></blockquote></li><li><p>其他方法</p><p>ReentrantLock还为我们提供了一些其他的方法，方便我们的使用。</p><ul><li><p><code>getQueuedThreads()</code>：获取等待队列中等待的线程，返回一个List&lt;Thread&gt;对象，按照加入队列顺序倒序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">  <span class="comment">// 从尾部开始迭代</span></span><br><span class="line">  <span class="keyword">for</span> (Node p = tail; p != <span class="keyword">null</span>; p = p.prev) &#123;</span><br><span class="line">    Thread t = p.thread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">      list.add(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>tryLock()</code>：尝试获取锁</p></li><li><p><code>isFair()</code>：获取当前锁是否为公平锁，true代表公平锁</p></li><li><p><code>newCondition()</code>：锁控制条件类实例，类似于wait和notify</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 使用方式:ArrayBlockingQueue */</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition notEmpty = lock.newCondition();</span><br><span class="line">Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  checkNotNull(e);</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == items.length)</span><br><span class="line">      notFull.await();</span><br><span class="line">    enqueue(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  E x = (E) items[takeIndex];</span><br><span class="line">  items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">    takeIndex = <span class="number">0</span>;</span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">    itrs.elementDequeued();</span><br><span class="line">  notFull.signal();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">      notEmpty.await();</span><br><span class="line">    <span class="keyword">return</span> dequeue();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  items[putIndex] = x;</span><br><span class="line">  <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">    putIndex = <span class="number">0</span>;</span><br><span class="line">  count++;</span><br><span class="line">  notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="五-共享锁countdownlatch"><a class="markdownIt-Anchor" href="#五-共享锁countdownlatch"></a> 五、共享锁CountDownLatch</h3><ol><li><p>CountDownLatch基本原理</p><p>CountDownLatch翻译一下就是&quot;倒数门栓&quot;，可以理解为给一个门上了n把锁，然后锁一把一把的开，直到所有的锁都打开之后，门才能彻底打开。所以CountDownLatch只有一个构造器，构造器传入锁的数量，每个线程执行完一个任务就倒数一次，当所有的线程都执行完成之后，主线程才能继续往下执行，数量需要和需要执行的线程数一致，否则会出现提前释放和无法释放的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">  <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch主要通过await()和countDown()完成锁等待和倒数，没调用一次countDown()就将计数器减一，一般在执行任务的线程内调用，此方法不区分调用者，可以在一个线程内调用多次；await()方法是将调用该方法的线程处于等待状态，一般是主线程调用，可以在多个线程内调用，所有调用了await()方法的线程都将陷入等待，并且共享同一把锁，当CountDownLatch的锁释放完之后，所有等待的线程都同时结束等待并恢复执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 阻塞</span></span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 释放共享锁</span></span><br><span class="line">  sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现在CountDownLatch中也是通过Sync类来控制锁的，并且Sync是CountDownLatch的内部类，我们看一下Sync的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">  Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="comment">// 初始化锁的数量</span></span><br><span class="line">    setState(count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前剩余的锁数量</span></span><br><span class="line">    <span class="keyword">return</span> getState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据剩余锁的数量决定是否加锁成功，若还有剩余锁，则返回-1，表示加锁成功，否则返回1，表示不允许加锁</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState();</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 锁已全部释放，不允许释放</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 锁-1</span></span><br><span class="line">      <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 通过CAS设置state值，确保并发安全</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">        <span class="comment">// 当nextc为0的时候表示锁已经全部释放了</span></span><br><span class="line">        <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>countDown方法工作方式</p><p>tryReleaseShared()方法在AQS的releaseShared()方法中调用，方法中只有一个if判断，控制锁释放的时机，doReleaseShared()方法主要作用是唤醒调用了await()方法的线程。如果CountDownLatch是独占式的，那么当计数器为减至0时，就只有一个线程会被唤醒，这就乱套了，严重BUG。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    doReleaseShared();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 获取等待队列的头结点</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">// 头结点不为空且不是尾结点，也就是等待队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">      <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">      <span class="comment">// SIGNAL表示当前节点的线程正在等待被唤醒</span></span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="comment">// 清楚当前节点的等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 唤醒当前节点的下一个节点</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果h还是头结点，则说明等待队列在上面的代码执行过程中没有被其他线程处理</span></span><br><span class="line">    <span class="keyword">if</span> (h == head)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 清除当前节点的等待状态</span></span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前节点的后继节点</span></span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="comment">// 后继节点不存在或者该节点中的线程已经被取消等待</span></span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 队列从尾部往前遍历，找到最后一个处于等待状态的节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">      <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 唤醒离当前节点最近的处于等待状态的节点线程</span></span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们了解了CountDownLatch的countDown()方法的执行逻辑，总结一下就是每次调用countDown()方法都会将state减1，直到state减至0的时候，调用doReleaseShared()方法将等待队列中的所有线程的等待状态都清除掉(waitStatus通过CAS设置为0)。</p></li><li><p>await()方法工作方式</p><p>await()方法调用了Sync的acquireSharedInterruptibly()方法，在该方法中判断当前线程是否具有共享执行权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 当前线程是否被中断</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">// 判断当前线程是否有执行权限，也就是校验是否还有未释放的锁</span></span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 阻塞</span></span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个共享模式的节点</span></span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取当前节点的前置节点</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="comment">// 前置节点是否为head节点</span></span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="comment">// 加锁，如果还有锁未释放，也就是state&gt;0，方法返回-1，否则返回1</span></span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">        <span class="comment">// 锁已全部释放</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 将当前节点设置为头结点，表示所有线程都已经执行完毕，退出for循环，可以继续await()方法之后的代码</span></span><br><span class="line">          setHeadAndPropagate(node, r);</span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 代码执行到这里说明当前锁还未释放完，使用LockSupport.park(this);挂起当前线程</span></span><br><span class="line">      <span class="comment">// 所有的线程都会等待在此处，在countDown()方法中被LockSupport.unpark(s.thread);唤醒后继续从这里执行</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">  Node h = head;</span><br><span class="line">  setHead(node);</span><br><span class="line">  <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">      (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">      <span class="comment">// 释放并唤醒结束await</span></span><br><span class="line">      doReleaseShared();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用场景</p><ul><li><p>场景1：在每个线程内调用一次countDown()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">  CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> fi = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(fi * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(fi);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        latch.countDown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"before:"</span> + System.currentTimeMillis());</span><br><span class="line">  latch.await();</span><br><span class="line">  System.out.println(<span class="string">"after:"</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>0</p><p>before:1587753222118</p><p>1</p><p>2</p><p>after:1587753224118</p></blockquote></li><li><p>场景2：在每个线程内调用三次countDown()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">  CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> fi = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(fi * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(fi);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        latch.countDown();</span><br><span class="line">        latch.countDown();</span><br><span class="line">        latch.countDown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"before:"</span> + System.currentTimeMillis());</span><br><span class="line">  latch.await();</span><br><span class="line">  System.out.println(<span class="string">"after:"</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>0</p><p>before:1587753292096</p><p>after:1587753292096</p><p>1</p><p>2</p></blockquote></li></ul></li><li><p>总结</p><p>CountDownLatch是通过一个计数器来实现的共享锁，计数器的值就是线程的数量，在主线程中使用CountDownLatch的实例方法await()阻塞所有的线程，阻塞地点在parkAndCheckInterrupt()方法中；每调用一次countDown()方法都会将计数器减1，直到计数器归零之后唤醒所有等待的线程，使await()执行结束，既然await()执行结束了，那么也就可以继续执行await()的后续代码了。</p></li></ol><h3 id="六-总结"><a class="markdownIt-Anchor" href="#六-总结"></a> 六、总结</h3><p>通过CountDownLatch和ReentrantLock可以发现几个特点：</p><ol><li>独占锁的使用和申请加锁线程强关联，每此只能由一个线程霸占着锁，且可以通过当前线程和锁拥有者线程对比来实现锁的重入</li><li>共享锁的使用和线程弱关联，每次可以执行一批线程任务，使用state来控制运行的线程数量，通过LockSupport.park()阻塞这批任务，每个线程执行完之后将state的值减1，直至归零，然后通过LockSupport.unpark()退出阻塞</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-简介&quot;&gt;&lt;/a&gt; 一、简介&lt;/h3&gt;
&lt;p&gt;在Java中，谈到并发就不得不说到jdk中的J.U.C包，而说到此包必定要说到AQS(AbstractQueuedSynchroni
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
</feed>
