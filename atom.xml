<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2020-06-10T14:49:23.634Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL如何存储多选框的结果?</title>
    <link href="http://luxiaowan.github.io/2020/06/09/MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%A4%9A%E9%80%89%E6%A1%86%E7%9A%84%E7%BB%93%E6%9E%9C/"/>
    <id>http://luxiaowan.github.io/2020/06/09/MySQL如何存储多选框的结果/</id>
    <published>2020-06-09T15:35:00.000Z</published>
    <updated>2020-06-10T14:49:23.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>在实际工作中，经常会遇到要存储多选框结果的情况，多选框的属性的值有多个，通常我们使用的存储方式大多是横向和纵向分隔两种方式。比如我们有一个场景：用户在注册的时候需要选择兴趣爱好，共有10个选项，可不选、单选和多选。</p><ol><li><p>横向分隔</p><p>横向的意思是将所有的数据存储在一条数据的一个字段中，在字段中使用特殊符号将每个结果分隔开，比如：1,2,3,4,5,6。</p><table><thead><tr><th>id</th><th>user_id</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>,1,2,3,4,5,6,</td></tr><tr><td>2</td><td>2</td><td>,3,5,6,8,9,</td></tr></tbody></table><p>这种方式存储简单，查询使用like进行查询；在更新的时候需要整个字段全量更新。</p><ul><li><p>查询兴趣爱好id=3的用户id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from sth_user_hobbies where value like &apos;%,3,%&apos;;</span><br></pre></td></tr></table></figure></li><li><p>查询兴趣爱好id=3和4的用户id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from sth_user_hobbies where value like &apos;%,3,4,%&apos;;</span><br></pre></td></tr></table></figure></li><li><p>用户user_id=2取消兴趣id=8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update sth_user_hobbies set value = &apos;,3,5,6,9,&apos; where user_id=2;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>纵向分隔</p><p>纵向的意思是每一个结果存储为一条数据，选择了多少个框就有多少条数据，比如：</p><table><thead><tr><th>id</th><th>user_id</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>8</td></tr></tbody></table><ul><li><p>查询兴趣爱好id=3的用户id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from sth_user_hobbies where value=3;</span><br></pre></td></tr></table></figure></li><li><p>查询兴趣爱好id=3和4的用户id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from sth_user_hobbies where value in (3, 4);</span><br></pre></td></tr></table></figure></li><li><p>用户user_id=2取消兴趣id=8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from sth_user_hobbies where user_id=2 and value=8;</span><br></pre></td></tr></table></figure></li></ul><p>这种存储方式简单高效，缺点就是数据量大，若多选框有30个可选值，10万个用户都选择了全部，那在表中就会有300万条记录，是横向分隔方案的30倍；优势就是数据分散，可以使用索引，并且不需要对数据进行二次处理。</p></li></ol><p>上面这两种是我们常用的方式，那么是否有其他方式来处理多选框的数据存储问题？下面就来看下另一种方案。</p><h3 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h3><p>位运算很简单，程序中的所有数在计算机内存中都是以二进制的形式存储的。位运算就是直接对整数在内存中的二进制位进行操作。比如，and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）。</p><table><thead><tr><th style="text-align:left">含义</th><th style="text-align:left">Java</th><th>MySQL</th></tr></thead><tbody><tr><td style="text-align:left">按位与</td><td style="text-align:left">a &amp; b</td><td>a &amp; b</td></tr><tr><td style="text-align:left">按位或</td><td style="text-align:left">a | b</td><td>a | b</td></tr><tr><td style="text-align:left">按位异或</td><td style="text-align:left">a ^ b</td><td>a ^ b</td></tr><tr><td style="text-align:left">按位取反</td><td style="text-align:left">~a</td><td>~a</td></tr><tr><td style="text-align:left">左移</td><td style="text-align:left">a &lt;&lt; b</td><td>a &lt;&lt; b</td></tr><tr><td style="text-align:left">带符号右移</td><td style="text-align:left">a &gt;&gt; b</td><td>a &gt;&gt; b</td></tr></tbody></table><p>位运算是计算机的基础知识，本篇不做详细讲解，可以去谷歌<a href="https://www.google.com/search?newwindow=1&amp;sxsrf=ALeKk00onJ28qgHokC2FKEPuPis9R9UlXw%3A1591759000208&amp;ei=mFDgXt6WDJb8wQO0q5SIAQ&amp;q=%E4%BD%8D%E8%BF%90%E7%AE%97&amp;oq=%E4%BD%8D%E8%BF%90%E7%AE%97&amp;gs_lcp=CgZwc3ktYWIQAzICCAAyAggAMgIIADICCAAyAggAMgIIADICCAAyAggAMgIIADICCAA6BAgAEEM6BAgjECc6BQgAELEDOgUIABCLAzoICAAQsQMQiwM6BwgAELEDEEM6CAgAEIMBEIsDUIy9rARYhsisBGC0yawEaABwAHgAgAHMAogB1hSSAQcwLjYuNS4xmAEAoAEBqgEHZ3dzLXdpergBAg&amp;sclient=psy-ab&amp;ved=0ahUKEwjewpmupPbpAhUWfnAKHbQVBREQ4dUDCAw&amp;uact=5" target="_blank" rel="noopener">位运算</a>学习一下。</p><h3 id="mysql位运算解决方案"><a class="markdownIt-Anchor" href="#mysql位运算解决方案"></a> MySQL位运算解决方案</h3><p>了解了位运算，那么我们来看下在MySQL中，怎么使用位运算来解决上述场景。</p><p>一共有10个兴趣爱好选项，那么我们将这10个兴趣爱好的ID设置为1、2、4、8、16、32、64、128、256、512，我们的表结构为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table sth_user_hobbies</span><br><span class="line">(</span><br><span class="line">id bigint auto_increment primary key,</span><br><span class="line">user_id bigint not null comment &apos;用户ID&apos;,</span><br><span class="line">hobbies bigint null comment &apos;兴趣爱好&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>当我们插入一条数据时，可以在业务代码中通过位运算计算出最终数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; hobbyList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    add(<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">2</span>);</span><br><span class="line">    add(<span class="number">4</span>);</span><br><span class="line">    add(<span class="number">16</span>);</span><br><span class="line">    add(<span class="number">128</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// hobby = 151</span></span><br><span class="line"><span class="keyword">int</span> hobby = hobbyList.stream().mapToInt(v -&gt; v).reduce(<span class="number">0</span>, (a, b) -&gt; a | b);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into sth_user_hobbies(user_id, hobbies) values(1, 151);</span><br></pre></td></tr></table></figure></li><li><p>当我们要查询所有对id=4感兴趣的用户id时，可以通过与运算来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from sth_user_hobbies where hobbies &amp; 4 = 4;</span><br></pre></td></tr></table></figure><p>是不是很简单，但是在查询语句中，我们对列<code>hobbies</code>进行了计算，所以该列无法建立索引，因为当索引列参与计算时，会自动将索引失效。</p></li><li><p>当我们要查询所有对id=4和16感兴趣的用户id时，则可以先将4和16进行或运算，然后再带入到SQL中进行与运算，也可以在SQL中直接进行计算，不过建议是在业务逻辑代码中把数据计算好再带入SQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from sth_user_hobbies where hobbies &amp; (4 | 16) = (4 | 16);</span><br></pre></td></tr></table></figure></li><li><p>当我们对id=16不再感兴趣，取消该兴趣爱好，那么我们就可以用到异或操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update sth_user_hobbies set hobbies = hobbies^16 where user_id = 1;</span><br></pre></td></tr></table></figure></li><li><p>当我们新增加了一个或多个兴趣爱好，那么则可以在业务代码中将其计算好二进制的值，然后带入到SQL中进行或操作，再或者直接带入到SQL中进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update sth_user_hobbies set hobbies = hobbies | (4 | 16) where user_id = 1;</span><br></pre></td></tr></table></figure></li><li><p>当我们要查询所有对id=4或id=8感兴趣的用户id时，则和正常的使用没什么区别，也要使用到or关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from sth_user_hobbies where hobbies &amp; 4 = 4 or hobbies &amp; 8 = 8;</span><br></pre></td></tr></table></figure></li></ul><p>上面的一些基本操作让我们的查询更加方便，但是如果我们要查询某用户选择的所有兴趣爱好列表，那么该怎么操作？</p><p>这个情况就变得有些复杂了，因为我们在数据库中存储的是一个计算后的数字，我们需要通过数字反推出来列表，这就比较麻烦了，那有没有什么好的办法呢？</p><hr><p>答案是：没有。只能一个个的去做与运算，返回与运算后相等的数据，或者连表查询，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select uh.user_id, h.* </span><br><span class="line">from sth_user_hobbies uh </span><br><span class="line">left join sth_hobbies h </span><br><span class="line">on uh.hobbies &amp; h.id = h.id </span><br><span class="line">where uh.user_id = 1;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;在实际工作中，经常会遇到要存储多选框结果的情况，多选框的属性的值有多个，通常我们使用的存储方式大多是横向和纵向分隔两种方式。比如我们有一个场景：
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐十款IDEA撸码神器插件</title>
    <link href="http://luxiaowan.github.io/2020/06/09/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BEIDEA%E6%92%B8%E7%A0%81%E7%A5%9E%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>http://luxiaowan.github.io/2020/06/09/推荐几款IDEA撸码神器插件/</id>
    <published>2020-06-09T00:55:00.000Z</published>
    <updated>2020-06-09T15:12:34.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>IDEA作为一款常用的代码编辑工具，以功能强大和人性化等特点备受推崇，并且在使用过程中，我们还可以借助一些强大的插件来帮助我们简化编码工作。下面介绍几款我常用的功能性插件，每一个功能都相当不错，大家可以选择性使用。</p><h3 id="插件"><a class="markdownIt-Anchor" href="#插件"></a> 插件</h3><ol><li><p>Alibaba Java Coding Guidelines</p><p>及时检测代码中的坏味道，在扫描代码之后，将不符合阿里规约的代码显示出来，并且我们可以开启实时检测，也就是在编码的同时进行代码检测，这样可以快速的发现代码问题，但是这样对系统的开销较大。</p><p><img src="/images/image-20200609090644138.png" alt="image-20200609090644138"></p><blockquote><p>使用方式：</p></blockquote><ul><li>检测某个类：在类文件上/中右击，选择编码规约扫描</li><li>检测某个包下的所有类：在包名上右击，选择编码规约扫描</li><li>检测某个工程下的所有类：在工程上右击，选择编码规约扫描</li></ul><img src="/images/image-20200609090721705.png" alt="image-20200609090721705" style="zoom:33%;"></li><li><p>CodeGlance</p><p>在编辑器窗格中嵌入一个类似于Sublime中的代码小地图。使用自定义的颜色进行语法高亮，可以同时处理浅色和深色主题。具体样式如下：</p><img src="/images/image-20200609091153736.png" alt="image-20200609091153736" style="zoom:50%;"></li><li><p>Eclipse Code Formatter</p><p>该插件允许直接从IntelliJ使用Eclipse的代码格式化程序，解决在同时使用IDEA和Eclipse的团队环境中维护通用代码风格的问题。</p><p>文末奉上个人使用的<code>CodeFormatter.xml</code>文件。</p><p><img src="/images/image-20200609091452097.png" alt="image-20200609091452097"></p></li><li><p>Free Mybatis plugin</p><p>这个是简化MyBatis开发的最基础插件，关键是免费的，它可以让MyBatis的Mapper.java和Mapper.xml建立跳转关系，快速通过方法找到SQL，或通过SQL找到方法。</p><img src="/images/image-20200609092347294.png" alt="image-20200609092347294" style="zoom:50%;"><img src="/images/image-20200609092414704.png" alt="image-20200609092414704" style="zoom:50%;"></li><li><p>Lombok</p><p>我们在使用Lombok的时候，如果再idea中不安装插件，那么代码中使用了Lombok生成的代码会报错，所以要是想在idea中使用Lombok，必须安装Lombok插件，免费的</p></li><li><p>Maven Helper</p><p>可以帮助我们解决Maven依赖的包冲突，和<code>mvn dependency:tree</code>作用一样，不过这个插件是可视化的，简单方便</p><p><img src="/images/image-20200609092732290.png" alt="image-20200609092732290"></p></li><li><p>Rainbow Brackets</p><p>这是一个比较炫酷的插件，主要的作用其实就是将括号变成彩色的，这样在比对代码块的时候就更方便了</p><img src="/images/image-20200609093031332.png" alt="image-20200609093031332" style="zoom:50%;"></li><li><p>stackoverflow</p><p>这个插件可以直接选中代码或报错信息进行查找，该插件使用的搜索引擎是谷歌，所以没有VPN的同学可以忽略该插件</p></li><li><p>VisualVM Launcher</p><p>这个插件是个神器，可以在运行代码的同时启动jvisualvm进行项目监控</p><img src="/images/image-20200609094657696.png" alt="image-20200609094657696" style="zoom:50%;"></li><li><p>Save Actions</p><p>这个插件用处还是蛮大的，就不多做介绍了，可以看图理解</p><p><img src="/images/image-20200609095258282.png" alt="image-20200609095258282"></p></li></ol><hr><p>上面介绍了10个插件神器，大多是经常使用的，当然还有很多很厉害的插件，就不多做描述了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span> <span class="attr">version</span>=<span class="string">"12"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span> <span class="attr">kind</span>=<span class="string">"CodeFormatterProfile"</span> <span class="attr">name</span>=<span class="string">"YD Conventions"</span> <span class="attr">version</span>=<span class="string">"12"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_ellipsis"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_after_imports"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.format_javadoc_comments"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indentation.size"</span> <span class="attr">value</span>=<span class="string">"4"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.disabling_tag"</span> <span class="attr">value</span>=<span class="string">"@formatter:off"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.continuation_indentation"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_enum_constants"</span> <span class="attr">value</span>=<span class="string">"49"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_before_imports"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_after_package"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_binary_operator"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.indent_root_tags"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.enabling_tag"</span> <span class="attr">value</span>=<span class="string">"@formatter:on"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.compiler.problem.enumIdentifier"</span> <span class="attr">value</span>=<span class="string">"error"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indent_statements_compare_to_block"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.line_length"</span> <span class="attr">value</span>=<span class="string">"80"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.use_on_off_tags"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_method_declaration"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_binary_expression"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_block"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_lambda_body"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.compact_else_if"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.compiler.problem.assertIdentifier"</span> <span class="attr">value</span>=<span class="string">"error"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_binary_operator"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_unary_operator"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_ellipsis"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.format_line_comments"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.align_type_members_on_columns"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_assignment"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_conditional_expression"</span> <span class="attr">value</span>=<span class="string">"80"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_block_in_case"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.format_header"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode"</span> <span class="attr">value</span>=<span class="string">"enabled"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_method_declaration"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.join_wrapped_lines"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_resources_in_try"</span> <span class="attr">value</span>=<span class="string">"80"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.compiler.source"</span> <span class="attr">value</span>=<span class="string">"1.8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.tabulation.size"</span> <span class="attr">value</span>=<span class="string">"4"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.format_source_code"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_before_field"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_before_method"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.compiler.codegen.targetPlatform"</span> <span class="attr">value</span>=<span class="string">"1.8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_switch"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_after_type_annotation"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.format_html"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_compact_if"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indent_empty_lines"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_unary_operator"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_after_label"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_before_member_type"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_semicolon"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.format_block_comments"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_lambda_arrow"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indent_statements_compare_to_body"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.alignment_for_multiple_fields"</span> <span class="attr">value</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_array_initializer"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.wrap_before_binary_operator"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.compiler.compliance"</span> <span class="attr">value</span>=<span class="string">"1.8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_enum_constant"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.brace_position_for_type_declaration"</span> <span class="attr">value</span>=<span class="string">"end_of_line"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_before_package"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_lambda_arrow"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.join_lines_in_comments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.comment.indent_parameter_description"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.tabulation.char"</span> <span class="attr">value</span>=<span class="string">"space"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.blank_lines_between_import_groups"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.lineSplit"</span> <span class="attr">value</span>=<span class="string">"120"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation"</span> <span class="attr">value</span>=<span class="string">"do not insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">id</span>=<span class="string">"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch"</span> <span class="attr">value</span>=<span class="string">"insert"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;IDEA作为一款常用的代码编辑工具，以功能强大和人性化等特点备受推崇，并且在使用过程中，我们还可以借助一些强大的插件来帮助我们简化编码工作。下面
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Cannot Resolve org.openjfx:javafx.base:11.0.0-SNAPSHOT</title>
    <link href="http://luxiaowan.github.io/2020/05/31/Cannot-resolve-org.openjfxjavafx.base11.0.0-SNAPSHOT/"/>
    <id>http://luxiaowan.github.io/2020/05/31/Cannot-resolve-org.openjfxjavafx.base11.0.0-SNAPSHOT/</id>
    <published>2020-05-31T15:50:00.000Z</published>
    <updated>2020-05-31T15:49:19.810Z</updated>
    
    <content type="html"><![CDATA[<p>使用idea打开一个项目时，突然在构建的时候报错：</p><p>Cannot resolve org.openjfx:javafx.base:11.0.0-SNAPSHOT</p><p>这是因为项目的maven配置默认使用了jdk11，我们修改回jdk8即可</p><p><img src="/images/image-20200531234857539.png" alt="image-20200531234857539"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用idea打开一个项目时，突然在构建的时候报错：&lt;/p&gt;
&lt;p&gt;Cannot resolve org.openjfx:javafx.base:11.0.0-SNAPSHOT&lt;/p&gt;
&lt;p&gt;这是因为项目的maven配置默认使用了jdk11，我们修改回jdk8即可&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="BUG" scheme="http://luxiaowan.github.io/categories/BUG/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker安装nacos</title>
    <link href="http://luxiaowan.github.io/2020/05/31/Docker%E5%AE%89%E8%A3%85nacos/"/>
    <id>http://luxiaowan.github.io/2020/05/31/Docker安装nacos/</id>
    <published>2020-05-30T16:56:00.000Z</published>
    <updated>2020-05-30T17:35:36.180Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-搜索docker中可用的nacos源"><a class="markdownIt-Anchor" href="#一-搜索docker中可用的nacos源"></a> 一、搜索docker中可用的nacos源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nacos</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200531011955548.png" alt="image-20200531011955548"></p><h4 id="二-拉取nacos镜像"><a class="markdownIt-Anchor" href="#二-拉取nacos镜像"></a> 二、拉取nacos镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nacos/nacos-server</span><br></pre></td></tr></table></figure><h4 id="三-启动nacos容器"><a class="markdownIt-Anchor" href="#三-启动nacos容器"></a> 三、启动nacos容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --env MODE=standalone --name nacos -d -p 28848:8848 nacos/nacos-server</span><br></pre></td></tr></table></figure><p>nacos的默认端口是8848，默认账号密码是nacos/nacos</p><p>nacos的启动参数：</p><table><thead><tr><th>name</th><th>description</th><th>option</th></tr></thead><tbody><tr><td>MODE</td><td>cluster模式/standalone模式</td><td>cluster/standalone default <strong>cluster</strong></td></tr><tr><td>NACOS_SERVERS</td><td>nacos cluster地址</td><td>eg. ip1,ip2,ip3</td></tr><tr><td>PREFER_HOST_MODE</td><td>是否支持hostname</td><td>hostname/ip default <strong>ip</strong></td></tr><tr><td>NACOS_SERVER_PORT</td><td>nacos服务器端口</td><td>default <strong>8848</strong></td></tr><tr><td>NACOS_SERVER_IP</td><td>多网卡下的自定义nacos服务器IP</td><td></td></tr><tr><td>SPRING_DATASOURCE_PLATFORM</td><td>standalone 支持 mysql</td><td>mysql / empty default empty</td></tr><tr><td>MYSQL_MASTER_SERVICE_HOST</td><td>mysql 主节点host</td><td></td></tr><tr><td>MYSQL_MASTER_SERVICE_PORT</td><td>mysql 主节点端口</td><td>default : <strong>3306</strong></td></tr><tr><td>MYSQL_MASTER_SERVICE_DB_NAME</td><td>mysql 主节点数据库</td><td></td></tr><tr><td>MYSQL_MASTER_SERVICE_USER</td><td>数据库用户名</td><td></td></tr><tr><td>MYSQL_MASTER_SERVICE_PASSWORD</td><td>数据库密码</td><td></td></tr><tr><td>MYSQL_SLAVE_SERVICE_HOST</td><td>mysql从节点host</td><td></td></tr><tr><td>MYSQL_SLAVE_SERVICE_PORT</td><td>mysql从节点端口</td><td>default :3306</td></tr><tr><td>MYSQL_DATABASE_NUM</td><td>数据库数量</td><td>default :2</td></tr><tr><td>JVM_XMS</td><td>-Xms</td><td>default :2g</td></tr><tr><td>JVM_XMX</td><td>-Xmx</td><td>default :2g</td></tr><tr><td>JVM_XMN</td><td>-Xmn</td><td>default :1g</td></tr><tr><td>JVM_MS</td><td>-XX:MetaspaceSize</td><td>default :128m</td></tr><tr><td>JVM_MMS</td><td>-XX:MaxMetaspaceSize</td><td>default :320m</td></tr><tr><td>NACOS_DEBUG</td><td>开启远程调试</td><td>y/n default :n</td></tr><tr><td>TOMCAT_ACCESSLOG_ENABLED</td><td>server.tomcat.accesslog.enabled</td><td>default :false</td></tr></tbody></table><h4 id="四-配置数据库"><a class="markdownIt-Anchor" href="#四-配置数据库"></a> 四、配置数据库</h4><p>执行<a href="https://github.com/alibaba/nacos/blob/1.3.0-beta/distribution/conf/nacos-mysql.sql" target="_blank" rel="noopener">nacos数据库MySQL脚本</a>，进入nacos的容器内，修改<code>config/application.properties</code>的内容：</p><p><img src="/images/image-20200531013240596.png" alt="image-20200531013240596"></p><p>因为我只启了一个MySQL容器，所以在这里将<code>db.url.1</code>注释掉了。修改完配置后重启nacos容器，然后访问http://127.0.0.1:28848/nacos/index.html即可进入到nacos控制台。</p><hr><p>至此我们的nacos已经安装完成了，想要知道更多内容，建议查阅nacos官方文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-搜索docker中可用的nacos源&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-搜索docker中可用的nacos源&quot;&gt;&lt;/a&gt; 一、搜索docker中可用的nacos源&lt;/h4&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="Nacos" scheme="http://luxiaowan.github.io/categories/Nacos/"/>
    
    
  </entry>
  
  <entry>
    <title>软引用、弱引用和虚引用</title>
    <link href="http://luxiaowan.github.io/2020/05/29/%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    <id>http://luxiaowan.github.io/2020/05/29/软引用、弱引用和虚引用/</id>
    <published>2020-05-29T04:50:00.000Z</published>
    <updated>2020-06-07T13:21:08.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="强引用"><a class="markdownIt-Anchor" href="#强引用"></a> 强引用</h4><p>强引用(strong reference)是使用最普遍的引用，如果一个对象具有强引用，那垃圾回收器绝不会回收它，例如<code>Object obj = new Object();</code>，即使当内存空间不足时，JVM宁愿抛出OOM，也不会回收具有强引用的对象来解决内存不足的问题。</p><p>我们可以显示的设置对象为null，或者跳出对象的生命周期范围，让垃圾收集器将其判定为不存在引用，是个可以被回收的对象，例如<code>obj = null;</code></p><p>全局对象：手动的将对象赋值为null，最典型的全局对象设置为null的就是在ArrayList的clear()方法中，对于类中的全局变量<code>elementData</code>来说，仅仅的将其置为null是不可行的，因为数组中的对象还是会继续引用的，所以此时需要将数组中每个位置的对象全部置为null，也就是将所有的对象的引用都释放掉，这样才会被GC回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment"> * be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear to let GC do its work</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量：一般情况下，一个对象保存在堆中，对象的引用保存在Java栈中，由于栈是线程私有的，所以当线程结束时，Java栈被自动回收，这时堆中对象的引用数-1，直到引用数变为0后，可以被GC回收。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们通过new创建的对象一般都是强引用</p></blockquote><h4 id="弱引用"><a class="markdownIt-Anchor" href="#弱引用"></a> 弱引用</h4><p>弱引用(weak reference)是可以被GC强制回收的，当垃圾收集器发现一个存活的弱可达对象时，就会将其放入响应的ReferenceQueue中，之后可能会遍历这个ReferenceQueue并执行响应的清理，弱可达对象是指该对象的引用只剩下弱引用。</p><p>我们可以通过弱引用的get()方法给对象赋值给新的强引用，在回收前，GC会再次判断该对象是否可以安全回收。所以，弱引用的对象的回收过程可以横跨多个GC周期，在Java中可以使用<code>WeakReference</code>类创建一个弱引用对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String cc = <span class="keyword">new</span> String(<span class="string">"串串"</span>);</span><br><span class="line">  <span class="comment">// 创建对象cc的弱引用</span></span><br><span class="line">  WeakReference&lt;String&gt; cc_wr = <span class="keyword">new</span> WeakReference&lt;&gt;(cc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ① cc = null;</span></span><br><span class="line">  <span class="comment">// ② System.gc();</span></span><br><span class="line">  <span class="comment">// 为对象cc创建一个强引用，若对象cc已经被回收，则返回null</span></span><br><span class="line">  String cc_s = cc_wr.get();</span><br><span class="line">  <span class="comment">// ③ cc = null;</span></span><br><span class="line">  System.out.println(cc_s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析</p><ol><li><p>仅开启①</p><p><img src="/images/image-20200530000738739.png" alt="image-20200530000738739"></p><p>弱引用对象尚未被回收</p></li><li><p>仅开启②</p><p><img src="/images/image-20200530001335758.png" alt="image-20200530001335758"></p></li><li><p>仅开启③</p><p><img src="/images/image-20200530001504957.png" alt="image-20200530001504957"></p></li><li><p>开启①②</p><p><img src="/images/image-20200530001545556.png" alt="image-20200530001545556"></p><p>哇啊哦~对象被回收了，这是因为我们先将对象的弱引用断开，然后又手动进行了一次gc，把对象给回收了</p></li><li><p>开启②③</p><p><img src="/images/image-20200530002013851.png" alt="image-20200530002013851"></p></li><li><p>开启①②③</p><p><img src="/images/image-20200530002029511.png" alt="image-20200530002029511"></p></li></ol></blockquote><h4 id="软引用"><a class="markdownIt-Anchor" href="#软引用"></a> 软引用</h4><p>软引用(Soft Reference)是比弱引用更难被垃圾回收器回收的对象，什么时候回收软引用完全由JVM自己决定，一般只会在即将OOM时才会回收软引用，算是JVM内存管理最后的倔强。这就意味着可能会有非常频繁的Full GC，STW时间也变长，因为老年代中的存活对象多了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SoftReference&lt;String&gt; cc_sr = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"串串"</span>));</span><br><span class="line">  System.out.println(cc_sr.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚引用"><a class="markdownIt-Anchor" href="#虚引用"></a> 虚引用</h4><p>虚引用和弱引用、软引用不同，它并不影响对象的生命周期，使用<code>java.lang.ref.PhantomReference</code>类表示，和弱引用、软引用不同的是，虚引用必须和引用队列关联使用，当GC准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用放进与之关联的引用队列中。</p><p>为了防止可回收对象的残留，虚引用对象不应该被获取，PhantomReference的get()方法始终返回null，虚引用不会被GC自动清除，因为它们被存放到队列中，通过虚引用可达的对象会继续留在内存中，直到调用此引用的clear()方法，或者引用自身变为不可达。</p><p>也就是说我们如果不手动调用clear()方法来清除虚引用，则非常可能造成OOM而导致JVM宕机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ReferenceQueue&lt;String&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">  PhantomReference&lt;String&gt; cc_p = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"cc"</span>), rq);</span><br><span class="line">  System.out.println(cc_p.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以使用JVM参数<code>-XX:+PrintReferenceGC</code>查看各类引用对GC的影响</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;强引用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#强引用&quot;&gt;&lt;/a&gt; 强引用&lt;/h4&gt;
&lt;p&gt;强引用(strong reference)是使用最普遍的引用，如果一个对象具有强引用，那垃圾回收器绝不会回收它，例如&lt;code&gt;Objec
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM优化之提升速率</title>
    <link href="http://luxiaowan.github.io/2020/05/29/JVM%E4%BC%98%E5%8C%96%E4%B9%8B%E6%8F%90%E5%8D%87%E9%80%9F%E7%8E%87/"/>
    <id>http://luxiaowan.github.io/2020/05/29/JVM优化之提升速率/</id>
    <published>2020-05-29T01:50:00.000Z</published>
    <updated>2020-06-04T13:16:34.603Z</updated>
    
    <content type="html"><![CDATA[<p>提升速率(promotion rate)是用于衡量单位时间内从新生代晋升到来年代的数据量，一般用MB/sec表示单位。JVM会将存活时间较长的对象从新生代提升到老年代，根据分代规则，老年代中不仅有存活时间长的对象，也有存活时间短的对象，这些存活时间短的对象的晋升过程就是过早提升，简单点讲就是对象存活时间尚未达到晋升年龄之前就被提升到了老年代。</p><hr><h4 id="测量提升速率"><a class="markdownIt-Anchor" href="#测量提升速率"></a> 测量提升速率</h4><p>一般情况下我们需要通过GC日志来测量提升速率，我们来跑一段代码查看一下GC日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boxing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">double</span> sensorValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sensorValue = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processSensorValue</span><span class="params">(Double value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LockSupport.parkNanos(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iterations = args.length &gt; <span class="number">0</span> ? Integer.parseInt(args[<span class="number">0</span>]) : <span class="number">1_000_000</span>;</span><br><span class="line"></span><br><span class="line">        initSensor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iterations;) &#123;</span><br><span class="line">            processSensorValue(sensorValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread sensorReader = <span class="keyword">new</span> Thread(Boxing::readSensor);</span><br><span class="line"></span><br><span class="line">        sensorReader.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        sensorReader.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200529103423364.png" alt="image-20200529103423364"></p><p>我们来分析一下这段GC日志，通过计算新生代使用量以及堆内存使用量，就可以通过差值算出老年代的使用量：</p><table><thead><tr><th>Event</th><th>Time</th><th>Young</th><th>整个堆减少内存</th><th>提升量</th><th>提升速率</th></tr></thead><tbody><tr><td>1st GC</td><td>425ms</td><td>63553kb</td><td>63545kb</td><td>8kb</td><td>0.02MB/sec</td></tr><tr><td>2nd GC</td><td>508ms</td><td>66003kb</td><td>65995kb</td><td>8kb</td><td>0.02MB/sec</td></tr><tr><td>3rd GC</td><td>587ms</td><td>65488kb</td><td>65488kb</td><td>0kb</td><td>0MB/sec</td></tr><tr><td>Total</td><td>587ms</td><td></td><td></td><td>16kb</td><td>0.03MB/sec</td></tr></tbody></table><p>从表格中我们看到平均的提升速率是0.03MB/sec，峰值是0.02MB/sec。</p><p>我们只能根据Minor GC计算提升速率，Full GC的日志不能用于计算提升速率，因为Major GC会清理掉老年代中的一部分对象，所以会计算不准确。</p><hr><p>和分配速率<a href="https://luxiaowan.github.io/2020/05/28/JVM%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E9%85%8D%E9%80%9F%E7%8E%87/">JVM优化之分配速率</a>一样，提升速率也会影响STW的频率，但分配速率主要影响Minor GC，而提升速率则影响Major GC的频率，若每次都有大量的对象从新生代晋升到老年代，那么老年代会很快被填满，老年代填充的越快，Major GC的频率就会越高。</p><p>一般来说，过早提升的症状会表现为以下形式：</p><ul><li>短时间内频繁的执行Full GC</li><li>每次Full GC后老年代的使用率都很低</li><li>提升速率接近于分配速率</li></ul><p><img src="/images/how-java-garbage-collection-works.png" alt="jgc"></p><p>我们来看一个过早提升的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrematurePromotion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>                MAX_CHUNKS        = Integer.getInteger(<span class="string">"max.chunks"</span>, <span class="number">10_000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Collection&lt;<span class="keyword">byte</span>[]&gt; accumulatedChunks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onNewChunk</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        accumulatedChunks.add(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (accumulatedChunks.size() &gt; MAX_CHUNKS) &#123;</span><br><span class="line">            processBatch(accumulatedChunks);</span><br><span class="line">            accumulatedChunks.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            onNewChunk(produceChunk());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] produceChunk() &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            bytes[i] = (<span class="keyword">byte</span>) (Math.random() * Byte.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">byte</span> sink;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processBatch</span><span class="params">(Collection&lt;<span class="keyword">byte</span>[]&gt; bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span>[] chunk : bytes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : chunk) &#123;</span><br><span class="line">                result ^= b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sink = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的JVM参数：<code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1</code>，将晋升年龄设置为1</p><blockquote><p>GC日志</p></blockquote><p><img src="/images/image-20200529111456993.png" alt="image-20200529111456993"></p><p>从日志中看到Full GC的频率很高，但是每次GC之后老年代的使用量都在减少，从日志上看是不是觉得和过早提升没多大关系？但是仔细想想，其实如果没有对象晋升到老年代或者晋升量很少的话，老年代的空间就不会不够用，也就不会被频繁的发生Full GC了，那么为什么老年代的使用量会减少呢？因为对象提升到老年代，同时老年代也有很多对象被回收，这就造成了老年代使用量减少的情况，但事实是大量的对象不断的提升到老年代，并触发Full GC。</p><hr><h4 id="优化策略"><a class="markdownIt-Anchor" href="#优化策略"></a> 优化策略</h4><ol><li><p>在JVM的整个GC流程里，Major GC和Full GC都依赖于Minor GC，可以简单的理解为都是由Minor GC触发的，那么我们就增大新生代的容量，让年轻代能放得下更多的对象，然后减少Minor GC的频率，这样的话Full GC的次数自然会被减少了。</p><p>比如上面的代码，我们通过JVM参数<code>-Xmx64m -XX:NewSize=32m</code>来扩充整堆和新生代的大小，运行上述代码，查看GC日志信息：</p><p><img src="/images/image-20200529120119214.png" alt="image-20200529120119214"></p><p>加大了新生代的大小，发现只发生了Minor GC，未触发Full GC，由此可见增加新生代的空间大小是可以减少Full GC</p></li><li><p>减少每次批处理的数量，但是此种情况要根据实际业务来决定</p></li><li><p>加大对象晋升年龄，防止对象过早晋升到老年代，可以通过JVM参数<code>-XX:MaxTenuringThreshold=15</code>来指定晋升年龄，但是新生代的对象晋升老年代并不一定非要等到最大年龄，比如当Survivor区的某个年龄的对象总量超过Survivor大小的一半时，大于等于这个年龄的所有对象都会被晋升到老年代</p></li><li><p>如果以上方案都不可以的话，就只能优化数据结构，减少内存消耗</p></li></ol><p>以上方案的总体目标都是为了让年轻代能够放得下更多的对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提升速率(promotion rate)是用于衡量单位时间内从新生代晋升到来年代的数据量，一般用MB/sec表示单位。JVM会将存活时间较长的对象从新生代提升到老年代，根据分代规则，老年代中不仅有存活时间长的对象，也有存活时间短的对象，这些存活时间短的对象的晋升过程就是过早
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://luxiaowan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM优化之分配速率</title>
    <link href="http://luxiaowan.github.io/2020/05/28/JVM%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E9%85%8D%E9%80%9F%E7%8E%87/"/>
    <id>http://luxiaowan.github.io/2020/05/28/JVM优化之分配速率/</id>
    <published>2020-05-28T15:53:00.000Z</published>
    <updated>2020-06-04T12:56:43.438Z</updated>
    
    <content type="html"><![CDATA[<p>在实际的开发过程中，使用Java语言开发的应用基本上都会遇到性能问题，比如接口超时、服务器负载高、并发数低、数据库性能低或死锁等，并且现在随着互联网的发展，“猛快糙”的开发方式会让代码变得越来越臃肿，随着系统访问量的增加，各种性能问题就随之而来了。</p><p>应用的性能问题非常多，比如磁盘、内存、网络IO、应用代码、数据库、缓存、JVM等，有前辈总结过可以将Java性能优化分为4个层级：</p><ol><li>应用层优化：也就是代码层，主要是代码上的优化，这个主要就要靠代码review和扎实的个人基础知识了，可以通过Java线程栈定位问题代码</li><li>数据库层优化：优化数据库读写方面的优化，分析SQL、定位死锁、分库分表</li><li>框架层优化：为应用选择合适的框架是最重要的，合适的框架能够带来更优的性能</li><li>JVM层优化：JVM是应用的最底层，属于是最难也是最容易出现性能瓶颈的一层，GC、JVM参数合理使用</li></ol><p>优化难度逐层增加，涉及的知识和解决的问题也不同，我们本文主要讲解一下JVM的年轻代GC方面的优化知识。</p><hr><p>运行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boxing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Double sensorValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sensorValue = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processSensorValue</span><span class="params">(Double value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LockSupport.parkNanos(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iterations = args.length &gt; <span class="number">0</span> ? Integer.parseInt(args[<span class="number">0</span>]) : <span class="number">1_000_000</span>;</span><br><span class="line"></span><br><span class="line">        initSensor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">            processSensorValue(sensorValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread sensorReader = <span class="keyword">new</span> Thread(Boxing::readSensor);</span><br><span class="line"></span><br><span class="line">        sensorReader.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        sensorReader.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM参数设置为<code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xmx32m</code>，运行代码，查看GC情况：</p><p><img src="/images/image-20200529013346025.png" alt="image-20200529013346025"></p><blockquote><p>这里先说一下什么叫分配速率(Allocation Rate)，分配速率是指单位时间内分配的内存量，通常使用<code>MB/sec</code>作为单位，也可以使用<code>PB/year</code>来表示，分配速率过高就会严重影响程序的性能，在JVM中会导致巨大的GC开销</p><p>计算上一次GC之后与下一次GC之前的年轻代使用量，两者差值除以时间，就是分配速率</p></blockquote><p>从上图GC日志中，我们计算一下信息：</p><ul><li>在JVM启动后391ms，共创建8704kb的对象，第一次YGC之后，年轻代中还有1004kb的存活对象</li><li>在JVM启动后459ms，年轻代的使用量再次增加到9708kb，触发第二次YGC，GC之后年轻代的使用量缩减到1004kb</li><li>在JVM启动后471ms，年轻代的使用量为9708kb，GC后为1020kb</li></ul><p>然后我们现在来计算一下这三次GC的分配速率：</p><table><thead><tr><th>Event</th><th>Time</th><th>YGC before</th><th>YGC after</th><th>Allocated During</th><th>Allocation Rate</th></tr></thead><tbody><tr><td>1st YGC</td><td>391ms</td><td>8704kb</td><td>1004kb</td><td>8704kb</td><td>22MB/sec</td></tr><tr><td>2nd YGC</td><td>459ms</td><td>9708kb</td><td>1004kb</td><td>8704kb</td><td>51MB/sec</td></tr><tr><td>3rd YGC</td><td>471ms</td><td>9708kb</td><td>1020kb</td><td>8704kb</td><td>709MB/sec</td></tr><tr><td>Total</td><td>471ms</td><td></td><td></td><td>26112kb</td><td>55MB/sec</td></tr></tbody></table><p>从表中我们看到，该程序的内存分配速率在55MB/sec。</p><hr><h4 id="分配速率的意义"><a class="markdownIt-Anchor" href="#分配速率的意义"></a> 分配速率的意义</h4><p>分配速率的变化会增加或降低STW的频率，从而影响吞吐量，但仅仅只有年轻代的YGC会受分配速率的影响，老年代GC的频率和持续时间不收分配速率的直接影响，而是受到提升速率的影响，也就是Major GC是受Minor GC影响的。</p><p>我们知道年轻代中分为Eden、Survivor from和Survivor to三个区，因为分配速率直接影响Minor GC，所以我们先看下修改Eden的大小是否会减小Minor GC的频率，提升分配速率。</p><p>使用JVM参数<code>-XX:NewSize</code>、<code>-XX:MaxNewSize</code>和<code>-XX:SurvivorRatio</code>设置Eden和Survivor区的大小，我们将Eden区分别设置为100M和500M，看一下GC日志：</p><ul><li><p>Eden区100M</p><p>JVM参数：<code>-XX:NewSize=125m -XX:MaxNewSize=125m -XX:SurvivorRatio=8</code></p><p><img src="/images/image-20200529015605343.png" alt="image-20200529015605343"></p><table><thead><tr><th>Event</th><th>Time</th><th>YGC before</th><th>YGC after</th><th>Allocated During</th><th>Allocation Rate</th></tr></thead><tbody><tr><td>1st YGC</td><td>686ms</td><td>102400kb</td><td>1967kb</td><td>102400kb</td><td>146MB/sec</td></tr><tr><td>2nd YGC</td><td>820ms</td><td>104367kb</td><td>1548kb</td><td>102400kb</td><td>747MB/sec</td></tr><tr><td>3rd YGC</td><td>947ms</td><td>103948kb</td><td>1548kb</td><td>102400kb</td><td>788MB/sec</td></tr><tr><td>Total</td><td>947ms</td><td></td><td></td><td>307200kb</td><td>317MB/sec</td></tr></tbody></table><p>分配速率为317MB/sec</p></li><li><p>Eden区500M</p><p>JVM参数：<code>-XX:NewSize=625m -XX:MaxNewSize=625m -XX:SurvivorRatio=8</code></p><p><img src="/images/image-20200529020327070.png" alt="image-20200529020327070"></p><table><thead><tr><th>Event</th><th>Time</th><th>YGC before</th><th>YGC after</th><th>Allocated During</th><th>Allocation Rate</th></tr></thead><tbody><tr><td>1st YGC</td><td>1126ms</td><td>512000kb</td><td>1967kb</td><td>512000kb</td><td>445MB/sec</td></tr><tr><td>2nd YGC</td><td>1752ms</td><td>513967kb</td><td>1836kb</td><td>512000kb</td><td>799MB/sec</td></tr><tr><td>3rd YGC</td><td>2429ms</td><td>513836kb</td><td>1772kb</td><td>512000kb</td><td>739MB/sec</td></tr><tr><td>Total</td><td>2429ms</td><td></td><td></td><td>1536000kb</td><td>618MB/sec</td></tr></tbody></table><p>分配速率为618MB/sec</p></li></ul><p>随着Eden区大小越来越大，分配速率也越来越大，因为减少了GC频率，就等于减少了任务线程的停顿，就可以做更多的工作，也就创建了更多的对象，所以对于同一个Java应用来说，分配速率越高，性能越高。</p><hr><h4 id="高分配速率对jvm的影响"><a class="markdownIt-Anchor" href="#高分配速率对jvm的影响"></a> 高分配速率对JVM的影响</h4><p>如果创建了过多的朝生夕死的对象，Minor GC的频率就会增加，在并发较大的情况下，会严重的影响吞吐量，从上面的三个场景可以看出来，当年轻代越大时Minor GC的次数就会越来越少，但是分配速率并没有降低，如果每次GC后只有少量的对象存活，Minor GC的暂停时间也不会明显的增加。</p><p>但是有时候增加年轻代的大小并不能彻底的解决问题，我们通过工具jvisualvm查看堆信息</p><p><img src="/images/image-20200529022229415.png" alt="image-20200529022229415"></p><p>大部分堆内存都被Double对象占用了，这个对象是在readSensor()方法中创建的，最简单的代码层面的优化就是将包装类Double换成原生类型，因为原生类型不算是对象，所以也就不会在堆中分配内存，而是之间覆盖一个属性域即可，不会产生GC事件，所以GC基本上完全消除。并且JVM通过逃逸分析技术来避免过度分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boxing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">double</span> sensorValue = Double.NaN;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sensorValue = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processSensorValue</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Double.isNaN(value)) &#123;</span><br><span class="line">            LockSupport.parkNanos(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iterations = args.length &gt; <span class="number">0</span> ? Integer.parseInt(args[<span class="number">0</span>]) : <span class="number">1_000_000</span>;</span><br><span class="line"></span><br><span class="line">        initSensor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iterations;) &#123;</span><br><span class="line">            processSensorValue(sensorValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSensor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread sensorReader = <span class="keyword">new</span> Thread(Boxing::readSensor);</span><br><span class="line"></span><br><span class="line">        sensorReader.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        sensorReader.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200529023002189.png" alt="image-20200529023002189"></p><p><img src="/images/image-20200529023022780.png" alt="image-20200529023022780"></p><p>控制台未输出任何GC日志，而jvisualvm上监控到的堆使用情况也极低，由此可见在代码中可以在适当情况下使用原生类型代替包装类。</p><hr><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>在年轻代使用上，应当适当的提高分配速率，减少Minor GC的频率，可以通过两种方式实现</p><ol><li>增大新生代大小</li><li>使用原生类型代替包装类，减少堆内对象的创建</li></ol><p>简单点说就是少创建对象、多分配空间，以减少GC次数，加大系统吞吐量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实际的开发过程中，使用Java语言开发的应用基本上都会遇到性能问题，比如接口超时、服务器负载高、并发数低、数据库性能低或死锁等，并且现在随着互联网的发展，“猛快糙”的开发方式会让代码变得越来越臃肿，随着系统访问量的增加，各种性能问题就随之而来了。&lt;/p&gt;
&lt;p&gt;应用的性能
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://luxiaowan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线程池中运行的线程，当等待队列未满的情况下，一定不大于核心线程数吗</title>
    <link href="http://luxiaowan.github.io/2020/05/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BD%93%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E6%9C%AA%E6%BB%A1%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%B8%80%E5%AE%9A%E4%B8%8D%E5%A4%A7%E4%BA%8E%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%90%97/"/>
    <id>http://luxiaowan.github.io/2020/05/28/线程池中运行的线程，当等待队列未满的情况下，一定不大于核心线程数吗/</id>
    <published>2020-05-28T03:17:00.000Z</published>
    <updated>2020-05-28T09:38:56.730Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="https://luxiaowan.github.io/2020/05/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E/">《线程池内运行的线程抛异常，线程池会怎么办》</a>了解到当线程执行的任务出现异常时，会将当前线程移出线程池，并新增一个线程到线程池中，我们先来回顾一下线程池的运行原理：</p><img src="/images/tpe-process.png" alt="tpe-process" style="zoom:50%;"><p>从原理图中可以看到只有当队列满了之后，才会去创建新的线程执行新加入的任务，那么到底有没有可能出现队列未满， 但是运行中的线程个数大于核心线程数？</p><p>理论上应该是不可能大于核心线程数，那么有没有意外呢？答案暂时不揭晓，我们先往下看，写几个demo测试一下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span> + (<span class="number">10</span> / finalI));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>​第一列为线程hashcode，第二列为阻塞队列中的任务个数，第三列为计算数字</p></blockquote><img src="/images/image-20200528132623899.png" alt="image-20200528132623899" style="zoom:50%;"><p>从控制台的输出能看到一共出现了4个不同的hashcode，也就表示创建过4个线程，然后线程1869318657执行任务时出现了异常，也就是除0异常，然后将其从线程池中移出，后续不再进行任务处理。从之前的文章中我们知道将异常的线程移除之后会重新创建一个线程加入到线程池中，那么正常情况下，线程池移除一个再加入一个，数量应该不变，但是从下面的输出看到这时同时有3个线程在处理任务，但是我们的核心线程数是2，为什么会出现3？</p><p>我们再来看下任务发生异常时的后续处理代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从runWorker方法中传过来的是true，所以这句目前版本中必定会被执行到</span></span><br><span class="line">  <span class="comment">// 作用是将当前线程池中的有效线程数-1，意思也就是出现异常的线程会被从线程池中拿掉</span></span><br><span class="line">  <span class="comment">// 为什么说是出现异常的线程会被拿掉呢？因为在try内部是一个while循环，除非关闭核心线程或运行中线程出现异常，否则不会执行到这里</span></span><br><span class="line">  <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">    decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 更新完成的任务数，只要是被线程池线程执行过的，不管是否出现异常，都被认为是执行成功的任务</span></span><br><span class="line">    completedTaskCount += w.completedTasks;</span><br><span class="line">    <span class="comment">// 将当前Worker线程从线程池中移除销毁</span></span><br><span class="line">    workers.remove(w);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryTerminate();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一系列判断，主要是判断是否符合给线程池创建新的线程</span></span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">      <span class="comment">// 如果核心线程允许超时回收，则不去创建线程，因为有新任务来的时候会自动创建</span></span><br><span class="line">      <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">      <span class="comment">// 如果核心线程可以被回收，但是当前阻塞队列中不为空时，创建1个线程去执行任务</span></span><br><span class="line">      <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 校验当前运行的线程是否大于允许运行的线程数，比如核心线程数</span></span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ①...</span></span><br><span class="line">    <span class="comment">// 给线程池创建新的线程</span></span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在创建新线程时，会进行一系列判断，若判断全部通过，就会去给线程池的池子中创建一个新的工作线程，这里传入的core参数是false，也就是当成非核心线程来创建，难道问题出在这里？如果我此时运行的线程数小于等于核心线程数，那么再加进来一个非核心线程？我们来看看addWorker()方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// goto语法</span></span><br><span class="line">  retry:</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">        ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">           firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           ! workQueue.isEmpty()))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">      <span class="comment">// 判断当前运行的线程个数是否超过了最大线程数</span></span><br><span class="line">      <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">          wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">break</span> retry;</span><br><span class="line">      c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">      <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">        <span class="keyword">continue</span> retry;</span><br><span class="line">      <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...创建线程...</span></span><br><span class="line">  <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法addWorker()的源码中我们看到，当我们参数core传一个false进来时，会去校验当前工作中的线程个数是否超过了最大线程数，如果没有超过的话则创建新的线程，问题就出在这里，为什么？</p><p>在方法processWorkerExit()中，我们对核心线程数进行的比较，但是如果在①处有新的任务调用execute()进来，则发现工作线程未达到核心线程数，这个时候就会去创建一个核心线程，创建之后，线程池中的工作线程就有2个了，然后我们从processWorkerExit()中传过来的请求会去校验工作线程个数是否超过了最大线程数，在我们的demo代码中是肯定不会超过的，那么就又会去创建一个线程放到线程池中，这样线程池中的工作线程就有3个了，具体流程图如下</p><table><thead><tr><th>正常流程</th><th>异常流程</th><th>工作线程数</th></tr></thead><tbody><tr><td>execute()</td><td></td><td>0</td></tr><tr><td>—addWorker()</td><td></td><td>1</td></tr><tr><td>execute()</td><td></td><td>1</td></tr><tr><td>—addWorker()</td><td></td><td>2</td></tr><tr><td></td><td>processWorkerExit()</td><td>2</td></tr><tr><td></td><td>—remove()</td><td>1</td></tr><tr><td>execute()</td><td></td><td>1</td></tr><tr><td>—addWorker()</td><td></td><td>2</td></tr><tr><td></td><td>—addWorker()</td><td>3</td></tr></tbody></table><blockquote><p>这就是为什么我们核心线程数是2，但是最终运行中的线程个数是3的原因</p></blockquote><hr><h4 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 🌰场景</h4><ol><li><p>任务尚未全部进入到队列中，队列未满</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span> + (<span class="number">10</span> / finalI));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/image-20200528132623899.png" alt="image-20200528132623899" style="zoom:50%;"><p>这个也就是我们上面跑的demo，工作线程个数超出了核心线程数。</p></li><li><p>任务已经全部进入到队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (finalI &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 前两个线程等待500毫秒，保证所有的任务都进入到队列中</span></span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(</span><br><span class="line">        Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span> + (<span class="number">10</span> / (finalI - <span class="number">4</span>)));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/image-20200528170037838.png" alt="image-20200528170037838" style="zoom:50%;"><p>我们看到当线程池开始执行任务时，已经把剩余的28个任务都放到队列中了，红色和蓝色下划线的线程是初始线程，当873出现异常后，将其移出线程池，然后创建一个新的线程执行队列中的剩余任务，因为这时所有的任务都在队列中等待被执行，execute()方法不会被调用，所以这种场景下，工作中的线程个数不会超过核心线程数。</p></li><li><p>任务尚未全部进入到队列中，队列已满，未达到最大线程数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(t1.hashCode() + <span class="string">", "</span> + t1.getName() + <span class="string">" "</span> + <span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">34</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (finalI &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 等待任务全部进入到队列中，且创建完额外线程接收多出来的两个任务</span></span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().hashCode() + <span class="string">": "</span> + pool.getQueue().size() + <span class="string">", "</span></span><br><span class="line">                         + pool.getActiveCount() + <span class="string">", "</span> + (<span class="number">10</span> / (finalI - <span class="number">33</span>)));</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>​第一列为线程hashcode，第二列为阻塞队列中的任务个数，第三列为当前的工作线程个数，第四列为计算数字</p></blockquote><img src="/images/image-20200528173106691.png" alt="image-20200528173106691" style="zoom:67%;"><p>从结果中我们看到创建了4个工作线程去执行任务，当线程230执行异常之后，创建了线程734继续执行，线程个数未超过最大线程数</p></li><li><p>任务尚未全部进入到队列中，队列已满，达到最大线程数</p><p>这种情况就会依据拒绝策略执行相关的代码逻辑，线程数不会超过最大线程数</p></li></ol><hr><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>从以上分析我们可以得出，只有在：任务尚未全部进入到队列中且队列未满的情况下，才会出现工作线程个数大于核心线程数，所以我们在使用线程池的过程中，待执行的任务尽量捕获所有的异常情况，不要将其抛出到线程池中的线程里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过&lt;a href=&quot;https://luxiaowan.github.io/2020/05/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>线程池内运行的线程抛异常，线程池会怎么办</title>
    <link href="http://luxiaowan.github.io/2020/05/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://luxiaowan.github.io/2020/05/27/线程池内运行的线程抛异常，线程池会怎么办/</id>
    <published>2020-05-27T04:56:00.000Z</published>
    <updated>2020-05-28T09:38:46.197Z</updated>
    
    <content type="html"><![CDATA[<p>通过文章<a href="https://luxiaowan.github.io/2020/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%AD%E7%AD%89%E5%BE%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%90%97/">《线程池运行的线程和队列中等待的线程是同一个吗》</a>我们了解到线程池中实际运行的是线程池自身的线程，只是在runWorker方法中调用了我们传递进入Runnable对象的run()方法，那么如果run()方法中出现异常了，那么要怎么处理？会不会将我们的线程池停掉？</p><p>我们先来看下runWorker()方法的具体逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  Thread wt = Thread.currentThread();</span><br><span class="line">  Runnable task = w.firstTask;</span><br><span class="line">  w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">  <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">           (Thread.interrupted() &amp;&amp;</span><br><span class="line">            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">          !wt.isInterrupted())</span><br><span class="line">        wt.interrupt();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        beforeExecute(wt, task);</span><br><span class="line">        Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterExecute(task, thrown);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task = <span class="keyword">null</span>;</span><br><span class="line">        w.completedTasks++;</span><br><span class="line">        w.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中我们看到，在调用用户Runnable实例方法run()的时候，进行了try…catch…finally，但是在catch()中是直接将异常抛出了，也就是说并未在while循环内消化掉，而是抛出给外层，这时会将while循环终止掉，然后在外层的try…finally中并未捕获内部传出的异常，所以异常信息会继续往上抛出，我们来关注一下这两层try的finally代码块，内部的finally中执行了一个空的方法afterExecute()，这个方法是留给我们自定义线程池时使用的，和beforeExecute()方法一样，既然是空方法，那我们就先不用去看它了，来看下外层的finally代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从runWorker方法中传过来的是true，所以这句目前版本中必定会被执行到</span></span><br><span class="line">  <span class="comment">// 作用是将当前线程池中的有效线程数-1，意思也就是出现异常的线程会被从线程池中拿掉</span></span><br><span class="line">  <span class="comment">// 为什么说是出现异常的线程会被拿掉呢？因为在try内部是一个while循环，除非关闭核心线程或运行中线程出现异常，否则不会执行到这里</span></span><br><span class="line">  <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">    decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 更新完成的任务数，只要是被线程池线程执行过的，不管是否出现异常，都被认为是执行成功的任务</span></span><br><span class="line">    completedTaskCount += w.completedTasks;</span><br><span class="line">    <span class="comment">// 将当前Worker线程从线程池中移除销毁</span></span><br><span class="line">    workers.remove(w);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryTerminate();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一系列判断，主要是判断是否符合给线程池创建新的线程</span></span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">      <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">      <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给线程池创建新的线程，core之所以传递false，是因为这里要防止创建失败</span></span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们看到在处理任务的过程中，如果线程出现异常，则会将该线程从线程池中移除销毁，然后再新创建一个线程加入到线程池中，也就是说在任务发生异常的时候，会终结掉运行它的线程。</p><blockquote><p>我们从源码中得到的信息，现在来验证一下我们的分析</p></blockquote><p>验证代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="number">10</span> / finalI - <span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><img src="/images/image-20200527152919795.png" alt="image-20200527152919795" style="zoom:70%;"><p>抛异常了，但是并未影响线程池中的其他任务，我们打断点在processWorkerExit()方法中，看下workers变量的数据</p><ul><li><p>异常发生之前</p><p><img src="/images/image-20200527154429404.png" alt="image-20200527154429404"></p></li><li><p>异常发生之后</p><p><img src="/images/image-20200527154504520.png" alt="image-20200527154504520"></p></li></ul><p>看到在异常前后，线程<code>1f36e637</code>被移除了，转而创建了一个<code>7073cb62</code>放到了线程池中，而未发生异常的线程<code>578486a3</code>依然存在于线程池中。</p><hr><blockquote><p>小结</p></blockquote><p>通过示例我们验证了一点：当任务出现未被捕获到的异常时，会将执行该任务的线程池中的线程从线程池移除并结束掉，然后移除之后创建一个新的线程放回到线程池中。</p><hr><p>上面我们知道了当线程执行的任务发生未被捕获的异常时，会将异常一直往上抛出，那么我们能否在主线程中捕获它进行处理呢？我们来试下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="number">10</span> / finalI - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      pool.execute(t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"发生了异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/images/image-20200527165519282.png" alt="image-20200527165519282"></p><p>由运行结果可以看出我们并未捕获到线程池中线程抛出的异常，也就是异常并未被抛出到主线程中，这就尴尬了，毕竟这些异常是和业务相关联的，我们却无法捕获和处理，这咋整呢？</p><p>忽的一下，想到了线程池的比较重要的一个参数：ThreadFactory接口，这个接口的作用是按需创建新线程的，使用线程工厂消除了对Thread#Thread(Runnable) new Thread的强依赖，使应用程序能够使用特殊的Thread子类、优先级等。大白话就是让线程池中的线程使用我们自定义的线程，这个自定义可不是我们通过execute()或submit()传进来的自定义线程，而是Worker类中的thread变量，也就是实际运行的线程，我们看一下Worker类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">  setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">  <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">  <span class="comment">// 调用ThreadFactory的newThread方法创建线程</span></span><br><span class="line">  <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中调用线程工厂的newThread()方法创建运行线程，我们上面通过ThreadPoolExecutor的构造方法创建线程池时并未传入ThreadFactory参数，那么就会使用默认的<code>Executors.defaultThreadFactory()</code>来创建线程，它的实现逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">    t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">    t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们要是想自定义Worker#thread的值的话，就自定义一个ThreadFactory实现类即可，比如我们可以把线程池创建语句升级为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>), r -&gt; &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.setUncaughtExceptionHandler((t1, e) -&gt; System.out.println(<span class="string">"发生了异常"</span>));</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="number">10</span> / finalI - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用lambda表达式来创建，使用Thread#setUncaughtExceptionHandler()方法来获取线程内未被捕获的异常，我们运行一下看看结果：</p><p><img src="/images/image-20200527175844897.png" alt="image-20200527175844897"></p><p>成功捕获了线程内部出现的异常。</p><hr><p>那么现在就又有一个问题了：如果我们主动捕获并处理线程内抛出的异常，那么这个线程还会从线程池中移除销毁吗？</p><p>我们来试下，还是使用上面的那段代码，然后断点打在processWorkerExit()方法中，看下执行结果</p><ul><li><p>异常之前</p><p><img src="/images/image-20200527180523846.png" alt="image-20200527180523846"></p></li><li><p>异常之后</p><p><img src="/images/image-20200527180634454.png" alt="image-20200527180634454"></p></li></ul><p>从执行结果来看，发生异常的线程是<code>35d176f7</code>，在异常发生之后同样从线程池中被移除了。</p><hr><blockquote><p>总结</p></blockquote><p>当线程池中线程执行任务的时候，任务出现未被捕获的异常的情况下，线程池会将允许该任务的线程从池中移除并销毁，且同时会创建一个新的线程加入到线程池中；可以通过ThreadFactory自定义线程并捕获线程内抛出的异常，也就是说甭管我们是否去捕获和处理线程池中工作线程抛出的异常，这个线程都会从线程池中被移除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过文章&lt;a href=&quot;https://luxiaowan.github.io/2020/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx配置RabbitMQ页面bug</title>
    <link href="http://luxiaowan.github.io/2020/05/26/Nginx%E9%85%8D%E7%BD%AERabbitMQ%E9%A1%B5%E9%9D%A2bug/"/>
    <id>http://luxiaowan.github.io/2020/05/26/Nginx配置RabbitMQ页面bug/</id>
    <published>2020-05-25T19:10:00.000Z</published>
    <updated>2020-05-25T19:15:24.686Z</updated>
    
    <content type="html"><![CDATA[<p>当使用Nginx来配置RabbitMQ的Web页面时，查看Exchange、Queue和Channels时，遇到了<code>the object you clicked on was not found it may have been deleted on the server.</code>，百思不得其解，整个代理都没有问题，配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  rabbitmq.xxx.com;</span><br><span class="line">    client_max_body_size   5m;</span><br><span class="line">    access_log acces.log;</span><br><span class="line">    error_log error.log;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        client_max_body_size   20m;</span><br><span class="line">        proxy_pass http://ip:port/;</span><br><span class="line"></span><br><span class="line">        port_in_redirect on;</span><br><span class="line">proxy_redirect  off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好像没问题，页面也可以正常访问，唯独查看不了消息的详细信息</p><h3 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h3><hr><p>最终瞎捣鼓，发现还是配置的问题，把proxy_pass修改为<code>proxy_pass http://ip:port</code>，把最后的<code>/</code>去掉即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当使用Nginx来配置RabbitMQ的Web页面时，查看Exchange、Queue和Channels时，遇到了&lt;code&gt;the object you clicked on was not found it may have been deleted on the se
      
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://luxiaowan.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Bug" scheme="http://luxiaowan.github.io/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器无法停止和删除</title>
    <link href="http://luxiaowan.github.io/2020/05/26/Docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E5%81%9C%E6%AD%A2%E5%92%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://luxiaowan.github.io/2020/05/26/Docker容器无法停止和删除/</id>
    <published>2020-05-25T17:38:00.000Z</published>
    <updated>2020-05-25T17:41:50.885Z</updated>
    
    <content type="html"><![CDATA[<p>1.停止容器</p><p>docker stop xxx-name</p><p>2.强制移除此容器</p><p>docker rm -f xxx-name</p><blockquote><p>如果出现Device or resource busy，则通过ps -ef | grep port查找容器进程pid，然后使用kill -9 pid停止进程</p></blockquote><p>3.清理此容器的网络占用</p><p>格式：docker network disconnect --force 网络模式 容器名称</p><p>示例：docker network disconnect --force bridge xxx-name</p><p>4.简查是否还有同名容器占用</p><p>格式：docker network inspect 网络模式<br>示例：docker network inspect bridge</p><p>5.重新构建容器</p><p>docker run xxx</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.停止容器&lt;/p&gt;
&lt;p&gt;docker stop xxx-name&lt;/p&gt;
&lt;p&gt;2.强制移除此容器&lt;/p&gt;
&lt;p&gt;docker rm -f xxx-name&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果出现Device or resource busy，则通过ps -e
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://luxiaowan.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Jenkins中创建项目时没有Maven项目</title>
    <link href="http://luxiaowan.github.io/2020/05/26/Jenkins%E4%B8%AD%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%B2%A1%E6%9C%89Maven%E9%A1%B9%E7%9B%AE/"/>
    <id>http://luxiaowan.github.io/2020/05/26/Jenkins中创建项目时没有Maven项目/</id>
    <published>2020-05-25T17:36:00.000Z</published>
    <updated>2020-05-25T17:38:10.178Z</updated>
    
    <content type="html"><![CDATA[<p>如果在创建项目时候，没有“创建一个Maven 项目”的选项，则需要安装Maven项目插件：Maven Integration plugin</p><p><img src="/images/image-20200526013750453.png" alt="image-20200526013750453"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果在创建项目时候，没有“创建一个Maven 项目”的选项，则需要安装Maven项目插件：Maven Integration plugin&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/image-20200526013750453.png&quot; alt=&quot;image-20
      
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://luxiaowan.github.io/categories/Jenkins/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker容器中安装vim</title>
    <link href="http://luxiaowan.github.io/2020/05/26/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AE%89%E8%A3%85vim/"/>
    <id>http://luxiaowan.github.io/2020/05/26/docker容器中安装vim/</id>
    <published>2020-05-25T17:35:00.000Z</published>
    <updated>2020-05-25T17:35:56.177Z</updated>
    
    <content type="html"><![CDATA[<p>在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: command not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package vim</span><br></pre></td></tr></table></figure><p>这时候需要敲：apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。</p><p>等更新完毕以后再敲命令：apt-get install vim命令即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: command not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：&lt;/p&gt;
&lt;figure class=&quot;highlight she
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://luxiaowan.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Jekins忘记admin密码</title>
    <link href="http://luxiaowan.github.io/2020/05/25/Jekins%E5%BF%98%E8%AE%B0admin%E5%AF%86%E7%A0%81/"/>
    <id>http://luxiaowan.github.io/2020/05/25/Jekins忘记admin密码/</id>
    <published>2020-05-25T15:59:00.000Z</published>
    <updated>2020-05-25T16:08:15.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-未修改admin的密码"><a class="markdownIt-Anchor" href="#一-未修改admin的密码"></a> 一、未修改admin的密码</h3><p>若未修改过admin的密码，那么我们可以通过查看<code>/var/jenkins_home/secrets/initialAdminPassword</code>文件来获取admin的初始密码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat <span class="regexp">/var/</span>jenkins_home<span class="regexp">/secrets/i</span>nitialAdminPassword</span><br></pre></td></tr></table></figure><h3 id="二-修改过admin的密码"><a class="markdownIt-Anchor" href="#二-修改过admin的密码"></a> 二、修改过admin的密码</h3><p>如果修改过admin的密码，那么就不能使用初始密码来解决了，可以通过以下步骤：</p><ol><li><p>删除Jenkins目录下config.xml文件中下面代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">useSecurity</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useSecurity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">authorizationStrategy</span> <span class="attr">class</span>=<span class="string">"hudson.security.FullControlOnceLoggedInAuthorizationStrategy"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">denyAnonymousReadAccess</span>&gt;</span>true<span class="tag">&lt;/<span class="name">denyAnonymousReadAccess</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizationStrategy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">securityRealm</span> <span class="attr">class</span>=<span class="string">"hudson.security.HudsonPrivateSecurityRealm"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">disableSignup</span>&gt;</span>true<span class="tag">&lt;/<span class="name">disableSignup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">enableCaptcha</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enableCaptcha</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">securityRealm</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>重启Jenkins</p></li><li><p>重新进入Jenkins，然后进入到<code>系统管理</code>-&gt;<code>全局安全配置(configure global security)</code></p><img src="/images/image-20200526000447792.png" alt="image-20200526000447792" style="zoom:50%;"></li><li><p>勾选<code>Jenkins专有用户数据库</code></p><img src="/images/image-20200526000537282.png" alt="image-20200526000537282" style="zoom:50%;"></li><li><p>回到<code>系统管理</code>页面，选择<code>管理用户</code></p><img src="/images/image-20200526000628607.png" alt="image-20200526000628607" style="zoom: 50%;"></li><li><p>选择用户设置</p><img src="/images/image-20200526000726021.png" alt="image-20200526000726021" style="zoom:50%;"></li><li><p>重置密码</p><img src="/images/image-20200526000747350.png" alt="image-20200526000747350" style="zoom:50%;"></li><li><p>重启Jenkins服务</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-未修改admin的密码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-未修改admin的密码&quot;&gt;&lt;/a&gt; 一、未修改admin的密码&lt;/h3&gt;
&lt;p&gt;若未修改过admin的密码，那么我们可以通过查看&lt;code&gt;/var/jenk
      
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://luxiaowan.github.io/categories/Jenkins/"/>
    
    
  </entry>
  
  <entry>
    <title>反序列化报错：Cannot Deserialize From Object Value (No Delegate- or Property-Based Creator)</title>
    <link href="http://luxiaowan.github.io/2020/05/22/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%A5%E9%94%99%EF%BC%9Acannot-deserialize-from-Object-value-(no-delegate--or-property-based-Creator)/"/>
    <id>http://luxiaowan.github.io/2020/05/22/反序列化报错：cannot-deserialize-from-Object-value-(no-delegate--or-property-based-Creator)/</id>
    <published>2020-05-22T15:50:00.000Z</published>
    <updated>2020-05-28T18:51:33.418Z</updated>
    
    <content type="html"><![CDATA[<p>反序列化报错：cannot deserialize from Object value (no delegate- or property-based Creator)</p><p>这个原因最根本的是没有找到无参构造方法，解决办法是给类加一个无参构造方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反序列化报错：cannot deserialize from Object value (no delegate- or property-based Creator)&lt;/p&gt;
&lt;p&gt;这个原因最根本的是没有找到无参构造方法，解决办法是给类加一个无参构造方法&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="BUG" scheme="http://luxiaowan.github.io/categories/BUG/"/>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Cannot Determine Value Type From String &#39;Xxxxxx&#39;</title>
    <link href="http://luxiaowan.github.io/2020/05/21/Cannot-determine-value-type-from-string-xxxxxx/"/>
    <id>http://luxiaowan.github.io/2020/05/21/Cannot-determine-value-type-from-string-xxxxxx/</id>
    <published>2020-05-21T11:40:00.000Z</published>
    <updated>2020-05-21T12:11:07.814Z</updated>
    
    <content type="html"><![CDATA[<p>在使用MyBatis的时候，若实体类上使用了lombok的@Builder注解，那么在查询数据做映射的时候会出现<code>Cannot determine value type from string 'xxxxxx'</code>错误，产生这个错误的原因是当使用了@Builder注解之后会默认把无参构造方法忽略掉，创建一个全参的构造方法，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long   id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被编译之后再反编译，变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    DemoBean(Long id, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DemoBean.<span class="function">DemoBeanBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoBean.DemoBeanBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...忽略setter、getter方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBeanBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        DemoBeanBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DemoBean.<span class="function">DemoBeanBuilder <span class="title">id</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DemoBean.<span class="function">DemoBeanBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DemoBean <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DemoBean(<span class="keyword">this</span>.id, <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DemoBean.DemoBeanBuilder(id="</span> + <span class="keyword">this</span>.id + <span class="string">", name="</span> + <span class="keyword">this</span>.name + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看到是没有默认构造方法，而MyBatis进行映射的时候会需要无参构造方法实例化一个类，所以我们再使用@Builder的时候，即使使用@NoArgsConstructor注解也无济于事，那我们该怎么办？</p><hr><p>在lombok中有一个@Tolerate注解，我们看下它的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Put on any method or constructor to make lombok pretend it doesn't exist,</span></span><br><span class="line"><span class="comment"> * i.e., to generate a method which would otherwise be skipped due to possible conflicts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Tolerate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释上的意思就是让lombok在扫描的时候假装被@Tolerate修饰的方法不存在，也就是会原封不动的被编译到字节码中，不会覆盖它，那么这样的话我们就可以进行骚操作了，修改原代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long   id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Tolerate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用MyBatis的时候，若实体类上使用了lombok的@Builder注解，那么在查询数据做映射的时候会出现&lt;code&gt;Cannot determine value type from string &#39;xxxxxx&#39;&lt;/code&gt;错误，产生这个错误的原因是当使用了@Bu
      
    
    </summary>
    
    
      <category term="BUG" scheme="http://luxiaowan.github.io/categories/BUG/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringCloud启动报错，提示The Following Method Did Not exist:CompositeHealthIndicator</title>
    <link href="http://luxiaowan.github.io/2020/05/21/SpringCloud%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%8C%E6%8F%90%E7%A4%BAThe-following-method-did-not-existCompositeHealthIndicator/"/>
    <id>http://luxiaowan.github.io/2020/05/21/SpringCloud启动报错，提示The-following-method-did-not-existCompositeHealthIndicator/</id>
    <published>2020-05-21T04:02:00.000Z</published>
    <updated>2020-05-21T15:26:49.989Z</updated>
    
    <content type="html"><![CDATA[<p>今天升级SpringBoot的版本，然后启动的时候懵逼了，报了个错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> Error starting Tomcat context. Exception: org.springframework.beans.factory.BeanCreationException. Message: Error creating bean with name 'servletEndpointRegistrar' defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web</span><br><span class="line"> </span><br><span class="line"> The web application [ROOT] appears to have started a thread named [spring.cloud.inetutils] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with <span class="string">'debug'</span> enabled.</span><br><span class="line"></span><br><span class="line">**An attempt was made to call a method that does not exist. The attempt was made from the following location:</span><br><span class="line"></span><br><span class="line">    org.springframework.cloud.client.discovery.health.DiscoveryCompositeHealthIndicator.&lt;init&gt;(DiscoveryCompositeHealthIndicator.java:<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">The following method did not exist:</span><br><span class="line"></span><br><span class="line">    org.springframework.boot.actuate.health.CompositeHealthIndicator.&lt;init&gt;(Lorg/springframework/boot/actuate/health/HealthAggregator;)V**</span><br></pre></td></tr></table></figure><p>翻了一下资料后，发现是SpringBoot和SpringCloud的版本不匹配，修改成一致的就行了</p><table><thead><tr><th style="text-align:left">Release Train</th><th style="text-align:left">Boot Version</th></tr></thead><tbody><tr><td style="text-align:left">Hoxton</td><td style="text-align:left">2.2.x</td></tr><tr><td style="text-align:left">Greenwich</td><td style="text-align:left">2.1.x</td></tr><tr><td style="text-align:left">Finchley</td><td style="text-align:left">2.0.x</td></tr><tr><td style="text-align:left">Edgware</td><td style="text-align:left">1.5.x</td></tr><tr><td style="text-align:left">Dalston</td><td style="text-align:left">1.5.x</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天升级SpringBoot的版本，然后启动的时候懵逼了，报了个错：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL自增主键用完了咋整？</title>
    <link href="http://luxiaowan.github.io/2020/05/19/MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%94%A8%E5%AE%8C%E4%BA%86%E5%92%8B%E6%95%B4/"/>
    <id>http://luxiaowan.github.io/2020/05/19/MySQL自增主键用完了咋整/</id>
    <published>2020-05-18T16:15:00.000Z</published>
    <updated>2020-05-18T16:31:42.594Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL自增主键会用完吗？我们先来看下在MySQL中，int和bigint两种类型的值域是多少，</p><table><thead><tr><th>类型</th><th>最小值</th><th>最大值</th><th>所占字节</th></tr></thead><tbody><tr><td>int(有符号)</td><td>-2^31</td><td>2^31</td><td>4</td></tr><tr><td>int(无符号)</td><td>0</td><td>2^32</td><td>4</td></tr><tr><td>bigint(有符号)</td><td>-2^63</td><td>2^63</td><td>8</td></tr><tr><td>bigint(无符号)</td><td>0</td><td>2^64</td><td>8</td></tr></tbody></table><p>当我们使用int(有符号)类型的时候，创建一张表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table test_ai (</span><br><span class="line">id int(10) auto_increment primary key,</span><br><span class="line">name varchar(11) not null</span><br><span class="line">) engine=InnoDB;</span><br></pre></td></tr></table></figure><p>执行两条SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert test_ai(id, name) values(2147483646, &apos;cc1&apos;);</span><br><span class="line">insert test_ai(name) values(&apos;cc2&apos;);</span><br><span class="line">insert test_ai(name) values(&apos;cc3&apos;);</span><br></pre></td></tr></table></figure><p>当执行到第三句SQL的时候就会报错<code>Duplicate entry '2147483647' for key 'PRIMARY'</code>，也就是说当我们的自增主键用完之后，就无法继续往表中新增数据了</p><h4 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h4><hr><p>我们在正常情况下，不会让单表存储那么大的数据量，所以一般不会出现这个问题，如果真的脑抽抽的在一张表中存储那么多数据，或者当数据迁移的时候造成了自增主键混乱，那么我们可以使用bigint(无符号)类型作为自增主键。</p><p>使用bigint(无符号)类型时，如果我们每秒插入1W条数据，不间断的跑100年，单表的数据量为：10000 * 3600 * 24 * 365 * 100 = 31536000000000，还远远小于2^64，完全不会被用完，如果操作正确的话。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL自增主键会用完吗？我们先来看下在MySQL中，int和bigint两种类型的值域是多少，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;最小值&lt;/th&gt;
&lt;th&gt;最大值&lt;/th&gt;
&lt;th&gt;所占字节&lt;/th&gt;
&lt;/tr&gt;
&lt;/th
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot内置Tomcat启动时间</title>
    <link href="http://luxiaowan.github.io/2020/05/15/SpringBoot%E5%86%85%E7%BD%AETomcat%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    <id>http://luxiaowan.github.io/2020/05/15/SpringBoot内置Tomcat启动时间/</id>
    <published>2020-05-15T10:22:00.000Z</published>
    <updated>2020-05-15T17:58:50.202Z</updated>
    
    <content type="html"><![CDATA[<h4 id="疑惑"><a class="markdownIt-Anchor" href="#疑惑"></a> 疑惑</h4><p>SpringBoot中内置了Tomcat容器，那么Tomcat是在什么时间点启动的？是先扫描包加载类再启动Tomcat？，还是先启动Tomcat再扫描包加载类？</p><p>我们做一下假设：</p><ol><li>先启动Tomcat，再扫描包加载类</li><li>先扫描包加载类，再启动Tomcat</li></ol><p>接下来我们做一下验证。</p><h4 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h4><p>首先创建一个空的SpringBoot工程，然后启动它，查看一下控制台的输出日志：</p><img src="/images/image-20200515183550832.png" alt="image-20200515183550832" style="zoom:50%;"><p>从输出的日志中可以看到②中显示Tomcat进行初始化，并且正在启动中，然后③中进行初始化<code>WebApplicationContext</code>，紧接着就是初始化<code>WebApplicationContext</code>完成，然后是在④中报告我们Tomcat启动完成。</p><p>从日志上看，好像是先启动Tomcat再去扫描包的，具体是怎么回事，我们看一下源码，暂时先不揭晓。</p><ul><li><p>从启动类中进入到<code>SpringApplication.run()</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建启动监控类，监控启动过程用了多久，但是ms</span></span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  <span class="comment">// 开始计时，设置开始时间</span></span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="comment">// 上下文实例</span></span><br><span class="line">  ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 启动异常错误报告</span></span><br><span class="line">  Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 启用headless模式（headless模式是在系统缺少部分硬件支持的时候让服务自力更生）</span></span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line">  <span class="comment">// 获取spring.factories文件中配置的org.springframework.boot.SpringApplicationRunListener列表，原理是Spring的事件机制，所有的类都实现自ApplicationEvent，可以监听启动过程中的任意阶段</span></span><br><span class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">  <span class="comment">// 进入监听启动阶段</span></span><br><span class="line">  listeners.starting();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取JVM运行参数，也就是在使用java -jar xxx.jar命令启动时指定的其他参数</span></span><br><span class="line">    ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">    <span class="comment">// 准备运行环境，传入监听器和运行参数，获取环境变量，绑定到环境中</span></span><br><span class="line">    ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">    <span class="comment">// 配置spring.beaninfo.ignore属性，SpringBoot中默认为true</span></span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line">    <span class="comment">// 输出Banner信息，banner的输出方式有三种：none/console/log，默认为console，通过配置参数spring.main.banner-mode指定</span></span><br><span class="line">    Banner printedBanner = printBanner(environment);</span><br><span class="line">    <span class="comment">// ☆创建一个上下文实例，比较重点的地方☆</span></span><br><span class="line">    context = createApplicationContext();</span><br><span class="line">    <span class="comment">// 获取spring.factories文件中声明的SpringBootExceptionReporter</span></span><br><span class="line">    exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                                                     <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">    <span class="comment">// 创建上下文，设置环境变量和资源加载器，创建bean，加载到所有的listener中</span></span><br><span class="line">    prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">    <span class="comment">// 调用spring的refresh方法，并注册一个ShutdownHook（应用关闭时的动作，可以通过继承AbstractApplicationContext实现自定义）</span></span><br><span class="line">    refreshContext(context);</span><br><span class="line">    <span class="comment">// 空方法</span></span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line">    <span class="comment">// 启动完成，停止计时</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">      <span class="comment">// 输出启动信息，包括计时</span></span><br><span class="line">      <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入监听器的启动完成事件</span></span><br><span class="line">    listeners.started(context);</span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 进入监听器的运行中事件</span></span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中并未看到是在哪里启动了Tomcat容器，那么我们就看一下创建Spring上下文的方法中是否有关键字</p></li><li><p>createApplicationContext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">  <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">        <span class="keyword">case</span> SERVLET:</span><br><span class="line">          <span class="comment">// org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REACTIVE:</span><br><span class="line">          <span class="comment">// org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// org.springframework.context.annotation.AnnotationConfigApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个创建<code>ApplicationContext</code>实例的方法，我们只看Tomcat的<code>AnnotationConfigServletWebServerApplicationContext</code>，他的继承关系如下</p><p><img src="/images/AnnotationConfigServletWebServerApplicationContext.png" alt="AnnotationConfigServletWebServerApplicationContext"></p><p>以上类中并没有在静态代码块中启动Tomcat，则说明不是在这里启动的，这里只是创建一个<code>ApplicationContext</code>上下文实例</p></li><li><p>prepareContext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置环境变量</span></span><br><span class="line">  context.setEnvironment(environment);</span><br><span class="line">  <span class="comment">// 处理上下文</span></span><br><span class="line">  postProcessApplicationContext(context);</span><br><span class="line">  <span class="comment">// 做refresh前的初始化准备</span></span><br><span class="line">  applyInitializers(context);</span><br><span class="line">  <span class="comment">// 进入到监听器的上下文准备阶段</span></span><br><span class="line">  listeners.contextPrepared(context);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">    logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">    logStartupProfileInfo(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建特殊的引导类实例，单例的</span></span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">  beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">  <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建Banner类实例，单例的</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">    ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">    .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">    context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Load the sources</span></span><br><span class="line">  Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">  Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">  load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">  listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法里整个过程都在创建各种类的实例，并未出现对Tomcat的启动操作，看来也不在这个方法中，那么就继续往下看</p></li><li><p>refreshContext()方法</p><p>这个方法最终是调用到<code>AbstractApplicationContext#refresh()</code>中，这就到了Spring基础框架中。我们在分析createApplicationContext()方法的时候，知道Tomcat使用的是<code>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</code>类，这个类继承自<code>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext</code>，在这个类中，重写了父类<code>AbstractApplicationContext</code>中的refresh()、onRefresh()和finishRefresh()方法，而在<code>AbstractApplicationContext#refresh()</code>方法中，调用了onRefresh()和finishRefresh()这两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用的onRefresh()和finishRefresh()实际上是调用了<code>ServletWebServerApplicationContext</code>中的方法，那么我们就来看下这个类中的这两个方法分别做了什么</p><ul><li>onRefresh()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类的onRefresh()方法</span></span><br><span class="line">  <span class="keyword">super</span>.onRefresh();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建WebServer</span></span><br><span class="line">    createWebServer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Unable to start web server"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">  ServletContext servletContext = getServletContext();</span><br><span class="line">  <span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取ServletWebServerFactory的实例，使用Tomcat的话会获取到tomcatServletWebServerFactory</span></span><br><span class="line">    ServletWebServerFactory factory = getWebServerFactory();</span><br><span class="line">    <span class="comment">// 获取WebServer实例，方法内创建Tomcat并准备Tomcat启动所需环境变量</span></span><br><span class="line">    <span class="keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getSelfInitializer().onStartup(servletContext);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化自定义的环境变量，涉及到servletContextInitParams和servletConfigInitParams</span></span><br><span class="line">  initPropertySources();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ServletWebServerFactory <span class="title">getWebServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用bean名称，这样我们就不会考虑层次结构</span></span><br><span class="line">  String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class="line">  <span class="keyword">if</span> (beanNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取Bean实例，这里获取到的就是TomcatServletWebServerFactory类的实例</span></span><br><span class="line">  <span class="keyword">return</span> getBeanFactory().getBean(beanNames[<span class="number">0</span>], ServletWebServerFactory.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码我们知道在onRefresh()方法中主要是创建Tomcat实例，准备Tomcat启动所需参数和配置信息，并未启动Tomcat</p><ul><li>finishRefresh()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.finishRefresh();</span><br><span class="line">  <span class="comment">// 启动WebServer，难道是这里启动的Tomcat？</span></span><br><span class="line">  WebServer webServer = startWebServer();</span><br><span class="line">  <span class="keyword">if</span> (webServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    publishEvent(<span class="keyword">new</span> ServletWebServerInitializedEvent(webServer, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> WebServer <span class="title">startWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">  <span class="keyword">if</span> (webServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 启动WebServer，这里调用的是TomcatWebServer#start()方法</span></span><br><span class="line">    webServer.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> webServer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TomcatWebServer#start()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">  <span class="comment">// 加锁防并发</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.started) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      addPreviouslyRemovedConnectors();</span><br><span class="line">      <span class="comment">// 获取Tomcat的Connector</span></span><br><span class="line">      Connector connector = <span class="keyword">this</span>.tomcat.getConnector();</span><br><span class="line">      <span class="keyword">if</span> (connector != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.autoStart) &#123;</span><br><span class="line">        <span class="comment">// 如果connector不为null，并且自动启动，则启动时执行延迟加载</span></span><br><span class="line">        <span class="comment">// 当端口大于0的时候，autoStart就为true</span></span><br><span class="line">        performDeferredLoadOnStartup();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查Connector是否已启动，若有未启动的Connector则抛异常</span></span><br><span class="line">      checkThatConnectorsHaveStarted();</span><br><span class="line">      <span class="comment">// 修改运行标识属性</span></span><br><span class="line">      <span class="keyword">this</span>.started = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 输出Tomcat启动成功日志</span></span><br><span class="line">      logger.info(<span class="string">"Tomcat started on port(s): "</span> + getPortsDescription(<span class="keyword">true</span>) + <span class="string">" with context path '"</span></span><br><span class="line">                  + getContextPath() + <span class="string">"'"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectorStartFailedException ex) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里好像也仅仅就是检测Tomcat服务是否启动成功了，并没有执行启动这个操作，看来也不在这里。</p><p>这就奇怪了，我们几乎翻遍了整个启动类的代码，都没有Tomcat启动的代码，那么Tomcat是怎么启动的呢？是不是我们遗漏了什么？我们来回顾一下上面的分析，TomcatWebServer实例的获取的地方<code>ServletWebServerFactory#getWebServer()</code>方法内我们好像没有看，是不是在创建TomcatWebServer实例的时候直接就启动了，然后在<code>TomcatWebServer#start()</code>方法中只是去检测启动的状态？我们来看下<code>ServletWebServerFactory#getWebServer()</code>的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebServer <span class="title">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.disableMBeanRegistry) &#123;</span><br><span class="line">    Registry.disableRegistry();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 简单略过</span></span><br><span class="line">  Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">  File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span>) ? <span class="keyword">this</span>.baseDirectory : createTempDir(<span class="string">"tomcat"</span>);</span><br><span class="line">  tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">  Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">  connector.setThrowOnFailure(<span class="keyword">true</span>);</span><br><span class="line">  tomcat.getService().addConnector(connector);</span><br><span class="line">  customizeConnector(connector);</span><br><span class="line">  tomcat.setConnector(connector);</span><br><span class="line">  tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">  configureEngine(tomcat.getEngine());</span><br><span class="line">  <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">    tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">  &#125;</span><br><span class="line">  prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">  <span class="comment">// 获取TomcatWebServer实例</span></span><br><span class="line">  <span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不重要</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TomcatWebServer <span class="title">getTomcatWebServer</span><span class="params">(Tomcat tomcat)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// autoStart = getPort() &gt;= 0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatWebServer</span><span class="params">(Tomcat tomcat, <span class="keyword">boolean</span> autoStart)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(tomcat, <span class="string">"Tomcat Server must not be null"</span>);</span><br><span class="line">  <span class="keyword">this</span>.tomcat = tomcat;</span><br><span class="line">  <span class="keyword">this</span>.autoStart = autoStart;</span><br><span class="line">  <span class="comment">// 最重要的方法</span></span><br><span class="line">  initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>initialize()方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动服务器以触发初始化侦听器</span></span><br><span class="line">      <span class="keyword">this</span>.tomcat.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 所有Tomcat线程都是守护进程线程。我们创建一个阻塞非守护进程来停止立即关闭</span></span><br><span class="line">      startDaemonAwaitThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      stopSilently();</span><br><span class="line">      destroySilently();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> WebServerException(<span class="string">"Unable to start embedded Tomcat"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于找到了，语句<code>this.tomcat.start()</code>就是启动Tomcat容器的关监语句。</p></li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>通过对SpringApplication.run()方法执行顺序的分析来看，先构建Spring上下文加载Bean，也就是扫描包，然后再在refreshContext()方法中创建Tomcat容器并启动容器。</p><p>由此我们可以验证出假设2是正确的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;疑惑&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#疑惑&quot;&gt;&lt;/a&gt; 疑惑&lt;/h4&gt;
&lt;p&gt;SpringBoot中内置了Tomcat容器，那么Tomcat是在什么时间点启动的？是先扫描包加载类再启动Tomcat？，还是先启动Tomcat
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM指针碰撞和空闲列表</title>
    <link href="http://luxiaowan.github.io/2020/05/12/JVM%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8/"/>
    <id>http://luxiaowan.github.io/2020/05/12/JVM指针碰撞和空闲列表/</id>
    <published>2020-05-12T02:40:00.000Z</published>
    <updated>2020-05-12T03:17:43.831Z</updated>
    
    <content type="html"><![CDATA[<p>Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，在堆上为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，将对象放进去。常用的分配方法有指针碰撞和空闲列表两种实现方式。</p><h4 id="指针碰撞"><a class="markdownIt-Anchor" href="#指针碰撞"></a> 指针碰撞</h4><p>适用于堆内存完整的情况，已分配的内存和空闲内存分表在不同的一侧，通过一个指针指向分界点，当需要分配内存时，把指针往空闲的一端移动与对象大小相等的距离即可，用于Serial和ParNew等不会产生内存碎片的垃圾收集器。</p><img src="/images/image-20200512111153143.png" alt="image-20200512111153143" style="zoom:50%;"><h4 id="空闲列表"><a class="markdownIt-Anchor" href="#空闲列表"></a> 空闲列表</h4><p>适用于堆内存不完整的情况，已分配的内存和空闲内存相互交错，JVM通过维护一张内存列表记录可用的内存块信息，当分配内存时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录，最常见的使用此方案的垃圾收集器就是CMS。</p><img src="/images/image-20200512111650404.png" alt="image-20200512111650404" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，在堆上为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，将对象放进去。常用的分配方法有指针碰撞和空闲列表两种实现方式。&lt;/p&gt;
&lt;h4 id=&quot;指针碰撞&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
</feed>
