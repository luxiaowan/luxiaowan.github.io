<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2020-03-27T16:42:41.273Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis相关东西</title>
    <link href="http://luxiaowan.github.io/2020/03/26/Redis%E7%9B%B8%E5%85%B3%E4%B8%9C%E8%A5%BF/"/>
    <id>http://luxiaowan.github.io/2020/03/26/Redis相关东西/</id>
    <published>2020-03-26T14:15:00.000Z</published>
    <updated>2020-03-27T16:42:41.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li>Redis是什么</li><li>五种数据类型</li><li>Redis为何这么快</li><li>Redis和Memcached的区别</li><li>淘汰策略</li><li>持久化</li><li>主从复制</li><li>哨兵</li></ul><hr><h4 id="redis是什么"><a class="markdownIt-Anchor" href="#redis是什么"></a> Redis是什么</h4><p>​Redis是由C语言编写的一个开源的高性能键值对的内存数据库，是一款NoSQL(not-only sql | no sql)数据库，可以用作缓存、数据库、消息中间件。</p><p>​Redis作为一款内存数据库，其优势为：</p><pre><code>1. 性能优秀，数据都存于内存中，读写速度快，理论读取速度能达到10W/秒；2. 单线程操作，线程安全，采用IO多路复用实现垃圾回收和持久化；3. 支持丰富的数据类型：字符串(string)、列表(list)、散列(hash)、集合(set)、有序集合(zset)；4. 支持数据持久化，并且提供RDB和AOF两种持久化方式；5. 可以用于分布式锁，也可以利用Redis的发布-订阅特性实现消息队列；6. 主从复制，哨兵，高可用。</code></pre><h4 id="五种数据类型"><a class="markdownIt-Anchor" href="#五种数据类型"></a> 五种数据类型</h4><ul><li>字符串(string)类型：Redis的字符串类型是最基本的类型，可以理解为一个key对应一个value，value可以是字符也可以是数字，该类型可以存储图片或者序列化后的对象等二进制数据，支持的value大小最大512M，当value小于44字节(3.2版本+是44，3.0版本-是39)时，字符串编码为embstr，大于的时候字符串编码为raw，常用的命令有set、get等。</li><li>散列(hash)类型：hash是一个键值对的集合，特别适合用于存储对象，可以直接获取到对象的某个属性的值，常用的命令有hset、hget、hgetall等。</li><li>列表(list)类型：</li><li>集合(set)类型：</li><li>有序集合(zset)类型：</li></ul><h4 id="redis为何那么快"><a class="markdownIt-Anchor" href="#redis为何那么快"></a> Redis为何那么快</h4><p>​Redis之所以是单线程的还那么快，完全是因为Redis是纯内存操作，没有CPU上下文切换带来的消耗，也没有磁盘寻址等带来的IO开销，官方理论QPS为10W+。</p><p>​既然Redis的性能瓶颈是内存和网络带宽，那么就没必要设计成多线程模式，否则会多出CPU切换，且只要涉及到多线程必然会因为资源竞争而衍生出资源锁的使用，频繁的加锁、释放锁还是非常浪费时间的，所以既然多线程会带来那么多问题，还是使用单线程得了，并且Redis本身就是K-V存储，查询时间复杂度限制在O(1)的情况，所以Redis才那么快。</p><h4 id="redis和memcached的区别"><a class="markdownIt-Anchor" href="#redis和memcached的区别"></a> Redis和Memcached的区别</h4><ul><li>存储方式：Memcache将数据存储在内存中，若服务器出现故障，则数据全部丢失，无法持久化。Redis提供了RDB和AOF两种方式进行数据持久化，就算是服务器宕机，在恢复之后依然可以保证数据的完整性；</li><li>数据类型：Memcache仅支持字符串存储，而Redis支持字符串、列表、散列、集合、有序集合等类型，使用起来更方便和多样化；</li><li>value大小：Redis的字符串类型可以存储512M的内容，而Memcache最高仅能存储1M的内容，不过虽然Redis支持很大的value，但是一般不会那么用；</li><li>底层协议不同：Redis拥有自己的VM，Memcache使用系统函数</li></ul><h4 id="淘汰策略"><a class="markdownIt-Anchor" href="#淘汰策略"></a> 淘汰策略</h4><p>Redis目前有6种淘汰策略，据说新版本中有8种</p><ul><li>volatile-lru：从设置了过期时间的所有key中将最近最少使用(least recently used)的key淘汰掉</li><li>volatile-ttl：从设置了过期时间的所有key中将剩余存活时间最少(time to live)的key淘汰掉</li><li>volatile-random：从设置了过期时间的所有key中随机淘汰掉部分key</li><li>allkeys-lru：从所有的key中将最近最少使用的key淘汰掉</li><li>allkeys-random：从所有的key中随机淘汰掉部分key</li><li>noeviction：不执行数据淘汰，当内存不足时直接拒绝新的插入请求，并返回错误信息</li><li>volatile-lfu：从设置了过期时间的所有key中将访问频率最少(least frequently used)的key淘汰掉</li><li>allkeys-lfu：从所有的key中将访问频率最少的key淘汰掉</li></ul><h4 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h4><p>Redis支持两种持久化方式，持久化的目的是将内存中的数据写入到磁盘中，防止服务出现故障后的数据丢失的情况。</p><ul><li><p>RDB方式：RDB是Redis的默认持久化方式，属于是定时保存，每隔一段时间将fork出一个子进程去将内存中的数据写入到一个临时dump.rdb(名字在配置文件中设置)文件中，待子进程执行完成之后，将这个临时的dump文件替换掉原来的dump文件，这样做的目的是可以实现copy-on-write，子进程运行过程中使用的内存资源与Redis主进程无关</p><p>*<em><font color="red"><em>通过bgsave和save命令可以手动触发执行RDB</em></font></em></p><p><img src="/Users/chuan/Documents/projects_code/git-project/github_blog/source/images/image-20200327015702174.png" alt="image-20200327015702174"></p><p>配置信息：redis.conf文件中</p><blockquote><p>解读：</p><p>save 900 1：900秒内若至少有1个key发生变化，则触发备份</p><p>save 300 10：300秒内若至少有10个key发生变化，则触发备份</p><p>save 60 10000：60秒内若至少有1万个key发生变化，则触发备份</p></blockquote><p><img src="/Users/chuan/Documents/projects_code/git-project/github_blog/source/images/redis-rdb-conf.png" alt="image-20200327001846508"></p><blockquote><p>劣势：</p><ol><li>RDB持久化方式适合于整库备份，dump文件用于故障恢复，但是由于RDB方式并不是实时的整库备份，所以我们拿到的dump文件总是会和内存中的数据不一致，如果你想要避免服务器发生故障的时候丢失数据，那么仅仅使用RDB是万万不行的，需要配合AOF使用。</li><li>为了使用子进程在磁盘上持久存储，RDB经常需要fork()。如果数据集很大，Fork()可能很耗时，并且可能导致Redis停止为客户端提供服务几毫秒甚至一秒钟(如果数据集很大，而且CPU性能不是很好)。AOF还需要fork()，但是您可以调整重写日志的频率，而不需要牺牲持久性。</li></ol><p>优势：</p><ol><li><p>RDB是一个非常紧凑的单文件时间点表示您的Redis数据。RDB文件非常适合备份。例如，您可能希望在最近的24小时内每小时存档一次RDB文件，并在30天内每天保存一次RDB快照。这允许您在发生灾难时轻松地恢复不同版本的数据集。</p></li><li><p>RDB对于灾难恢复非常有用，它是一个紧凑的文件，可以传输到远程数据中心上。</p></li><li><p>RDB最大限度地提高了Redis性能，因为为了保持Redis父进程所需做的惟一工作就是创建一个将完成所有其余工作的子进程。父实例永远不会执行磁盘I/O或类似的操作。</p></li><li><p>与AOF相比，RDB允许对大数据集进行更快的重启。</p></li></ol></blockquote></li><li><p>AOF方式：AOF方式在Redis中是默认未开启的，在开启AOF后，会将内容写入到appendonly.aof文件中，文件的内容是服务器接收到的所有对数据进行修改的命令集合，按照时间顺序追加到文件尾部，并且在故障恢复的时候，会优先读取appendonly.aof文件中的内容，因为aof的默认策略是每秒钟写入一次，所以当采用aof进行持久化的时候，最多也仅仅丢失一秒的数据。</p><p>配置信息：redis.conf文件中</p><p><img src="/Users/chuan/Documents/projects_code/git-project/github_blog/source/images/redis-aof-conf.png" alt="image-20200327003834988"></p><blockquote><p>劣势：</p><p>随着服务运行时间越来越久，内存中的数据变更次数越来越多，会造成aof文件越来越大，当然我们可以在配置文件redis.conf中设置aof文件重写策略，默认当aof文件大小达到64mb且增长比例超过了之前是100%的时候进行重写，重写的规则是将内存中的数据的当前值全部以对应的set命令写入到新的aof文件中，比如当前aof文件100mb，重写之后80mb，那么只有当文件再次达到160mb(160&gt;=80*2&amp;&amp;160&gt;64)的时候才会再次进行重写，</p><p><img src="/Users/chuan/Documents/projects_code/git-project/github_blog/source/images/redis-aof-rewrite.png" alt="image-20200327005212374"></p></blockquote></li></ul><blockquote><p>AOF文件损坏修复：</p><p>​如果在AOF文件写入的过程中突然宕机，可能会导致aof文件损坏，我们可以使用redis-check-aof --fix命令来修复</p></blockquote><p>####### 故障恢复</p><ul><li><p>若同时开启了RDB和AOF，那么在故障恢复的时候先使用AOF文件进行恢复，这样可以保证丢失最少的数据，但是如果我们想尽快的恢复Redis服务，可以允许丢失一部分数据，那么可以禁用AOF，只使用RDB，使用RDB之所以比AOF快，是因为AOF是一条条命令的去执行的，直到最终状态，RDB是一次性把所有数据的最终状态刷到内存的</p></li><li><p>AOF日志文件的命令通过可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p></li><li></li></ul><h4 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制"></a> 主从复制</h4><p>​redis单节点存在单点故障问题，为了解决单点问题，一般都需要对redis配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率。</p><p>​<strong>复制过程</strong></p><ol><li><p>从节点执行slaveof [masterIP] [masterPort]，保存主节点信息 ；</p></li><li><p>从节点中的定时任务发现主节点信息，建立和主节点的socket连接；</p></li><li><p>从节点发送Ping信号，主节点返回Pong，两边能互相通信；</p></li><li><p>连接建立后，主节点将所有数据发送给从节点（数据同步）；</p></li><li><p>主节点把当前的数据同步给从节点后，便完成了复制的建立过程；</p></li><li><p>接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</p></li></ol><h4 id="哨兵"><a class="markdownIt-Anchor" href="#哨兵"></a> 哨兵</h4><ul><li>主从复制存在的问题<ol><li>一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预；</li><li>主节点的写能力受到单机的限制；</li><li>主节点的存储能力受到单机的限制；</li><li>原生复制的弊端在早期的版本中也会比较突出，比如：redis复制中断后，从节点会发起psync。此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</li></ol></li><li>改善方式</li></ul><p>哨兵模式是一种特殊的模式，Redis提供了哨兵命令，哨兵是一个独立的进程，原理是通过哨兵发送命令，然后等待Redis服务器的响应，进而实现对Redis实例的监控。</p><ul><li><p>运行方式</p><ul><li><p>通过命令的发送，Redis实例返回监控的运行状态，所有的Redis服务器</p></li><li><p>当master机器宕机后，会随机选择一个slave节点作为master，然后通过发布订阅模式通知其他slave节点，修改配置信息，更改跟随的主机</p></li><li><p>单哨兵模式相对来说不太可靠，毕竟会出现一言堂的情况，所以我们在使用哨兵的时候一般会采用多少兵模式，每一个哨兵都监控所有的Redis服务器，哨兵之间互相监控，当一个节点宕机后，只有指定数量的哨兵全部将其标记为下线，才会将节点移除</p></li></ul></li><li><p>故障切换过程</p><ul><li>主节点服务器宕机</li><li>哨兵1检测到主节点宕机，然后将其标记为客观下线，这个时候主节点还是主节点，并未进行failover过程</li><li>其他哨兵检测到主节点宕机，全部哨兵都会将主节点标记为客观下线</li><li>标记为客观下线的哨兵数量达到指定数量的时候，由一个哨兵进行投票，根据投票结果决定是否进行主节点切换</li><li>主节点切换完成之后，通过<em>发布订阅模式</em>让各个哨兵和从服务器更换主服务器配置，这个过程称为主观下线</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Redis是什么&lt;/li&gt;
&lt;li&gt;五种数据类型&lt;/li&gt;
&lt;li&gt;Redis为何这么快&lt;/li&gt;
&lt;li&gt;Redis和Memcac
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
      <category term="面试" scheme="http://luxiaowan.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>服务治理思考</title>
    <link href="http://luxiaowan.github.io/2020/03/24/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E6%80%9D%E8%80%83/"/>
    <id>http://luxiaowan.github.io/2020/03/24/服务治理思考/</id>
    <published>2020-03-24T05:21:00.000Z</published>
    <updated>2020-03-24T06:29:57.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>服务治理概念当下主要针对的是分布式架构下的多服务、微服务等。分布式系统由若干个大大小小的服务组成，服务之间通过HTTP或TCP的方式进行相互通信，促使整个系统活络起来。当分布式系统中的服务随着业务的发展不断变多时，我们就需要对服务进行相关的管理，不能一味的任由其野蛮增长。</p><h3 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h3><h4 id="1-节点管理即服务提供者在注册中心及客户端创建的服务节点"><a class="markdownIt-Anchor" href="#1-节点管理即服务提供者在注册中心及客户端创建的服务节点"></a> 1. 节点管理，即服务提供者在注册中心及客户端创建的服务节点。</h4><p>节点注册于注册中心，缓存于客户端，目的为若注册中心与服务端出现网络连通故障，但客户端与服务端网络连通正常，此时注册中心已将节点移除，但客户端在下一次同步注册中心节点之前仍可通过自身缓存的服务节点发送请求。</p><ul><li><p>注册中心管理：服务提供者定时向注册中心发送心跳通知来证明其是存活状态，每次收到心跳通知均与上一次收到通知的时间进行比较，如果时差超出注册中心允许的最大值，则认为该服务提供者发生故障，将其从注册中心移除，随即通知监听客户端。</p></li><li><p>客户端管理：若注册中心与服务端网络连通出现问题，但客户端与服务端网络连接正常，直至下一次与注册中心同步之前仍可继续使用该节点。若客户端与服务端网络连通故障，但注册中心与服务端网络连通正常，则客户端会将该节点从缓存中移除直至下一次与注册中心进行同步，周而复始。</p></li></ul><h4 id="2-负载均衡顾名思义平衡所有服务端处理请求的负载防止某个服务端因接受过多请求导致服务故障"><a class="markdownIt-Anchor" href="#2-负载均衡顾名思义平衡所有服务端处理请求的负载防止某个服务端因接受过多请求导致服务故障"></a> 2. 负载均衡，顾名思义：平衡所有服务端处理请求的负载，防止某个服务端因接受过多请求导致服务故障。</h4><ul><li><p>随机算法：字面意思，简洁明了，就是采用随机数的方式选择本次请求所要转发的服务端，此法非常公平，不会因为服务端配置的优劣而对其另眼相看，绝对的公平！</p></li><li><p>加权法：又叫轮询算法。本法则事在人为，完全按照主人的喜好行事，又称拍马屁，就好比食堂打饭，所有人围绕一个圈，如果打饭阿姨看到每个人的长相都一样，那么他对所有人都没有私心，从第一个开始每人给一勺，如此循环下去，谁都不会多谁也不会少，大家都均等，这就是大家的对注册中心来说权重都一样；如果打饭阿姨喜欢帅哥，看到长得帅的（比如我）每次都会多给一勺，其他人仍是一勺，此种情况对于注册中心而言，我的权重大于其他服务提供者，所以每一批请求中都会多分发给权重大的服务端。（此例不太恰当，换为吃饭：胖子和瘦子，胖子多吃，瘦子少吃，好像更好）。</p></li><li><p>最少活跃算法：这个拿吃饭来说吧，吃得多的碗落不下了，然后就少盛点，吃的少趁机多吃点均衡一下。上面也说了，打饭阿姨因为我长得帅，每次给别人打着饭呢都会不定时的拐到我这边给我加上一碗，递过来一碗饭，我桌子上的碗的数量就+1，等我吃完一碗饭将空碗回收后，桌子上的碗的数量就-1，但是打饭阿姨给的次数太过频繁，导致我面前很多碗，其他人面前的碗则很少，有人就向领导投诉，领导痛斥一顿后，阿姨则给面前碗最少的人开始打饭，这时此人碗的数量+1，然后阿姨重新统计，下一碗给统计后面前碗最少的人，这样大家都不至于被冷落，一旦落后，立刻照顾到。</p></li><li><p>一致性Hash算法：对每次请求的参数均计算hash，hash值相同的转发到同一个节点。上体育课1234报数排队，报到相同数字的站在一队，若某一队解散，由4队变成3队，则解散的这一队的人重新123报数，归并相关各队。（为什么不用吃饭举例了？因为再吃就撑死了！）</p></li></ul><h4 id="3-服务路由"><a class="markdownIt-Anchor" href="#3-服务路由"></a> 3. 服务路由</h4><ul><li><p>灰度访问：类似于单双号限行和不限行。一条马路刚修好，实行为期一个礼拜的单双号限行，一个礼拜之内无故障，则取消限行，大家都可以走。</p></li><li><p>就近原则：每次请求到达，客户端先关门在自己的局域网内查找可用的服务提供者，若有则直接调用，若未查到则出门浪。</p></li></ul><blockquote><p>配置分为静态配置和动态配置，这里不做解释了，字面意思！</p></blockquote><h4 id="4-服务容错有容奶大要有一颗包容的心没错是不是没发现奶非乃"><a class="markdownIt-Anchor" href="#4-服务容错有容奶大要有一颗包容的心没错是不是没发现奶非乃"></a> 4. 服务容错：有容奶大！要有一颗包容的心！没错，是不是没发现奶非乃！😳</h4><ul><li><p>failover：拆开来就是fail over，也就是请求服务端a，然后a故障了，那就直接将请求转发给服务端b，结果b也故障了，那就再转发给c，直到成功！当然也可以设置最大转发次数，比如设置最大转发次数是两次，那么（划重点）在服务端2也故障时就不会转发给c了，直接返回给客户端告知失败！此方式为幂等的，也就是每一个服务提供方返回的数据均相等。</p></li><li><p>failback：遇到请求故障，那么就告知客户端请求失败，不再重试，然后根据返回的指令进行下一步操作。</p></li><li><p>failcache：遇到故障，就把请求缓存起来，间隔一段时间再发起请求，防止频繁请求影响服务端恢复。</p></li><li><p>failfast：遇到故障就返回，管他誓言有多真！绝不重试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;服务治理概念当下主要针对的是分布式架构下的多服务、微服务等。分布式系统由若干个大大小小的服务组成，服务之间通过HTTP或TCP的方式进行相互通信
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="服务治理" scheme="http://luxiaowan.github.io/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OLTP和OLAP区别</title>
    <link href="http://luxiaowan.github.io/2020/03/24/OLTP%E5%92%8COLAP%E5%8C%BA%E5%88%AB/"/>
    <id>http://luxiaowan.github.io/2020/03/24/OLTP和OLAP区别/</id>
    <published>2020-03-24T03:15:00.000Z</published>
    <updated>2020-03-24T04:44:39.771Z</updated>
    
    <content type="html"><![CDATA[<p>我们在《<a href="http://luxiaowan.github.io/2020/03/24/MongoDB%E5%92%8CElasticsearch%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/">MongoDB和Elasticsearch简单对比</a>》一文中提到了OLAP和OLTP，然后我去问了几个技术人员，基本上知道这两个名词的人少之又少，当然这也情有可原，毕竟IT行业里名词太多了，我们来说一下这两者的区别</p><h3 id="词义"><a class="markdownIt-Anchor" href="#词义"></a> 词义</h3><ol><li>OLTP：on-line Transaction Processing，联机(在线)事务处理</li><li>OLAP：on-line Analytical Processing，联机(在线)分析处理</li></ol><blockquote><p>从名词上我们就可以看出，OLTP主要是执行日常基本的事务处理，OLAP主要是执行日常的数据分析</p></blockquote><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><ol><li>OLAP<ul><li>实时性不高。比如ES中常见的使用日期检索日志</li><li>数据量大。ES利用其倒排索引的特点强化全文检索能力，即使有大量的日志打到ES中，我们仍然可以很快的查询出对应数据，效率贼高</li><li>动态检索纬度。我们在做数据分析时，数据的检索纬度是非常重要的一个条件，因为我们一般都是需要依据某一纬度做数据分析，这样才能将分析出来的数据提供给决策使用，不同的决策者需要的纬度不同，所以OLAP需要支持动态的检索纬度</li></ul></li><li>OLTP<ul><li>实时性高。既然是联机事务处理，那么对实时性要求肯定是一个高指标要求，会尽量杜绝出现数据变更不实时的情况</li><li>数据量不是很大。数据量过大会影响CRUD的性能</li><li>对确定性的数据进行操作。</li><li>高并发且满足ACID。</li></ul></li></ol><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><ol><li>OLTP一般是指我们常说的关系型数据库，或者说是支持频繁CRUD的数据存储媒介。</li><li>OLAP一般用于大数据处理和数据仓库，目前OLAP系统内的数据大多是针对OLTP内存储的数据做出进一步分析和应用，然后提供信息支持最终决策，对其大多是查多改少</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在《&lt;a href=&quot;http://luxiaowan.github.io/2020/03/24/MongoDB%E5%92%8CElasticsearch%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/&quot;&gt;MongoDB和Elasticsea
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB和Elasticsearch对比</title>
    <link href="http://luxiaowan.github.io/2020/03/24/MongoDB%E5%92%8CElasticsearch%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://luxiaowan.github.io/2020/03/24/MongoDB和Elasticsearch简单对比/</id>
    <published>2020-03-24T02:09:00.000Z</published>
    <updated>2020-03-24T03:14:25.705Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>MongoDB和Elasticsearch都属于是NoSQL类型的数据存储媒介，两者有很大的一个相似度，但使用方式和场景还是有所区别的。</p><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><ol><li>MongoDB创立的初衷是为了干掉关系型数据库，和RDBMS算是竞争关系。</li><li>Elasticsearch起初就是以检索查询为主要应用场景出道，和RDBMS有点互相协助的意思。</li></ol><h3 id="相同点"><a class="markdownIt-Anchor" href="#相同点"></a> 相同点</h3><ol><li>数据存储格式为json</li><li>聚合和全文检索</li><li>CRUD</li><li>分片和复制</li><li>简单的join操作</li><li>适用于大数据量的处理</li><li>不支持事务</li></ol><h3 id="不同点"><a class="markdownIt-Anchor" href="#不同点"></a> 不同点</h3><ol><li>开发语言不同：ES的Java语言(restful)，Mongo是C++语言(driver)，从开发角度来看，ES对Java更方便</li><li>分片方式：ES是hash，Mongo是range和hash</li><li>分布式：ES的主副分片自动组合和配置，Mongo需要手动配置集群“路由+服务配置+sharding”</li><li>索引：ES自建倒排索引，检索力度强，Mongo手动创建索引（B树），不支持倒排索引，这点和RDBMS类似</li><li>检索字段：ES全文检索，可用的检索插件较多，Mongo对索引字段个数有限制，全文检索效率低乃至不采用</li><li>时效性：ES非实时，有丢数据的风险，Mongo实时，理论上无丢数据的风险</li></ol><h3 id="终"><a class="markdownIt-Anchor" href="#终"></a> 终</h3><p>ES偏向于检索、查询和数据分析，适用于OLAP（on-line Analytical Processing）系统，Mongo偏向于大数据下的CRUD，适用于OLTP（on-line Transaction Processing）系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;MongoDB和Elasticsearch都属于是NoSQL类型的数据存储媒介，两者有很大的一个相似度，但使用方式和场景还是有所区别的。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="NoSQL" scheme="http://luxiaowan.github.io/categories/NoSQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL简单优化技巧</title>
    <link href="http://luxiaowan.github.io/2020/03/23/MySQL%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <id>http://luxiaowan.github.io/2020/03/23/MySQL简单优化技巧/</id>
    <published>2020-03-22T18:08:00.000Z</published>
    <updated>2020-03-23T14:48:44.504Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>一提到MySQL优化，大多数同学都比较依赖于DBA，但是对于程序员来说，掌握SQL的编写技巧其实很重要。</p><h3 id="技巧"><a class="markdownIt-Anchor" href="#技巧"></a> 技巧</h3><ol><li>比较运算符能用“=”就不要用“&lt;&gt;”，因为“=”能够增大列索引的使用概率</li><li>如果只查询一条数据，那么就使用“limit 1”，告知查询游标找到第一个之后就返回，以免进行全表扫描</li><li>给列选择合适的类型，比如可以使用TINYINT代替INT，节省磁盘和内存的消耗</li><li>拆解复杂SQL，减少join的出现</li><li>若查询字段全部为某联合索引字段，则避免使用“SELECT * ”，*会造成回表</li><li>WHERE、ORDER BY、JOIN的列尽量使用索引字段</li><li>使用EXPLAIN查看执行计划</li><li>可以使用ENUM的时候不要用VARCHAR</li><li>字段尽量设置为NOT NULL，尤其是索引字段</li><li>长度比较大的字段尽量拆分为副表，如果这个字段不会被经常使用</li><li>经常发生变动的数据库尽量把查询缓存关闭，否则在每次变动的时候都要删除缓存，查询的时候也要查询和更新缓存，浪费时间</li><li>索引字段的长度尽量不要太长，毕竟一个索引数据页只有16k，如果一个索引内容过长，那么可能就会造成一个数据页只能存储一个索引字段，浪费空间</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;一提到MySQL优化，大多数同学都比较依赖于DBA，但是对于程序员来说，掌握SQL的编写技巧其实很重要。&lt;/p&gt;
&lt;h3 id=&quot;技巧&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器浅谈</title>
    <link href="http://luxiaowan.github.io/2020/03/22/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B5%85%E8%B0%88/"/>
    <id>http://luxiaowan.github.io/2020/03/22/JVM垃圾收集器浅谈/</id>
    <published>2020-03-22T03:15:00.000Z</published>
    <updated>2020-03-24T06:20:21.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>JVM是做Java的同学都必须要了解的东西，为什么这么说，因为我们只有知道了Java程序运行环境的配置和工作逻辑，才能对运行环境进行相关的优化和配置修改，让JVM在不同的服务器环境使用不同的配置，从而达到JVM环境最优化。</p><p>说到JVM就不得不说一下GC（garbage collection），垃圾收集的意思是找到垃圾并清理掉，但是常规的垃圾收集器却是找到正在被使用的对象，然后把其他的对象全部当作是垃圾对象清理掉。</p><p>写过C语言的同学都知道，在C语言中，我们需要手动的去管理内存，在使用内存之前我们需要先申请（malloc）一定大小的内存，使用完成之后需要手动的把使用的内存释放掉（free），如果忘记释放内存则很快会导致内存溢出，</p><h2 id="gc算法"><a class="markdownIt-Anchor" href="#gc算法"></a> GC算法</h2><ol><li><p>引用计数法</p><p>为每个对象添加一个引用计数器，在对象被引用时，计数器+1，引用结束后，计数器-1，最终清除掉引用计数器为0的对象，并级联删除该对象引用的所有的对象，只保留引用计数不为0的对象。</p><p>这种算法看起来是不是很屌，是的，非常简单，只需要在对象被引用的时候串行修改引用计数器的值即可，但也容易出现一种问题：循环引用！循环引用就是几个废对象之间循环引用，尽管他们的引用计数器都不为0，但是在整个程序中却没有被使用，但是他们永远不会被回收，这样的对象多了之后很容易造成内存泄漏。</p></li><li><p>标记-清除</p></li><li><p>标记-清理-整理</p></li><li><p>可达性分析法</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;JVM是做Java的同学都必须要了解的东西，为什么这么说，因为我们只有知道了Java程序运行环境的配置和工作逻辑，才能对运行环境进行相关的优化和
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="GC" scheme="http://luxiaowan.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>RMI远程服务调用简述</title>
    <link href="http://luxiaowan.github.io/2020/03/20/RMI%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%AE%80%E8%BF%B0/"/>
    <id>http://luxiaowan.github.io/2020/03/20/RMI远程服务调用简述/</id>
    <published>2020-03-19T16:15:00.000Z</published>
    <updated>2020-03-19T17:50:31.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rmi是什么"><a class="markdownIt-Anchor" href="#rmi是什么"></a> RMI是什么</h2><p>RMI(Remote Method Invocation)意为远程方式调用，顾名思义，是Java版的RPC实现技术，是建立分布式Java应用程序的方便途径。RMI是基于接口的，一般是接口定义和实现分开在不同的工程中。</p><p>相似：Hessian，Burlap，Httpinvoker，webservice</p><h2 id="为什么使用rmi"><a class="markdownIt-Anchor" href="#为什么使用rmi"></a> 为什么使用RMI</h2><p>它允许运行在一台虚拟机上的方法调用运行在另一台虚拟机上的对象方法，这样可以让每个任务运行在更适合的虚拟机上。</p><h2 id="rmi怎么用"><a class="markdownIt-Anchor" href="#rmi怎么用"></a> RMI怎么用</h2><ul><li>定义一个java.rmi.Remote的子接口，也就是定义一个接口AnimalService，继承自Remote，接口中的所有方法必须显式的抛出java.rmi.RemoteException异常，否则服务会注册失败，谨记!</li><li>创建AnimalService的实现类DogServiceImpl，这个类需要继承java.rmi.server.UnicastRemoteObject</li><li>将服务AnimalService注册到rmi中心</li><li>客户端引用接口定义jar包</li><li>客户端获取AnimalService的远程服务</li><li>进行相关方法调用</li></ul><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><p>因为RMI是Java版的RPC通讯技术，所以他只适用于Java程序上，如果想跨语言通讯，那就只能另谋它法了</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><ul><li>接口（工程：rmi-api）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中所有的方法必须声明throws RemoteException</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">laugh</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现（工程：rmi-service）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cc.kevinlu.spidemo.spi.AnimalService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">AnimalService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DogServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">laugh</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Server</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cc.kevinlu.spidemo.spi.AnimalService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AnimalService dogService = <span class="keyword">new</span> DogServiceImpl();</span><br><span class="line">        AnimalService lionService = <span class="keyword">new</span> LionServiceImpl();</span><br><span class="line">      <span class="comment">// 设置服务提供的端口</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">8891</span>);</span><br><span class="line">      <span class="comment">// 设置rmi的host为127.0.0.1，否则可能会出现connect refused错误</span></span><br><span class="line">        System.setProperty(<span class="string">"java.rmi.server.host"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">      <span class="comment">// 发布服务</span></span><br><span class="line">        Naming.bind(<span class="string">"rmi://127.0.0.1:8891/dogs"</span>, dogService);</span><br><span class="line">        System.out.println(<span class="string">"dog service publish success!"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端（rmi-client：引用rmi-api）</li></ul><ol><li><p>正常情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnimalService dogService = (AnimalService) Naming.lookup(<span class="string">"rmi://127.0.0.1:8891/dogs"</span>);</span><br><span class="line">dogService.laugh();</span><br></pre></td></tr></table></figure></li><li><p>反射的方式去回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = Naming.lookup(<span class="string">"rmi://127.0.0.1:8891/dogs"</span>);</span><br><span class="line">Method method = obj.getClass().getMethod(<span class="string">"laugh"</span>);</span><br><span class="line">method.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;rmi是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rmi是什么&quot;&gt;&lt;/a&gt; RMI是什么&lt;/h2&gt;
&lt;p&gt;RMI(Remote Method Invocation)意为远程方式调用，顾名思义，是Java版的RPC实现技术，是建
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>设置生成CGLib和JDK代理生成的class文件</title>
    <link href="http://luxiaowan.github.io/2020/03/17/%E8%AE%BE%E7%BD%AE%E7%94%9F%E6%88%90CGLib%E5%92%8CJDK%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6/"/>
    <id>http://luxiaowan.github.io/2020/03/17/设置生成CGLib和JDK代理生成的class文件/</id>
    <published>2020-03-17T13:20:00.000Z</published>
    <updated>2020-03-17T13:54:16.360Z</updated>
    
    <content type="html"><![CDATA[<p>jdk和cglib代理方式属于是老生常谈了，这里就不说了，我们说一下特别的。</p><p>我们都知道cglib是针对于类，jdk是针对于接口，</p><p>cglib在目标类被代理后会自动生成目标类的子类，也就是<code>xxxclass$$EnhancerByCGLIB$$c03f68c4.class</code></p><p>jdk代理后会自动生成目标接口的实现，也就是<code>$Proxy0.class</code></p><p>我们平时代码在编译过程中是不会生成代理类的class文件，只有在运行中才会生成</p><p>我们可以通过在启动类中设置代理类生成路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置CGLib代理类的生成位置</span></span><br><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"./cg"</span>);</span><br><span class="line"><span class="comment">// 设置JDK代理类的输出</span></span><br><span class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jdk和cglib代理方式属于是老生常谈了，这里就不说了，我们说一下特别的。&lt;/p&gt;
&lt;p&gt;我们都知道cglib是针对于类，jdk是针对于接口，&lt;/p&gt;
&lt;p&gt;cglib在目标类被代理后会自动生成目标类的子类，也就是&lt;code&gt;xxxclass$$EnhancerByCGL
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux更换yum源</title>
    <link href="http://luxiaowan.github.io/2020/03/12/Centos%E6%9B%B4%E6%8D%A2yum%E6%BA%90/"/>
    <id>http://luxiaowan.github.io/2020/03/12/Centos更换yum源/</id>
    <published>2020-03-12T05:05:00.000Z</published>
    <updated>2020-03-12T13:35:37.430Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们安装的Linux虚拟机或购买的云服务器上默认使用的yum源在国内有时候会传输很慢，现在大多我们在使用Linux之前都会修改一下yum源，以下以centos为例，将yum源修改为阿里云的。可以到https://developer.aliyun.com/mirror/中查看帮助</p></blockquote><h4 id="备份机器中的源文件"><a class="markdownIt-Anchor" href="#备份机器中的源文件"></a> 备份机器中的源文件</h4><p>备份的目的是为了操作失败后可以随时回滚</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure><h4 id="下载新的-centos-baserepo-到-etcyumreposd"><a class="markdownIt-Anchor" href="#下载新的-centos-baserepo-到-etcyumreposd"></a> 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</h4><p>我们的yum源配置文件在/etc/yum.repos.d/目录中，所以我们将阿里云的repo文件下载到该目录下（可以根据系统版本到http://mirrors.aliyun.com/repo/查看对应的文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要下载与系统版本一致的repo文件</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><h4 id="运行yum-makecache生成缓存"><a class="markdownIt-Anchor" href="#运行yum-makecache生成缓存"></a> 运行yum makecache生成缓存</h4><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>若出现Couldn’t resolve host '<a href="http://mirrors.cloud.aliyuncs.com" target="_blank" rel="noopener">mirrors.cloud.aliyuncs.com</a>’的信息，则表示网络不通，可以使用下面命令修改repo文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们安装的Linux虚拟机或购买的云服务器上默认使用的yum源在国内有时候会传输很慢，现在大多我们在使用Linux之前都会修改一下yum源，以下以centos为例，将yum源修改为阿里云的。可以到https://developer.aliyun.c
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://luxiaowan.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>kubernates调整nodePort端口范围</title>
    <link href="http://luxiaowan.github.io/2020/03/11/kubernates%E8%B0%83%E6%95%B4nodePort%E7%AB%AF%E5%8F%A3%E8%8C%83%E5%9B%B4/"/>
    <id>http://luxiaowan.github.io/2020/03/11/kubernates调整nodePort端口范围/</id>
    <published>2020-03-11T08:02:00.000Z</published>
    <updated>2020-03-11T08:12:05.657Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，k8s 集群 nodePort 分配的端口范围为：30000-32767，如果我们指定的端口不在这个范围就会报错：</p><blockquote><p>Error: release kong failed: Service “xxx” is invalid: spec.ports[0].nodePort: Invalid value: 12306: provided port is not in the valid range. The range of valid ports is 30000-32767</p></blockquote><p>所以我们修改 /etc/kubernetes/manifests/kube-apiserver.yaml 文件，在 command 下添加 <code>--service-node-port-range=1-65535</code> 参数，添加 nodePort 范围参数后会自动生效，无需进行其他操作：<br><code>vim /etc/kubernetes/manifests/kube-apiserver.yaml</code></p><p><img src="/images/image-20200311160941739.png" alt="image-20200311160941739"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默认情况下，k8s 集群 nodePort 分配的端口范围为：30000-32767，如果我们指定的端口不在这个范围就会报错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Error: release kong failed: Service “xxx” is invalid:
      
    
    </summary>
    
    
      <category term="kubernates" scheme="http://luxiaowan.github.io/categories/kubernates/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos7.7安装kubernates集群</title>
    <link href="http://luxiaowan.github.io/2020/03/11/Centos7.7%E5%AE%89%E8%A3%85kubernates%E9%9B%86%E7%BE%A4/"/>
    <id>http://luxiaowan.github.io/2020/03/11/Centos7.7安装kubernates集群/</id>
    <published>2020-03-11T05:11:00.000Z</published>
    <updated>2020-03-11T06:52:52.764Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h4><p>本文主要讲解使用kubeadm搭建高可用的集群，这种方式是最简单最快的。</p><h4 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h4><p>我们安装k8s的机器资源条件如下：</p><ul><li>centos7.7</li><li>内存不低于2G，CPU不少于2核，否则在安装的时候会报错</li><li>集群中的所有机器都要保证网络连通性</li><li>相关端口开放</li><li>swap关闭</li></ul><ol><li><p>更新系统</p><p>在开始安装服务之前，我们先更新一下yum源，然后安装相关的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装git(可选)</span></span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure></li><li><p>禁用swap分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭swap分区，该命令只是临时关闭，机器重启后还会自动打开</span></span><br><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久性关闭swap分区，禁止机器重启后自动打开</span></span><br><span class="line">sed -i '/ swap / s/^/#/' /etc/fstab</span><br></pre></td></tr></table></figure></li><li><p>更换yum源为国内镜像</p><p>centos的yum源默认为国外的，如果你的服务器是在国内，那么可能访问不了，所以我们需要把yum的源更换为国内的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里有一个注意点，就是下面的Centos-7.repo，这里因为我们使用的centos7，如果你的系统是centos8，那么就改成Centos-8.repo，也就是改成相对应的版本，否则yum安装不了软件</span></span><br><span class="line">cd /etc/yum.repos.d  &amp;&amp; \</span><br><span class="line">sudo mv CentOS-Base.repo CentOS-Base.repo.bak &amp;&amp; \</span><br><span class="line">sudo wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo &amp;&amp; \</span><br><span class="line">yum clean all &amp;&amp; \</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></li><li><p>安装docker环境</p><p>k8s内部可以支持多种容器，我们最常使用的就是docker，所以我们这里也以docker为基础</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装docker依赖包</span></span><br><span class="line">yum install yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加docker库</span></span><br><span class="line">yum-config-manager --add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新源</span></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装docker</span></span><br><span class="line">yum install containerd.io-1.2.10 \</span><br><span class="line">  docker-ce-19.03.4 \</span><br><span class="line">  docker-ce-cli-19.03.4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置docker daemon</span></span><br><span class="line">mkdir /etc/docker</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  "exec-opts": ["native.cgroupdriver=systemd"],</span><br><span class="line">  "log-driver": "json-file",</span><br><span class="line">  "log-opts": &#123;</span><br><span class="line">    "max-size": "100m"</span><br><span class="line">  &#125;,</span><br><span class="line">  "storage-driver": "overlay2",</span><br><span class="line">  "storage-opts": [</span><br><span class="line">    "overlay2.override_kernel_check=true"</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建docker.service.d</span></span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用docker.service</span></span><br><span class="line">systemctl enable docker.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载&amp;重启docker</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>安装完之后使用docker -v查看版本</p></li><li><p>更换docker为国内源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置</span></span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">"registry-mirrors": ["https://registry.docker-cn.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker</span></span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure></li><li><p>安装kubeadm、kubelet、和kubectl</p><blockquote><p>kubeadm 负责引导集群，kubelet 在集群的所有节点运行，负责启动 pods 和 containers，kubectl 则负责与集群交互，我们需要在所有节点安装这些组件</p></blockquote><ol><li><p>配置k8s国内源</p><p>我们把k8s的源修改为阿里云的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置国内源</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>关闭SELinux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config</span><br></pre></td></tr></table></figure></li><li><p>配置网络参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl --system</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保 br_netfilter 模块已经加载</span></span><br><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure></li><li><p>安装并启动kubeadm、kubelet、和kubectl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">systemctl enable --now kubelet</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用kubeadm初始化集群</p><blockquote><p>因为我的服务器在国内，且由于 kubeadm 初始化集群的依赖镜像在国内访问不了，所以初始化集群之前先使用国内源拉取依赖镜像</p></blockquote><ol><li><p>拉取依赖镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取依赖镜像列表</span></span><br><span class="line">kubeadm config images list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用阿里源下载 K8s 依赖镜像</span></span><br><span class="line">kubeadm config images list |sed -e 's/^/docker pull /g' -e 's#k8s.gcr.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g' |sh -x</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过docker tag修改镜像与国外镜像名称相同，这样的目的是在初始化的时候，docker会先在本地查找，若本地已有镜像则不会再去远程拉取，等于来了一招瞒天过海</span></span><br><span class="line">docker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk '&#123;print "docker tag ",$1":"$2,$1":"$2&#125;' |sed -e 's#registry.cn-hangzhou.aliyuncs.com/google_containers#k8s.gcr.io#2' |sh -x</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除原镜像，这个可选</span></span><br><span class="line">docker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk '&#123;print "docker rmi ", $1":"$2&#125;' |sh -x</span><br></pre></td></tr></table></figure></li><li><p>master节点初始化</p><p>我们使用kubeadm init指令初始化master节点，具体的参数可参考官方文档：<a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> local_ip是本机局域网ip，kubectl_version是我们镜像的版本</span></span><br><span class="line">kubeadm init --apiserver-advertise-address=&lt;local_ip&gt; --kubernetes-version=&lt;kubectl_version&gt; --pod-network-cidr=10.244.0.0/16 --v=5</span><br></pre></td></tr></table></figure><p>执行成功之后，日志会打印出下面语句，并且会告知我们节点加入的方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root或非root用户均可执行</span></span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure></li><li><p>开启使用master节点资源</p><p>默认master节点是不参与pod调度的，这样对于master节点的资源来说有点太过浪费，所以我们通过下面的命令使master节点也参与pod调度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure></li></ol></li><li><p>添加网络组件</p><p>我们通过kubectl get nodes查看集群内的节点，当前应该只有master一个节点，但是节点的状态为NotReady，查看coredns的pod（kubectl get pod --all-namespaces），会发现coredns处于pending状态，原因就是我们还未安装网络组件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网络组件我们选择WeaveNet，安装完之后稍等一会就可以了</span></span><br><span class="line">kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"</span><br></pre></td></tr></table></figure></li><li><p>向集群中添加node节点</p><p>每一台node都需要操作从1~6的步骤，然后我们使用kubeadm join来添加到集群中，这里的token是在master节点创建的，我们可以使用<code>kubeadm token list</code>命令查看可用的token，如果没有可用的token，那么我们使用<code>kubeadm token create</code>创建新的token，一个token的有效期为24小时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.0.54:6443 --token 9dmyq2.c50cvh32r62o6jlx \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4640dd5d3788968d86ce3cb792c1e368586ee6731de5a07ad8ad331926a2f233</span><br></pre></td></tr></table></figure></li><li><p>验证</p><p>加入之后我们在master节点通过<code>kubectl get nodes</code>来查看所有的节点，验证是否加入成功。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础&quot;&gt;&lt;/a&gt; 基础&lt;/h4&gt;
&lt;p&gt;本文主要讲解使用kubeadm搭建高可用的集群，这种方式是最简单最快的。&lt;/p&gt;
&lt;h4 id=&quot;安装步骤&quot;&gt;&lt;a class=&quot;markdow
      
    
    </summary>
    
    
      <category term="kubernates" scheme="http://luxiaowan.github.io/categories/kubernates/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos中安装rz和sz替代ftp</title>
    <link href="http://luxiaowan.github.io/2020/03/10/Centos%E4%B8%AD%E5%AE%89%E8%A3%85rz%E5%92%8Csz%E6%9B%BF%E4%BB%A3ftp/"/>
    <id>http://luxiaowan.github.io/2020/03/10/Centos中安装rz和sz替代ftp/</id>
    <published>2020-03-10T04:44:00.000Z</published>
    <updated>2020-03-10T04:47:26.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>lrzsz 官网入口：<a href="http://freecode.com/projects/lrzsz/" target="_blank" rel="noopener">http://freecode.com/projects/lrzsz/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装lrzsz</span></span><br><span class="line">yum install -y lrzsz</span><br></pre></td></tr></table></figure><p>安装完成之后就可以直接使用了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上传文件</span></span><br><span class="line">rz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载文件</span></span><br><span class="line">sz</span><br></pre></td></tr></table></figure><p>操作很简单</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;lrzsz 官网入口：&lt;a href=&quot;http://freecode.com/projects/lrzsz/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://freecode.com/projects/lrzsz/&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://luxiaowan.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s中YAML文件解释</title>
    <link href="http://luxiaowan.github.io/2020/03/10/k8s%E4%B8%ADYAML%E6%96%87%E4%BB%B6%E8%A7%A3%E9%87%8A/"/>
    <id>http://luxiaowan.github.io/2020/03/10/k8s中YAML文件解释/</id>
    <published>2020-03-09T16:30:00.000Z</published>
    <updated>2020-03-09T16:34:54.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="yaml语法规则"><a class="markdownIt-Anchor" href="#yaml语法规则"></a> YAML语法规则</h4><blockquote><p>大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tal键，只允许使用空格 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 ”#” 表示注释，从这个字符一直到行尾，都会被解析器忽略</p><p>在Kubernetes中，只需要知道两种结构类型即可： Lists Maps</p></blockquote><p>####YAML属性解释</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yaml格式的pod定义文件完整内容：</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>       <span class="comment">#必选，版本号，例如v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       <span class="comment">#必选，Pod</span></span><br><span class="line"><span class="attr">metadata:</span>       <span class="comment">#必选，元数据</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">string</span>       <span class="comment">#必选，Pod名称</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">string</span>    <span class="comment">#必选，Pod所属的命名空间</span></span><br><span class="line"><span class="attr">  labels:</span>      <span class="comment">#自定义标签</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>     <span class="comment">#自定义标签名字</span></span><br><span class="line"><span class="attr">  annotations:</span>       <span class="comment">#自定义注释列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span>         <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line"><span class="attr">  containers:</span>      <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span>     <span class="comment">#必选，容器名称</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">string</span>    <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">[Always</span> <span class="string">| Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像</span></span><br><span class="line"><span class="string"></span><span class="attr">    command:</span> <span class="string">[string]</span>    <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line"><span class="attr">    args:</span> <span class="string">[string]</span>     <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line"><span class="attr">    workingDir:</span> <span class="string">string</span>     <span class="comment">#容器的工作目录</span></span><br><span class="line"><span class="attr">    volumeMounts:</span>    <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>     <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">string</span>    <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="string">boolean</span>    <span class="comment">#是否为只读模式</span></span><br><span class="line"><span class="attr">    ports:</span>       <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>     <span class="comment">#端口号名称</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="string">int</span>   <span class="comment">#容器需要监听的端口号</span></span><br><span class="line"><span class="attr">      hostPort:</span> <span class="string">int</span>    <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">string</span>     <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line"><span class="attr">    env:</span>       <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>     <span class="comment">#环境变量名称</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">string</span>    <span class="comment">#环境变量的值</span></span><br><span class="line"><span class="attr">    resources:</span>       <span class="comment">#资源限制和请求的设置</span></span><br><span class="line"><span class="attr">      limits:</span>      <span class="comment">#资源限制的设置</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">string</span>     <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line"><span class="attr">      requests:</span>      <span class="comment">#资源请求的设置</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">string</span>     <span class="comment">#内存清楚，容器启动的初始可用数量</span></span><br><span class="line"><span class="attr">    livenessProbe:</span>     <span class="comment">#对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class="line"><span class="attr">      exec:</span>      <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">[string]</span>  <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line"><span class="attr">      httpGet:</span>       <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">        port:</span> <span class="string">number</span></span><br><span class="line"><span class="attr">        host:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">        scheme:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">        HttpHeaders:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">      tcpSocket:</span>     <span class="comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class="line"><span class="attr">         port:</span> <span class="string">number</span></span><br><span class="line"><span class="attr">       initialDelaySeconds:</span> <span class="number">0</span>  <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line"><span class="attr">       timeoutSeconds:</span> <span class="number">0</span>   <span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class="line"><span class="attr">       periodSeconds:</span> <span class="number">0</span>    <span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class="line"><span class="attr">       successThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">       failureThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">       securityContext:</span></span><br><span class="line"><span class="attr">         privileged:</span><span class="literal">false</span></span><br><span class="line"><span class="attr">    restartPolicy:</span> <span class="string">[Always</span> <span class="string">| Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span></span><br><span class="line"><span class="string"></span><span class="attr">    nodeSelector:</span> <span class="string">obeject</span>  <span class="comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span></span><br><span class="line"><span class="attr">    imagePullSecrets:</span>    <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">    hostNetwork:</span><span class="literal">false</span>      <span class="comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class="line"><span class="attr">    volumes:</span>       <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>     <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line"><span class="attr">      emptyDir:</span> <span class="string">&#123;&#125;</span>     <span class="comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class="line"><span class="attr">      hostPath:</span> <span class="string">string</span>     <span class="comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">string</span>     <span class="comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class="line"><span class="attr">      secret:</span>      <span class="comment">#类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span></span><br><span class="line"><span class="attr">        scretname:</span> <span class="string">string</span>  </span><br><span class="line"><span class="attr">        items:</span>     </span><br><span class="line"><span class="attr">        - key:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">      configMap:</span>     <span class="comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">        items:</span></span><br><span class="line"><span class="attr">        - key:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;yaml语法规则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#yaml语法规则&quot;&gt;&lt;/a&gt; YAML语法规则&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tal键，只允许使用空格 缩进的
      
    
    </summary>
    
    
      <category term="kubernates" scheme="http://luxiaowan.github.io/categories/kubernates/"/>
    
    
  </entry>
  
  <entry>
    <title>Git修改已提交用户信息</title>
    <link href="http://luxiaowan.github.io/2020/02/11/Git%E4%BF%AE%E6%94%B9%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    <id>http://luxiaowan.github.io/2020/02/11/Git修改已提交用户信息/</id>
    <published>2020-02-11T08:46:00.000Z</published>
    <updated>2020-02-11T10:03:16.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修改git用户名和邮箱"><a class="markdownIt-Anchor" href="#修改git用户名和邮箱"></a> 修改Git用户名和邮箱</h3><ol><li>修改某一项目配置</li></ol><p>终端进入到项目所在目录下，执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config user.name "cc"</span><br><span class="line"></span><br><span class="line">git config user.email "cc@cc.cc"</span><br></pre></td></tr></table></figure><ol start="2"><li>修改全局配置</li></ol><p>打开终端，执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "cc"</span><br><span class="line"></span><br><span class="line">git config --global user.email "cc@cc.cc"</span><br></pre></td></tr></table></figure><h3 id="修改项目最近一次提交信息"><a class="markdownIt-Anchor" href="#修改项目最近一次提交信息"></a> 修改项目最近一次提交信息</h3><ol><li>修改提交用户</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author="username &lt;email&gt;"</span><br></pre></td></tr></table></figure><ol start="2"><li>修改提交备注信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>然后执行之后跳转到新的页面</p><p><img src="/images/image-20200211171804477.png" alt="image-20200211171804477"></p><p>修改顶部备注信息然后保存即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;修改git用户名和邮箱&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#修改git用户名和邮箱&quot;&gt;&lt;/a&gt; 修改Git用户名和邮箱&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;修改某一项目配置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;终端进入到项目所在目录下，执行以
      
    
    </summary>
    
    
      <category term="Git" scheme="http://luxiaowan.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux禁止root用户远程登录</title>
    <link href="http://luxiaowan.github.io/2020/02/11/Linux%E7%A6%81%E6%AD%A2root%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
    <id>http://luxiaowan.github.io/2020/02/11/Linux禁止root用户远程登录/</id>
    <published>2020-02-11T03:35:00.000Z</published>
    <updated>2020-02-11T05:05:54.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="添加一个新用户"><a class="markdownIt-Anchor" href="#添加一个新用户"></a> 添加一个新用户</h3><ol><li><p>添加新用户</p><p>useradd cc</p></li><li><p>设置新用户密码</p><p>passwd cc</p></li></ol><h3 id="修改etcsudoers文件"><a class="markdownIt-Anchor" href="#修改etcsudoers文件"></a> 修改/etc/sudoers文件</h3><p>找到## Allow root to run any commands anywhere</p><p>在<code>root ALL=(ALL) ALL</code>下方添加语句<code>cc ALL=(ALL) ALL</code></p><p><img src="/images/image-20200211113749629.png" alt="image-20200211113749629"></p><blockquote><p>此文件为readonly文件，保存使用<code>wq!</code>命令</p></blockquote><h3 id="修改etcsshsshd_config文件"><a class="markdownIt-Anchor" href="#修改etcsshsshd_config文件"></a> 修改/etc/ssh/sshd_config文件</h3><p>找到<code>PermitRootLogin yes</code>修改为<code>PermitRootLogin no</code></p><p>保存之后执行<code>service sshd restart</code>命令即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;添加一个新用户&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#添加一个新用户&quot;&gt;&lt;/a&gt; 添加一个新用户&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加新用户&lt;/p&gt;
&lt;p&gt;useradd cc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置新用户
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://luxiaowan.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>MacBook连接iPhone不稳定</title>
    <link href="http://luxiaowan.github.io/2020/02/11/MacBook%E8%BF%9E%E6%8E%A5iPhone%E4%B8%8D%E7%A8%B3%E5%AE%9A/"/>
    <id>http://luxiaowan.github.io/2020/02/11/MacBook连接iPhone不稳定/</id>
    <published>2020-02-11T01:32:00.000Z</published>
    <updated>2020-02-11T01:34:27.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p>MacBook经常在使用USB连接iPhone的时候不稳定，连接一跳一跳的</p><h1 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h1><p>在电脑终端下运行<code>sudo killall -STOP -c usbd</code>，然后输入电脑密码，然后重新插上连接线，就OK了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题&quot;&gt;&lt;/a&gt; 问题&lt;/h1&gt;
&lt;p&gt;MacBook经常在使用USB连接iPhone的时候不稳定，连接一跳一跳的&lt;/p&gt;
&lt;h1 id=&quot;解决&quot;&gt;&lt;a class=&quot;markdown
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>头条、美团、滴滴、京东等大厂面试题</title>
    <link href="http://luxiaowan.github.io/2019/12/25/%E5%88%B7%E9%A2%98/"/>
    <id>http://luxiaowan.github.io/2019/12/25/刷题/</id>
    <published>2019-12-24T16:35:00.000Z</published>
    <updated>2019-12-24T16:36:27.409Z</updated>
    
    <content type="html"><![CDATA[<h4 id="头条"><a class="markdownIt-Anchor" href="#头条"></a> 头条</h4><ol><li><p>聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。</p></li><li><p>讲项目中的难点、挑战，你是如何解决的？</p></li><li><p>Redis 中有几种类型 &amp; 各自底层怎么实现的 &amp; 项目中哪个地方用了什么类型，怎么使用的？</p></li><li><p>Redis如何实现分布式锁，zk如何实现分布式锁，两者的区别。如果service还没执行完，分布式锁在Redis中已经过期了，怎么解决这种问题？</p></li><li><p>synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁。</p></li><li><p>锁升级的过程。</p></li><li><p>Java运行时区域及各个区域的作用、对GC的了解、Java内存模型及为什么要这么设计？</p></li><li><p>对索引的理解，组合索引，索引的最佳实践</p></li><li><p>countDownLatch用过没有，在项目中如何使用的，对AQS的了解。</p></li><li><p>写生产者消费者问题，考虑高并发的情况，可以使用Java 类库，白纸写代码。</p></li><li><p>设计一个发号器，考虑集群和高并发的情况，要求发号器生成的id是递增趋势，通过id可以区分出来是今天生成的id还是昨天生成的id，但是生成的id中不能直接带有日期，要具有一定的混淆功能，白纸写代码。</p></li><li><p>一个二位数组，每个元素都可以往上下左右四个方向走，寻找最长递增路径。如下图所示，最长递增路径即红色字体路径。白纸写代码。</p><p>![image-20190924230411189](/Users/chuan/Library/Application Support/typora-user-images/image-20190924230411189.png)</p></li></ol><h4 id="美团"><a class="markdownIt-Anchor" href="#美团"></a> 美团</h4><ol><li><p>数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？</p></li><li><p>聚簇索引/非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p></li><li><p>MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？</p></li><li><p>MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁</p></li><li><p>谈下对GC的了解，何为垃圾，有哪些GC算法，有哪些垃圾回收器，cms和g1的区别，还有一个直击灵魂的问题，看过cms的源码吗？</p></li><li><p>有没有排查过线上OOM的问题，如何排查的？</p></li><li><p>有没有使用过JVM自带的工具，如何使用的？</p></li><li><p>假设有下图所示的一个Full GC 的图，纵向是内存使用情况，横向是时间，你如何排查这个Full GC 的问题，怎么去解决你说出来的这些问题？</p><p>![image-20190924230348754](/Users/chuan/Library/Application Support/typora-user-images/image-20190924230348754.png)</p></li><li><p>说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的？</p></li><li><p>对CAS的理解，CAS带来的问题，如何解决这些问题？</p></li><li><p>volatile底层、synchronized底层、锁升级的过程、MESI</p></li><li><p>Ehcache支持哪些缓存？</p></li><li><p>JUC有研究没有，讲一讲？</p></li><li><p>聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。</p></li><li><p>讲项目中的难点、挑战，如何解决的，项目这一块会问的特别细。</p></li><li><p>如何保证RocketMQ 消息的顺序性，如何解决重复消费问题。</p></li><li><p>项目中如何保证接口的幂等操作。</p></li><li><p>讲一讲对Redis 的了解，项目中如何使用的，哪个地方使用的，为什么要使用？</p></li><li><p>哨兵机制、Redis 两种备份方式的区别，项目中用的哪种，为什么？</p></li><li><p>讲一讲对分布式锁的了解</p></li><li><p>项目中系统监控怎么做的？</p></li><li><p>如何理解Spring中的AOP 和 IOC，以及DI，读过Spring源码没有？</p></li><li><p>读过MyBatis源码没有？</p></li><li><p>说一个你了解最多的框架，说出你的理解。</p></li><li><p>如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？</p></li><li><p>聊一聊对分库分表的理解。</p></li><li><p>Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启/关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？</p></li><li><p>Dubbo有了解没有？</p></li><li><p>怎么理解Java 中和 MySQL中的乐观锁、悲观锁？</p></li><li><p>一致性hash</p></li></ol><h4 id="滴滴"><a class="markdownIt-Anchor" href="#滴滴"></a> 滴滴</h4><ol><li>聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图，讲数据库设计。</li><li>处理过线上OOM问题没有，如何处理的？</li><li>遇到过线上服务器CPU飙高的情况没有，如何处理的？</li><li>线上有没有遇到其他问题，如何处理的？</li><li>对线程池的理解，项目中哪个地方使用了，如何使用的，用的Excutor框架中的哪个实现类，为什么用这个</li><li>对CAS的理解，CAS带来的问题，如何解决这些问题?</li><li>volatile底层、synchronized底层、锁升级的过程、MESI</li><li>对MySQL索引的理解、对组合索引的理解、索引的最佳实践</li><li>分布式锁的实现、对比Redis分布式锁 &amp; ZK分布式锁</li><li>唯一ID如何实现的，Snowflake实现原理，Snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量</li><li>如果线上一个功能是用栈结构实现的，使用过程中要注意哪些问题，为什么？</li><li>怎么理解线程安全？</li><li>怎么理解接口幂等？项目中如何保证的接口幂等？</li><li>怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？</li><li>如何理解网关，网关带来的好处和坏处，如何解决</li><li>Hystrix功能  &amp; 在项目中怎么使用的 &amp; Hystrix怎么检测断路器是否要开启/关闭 &amp;Hystrix实现原理</li><li>怎么理解命令模式和观察者模式，手写一个观察者模式或者命令模式的代码，策略模式也行</li><li>掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式</li><li>如何设计一个秒杀系统？</li><li>如果我现在就是要实现每秒10w请求，不能熔断限流，如何去设计？</li><li>假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？</li><li>服务A调用服务B中一个接口，服务B调用服务C中一个接口，如何实现若服务B响应服务A成功，则服务C一定响应服务B成功，需要考虑系统性能问题？</li><li>递归使用中有什么需要注意的地方，递归写法一般可以用什么去替换？</li><li>有两个表，table a，table b，写SQL查询出仅在table a中的数据、仅在table b中的数据、既在table a 又在table b 中的数据？</li><li>Spring 源码有了解没有？</li><li>MyBatis源码有了解没有？</li><li>MySQL事务隔离级别、MVCC？</li></ol><h4 id="京东"><a class="markdownIt-Anchor" href="#京东"></a> 京东</h4><ol><li>一个final修饰的属性，定义的时候没有初始化，在无参构造函数中初始化，可以吗，为什么</li><li>说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的，为什么不用其他的集合类</li><li>HashMap，concurrentHashMap底层实现</li><li>List删除是怎么实现的，遍历的时候可以删除吗？为什么?</li><li>Redis中有哪些数据结构，了解过其底层怎么实现的吗，和Java中相似的数据结构的对比？</li><li>Redis是单线程的还是多线程的，为什么这么快？</li><li>Redis Hash中某个key过大，变为String类型的大key，怎么处理，使用中如何避免出现这种问题?</li><li>设计模式在项目中哪个地方用到了，怎么使用的，能不能画一个你熟悉的设计模式的UML图，手写单例模式，手写静态内部类实现的单例模式。</li><li>讲一讲MySQL索引，实际工作中，哪些场景用了B+Tree索引，哪些场景用了hash索引？</li><li>explain 可以看到哪些信息，什么信息说明什么，explain的结果列讲一下</li><li>Spring源码看过没有，会多少讲多少？</li><li>MyBatis源码看过没有，会多少讲多少？</li><li>CAS的缺点，如何解决？</li><li>AQS、countDownLatch如何实现？</li><li>线程池如何实现，核心线程数和最大线程数设置成多少，为什么这么设置，项目中哪个地方使用了线程池，使用时需要注意什么</li><li>MySQL事务隔离级别，幻读，脏读，项目中用什么事务隔离级别，为什么？</li><li>volatile底层原理、synchronized实现机制</li><li>对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？</li><li>Feign 和 Dubbo，了解多少说多少？</li><li>Eureka 和 Zookeeper，了解多少说多少？</li><li>Hystrix 和 sentinel，了解多少说多少？</li><li>Spring Cloud Alibaba，了解多少说多少？</li><li>对分库分表、读写分离的了解，了解多少说多少？</li><li>画一下Java 线程几个状态及状态之间互相转换的图？</li><li>聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图，讲数据库设计具体到部分表中有哪些字段？</li><li>部门体量比较大，可能需要加班，到凌晨两三点的那种，也可能通宵，通宵是大促期间，你能接受吗？</li><li>也会加班到十点，这个不是大促期间，但也不是每天，非常态情况，你能接受吗，你在哪里住，过来要多久，有男朋友吗？</li></ol><h4 id="火币"><a class="markdownIt-Anchor" href="#火币"></a> 火币</h4><ol><li>Kafka 如何保证消息顺序消费、在consumer group 中新增一个consumer  会提高消费消息的速度吗、那如果我想提高消息消费的速度，我要怎么办？</li><li>Redis几种数据结构及底层，项目中如何使用的Redis？</li><li>哨兵机制、选举算法</li><li>一致性hash</li><li>Redis是单线程的还是多线程的，为什么速度这么快？</li><li>多路复用的几种方式以及区别？</li><li>对线程池的理解，在项目中如何使用的，多个线程之间如何共享数据，多个进程之间如何共享数据？</li><li>HashMap、concurrentHashMap的区别及底层实现、HashMap和HashTable 的区别？</li><li>什么是红黑树，什么是B-Tree，为什么HashMap中用红黑树不用其他树？</li><li>对MySQL索引的理解，为什么MySQL索引中用B+Tree，不用B-Tree 或者其他树，为什么不用hash 索引？</li><li>数据库和缓存的双写一致性问题？</li></ol><h4 id="每日一淘"><a class="markdownIt-Anchor" href="#每日一淘"></a> 每日一淘</h4><ol><li>用过哪些Object类的方法，如何使用的</li><li>Java如何实现序列化的，Serialization底层如何实现的</li><li>countDownLatch如何实现的</li><li>项目中监控报警机制如何做的，说说你的了解</li><li>线上服务器CPU飙高，如何处理这个问题</li><li>服务A调用服务B，用户请求服务A，发现返回较慢，如何定位这个问题</li><li>TIME_WAIT是什么状态还记得吗，什么情况下网络会出现这个状态</li></ol><h4 id="linkedme"><a class="markdownIt-Anchor" href="#linkedme"></a> linkedme</h4><ol><li>内核态和用户态、cas 和 sout 哪个用到了内核态和用户态的切换</li><li>哪些典型的应用用的是UDP？</li><li>线程池有了解吗，项目中如何使用的？</li><li>计算密集型/IO密集型任务分别如何设置线程池的核心线程数和最大线程数，为什么这么设置？</li><li>假如我下午5点要和5个人一起开会，但是这5个人现在都出去了，不在公司，但是今天会回来，问，我如何开这场会，用Java 并发方面的知识回答。</li></ol><h4 id="算法题"><a class="markdownIt-Anchor" href="#算法题"></a> 算法题</h4><ol><li><p>[1,1,2,2,3,4,4,5,5,5]  找出不重复的元素（黄包车）</p></li><li><p>反转链表，要求时间复杂度O(N)，空间复杂度O(1)  （火币）</p></li><li><p>非递归实现斐波那契数列 （爱奇艺）</p></li><li><p>这一周股市价格为[2,6,1,4,8]，求哪一天买入哪一天卖出，可获得最大收益，最大收益为多少 （爱奇艺）</p></li><li><p>按照箭头方向查找二叉树 （金山云）</p><p>![image-20190924230728819](/Users/chuan/Library/Application Support/typora-user-images/image-20190924230728819.png)</p></li><li><p>表a b c之间用ID关联，求阴影部分的数据  （金山云）</p><p>![image-20190924230750484](/Users/chuan/Library/Application Support/typora-user-images/image-20190924230750484.png)</p></li><li><p>一个整形无序数组，里面三个数只和等于一个目标值，求这三个数  （小米）</p></li><li><p>链表问题  （小米）</p><p>![image-20190924230830166](/Users/chuan/Library/Application Support/typora-user-images/image-20190924230830166.png)</p></li><li><p>扑克牌问题  （小米）<br>有十张扑克牌，从上面开始抽，抽出一张放桌子上，然后再抽出一张放扑克牌的最下面，这样循环往复的操作，直到手里的牌都没有了。这时，桌子上牌的顺序正好是1 2 3 4 5 6 7 8 9 10。要求写代码求出原顺序</p></li><li><p>手写大顶堆 （linkedMe）</p></li><li><p>手写LRU 算法 （火币）</p></li><li><p>字符串相加  （滴滴）<br>两个数字类型的字符串，直接转int或者double肯定都放不下，然后求这两个数的和，返回值还是字符串，15分钟时间，要求无Bug</p></li><li><p>寻找目标值位置  （滴滴）<br>有一个二维数组，数组横向有序，纵向有序，求目标值的位置，10分钟时间</p></li><li><p>求字符串“efabcbaefehiabcba”中最长的回文数，不去重（美团）</p></li><li><p>反转int类型的值x，不要借用String，只用int 即可。&amp;&amp; 针对该程序，写出其应有的测试用例 （美团）</p></li><li><p>top K 问题（每日一淘）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;头条&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#头条&quot;&gt;&lt;/a&gt; 头条&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="面试" scheme="http://luxiaowan.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>工程师和程序员的区别</title>
    <link href="http://luxiaowan.github.io/2019/12/21/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://luxiaowan.github.io/2019/12/21/工程师和程序员的区别/</id>
    <published>2019-12-20T17:03:00.000Z</published>
    <updated>2019-12-20T17:03:48.136Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开一个杂谈的类目，探讨平时工作中遇到的趣事，可能偶尔也会转载一些其他地方看到的有意思的行业趣事，纯属一乐。</p></blockquote><h4 id="开端"><a class="markdownIt-Anchor" href="#开端"></a> 开端</h4><p>今天下班后，公司里一个工作多年的小朋友找我闲聊，然后聊着聊着不知为啥聊到了行业上：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">小朋友：串串，你为什么不愿意带团队？</span><br><span class="line">串  串：不感兴趣！</span><br><span class="line">小朋友：你打算敲代码到<span class="number">35</span>岁吗😅</span><br><span class="line">串  串：<span class="number">40</span></span><br><span class="line">小朋友：就算技术上再牛逼，程序员在中国，到了四十也到头了吧</span><br><span class="line">串  串：工程师和程序员是两码事</span><br><span class="line">小朋友：本质区别在哪呢？你指有架构的能力吗？</span><br><span class="line">串  串：。。。。。。</span><br></pre></td></tr></table></figure><h4 id="我想说"><a class="markdownIt-Anchor" href="#我想说"></a> 我想说</h4><p>其实聊到这里，我突然发现很多做开发的同学对程序员和工程师这两个职业的认知好像并不是那么的分明，其实上面的对话还没有结束，我把工程师和程序员对等为进程和线程，做开发的同学应该都知道进程和线程的区别<code>(说不了解的回去把操作系统再细学一遍)</code>，为什么这么比喻呢<code>(其实这个比喻也不恰当，就是想把两者的区别扩大化一下，各位不要挑这个比喻啦，挑了我也不改)</code>，因为进程是由很多线程组成的，每一个线程都只处理进程中很小很小的一个模块，可能仅仅就是去把磁盘上的数据读到内存中而已，进程就像是一片森林，线程只是一棵树，我想表达的意思就是工程师所要掌握的知识技能，要比程序员多的多的多，也就是需要有大局观、知识广度、知识深度、行军线路等，而程序员是什么？<strong>你可以认为会写代码的都叫程序员，但只会写代码的程序员不能叫做工程师!!!</strong></p><h4 id="我还想说"><a class="markdownIt-Anchor" href="#我还想说"></a> 我还想说</h4><p>我们来看一下BOSS直聘上招聘程序员和工程师岗位JD的区别，这里可能要有图：</p><img src="/images/20711576856538.png" alt="Java高级程序员" style="zoom:25%;"><img src="/images/20721576856562.png" alt="20721576856562_.pic_hd" style="zoom:25%;">    <p>看到没，同样是高级岗位，但是岗位JD差别却很大，我们来分析一下区别：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java高级程序员：                            Java高级研发工程师：</span><br><span class="line">  无学历要求，会写代码就行                      最低科班出身</span><br><span class="line">  能用技术框架写代码，其他低要求                 业务、产品、研发均要擅长，自我驱动，技术攻坚，架构设计</span><br><span class="line">  强调技术要求，罗列一堆技术框架                 无技术框架要求，对软技能提到多次(代码洁癖、计算机原理、算法、行业经验、职责、质量、业务<span class="regexp">/产品/</span>设计<span class="regexp">/研发)</span></span><br></pre></td></tr></table></figure><p>我们从分析结果可以看出，一样的职级，一样的岗位，一样的技术，对程序员的要求是<strong>你会写代码就行</strong>，对工程师的要求是<strong>你不仅要会写代码，还要懂业务、产品、设计、产品和研发质量、数据结构和算法、计算机原理、软件工程学</strong>，现在是不是很清晰的知道了程序员和工程师的区别？</p><h4 id="我再说一下"><a class="markdownIt-Anchor" href="#我再说一下"></a> 我再说一下</h4><p>很多人会问：为什么国外的程序员到60岁还可以写代码，而中国的程序员35岁就要被淘汰？</p><p>其实行业淘汰的是程序员而不是工程师，一个有思想有眼界有能力的工程师是每一个公司都想聘用的，这一类人只会越老越吃香。</p><p>那么程序员为什么到35岁就会被淘汰呢？因为35岁还只是会写代码的人，身体已经被加班摧残的&quot;风烛残年&quot;了，每一年都会有一大批毕业生/培训生走入社会，他们身体健康、强壮、任劳任怨、爱加班，身为35岁的&quot;老年人&quot;，除了年龄大、发际线高、体重超标、脑子迟钝，还有哪一点比得过那么一群小鲜肉？哦~还有上有老下有小的山一般大的压力!!!</p><p>那么工程师为什么越老越吃香呢？因为工程师靠的不是写代码，靠的是自我沉淀和行业经验。</p><h4 id="总结下"><a class="markdownIt-Anchor" href="#总结下"></a> 总结下</h4><p>大家一开始都是从程序员做起的，为什么有的人可以成为工程师，有的人还是程序员呢？这就在于个人平时的积累了。</p><h4 id="玩"><a class="markdownIt-Anchor" href="#玩"></a> 玩</h4><p>最近一年面试了二十多个7、8年工作经验的人，很多人连最基本的技术知识和数据结构都不知道，记忆最深的就是有一个跟着7年的人跟我说：我会写代码，我能实现业务需求，不就行了么，我要知道那些原理干啥？</p><p>是不是又很多人也这么想的？这么想就对啦，等着30岁就被淘汰吧，35都不用等啦！</p><p><strong><font color="red">知道的越多，不知道的就越多</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开一个杂谈的类目，探讨平时工作中遇到的趣事，可能偶尔也会转载一些其他地方看到的有意思的行业趣事，纯属一乐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;开端&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#开端&quot;&gt;
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker安装phpmyadmin</title>
    <link href="http://luxiaowan.github.io/2019/12/20/Docker%E5%AE%89%E8%A3%85phpmyadmin/"/>
    <id>http://luxiaowan.github.io/2019/12/20/Docker安装phpmyadmin/</id>
    <published>2019-12-20T09:00:00.000Z</published>
    <updated>2019-12-20T15:07:26.882Z</updated>
    
    <content type="html"><![CDATA[<p>我们在云服务器上的MySQL数据库在暴露端口和开启远程连接的情况下，是非常不安全的，昨天我的一台服务器就遭到了勒索病毒的攻击，让我支付0.06比特币赎回我的数据。还好那个库中没有重要数据，只是一个弃用了半年的数据库，密码我自己都忘记了，还好通过手段找回了密码，登上去之后就傻眼了。那么如果我们不想开启远程登录还想操作数据库，怎么办？怎么办？用phpmyadmin就可以解决了，不过phpmyadmin也有一定的风险，下面看下怎么玩。</p><h3 id="使用docker发布phpmyadmin并且连接已经存在的mysql容器"><a class="markdownIt-Anchor" href="#使用docker发布phpmyadmin并且连接已经存在的mysql容器"></a> 使用Docker发布phpmyadmin并且连接已经存在的MySQL容器</h3><ol><li><p>首先下载phpmyadmin的docker镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先查询镜像仓库里有哪些镜像</span></span><br><span class="line">docker search phpmyadmin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取star最多的镜像or拉取你想用的镜像</span></span><br><span class="line">docker pull docker.io/phpmyadmin/phpmyadmin</span><br><span class="line"></span><br><span class="line">拉取镜像需要一段时间，这个要看服务器的带宽网速了</span><br></pre></td></tr></table></figure></li><li><p>启动镜像，连接到已存在的MySQL容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动镜像</span></span><br><span class="line">docker run --name myadmin -p 80:80 -d --link mysql-db:db docker.io/phpmyadmin/phpmyadmin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改容器配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 将配置文件复制到宿主机中</span></span></span><br><span class="line">docker cp myadmin:/etc/phpmyadmin/config.inc.php .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改配置文件信息(这里修改的db就是在启动的时候--link后面指定的别名)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">cfg[<span class="string">'Servers'</span>][<span class="variable">$i</span>][<span class="string">'host'</span>] = <span class="string">'localhost'</span> ——&gt; <span class="variable">$cfg</span>[<span class="string">'Servers'</span>][<span class="variable">$i</span>][<span class="string">'host'</span>] = <span class="string">'db'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 将修改后的配置文件复制回容器中</span></span></span><br><span class="line">docker cp ./config.inc.php myadmin:/etc/phpmyadmin/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启phpmyadmin容器</span></span><br></pre></td></tr></table></figure></li><li><p>此处就可以连接了，当然你也可以修改配置文件限制连接的用户，然后在MySQL中给连接用户授权</p></li></ol><h3 id="使用docker-compose创建"><a class="markdownIt-Anchor" href="#使用docker-compose创建"></a> 使用docker-compose创建</h3><ol><li><p>安装docker-compose，这里就不赘述了，回头专门用篇文章来解释</p></li><li><p>编写docker-compose.yml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">version: "2"</span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: hub.c.163.com/library/mysql</span><br><span class="line">    container_name: test-mysql</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - "3306:3306"</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_USER: "root"</span><br><span class="line">      MYSQL_PASSWORD: "root"</span><br><span class="line">      MYSQL_ROOT_PASSWORD: "root"</span><br><span class="line">    networks:</span><br><span class="line">      - net-mysql</span><br><span class="line"></span><br><span class="line">  phpmyadmin:</span><br><span class="line">    image: docker.io/phpmyadmin/phpmyadmin</span><br><span class="line">    container_name: test-myadmin</span><br><span class="line">    ports:</span><br><span class="line">      - "80:80"</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_USER: "root"</span><br><span class="line">      MYSQL_PASSWORD: "root"</span><br><span class="line">      MYSQL_ROOT_PASSWORD: "root"</span><br><span class="line">    networks:</span><br><span class="line">      - net-mysql</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  net-mysql:</span><br></pre></td></tr></table></figure></li><li><p>发布容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用命令发布容器</span></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li><li><p>然后就可以使用了，不需要修改任何配置文件</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在云服务器上的MySQL数据库在暴露端口和开启远程连接的情况下，是非常不安全的，昨天我的一台服务器就遭到了勒索病毒的攻击，让我支付0.06比特币赎回我的数据。还好那个库中没有重要数据，只是一个弃用了半年的数据库，密码我自己都忘记了，还好通过手段找回了密码，登上去之后就傻
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://luxiaowan.github.io/categories/Docker/"/>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/tags/MySQL/"/>
    
      <category term="Docker" scheme="http://luxiaowan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Nacos基本使用</title>
    <link href="http://luxiaowan.github.io/2019/12/20/Nacos%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://luxiaowan.github.io/2019/12/20/Nacos基本使用/</id>
    <published>2019-12-20T01:30:00.000Z</published>
    <updated>2019-12-20T15:07:26.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="啥"><a class="markdownIt-Anchor" href="#啥"></a> 啥</h3><ol><li>Nacos是什么</li><li>Nacos解决什么问题</li><li>Nacos怎么使用</li><li>Nacos架构图</li><li>Nacos作为配置中心</li><li>Nacos作为服务注册中心</li></ol><hr><p><strong>以上问题，在Nacos官网都有详细的说明，要学会查看官方文档，其他地方写的基本也都是copy的官方文档，所以我这里就不再赘述了，直接上官网地址给你们：<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></strong></p><h3 id="在使用过程中如果遇到什么问题可以去提issuehttpsgithubcomalibabanacosissues"><a class="markdownIt-Anchor" href="#在使用过程中如果遇到什么问题可以去提issuehttpsgithubcomalibabanacosissues"></a> 在使用过程中如果遇到什么问题，可以去提issue：<a href="https://github.com/alibaba/nacos/issues" target="_blank" rel="noopener">https://github.com/alibaba/nacos/issues</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;啥&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#啥&quot;&gt;&lt;/a&gt; 啥&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Nacos是什么&lt;/li&gt;
&lt;li&gt;Nacos解决什么问题&lt;/li&gt;
&lt;li&gt;Nacos怎么使用&lt;/li&gt;
&lt;li&gt;Nacos架构图&lt;/l
      
    
    </summary>
    
    
      <category term="Nacos" scheme="http://luxiaowan.github.io/categories/Nacos/"/>
    
    
  </entry>
  
</feed>
