<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2020-04-11T18:21:03.310Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Consul心跳机制</title>
    <link href="http://luxiaowan.github.io/2020/04/12/Consul%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/"/>
    <id>http://luxiaowan.github.io/2020/04/12/Consul心跳机制/</id>
    <published>2020-04-11T16:26:00.000Z</published>
    <updated>2020-04-11T18:21:03.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>我们知道Eureka是通过Client向Server发送renew通知来续命，属于是&quot;去中心化&quot;的设计，而Consul是&quot;中心化&quot;设计，Consul的心跳由Server端发起</p><h3 id="consul心跳"><a class="markdownIt-Anchor" href="#consul心跳"></a> Consul心跳</h3><p>Client在注册到Consul Server的时候(<code>ConsulServiceRegistry#register</code>)，会将客户端的注册信息全部发送给注册中心(接口：<code>/v1/agent/service/register</code>)，其中主要信息包括服务id、name、ip、port、health-check-url等，所以Consul Server才会知道向Client的哪个接口发送心跳。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id='consul-demo-7702',</span><br><span class="line">    name='consul-demo',</span><br><span class="line">    tags=[</span><br><span class="line">        secure=false</span><br><span class="line">    ],</span><br><span class="line">    address='192.168.0.107',</span><br><span class="line">    meta=null,</span><br><span class="line">    port=7702,</span><br><span class="line">    enableTagOverride=null,</span><br><span class="line">    check=Check&#123;</span><br><span class="line">        script='null',</span><br><span class="line">        interval='10s',</span><br><span class="line">        ttl='null',</span><br><span class="line">        http='http://192.168.0.107:7702/health',</span><br><span class="line">        method='null',</span><br><span class="line">        header=&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        tcp='null',</span><br><span class="line">        timeout='null',</span><br><span class="line">        deregisterCriticalServiceAfter='null',</span><br><span class="line">        tlsSkipVerify=null,</span><br><span class="line">        status='null'</span><br><span class="line">    &#125;,</span><br><span class="line">    checks=null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里check.http是值是我们在项目的properties文件中配置的：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">7702</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consul-demo</span></span><br><span class="line"><span class="meta">spring.cloud.consul.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="comment"># 心跳接口</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.health-check-path</span>=<span class="string">/health</span></span><br></pre></td></tr></table></figure><p>Spring Cloud Consul的心跳接口默认为actuator包中的/actuator/health，所以如果我们既没设置自定义的心跳接口，也没依赖actuator包，那么Consul Server就会在我们注册的Service上显示service checks fail</p><p><img src="/images/image-20200412013415372.png" alt="image-20200412013415372"></p><p>我们查看Consul Server控制台，发现会控制台健康检查语句<code>agent: Check is now critical: check=service:consul-demo-client-18090</code>，正常的健康检查语句是<code>agent: Check status updated: check=service:consul-demo-7702 status=passing</code></p><p>默认情况下Consul会每隔10秒，通过一个HTTP接口<code>/health</code>来检测节点的健康情况。 如果健康检测失败，那服务实例就会被标记成critical，可以通过在检查定义中指定超时字段来配置自定义HTTP检查超时值，检查的输出限制在大约4KB，大于此值的响应将被截断，会被认为健康检查未通过。</p><blockquote><p>spring.cloud.consul.discovery.prefer-ip-address参数决定上报给注册中心的健康接口是IP还是hostname</p><p>构建</p></blockquote><ul><li><p>健康检查接口创建源码</p><p>ConsulAutoRegistration#createCheck</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NewService.<span class="function">Check <span class="title">createCheck</span><span class="params">(Integer port,</span></span></span><br><span class="line"><span class="function"><span class="params">HeartbeatProperties ttlConfig, ConsulDiscoveryProperties properties)</span> </span>&#123;</span><br><span class="line">  NewService.Check check = <span class="keyword">new</span> NewService.Check();</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(properties.getHealthCheckCriticalTimeout())) &#123;</span><br><span class="line">    check.setDeregisterCriticalServiceAfter(</span><br><span class="line">      properties.getHealthCheckCriticalTimeout());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ttlConfig.isEnabled()) &#123;</span><br><span class="line">    check.setTtl(ttlConfig.getTtl());</span><br><span class="line">    <span class="keyword">return</span> check;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Assert.notNull(port, <span class="string">"createCheck port must not be null"</span>);</span><br><span class="line">  Assert.isTrue(port &gt; <span class="number">0</span>, <span class="string">"createCheck port must be greater than 0"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若自定义了spring.cloud.consul.discovery.health-check-url</span></span><br><span class="line">  <span class="keyword">if</span> (properties.getHealthCheckUrl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    check.setHttp(properties.getHealthCheckUrl());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义了spring.cloud.consul.discovery.health-check-path或默认</span></span><br><span class="line">    check.setHttp(String.format(<span class="string">"%s://%s:%s%s"</span>, properties.getScheme(),</span><br><span class="line">                                properties.getHostname(), port, properties.getHealthCheckPath()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// spring.cloud.consul.discovery.health-check-headers</span></span><br><span class="line">  check.setHeader(properties.getHealthCheckHeaders());</span><br><span class="line">  <span class="comment">// 设置健康检查频率spring.cloud.consul.discovery.health-check-interval，字符串，要加上单位"5s"</span></span><br><span class="line">  check.setInterval(properties.getHealthCheckInterval());</span><br><span class="line">  <span class="comment">// 设置健康检查超时时间spring.cloud.consul.discovery.health-check-timeout，字符串，要加上单位"5s"</span></span><br><span class="line">  check.setTimeout(properties.getHealthCheckTimeout());</span><br><span class="line">  check.setTlsSkipVerify(properties.getHealthCheckTlsSkipVerify());</span><br><span class="line">  <span class="keyword">return</span> check;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200412020911482.png" alt="image-20200412020911482"></p><p>图中Tags一栏有一个<code>secure=false</code>，这个是由客户端返回给Server，这个标识是检测健康检查接口是否为https协议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">createTags</span><span class="params">(ConsulDiscoveryProperties properties)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; tags = <span class="keyword">new</span> LinkedList&lt;&gt;(properties.getTags());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isEmpty(properties.getInstanceZone())) &#123;</span><br><span class="line">    tags.add(properties.getDefaultZoneMetadataName() + <span class="string">"="</span></span><br><span class="line">             + properties.getInstanceZone());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isEmpty(properties.getInstanceGroup())) &#123;</span><br><span class="line">    tags.add(<span class="string">"group="</span> + properties.getInstanceGroup());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查请求schema是否为https</span></span><br><span class="line">  tags.add(<span class="string">"secure="</span></span><br><span class="line">           + Boolean.toString(properties.getScheme().equalsIgnoreCase(<span class="string">"https"</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;我们知道Eureka是通过Client向Server发送renew通知来续命，属于是&amp;quot;去中心化&amp;quot;的设计，而Consul是&amp;q
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringCloud" scheme="http://luxiaowan.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Consul是什么</title>
    <link href="http://luxiaowan.github.io/2020/04/11/Consul%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://luxiaowan.github.io/2020/04/11/Consul是什么/</id>
    <published>2020-04-11T07:32:00.000Z</published>
    <updated>2020-04-11T15:37:22.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>Consul是一个基于CP的轻量级分布式高可用的系统，提供服务发现、健康检查、K-V存储、多数据中心等功能，不需要再依赖其他组件(Zk、Eureka、Etcd等)。</p><ul><li>服务发现：Consul可以提供一个服务，比如api或者MySQL之类的，其他客户端可以使用Consul发现一个指定的服务提供者，并通过DNS和HTTP应用程序可以很容易的找到所依赖的服务。</li><li>健康检查：Consul客户端提供相应的健康检查接口，Consul服务端通过调用健康检查接口检测客户端是否正常</li><li>K-V存储：客户端可以使用Consul层级的Key/Value存储，比如动态配置,功能标记,协调,领袖选举等等</li><li>多数据中心：Consul支持开箱即用的多数据中心</li></ul><h3 id="架构介绍"><a class="markdownIt-Anchor" href="#架构介绍"></a> 架构介绍</h3><img src="/images/consul-arch-420ce04a.png" alt="Consul Architecture" style="zoom: 30%;"><p>看得出一个Consul集群是由N个Server和M个Client节点组成的。</p><ul><li>Client节点：使用的client模式，该模式下可以接收服务的注册请求，但是会把请求转发给Server节点，自身不做处理，并且不持久化在本地</li><li>Server节点：使用server模式，处理注册请求，将注册信息持久化到本地，用作故障恢复。<ul><li>Server节点分为Leader和Follower两个身份，Leader负责监控Follower，同步注册信息给所有的Follower，一个集群中只能有一个Leader</li><li>Server之间通过RPC消息通信，Follower不会主动发起RPC请求，只会有Leader或选举时的Candidate主动发起</li><li>Follower节点接收到RPC请求后，会将请求转发给Leader节点，由Leader节点处理后进行相应的ACK，请求分为事务型和非事务型，非事务型的请求由Leader节点直接响应，事务型的请求</li><li>集群一般推荐3或5个节点比较合适，因为Raft选举时，4和3、5和6的结果是一样的</li></ul></li></ul><h4 id="gossip是什么"><a class="markdownIt-Anchor" href="#gossip是什么"></a> Gossip是什么</h4><p>从架构图中发现有一个Gossip，一个DC中涵盖了两个Gossip池，LAN池和WAN池，为什么会有Gossip，因为Consul是建立在Serf基础之上的，Gossip由Serf提供，Gossip是一个去中心化的协议。Consul中用Gossip维护节点关系，告知当前节点集群中还有哪些节点，其他节点的身份，是Follower还是Leader。</p><ul><li>LAN Gossip：局域网内唯一，LAN池是用于局域网内的节点消息广播，Consul的Client和Server节点全部都在LAN池中，LAN池中的客户端可以自动发现服务器，不需要进行过多的配置，LAN池能保证快速可靠的消息传播，比如Leader选举。</li><li>WAN Gossip：WAN是全局唯一的，无论属于哪一个DC，所有Server应该加入到WAN中，由WAN提供信息让Server节点可以执行跨数据中心的请求。</li></ul><h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3><img src="/images/consol_service.png" alt="consol_service" style="zoom:75%;"><ol><li>Producer启动之后，会向Consul注册中心发送一个POST请求，上报自己的id、name、ip、port、健康检查接口、心跳频率等信息</li><li>Consul接收到Producer上报的信息之后，根据上报的心跳频率和健康检查接口对Producer进行健康检查，检验Producer是否健康</li><li>Consumer启动之后，会从Consul拉取Producer的列表缓存在本地，后续的请求都会从本地选举发出，使用RestTemplate发出请求的时候，每次都会从Consul同步一下服务者信息。</li></ol><h3 id="leader选举"><a class="markdownIt-Anchor" href="#leader选举"></a> Leader选举</h3><p>一个DC可以有多个Server，但是只能有一个Leader，Leader基于Raft算法进行选举，在Leader选举过程中，整个集群都无法对外提供服务。</p><p>节点的身份有Follower、Candidate、Leader三种，所有的节点在初始化的时候都为Follower，节点加入到LAN Gossip池后，由Raft协议的Leader-Follower模式进行Leader选举。</p><p><img src="/images/raft-status.png" alt="Raft状态变更"></p><ul><li><p>概念</p><ul><li>Leader：集群中仅有一个，处理客户端所有的请求，遇到事务型的请求时会在本地处理后再生成同步日志，由Gossip通知到各个Follower节点进行同步</li><li>Follower：所有节点的初始状态，正常集群中可以有多个Follower，不处理任何请求也不发送任何请求，只响应来自Leader和Candidate的请求，当接收到客户端发来的请求时会自动将请求转发给Leader节点处理</li><li>Candidate：Follower超过选举器时都未收到来自Leader的心跳时，自动转换身份为Candidate，并根据Raft算法执行新一轮的Leader选举</li><li>Election Time(选举超时时间)：每一个节点都维护着自己的选举计时器，这个计时器的值需要大于心跳间隔，Follower收到Leader的心跳请求后会重置选举计时器，如果这个计时器归零了，则将节点身份转换为Candidate，并向其他节点发送投票。设置选举计时器主要是为了防止因为网络抖动等问题而引起心跳消息丢失，不然可能一旦心跳丢失了就立刻进入选举</li><li>Heart time(心跳超时时间)：Leader向Follower发送心跳的时间间隔</li><li>Term(任期)：任期是一个全局递增的数字，没进行一次选举，任期数就+1，每个节点都记录该值</li></ul></li><li><p>Raft算法</p><p>Raft是一个共识算法，也就是当大多数对某个事情都赞同的情况下执行该事情，主要为解决分布式一致性的问题。Raft算法是从Paxos的理论演变而来，Raft把问题分解成领导选举、日志复制、安全和成员变化</p><ul><li>领导选举：集群中必须存在一个Leader节点</li><li>日志复制：Leader节点接收并处理客户端的请求，然后将这些请求序列化成日志再同步到集群中的其他节点</li><li>安全性：已经被Raft状态机记录过的数据，就不能被再次输入到Raft状态机中</li></ul></li><li><p>Leader选举过程</p><ul><li><p>选举过程</p><p>在节点刚开始启动时，初始状态是Follower状态。一个Follower状态的节点，只要一直收到来自Leader或者Candidate的正确RPC消息的话，将一直保持在Follower状态。Leader节点通过周期性的发送心跳请求（一般使用带有空数据的AppendEntries RPC来进行心跳）来维持着Leader节点状态。每个Follower同时还有一个选举超时（Election timeout）定时器，如果在这个定时器超时之前都没有收到来自Leader的心跳请求，那么Follower将认为当前集群中没有Leader了，将发起一次新的选举。</p><p>发起选举时，Follower将递增它的任期号然后切换到Candidate状态。然后通过向集群中其它节点发送RequestVote RPC请求来发起一次新的选举，一个节点将保持在该任期内的Candidate状态下。</p></li><li><p>选举过程中可能遇到的问题</p><ul><li><p>该Candidate节点收到超过半数以上集群中其它节点的投票赢得选举</p><p>如果Candidate节点收到了集群中半数以上节点的投票，那么此Candidate节点将成为新的Leader。每个节点在一个任期中只能给一个节点投票，而且遵守“先来后到”的原则，这样就保证每个任期最多只有一个节点会赢得选举成为leader。</p></li><li><p>收到任期号比当前节点任期号不一致的请求</p><ul><li>比当前节点任期号小：说明当前集群已经进入了下一轮选举，则自动拒绝收到的请求，继续保持在Candidate状态</li><li>比当前节点任期号大：说明集群中已经存在了Leader，节点从Candidate切换到Follower</li></ul></li><li><p>选举后没有任何一个节点成为Leader</p><p>本次选举未选举出Leader，则将集群中的任期号+1，再次进行选举</p></li></ul></li></ul></li></ul><h3 id="springcloud使用consul"><a class="markdownIt-Anchor" href="#springcloud使用consul"></a> SpringCloud使用Consul</h3><ol><li><p>安装并启动Consul Server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./consul agent -dev</span><br></pre></td></tr></table></figure></li><li><p>创建SpringCloud项目</p><ul><li>服务提供方</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">7702</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consul-demo</span></span><br><span class="line"><span class="meta">spring.cloud.consul.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.health-check-path</span>=<span class="string">/health</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/health"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"----health check----"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello consul"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务调用方</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">18090</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consul-demo-client</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://consul-demo/health"</span>, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>两个项目启动后，查看服务注册情况：<a href="http://127.0.0.1:8500/" target="_blank" rel="noopener">http://127.0.0.1:8500/</a></li></ul><p><img src="/images/image-20200411225129805.png" alt="image-20200411225129805"></p><p>访问接口测试：<a href="http://127.0.0.1:18090/hello" target="_blank" rel="noopener">http://127.0.0.1:18090/hello</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;Consul是一个基于CP的轻量级分布式高可用的系统，提供服务发现、健康检查、K-V存储、多数据中心等功能，不需要再依赖其他组件(Zk、Eure
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringCloud" scheme="http://luxiaowan.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Eureka集群搭建</title>
    <link href="http://luxiaowan.github.io/2020/04/11/Eureka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://luxiaowan.github.io/2020/04/11/Eureka集群搭建/</id>
    <published>2020-04-11T05:16:00.000Z</published>
    <updated>2020-04-11T07:17:46.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="eureka集群"><a class="markdownIt-Anchor" href="#eureka集群"></a> Eureka集群</h3><p>Eureka是基于AP的分布式服务注册中心，集群中所有的Server节点都互为对方的备份，可以把所有的节点都看作是Master节点，也可以把所有的节点都看作是Slave节点，任一节点接收到新的服务注册请求后，都会在registry完成之后同步给其他的Server节点，续约操作renew和registry的逻辑一样。</p><img src="/images/image-20200411134658642.png" alt="image-20200411134658642" style="zoom:50%;"><p>当集群中一个Server节点宕机之后，Client会把自动切换到存活的节点，由于集群中的所有Server之间是相互同步的，所以各个Server节点之间的信息是相同的，除非是在一个Client刚注册到Server1还未同步给其他节点时宕机了，会造成信息不一致的情况，但当节点将续约请求发送给其他节点时，如果这个节点没有这个Client的信息，则会重新进行registry，并同步给集群中的其他节点。</p><img src="/images/image-20200411134915369.png" alt="image-20200411134915369" style="zoom:50%;"><p>因为Eureka集群是基于AP的，所以只要有一个Server节点可用，那么整个集群就是可用的，每一个Server节点都有一个server_id属性，当节点宕机后，会选择server_id值靠的最近的Server接收宕机节点的请求。</p><h3 id="搭建集群"><a class="markdownIt-Anchor" href="#搭建集群"></a> 搭建集群</h3><p>Eureka Server搭建很简单，最主要的就是节点配置文件的内容</p><ol><li>Eureka Server</li></ol><ul><li>peer1</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9001</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer1</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#是否将eureka自身作为应用注册到eureka注册中心</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span> <span class="comment">#为true时，可以启动，但报异常：Cannot execute request on any known server</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer2:9002/eureka/,http://peer3:9003/eureka/</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>peer2</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9002</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#是否将eureka自身作为应用注册到eureka注册中心</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span> <span class="comment">#为true时，可以启动，但报异常：Cannot execute request on any known server</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:9001/eureka/,http://peer3:9003/eureka/</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>peer3</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9003</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer3</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#是否将eureka自身作为应用注册到eureka注册中心</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span> <span class="comment">#为true时，可以启动，但报异常：Cannot execute request on any known server</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:9001/eureka/,http://peer2:9002/eureka/</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Eureka Client</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">7080</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-health</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://127.0.0.1:9001/eureka/</span></span><br><span class="line"><span class="meta">eureka.instance.health-check-url-path</span>=<span class="string">/cc/health</span></span><br><span class="line"><span class="meta">eureka.instance.lease-renewal-interval-in-seconds</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">eureka.instance.lease-expiration-duration-in-seconds</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure><p>在客户端的defaultZone不论设置集群中的哪一个节点或哪几个节点，整个集群的所有节点都会有这个Client的注册信息，这就是因为Server节点的replicate功能。</p><p><img src="/images/image-20200411143623870.png" alt="image-20200411143623870"></p><p>当我们关闭掉其他Server节点，只留一个可用节点的时候，注册中心仍然可以提供服务。但如果我们在Client的defaultZone只设置一个节点的信息的话，那么在这个节点宕机之后，Client就找不到可以继续renew的节点了，最终整个集群都收不到这个Client的续约，在<code>lease-expiration-duration-in-seconds</code>之后，集群会将这个Client从服务列表移除，这损失可就太大了。</p><p>所以应该把Server和Client节点的defaultZone要设置齐全。Client把所有Server节点都设置进来，Server节点也把所有的Server节点都设置进来。</p><h3 id="集群参数"><a class="markdownIt-Anchor" href="#集群参数"></a> 集群参数</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Eureka Server启动时，从远程Eureka Server读取不到注册信息时，多长时间不允许Client访问，默认5分钟</span></span><br><span class="line"><span class="attr">eureka.server.wait-time-in-ms-when-sync-empty</span></span><br><span class="line"><span class="comment"># Eureka Server 集群节点更新频率，单位：毫秒，默认10分钟</span></span><br><span class="line"><span class="attr">eureka.server.peer-eureka-nodes-update-interval-ms</span></span><br><span class="line"><span class="comment"># 初始化实例信息到Eureka服务端的间隔时间，单位为秒，默认40秒</span></span><br><span class="line"><span class="attr">eureka.client.initial-instance-info-replication-interval-seconds</span></span><br><span class="line"><span class="comment"># 更新实例信息的变化到Eureka服务端的间隔时间，单位为秒，默认30秒</span></span><br><span class="line"><span class="attr">eureka.client.instance-info-replication-interval-seconds</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;eureka集群&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#eureka集群&quot;&gt;&lt;/a&gt; Eureka集群&lt;/h3&gt;
&lt;p&gt;Eureka是基于AP的分布式服务注册中心，集群中所有的Server节点都互为对方的备份，可以把所有的节点都
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringCloud" scheme="http://luxiaowan.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Eureka心跳检测</title>
    <link href="http://luxiaowan.github.io/2020/04/10/Eureka%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/"/>
    <id>http://luxiaowan.github.io/2020/04/10/Eureka心跳检测/</id>
    <published>2020-04-10T13:18:00.000Z</published>
    <updated>2020-04-10T18:45:18.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>注册中心的心跳机制有两种形式：客户端主动上报和客户端被动响应。Eureka属于是主动上报类型的，Client通过renew机制频繁的向Server发送消息，通知Server它还活着，不要将其从服务列表中剔除，但是我们renew仅仅是监控Client是否存活，并不会去检测Client依赖的服务是否存活</p><img src="/images/image-20200410233537737.png" alt="image-20200410233537737" style="zoom: 40%;"><p>从图中我们发现Client123和Client456两个客户端均依赖了第三方组件，并且MySQL同时宕机了。</p><ul><li>Client123使用了Eureka自带的renew机制，renew最基础的就是调一下Server的<code>/apps/{appName}/{instanceId}?status=&amp;lastDirtyTimestamp=</code>接口，正常情况下Client启动后的status为UP，所以只要Client自身服务不出问题，永远都是UP，默认的指示器是<code>CompositeHealthIndicator</code>，默认的管理器为<code>EurekaHealthCheckHandler</code>；</li><li>Client456通过扩展<code>HealthIndicator</code>接口和<code>HealthCheckHandler</code>接口，然后来自定义需要监控的内容</li></ul><h3 id="默认健康监控组件"><a class="markdownIt-Anchor" href="#默认健康监控组件"></a> 默认健康监控组件</h3><p>在类<code>DiscoveryClient#getHealthCheckHandler</code>方法中选择需要使用的健康管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HealthCheckHandler <span class="title">getHealthCheckHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HealthCheckHandler healthCheckHandler = <span class="keyword">this</span>.healthCheckHandlerRef.get();</span><br><span class="line">  <span class="keyword">if</span> (healthCheckHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != healthCheckHandlerProvider) &#123;</span><br><span class="line">      healthCheckHandler = healthCheckHandlerProvider.get();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != healthCheckCallbackProvider) &#123;</span><br><span class="line">      healthCheckHandler = <span class="keyword">new</span> HealthCheckCallbackToHandlerBridge(healthCheckCallbackProvider.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == healthCheckHandler) &#123;</span><br><span class="line">      healthCheckHandler = <span class="keyword">new</span> HealthCheckCallbackToHandlerBridge(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.healthCheckHandlerRef.compareAndSet(<span class="keyword">null</span>, healthCheckHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.healthCheckHandlerRef.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法调用流程图</strong></p><p><img src="/images/image-20200411021953543.png" alt="image-20200411021953543"></p><h3 id="自定义健康监控"><a class="markdownIt-Anchor" href="#自定义健康监控"></a> 自定义健康监控</h3><ol><li><p>自定义监控组件</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HealthPolicyBean</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">InitializingBean</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;<span class="keyword">String</span>, Object&gt; redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调度线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService scheduled = Executors.<span class="keyword">new</span><span class="type">ScheduledThreadPool</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库健康情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> boolean                 dbHealth    = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis健康情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> boolean                 redisHealth = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MongoDB健康情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> boolean                 mongoHealth = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    <span class="comment">// 创建调度器</span></span><br><span class="line">        ThreadPoolExecutor heartbeatExecutor = <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">"redis-HeartbeatExecutor-%d"</span>).setDaemon(<span class="literal">true</span>).build());</span><br><span class="line"></span><br><span class="line">        TimedSupervisorTask task = <span class="keyword">new</span> <span class="type">TimedSupervisorTask</span>(<span class="string">"redis-heartbeat"</span>, scheduled, heartbeatExecutor, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="number">100</span>, <span class="keyword">new</span> <span class="type">RedisTimer</span>());</span><br><span class="line"></span><br><span class="line">        scheduled.schedule(task, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监控Redis状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    protected <span class="class"><span class="keyword">class</span> <span class="title">RedisTimer</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;RedisClientInfo&gt; clientList = redisTemplate.getClientList();</span><br><span class="line">                <span class="keyword">if</span> (clientList == <span class="literal">null</span> || clientList.isEmpty()) &#123;</span><br><span class="line">                    HealthPolicyBean.redisHealth = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HealthPolicyBean.redisHealth = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                HealthPolicyBean.redisHealth = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义HealthIndicator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cc健康指示器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (HealthPolicyBean.dbHealth &amp;&amp; HealthPolicyBean.redisHealth &amp;&amp; HealthPolicyBean.mongoHealth) &#123;</span><br><span class="line">          <span class="comment">// 当所有组件都正常时才返回UP</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Health.Builder(Status.UP).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Health.Builder(Status.DOWN).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义HealthCheckHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cc健康管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CcHealthCheckHandler</span> <span class="keyword">implements</span> <span class="title">HealthCheckHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CcHealthIndicator ccHealthIndicator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ccHealthIndicator.health().getStatus().equals(Status.UP)) &#123;</span><br><span class="line">            <span class="keyword">return</span> InstanceInfo.InstanceStatus.UP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> InstanceInfo.InstanceStatus.DOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法调用流程图</strong></p><p><img src="/images/image-20200411021933621.png" alt="image-20200411021933621"></p></li></ol><h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3><p>我们打开Redis服务，启动Eureka Server、Client123和Client456。</p><ul><li><p>Redis运行中</p><p>Redis正常运行时，两个服务都处于正常情况</p><p><img src="/images/image-20200411022923590.png" alt="image-20200411022923590"></p></li><li><p>Redis停止</p><p>将Redis服务停掉，等待一个renew周期后，服务状态发生变化，使用默认HealthCheckHandler的CUSER-SERVICE的status仍然为UP，而我们自定义HealthCheckHandler的EUREKA-HEALTH服务的status已经变成了DOWN，符合正常要求。</p><p><img src="/images/image-20200411023355326.png" alt="image-20200411023355326"></p></li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>在实际的生产工作中，尽量不要使用默认的HealthCheckHandler，不然就算是我们项目的MySQL、Redis、MongoDB、MQ都挂掉了，只要项目的进程还存活，那么status就很大的可能是UP，但实际上项目已经无法正常提供服务了，会给我们的项目带来很大的麻烦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;注册中心的心跳机制有两种形式：客户端主动上报和客户端被动响应。Eureka属于是主动上报类型的，Client通过renew机制频繁的向Serve
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringCloud" scheme="http://luxiaowan.github.io/tags/SpringCloud/"/>
    
      <category term="Eureka" scheme="http://luxiaowan.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>Eureka服务注册详解</title>
    <link href="http://luxiaowan.github.io/2020/04/10/Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E8%AF%A6%E8%A7%A3/"/>
    <id>http://luxiaowan.github.io/2020/04/10/Eureka服务注册详解/</id>
    <published>2020-04-10T03:00:00.000Z</published>
    <updated>2020-04-10T14:41:02.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>服务注册与发现是Spring Cloud Eureka的核心功能，首先我们需要一个Eureka Server，然后再来一个Eureka Client，那么Client的服务是怎么自动注册到Server的呢？我们都知道SpringBoot是约定大于配置的一个框架，自动配置是在启动的时候扫描/META-INF/spring.factories文件中EnableAutoConfiguration下的所有的*AutoConfiguration类，看一下eureka-client包下的spring.factories文件内容</p><p><img src="/images/image-20200410145122079.png" alt="image-20200410145122079"></p><p>我们主要关注两个类<code>EurekaClientAutoConfiguration</code>和<code>EurekaDiscoveryClientConfiguration</code></p><p>在类EurekaClientAutoConfiguration的定义上我们可以看到这个类是在<code>EurekaDiscoveryClientConfiguration</code>初始化完成之后再进行初始化的，这不是重点，重点来看<code>EurekaClientAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureAfter</span>(name = &#123;</span><br><span class="line">  <span class="string">"org.springframework.cloud.autoconfigure.RefreshAutoConfiguration"</span>,</span><br><span class="line">  <span class="string">"org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration"</span>,</span><br><span class="line">  <span class="string">"org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationAutoConfiguration"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册服务"><a class="markdownIt-Anchor" href="#注册服务"></a> 注册服务</h3><p>EurekaClientAutoConfiguration类的主要功能是配置EurekaClient。其中有个关键的内部类<code>RefreshableEurekaClientConfiguration</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnRefreshScope</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RefreshableEurekaClientConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> AbstractDiscoveryClientOptionalArgs&lt;?&gt; optionalArgs;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(destroyMethod = <span class="string">"shutdown"</span>)</span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span>(value = EurekaClient.class, search = SearchStrategy.CURRENT)</span><br><span class="line">  <span class="meta">@org</span>.springframework.cloud.context.config.annotation.RefreshScope</span><br><span class="line">  <span class="meta">@Lazy</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> EurekaClient <span class="title">eurekaClient</span><span class="params">(ApplicationInfoManager manager, EurekaClientConfig config, EurekaInstanceConfig instance, @Autowired(required = <span class="keyword">false</span>)</span> HealthCheckHandler healthCheckHandler) </span>&#123;</span><br><span class="line">    ApplicationInfoManager appManager;</span><br><span class="line">    <span class="keyword">if</span> (AopUtils.isAopProxy(manager)) &#123;</span><br><span class="line">      appManager = ProxyUtils.getTargetObject(manager);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      appManager = manager;</span><br><span class="line">    &#125;</span><br><span class="line">    CloudEurekaClient cloudEurekaClient = <span class="keyword">new</span> CloudEurekaClient(appManager, config, <span class="keyword">this</span>.optionalArgs, <span class="keyword">this</span>.context);</span><br><span class="line">    cloudEurekaClient.registerHealthCheck(healthCheckHandler);</span><br><span class="line">    <span class="keyword">return</span> cloudEurekaClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类被<code>@ConditionalOnRefreshScope</code>标注了，因为在<code>spring-cloud-context</code>包的<code>spring.factories</code>中配置了RefreshAutoConfiguration，且<code>@ConditionalOnRefreshScope</code>的实例化取决于RefreshAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RefreshScope.class)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(RefreshAutoConfiguration.class)<span class="comment">// 重点</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"eureka.client.refresh.enable"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">                       matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@interface</span> ConditionalOnRefreshScope &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然<code>RefreshableEurekaClientConfiguration</code>类被实例化了，那么里面的<code>EurekaClient</code>也同样被实例化了，在<code>eurekaClient()</code>方法中返回的是<code>CloudEurekaClient</code>类的实例，那么关键就是这个类了。</p><img src="/images/image-20200410153201415.png" alt="image-20200410153201415" style="zoom: 56%;"><p><code>CloudEurekaClient</code>继承自<code>DiscoveryClient</code>，并且在构造器中是直接调了父类的构造器去处理具体逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</span><br><span class="line">                    Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建调度线程池，只给heartbeat和cacheRefresh使用，所以核心线程池为2即可</span></span><br><span class="line">    scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</span><br><span class="line">                                                 <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                                                 .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</span><br><span class="line">                                                 .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">                                                 .build());</span><br><span class="line"></span><br><span class="line">    heartbeatExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">      <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">      <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">      .setNameFormat(<span class="string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)</span><br><span class="line">      .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">      .build()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    cacheRefreshExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">      <span class="number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">      <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">      .setNameFormat(<span class="string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)</span><br><span class="line">      .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">      .build()</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to initialize DiscoveryClient!"</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从远程获取所有的服务</span></span><br><span class="line">  <span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">    fetchRegistryFromBackup();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在所有后台任务启动之前调用并执行预注册处理程序</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.preRegistrationHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.preRegistrationHandler.beforeRegistration();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka() &amp;&amp; clientConfig.shouldEnforceRegistrationAtInit()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!register() ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Registration error at startup. Invalid server response."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">      logger.error(<span class="string">"Registration error at startup: &#123;&#125;"</span>, th.getMessage());</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(th);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化调度任务（cacheRefreshTask、heartbeatTask）</span></span><br><span class="line">  initScheduledTasks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DiscoveryClient</code>构造器中调用的最核心的两个方法是<code>fetchRegistry()</code>和<code>initScheduledTasks()</code>，<code>fetchRegistry()</code>方法中调用了<code>getAndStoreFullRegistry()</code>，最终在此方法中向Eureka Server发送了获取所有实例的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndStoreFullRegistry</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</span><br><span class="line"></span><br><span class="line">  Applications apps = <span class="keyword">null</span>;</span><br><span class="line">  EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == <span class="keyword">null</span></span><br><span class="line">    ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())</span><br><span class="line">    : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());</span><br><span class="line">  <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</span><br><span class="line">    apps = httpResponse.getEntity();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作完成之后，调用<code>DiscoveryClient</code>的<code>initScheduledTasks()</code>方法，在这个方法中，注册两个定时任务，一个是以指定的时间间隔获取注册表信息的任务，另一个是在给定的时间间隔内更新租约的heartbeat任务，并且在任务都初始化完成之后调用<code>InstanceInfoReplicator#start</code>方法初始化一个注册远程服务的定时任务。类<code>InstanceInfoReplicator</code>实际上是一个线程，实现自Runnable接口，在他的run方法里调用了DiscoveryClient的register()方法通过REST调用向eureka服务注册。</p><ul><li><p>Eureka接口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">POST</span>    <span class="string">/eureka/apps/&#123;appName&#125;</span>                                            <span class="string">注册新的实例</span> </span><br><span class="line"><span class="string">DELETE</span>  <span class="string">/eureka/apps/&#123;appName&#125;/&#123;instanceId&#125;</span>                               <span class="string">注销应用实例</span> </span><br><span class="line"><span class="string">PUT</span>     <span class="string">/eureka/apps/&#123;appName&#125;/&#123;instanceId&#125;</span>                               <span class="string">应用实例发送心跳</span> </span><br><span class="line"><span class="string">GET</span>     <span class="string">/eureka/apps</span>                                                    <span class="string">查询所有的实例</span> </span><br><span class="line"><span class="string">GET</span>     <span class="string">/eureka/apps/&#123;appName&#125;</span>                                            <span class="string">查询指定appId的实例</span> </span><br><span class="line"><span class="string">GET</span>     <span class="string">/eureka/apps/&#123;appName&#125;/&#123;instanceId&#125;</span>                               <span class="string">查询指定appId和instanceId的实例</span> </span><br><span class="line"><span class="string">GET</span>     <span class="string">/eureka/instances/&#123;instanceId&#125;</span>                                  <span class="string">查询指定的instanceId的实例</span> </span><br><span class="line"><span class="string">PUT</span>     <span class="string">/eureka/apps/&#123;appName&#125;/&#123;instanceId&#125;/status?value=OUT_OF_SERVICE</span>   <span class="string">暂停应用实例</span> </span><br><span class="line"><span class="string">PUT</span>     <span class="string">/eureka/apps/&#123;appName&#125;/&#123;instanceId&#125;/status?value=UP</span>               <span class="string">恢复应用实例</span> </span><br><span class="line"><span class="string">PUT</span>     <span class="string">/eureka/apps/&#123;appName&#125;/&#123;instanceId&#125;/metadata?key=value</span>            <span class="string">更新元数据信息</span> </span><br><span class="line"><span class="string">GET</span>     <span class="string">/eureka/vips/&#123;vipAddress&#125;</span>                                       <span class="string">根据vip地址查询</span> </span><br><span class="line"><span class="string">GET</span>     <span class="string">/eureka/svips/&#123;svipAddress&#125;</span>                                     <span class="string">根据svip地址查询</span></span><br></pre></td></tr></table></figure></li></ul><p>这些接口被定义在eureka-core.jar的<code>com.netflix.eureka.resources</code>包中</p><ul><li><p>Eureka核心类</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InstanceInfo :              注册的服务实例,里面包含服务实例的各项属性</span><br><span class="line">LeaseInfo :                 <span class="type">Eureka</span>用这个类来标识应用实例的租约信息</span><br><span class="line">ServiceInstance :           发现的实例信息的抽象接口,约定了服务发现的实例应用有哪些通用信息</span><br><span class="line">InstanceStatus :            用于标识服务实例的状态,是一个枚举类,主要有状态<span class="type">UP</span>,DOWN,STARTING,OUT_OF_SERVICE,UNKNOWN</span><br><span class="line">EurekaServerConfigBean :    <span class="type">Eureka</span> Server的核心配置类，里面包含了Eureka Server的各项核心属性信息</span><br></pre></td></tr></table></figure></li></ul><h3 id="renew续约心跳"><a class="markdownIt-Anchor" href="#renew续约心跳"></a> renew续约心跳</h3><p>Eureka的续约需要每隔一段时间执行一次，目的是要告诉Eureka Server客户端还活着，以免Eureka Server将其当作是宕机的服务而剔除掉。</p><p>Client默认是每隔30秒发送一次renew请求，可以通过配置信息<code>eureka.instance.lease-renewal-interval-in-seconds</code>修改。</p><p>Server收到renew请求后，根据接收到的参数找到对应的实例，更新实例的续约时间，再将最新的续约时间同步到集群中的其他Server节点，最终完成续约。</p><p><img src="/images/eureka_renew.png" alt="eureka_renew"></p><p>Client端的续约定时任务是在实例化之后在<code>initScheduledTasks()</code>方法中被定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">    <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</span><br><span class="line">    <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();</span><br><span class="line">    logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: &#123;&#125;"</span>, renewalIntervalInSecs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建心跳实例</span></span><br><span class="line">    heartbeatTask = <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">      <span class="string">"heartbeat"</span>,</span><br><span class="line">      scheduler,</span><br><span class="line">      heartbeatExecutor,</span><br><span class="line">      renewalIntervalInSecs,</span><br><span class="line">      TimeUnit.SECONDS,</span><br><span class="line">      expBackOffBound,</span><br><span class="line">      <span class="keyword">new</span> HeartbeatThread()</span><br><span class="line">    );</span><br><span class="line">    scheduler.schedule(</span><br><span class="line">      heartbeatTask,</span><br><span class="line">      renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    logger.info(<span class="string">"Not registering with Eureka server per configuration"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到心跳最终使用的是类<code>HeartbeatThread</code>，这个类实际上就是一个线程类，通过ScheduledExecutorService来执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (renew()) &#123;</span><br><span class="line">      lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用接口进行续约</span></span><br><span class="line">    httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 若Server端返回服务不存在，则重新将服务注册到Server</span></span><br><span class="line">    <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123;</span><br><span class="line">      REREGISTER_COUNTER.increment();</span><br><span class="line">      <span class="keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();</span><br><span class="line">      <span class="keyword">boolean</span> success = register();</span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        instanceInfo.unsetIsDirty(timestamp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> httpResponse.getStatusCode() == Status.OK.getStatusCode();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Eureka Server根据Jersey框架实现HTTP请求，续约请求最终会被<code>com.netflix.eureka.resources.InstanceResource#renewLease</code>接口接收到，然后通过InstanceRegistry递交给PeerAwareInstanceRegistryImpl，最终递交给AbstractInstanceRegistry#renew处理具体的操作，经过一系列rule操作之后，最终调用Lease#renew完成对lastUpdateTimestamp的更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">  RENEW.increment(isReplication);</span><br><span class="line">  Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">  Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    leaseToRenew = gMap.get(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</span><br><span class="line">    RENEW_NOT_FOUND.increment(isReplication);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    InstanceInfo instanceInfo = leaseToRenew.getHolder();</span><br><span class="line">    <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// touchASGCache(instanceInfo.getASGName());</span></span><br><span class="line">      <span class="comment">// 匹配服务状态</span></span><br><span class="line">      InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(instanceInfo, leaseToRenew, isReplication);</span><br><span class="line">      <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</span><br><span class="line">        RENEW_NOT_FOUND.increment(isReplication);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</span><br><span class="line">        instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    renewsLastMin.increment();</span><br><span class="line">    leaseToRenew.renew();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>续约操作成功完成后，会调用PeerAwareInstanceRegistryImpl#replicateToPeers方法通知其他Eureka节点</p><blockquote><p>renew控制：</p><p>eureka.instance.lease-renewal-interval-in-seconds=10#10秒renew一次，默认30秒</p><p>eureka.instance.lease-expiration-duration-in-senconds=80#如果80秒内未发送续约请求，则关闭该客户端，默认为90秒</p><p>lease-expiration-duration-in-senconds不宜过大，否则可能出现客户端已down，但还是会有流量转发给它；但是也不宜过小，不然客户端可能会因为出现网络抖动而被移除。大于lease-renewal-interval-in-seconds两三倍以上。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;服务注册与发现是Spring Cloud Eureka的核心功能，首先我们需要一个Eureka Server，然后再来一个Eureka Clie
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringCloud" scheme="http://luxiaowan.github.io/tags/SpringCloud/"/>
    
      <category term="Eureka" scheme="http://luxiaowan.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>MySQL执行计划explain解析</title>
    <link href="http://luxiaowan.github.io/2020/04/10/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92explain%E8%A7%A3%E6%9E%90/"/>
    <id>http://luxiaowan.github.io/2020/04/10/MySQL执行计划explain解析/</id>
    <published>2020-04-09T17:03:00.000Z</published>
    <updated>2020-04-09T17:22:58.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h3><p><code>explain table</code>或<code>explain EXTENDED table</code></p><h3 id="参数解释"><a class="markdownIt-Anchor" href="#参数解释"></a> 参数解释</h3><p><img src="/images/image-20200410010618626.png" alt="image-20200410010618626"></p><ul><li><p>id：select查询的序列号，可以当做是执行顺序</p><ul><li>id相同时，执行顺序由上至下</li><li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li></ul></li><li><p>select_type：查询中每个select子句的类型</p><ul><li><p>SIMPLE(简单SELECT,不使用UNION或子查询等)</p></li><li><p>PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)</p></li><li><p>UNION(UNION中的第二个或后面的SELECT语句)</p></li><li><p>DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p></li><li><p>UNION RESULT(UNION的结果)</p></li><li><p>SUBQUERY(子查询中的第一个SELECT)</p></li><li><p>DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)</p></li><li><p>DERIVED(派生表的SELECT, FROM子句的子查询)</p></li><li><p>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p></li></ul></li><li><p>table：显示这一行的数据是关于哪张表的，有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果)</p></li><li><p>partitions：分区号</p></li><li><p>type：表示MySQL在表中找到所需行的方式，又称“访问类型”，常用的类型有： ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）</p><ul><li>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</li><li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树</li><li>range：只检索给定范围的行，使用一个索引来选择行</li><li>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li><li>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</li><li>const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system</li><li>NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li></ul></li><li><p>possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</p><p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p></li><li><p>Key：显示MySQL实际决定使用的键（索引）</p><p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p></li><li><p>key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</p><p><code>不损失精确性的情况下，长度越短越好</code></p></li><li><p>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p></li><li><p>rows：表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p></li><li><p>Extra：该列包含MySQL解决查询的详细信息,有以下几种情况：</p><ul><li><p>Using filesort</p><p>MySQL有两种方式可以生成有序的结果，通过排序操作或者使用索引，当Extra中出现了Using filesort 说明MySQL使用了后者，但注意虽然叫filesort但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是ordery by，group by语句的结果，这可能是一个CPU密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。</p></li><li><p>Using temporary</p><p>用临时表保存中间结果，常用于GROUP BY 和 ORDER BY操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。</p></li><li><p>Not exists</p><p>MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行， 就不再搜索了</p></li><li><p>Using index</p><p>说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现using where，表明索引被用来执行索引键值的查找，没有using where，表明索引用来读取数据而非执行查找动作。这是MySQL服务层完成的，但无需再回表查询记录。</p></li><li><p>Using index condition</p><p>这是MySQL 5.6出来的新特性，叫做“索引条件推送”。简单说一点就是MySQL原来在索引上是不能执行如like这样的操作的，但是现在可以了，这样减少了不必要的IO操作，但是只能用在二级索引上。</p></li><li><p>Using where</p><p>使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。<strong>注意</strong>：Extra列出现Using where表示MySQL服务器将存储引擎返回服务层以后再应用WHERE条件过滤</p></li><li><p>Using join buffer</p><p>使用了连接缓存：Block Nested Loop，连接算法是块嵌套循环连接;Batched Key Access，连接算法是批量索引连接</p></li><li><p>impossible where</p><p>where子句的值总是false，不能用来获取任何元组</p></li><li><p>select tables optimized away</p><p>在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p></li><li><p>distinct</p><p>优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#用法&quot;&gt;&lt;/a&gt; 用法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;explain table&lt;/code&gt;或&lt;code&gt;explain EXTENDED table&lt;/code&gt;&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL索引建立原则</title>
    <link href="http://luxiaowan.github.io/2020/04/10/MySQL%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E5%8E%9F%E5%88%99/"/>
    <id>http://luxiaowan.github.io/2020/04/10/MySQL索引建立原则/</id>
    <published>2020-04-09T16:50:00.000Z</published>
    <updated>2020-04-09T17:02:53.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>索引的目的是提升查询数据的效率，所以我们建索引的标准应该一切从提升查询效率为基准。</p><h3 id="小技巧"><a class="markdownIt-Anchor" href="#小技巧"></a> 小技巧</h3><ol><li><p>对于有唯一值的列尽量使用唯一索引</p></li><li><p>索引长度尽量小一点，长度小的索引可以节省索引空间，也会使查找的速度得到提升，因为索引页只有16k，索引列长度小的话，一页可以容纳更多的数据</p></li><li><p>太长的列可以选择部分内容做索引，遵循最左前缀原则</p></li><li><p>更新频繁的列不适合建索引</p></li><li><p>利用断桥原则（最左前缀原则），比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</p></li><li><p>不要过多创建索引，索引越多占用的空间越多，而且每次增、删、改操作都会重建索引，并且索引太多的话也会增加之后的优化复杂度</p></li><li><p>尽量扩展索引，比如现有索引(a)，现在我又要对(a,b)进行索引，不需要再建一个索引(a,b)，只需要在原索引(a)的基础上新增b列即可</p></li><li><p>一次查询是不能应用多个索引，即使你查询条件中有多个索引，最终也只会选择最优的一个</p><img src="/images/image-20200410005949806.png" alt="image-20200410005949806" style="zoom:67%;"></li><li><p>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行</p></li><li><p>like “xxxx%” 是可以用到索引的，like “%xxxx” 和 like “%xxx%” 则不行（但会用到索引下推）</p></li><li><p>NULL会使索引的效果大打折扣</p></li><li><p>索引列若出现函数或计算，则索引不会生效</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;索引的目的是提升查询数据的效率，所以我们建索引的标准应该一切从提升查询效率为基准。&lt;/p&gt;
&lt;h3 id=&quot;小技巧&quot;&gt;&lt;a class=&quot;mar
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
      <category term="索引" scheme="http://luxiaowan.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL回表、索引覆盖、索引下推</title>
    <link href="http://luxiaowan.github.io/2020/04/09/MySQL%E5%9B%9E%E8%A1%A8%E3%80%81%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E3%80%81%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/"/>
    <id>http://luxiaowan.github.io/2020/04/09/MySQL回表、索引覆盖、索引下推/</id>
    <published>2020-04-09T13:01:00.000Z</published>
    <updated>2020-04-09T16:37:44.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3><p>创建一张表，并创建一个自增主键索引和一个组合索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE index_opt_test (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  name varchar(11) DEFAULT NULL,</span><br><span class="line">  title varchar(11) DEFAULT NULL,</span><br><span class="line">  age int(11) DEFAULT NULL,</span><br><span class="line">  sex varchar(11) DEFAULT NULL,</span><br><span class="line">  content varchar(500) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (id),</span><br><span class="line">  KEY idx_cb (name,title,age)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h3 id="回表"><a class="markdownIt-Anchor" href="#回表"></a> 回表</h3><ol><li><p>什么是回表</p><p>回表是发生在二级索引上的一种数据查询操作，简单点讲就是我们要查询的列不在二级索引的列中，那么就必须根据二级索引查到主键ID，然后再根据主键ID到聚簇索引树上去查询整行的数据，这一过程就叫作回表。</p></li><li><p>为什么会回表</p><p>写一个会回表查询的SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name, age, sex from index_opt_test where name=&apos;cc&apos; and title=&apos;T7&apos; and age=35;</span><br></pre></td></tr></table></figure><p>解析：</p><p>​SQL需要查询的列包括<code>id、name、age、sex</code>，查询条件命中索引<code>idx_cb</code>，其中列<code>id、name、age</code>都在索引<code>idx_cb</code>中可以获取到，但是<code>sex</code>不能通过索引获取到，必须要获取到整行数据之后再从结果中捞出来<code>sex</code>列的数据，这种情况就必须要回表。</p></li><li><p>什么情况下不需要回表</p><p>当所有的列都能在二级索引树中查询到，就不需要再回表了，这种情况就是索引覆盖。</p></li></ol><h3 id="索引覆盖"><a class="markdownIt-Anchor" href="#索引覆盖"></a> 索引覆盖</h3><ol><li><p>什么是索引覆盖</p><p>当SQL语句中查询的列都在索引中时，我们就不需要回表去把整行数据都捞出来了，可以从非聚簇索引树中直接获取到我们需要的列的数据，这就叫索引覆盖。简单点来讲就是：所有不需要回表的查询操作都叫索引覆盖。</p></li><li><p>为什么会发生索引覆盖</p><p>关于为什么会发生索引覆盖这个问题，通过一条SQL来理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name, age from index_opt_test where name=&apos;cc&apos; and title=&apos;T7&apos;;</span><br></pre></td></tr></table></figure><p>这条SQL要查询的列<code>id、name、age</code>全部都能从非聚簇索引<code>idx_cb</code>中直接查询出来，可能会有个疑问：我们的索引列是name、title和age，为什么id明明不在组合索引中却还能发生索引覆盖？提出这个问题的同学真的是欠我一顿小烧烤，非聚簇索引的叶子节点里存的是什么东西：主键的关键字啊，我们这里主键是id，他的关键字就是id的值啊，那我们通过非聚簇索引是不是可以直接将主键id查出来，是不是就不用再回表了，不用回表是不是就发生了索引覆盖啊，就是那么简单。</p></li></ol><h3 id="索引下推"><a class="markdownIt-Anchor" href="#索引下推"></a> 索引下推</h3><ol><li><p>什么是索引下推</p><p>索引下推又叫索引条件下推(Index Condition Pushdown，简称ICP)，ICP默认是开启的，使用ICP可以减少存储引擎访问基础表的次数和Server访问存储引擎的次数。</p><ul><li><p>ICP没有启用：Server层会根据索引的断桥原则将命中的索引字段推送到引擎层获取数据，并把匹配到的数据全部返回到Server层，由Server层再根据剩余的where条件进行过滤，即使where条件中有组合索引的其他未命中的字段，也会保留在Server层做筛选，然后返回给Client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name, sex from index_opt_test where name=&apos;cc&apos; and title like &apos;%7&apos; and sex=&apos;male&apos;;</span><br></pre></td></tr></table></figure><p>执行过程：</p><ol><li>Server层把name推到引擎层</li><li>引擎层根据name去idx_cb的索引树中匹配主键</li><li>回表去捞数据返回给Server层</li><li>Server层再根据title、sex筛选出最终的数据</li><li>最后返回给客户端</li></ol><p><img src="/images/image-20200410003327016.png" alt="image-20200410003327016"></p></li><li><p>ICP启用：Server层会将where条件中在组合索引中的字段全部推送到引擎层，引擎层根据断桥原则匹配出索引数据，然后将其他索引字段带入再进行一次筛选，然后拿最终匹配的主键关键字回表查询出数据后返回给Server层，Server层再根据剩余的where条件做一次筛选，然后返回给Client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name, sex from index_opt_test where name=&apos;cc&apos; and title like &apos;%7&apos; and sex=&apos;male&apos;;</span><br></pre></td></tr></table></figure><p>执行过程：</p><ol><li>Server把name和title都推到引擎层</li><li>引擎层根据name去idx_cb中查询出主键关键字和title、age</li><li>再由title筛选出匹配的主键关键字</li><li>回表去捞数据返回给Server层</li><li>Server层再根据sex筛选出最终的数据</li><li>再返回给客户端</li></ol><p><img src="/images/image-20200410003348304.png" alt="image-20200410003348304"></p></li></ul></li><li><p>索引下推适用条件</p><ul><li>ICP 用于访问方法是 <code>range/ref/eq_ref/ref_or_null</code>，且需要访问表的完整行记录。</li><li>ICP适用于 InnoDB 和 MyISAM 的表，包括分区的表。</li><li>对于 InnoDB 表，ICP只适用于二级索引。ICP 的目标是减少访问表的完整行的读数量从而减少 I/O 操作。对于 InnoDB 的聚簇索引，完整的记录已经读进 InnoDB 的缓存，使用 ICP 不能减少 I/O 。</li><li>ICP 不支持建立在虚拟列上的二级索引（InnoDB 支持在虚拟列上建立二级索引）。</li><li>引用子查询、存储函数的条件没法下推，Triggered conditions 也没法下推。</li></ul><p>所以ICP 适用的一个隐含前提是二级索引必须是组合索引、且在使用索引进行扫描时只能采用最左前缀匹配原则。组合索引后面的列出现在 where 条件里，因此可以先过滤索引元组、从而减少回表读的数量。</p></li><li><p>为什么会发生索引下推</p><p>索引下推在5.6版本加入的，默认开启，可以通过命令<code>SHOW VARIABLES like '%optimizer_switch%'</code>查看当前状态</p><img src="/images/image-20200410001946545.png" alt="image-20200410001946545" style="zoom: 50%;"><ul><li><p>关闭索引下推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_switch = &apos;index_condition_pushdown=off&apos;;</span><br></pre></td></tr></table></figure><p>执行之后查看一下状态：</p><img src="/images/image-20200410002144781.png" alt="image-20200410002144781" style="zoom:50%;"><p>然后我们执行一下SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select id, name, sex from index_opt_test where name=&apos;cc&apos; and title like &apos;%7&apos; and sex=&apos;male&apos;;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200410002324446.png" alt="image-20200410002324446"></p><p>从执行计划我们可以看出当我们关闭索引下推后，Extra中的是<code>Using where</code></p></li><li><p>开启索引下推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_switch = &apos;index_condition_pushdown=on&apos;;</span><br></pre></td></tr></table></figure><p>执行之后查看一下状态：</p><img src="/images/image-20200410001946545.png" alt="image-20200410001946545" style="zoom: 50%;"><p>然后我们执行以下SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select id, name, sex from index_opt_test where name=&apos;cc&apos; and title like &apos;%7&apos; and sex=&apos;male&apos;;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200410002808326.png" alt="image-20200410002808326"></p><p>从执行计划中看到使用了<code>Using index condition</code>和<code>Using where</code>，<code>Using index condition</code>说明ICP生效了，title被推到了引擎层，而<code>Using where</code>是因为where条件中的sex字段</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备&quot;&gt;&lt;/a&gt; 准备&lt;/h3&gt;
&lt;p&gt;创建一张表，并创建一个自增主键索引和一个组合索引&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
      <category term="索引" scheme="http://luxiaowan.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL聚簇索引和非聚簇索引</title>
    <link href="http://luxiaowan.github.io/2020/04/09/MySQL%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
    <id>http://luxiaowan.github.io/2020/04/09/MySQL聚簇索引和非聚簇索引/</id>
    <published>2020-04-09T10:00:00.000Z</published>
    <updated>2020-04-09T12:20:19.744Z</updated>
    
    <content type="html"><![CDATA[<h3 id="聚簇索引"><a class="markdownIt-Anchor" href="#聚簇索引"></a> 聚簇索引</h3><p>聚簇索引是指叶子节点存储的是一整行记录，比如InnoDB的主键索引，主键和表数据存储在一起。聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，因为一行数据不能同时存储在两个地方，所以一张表中只能有一个聚簇索引，因为一张表的数据存储顺序只能是一种，故只有InnoDB主键索引是聚簇索引。</p><p>聚簇索引的存放顺序和数据的物理存储顺序是一致的，即只要是索引是挨着的，那么对应的数据在磁盘上的存储位置一定也是挨着的。</p><p>这里有一个问题：如果我们不用自增的字段作为主键，而使用字符串的话，会有什么不妥的地方？我们来分析看下：</p><ul><li>自增主键：按照主键的值按顺序递增，也就是会一直往后添加数据，只需要分配新页就可以了，那么已经存储了数据的页就永远不会再分裂，物理地址则不需要变动</li><li>字符串：需要根据字符串的ASSIC码值进行计算所要存储的位置，这个过程中会引起已存储数据的物理地址发生变动，并且需要不断的进行页的分裂，带来的性能开销非常大</li></ul><h4 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> 优势</h4><ol><li>可以一次性将相邻的数据加载到内存中，减少了磁盘IO次数</li><li>由于聚簇索引是将索引和数据存储在一起，那么我们找到索引位置的时候实际上就是找到了具体的数据，否则还要进行一次磁盘IO去将最终数据捞出来</li></ol><h4 id="劣势"><a class="markdownIt-Anchor" href="#劣势"></a> 劣势</h4><ol><li>插入速度严重依赖于插入顺序：如果使用的是非自增主键，则可能需要进行页的分裂，非常影响性能</li><li>主键更新代价大：更新一次主键，可能导致被更新的行发生移动，引起页的分裂，非常影响性能</li><li>二级索引查询需要再次根据主键索引回表查询整行数据，因为InnoDB的二级索引的叶子节点存储的是主键的值</li></ol><h3 id="非聚簇索引"><a class="markdownIt-Anchor" href="#非聚簇索引"></a> 非聚簇索引</h3><p>非聚簇索引的叶子节点存储的是主键值或行数据存储的物理位置，MyIsam甭管是主键还是非主键索引都是非聚簇索引索引，InnoDB的非主键索引用的也是非聚簇索引，但是这两种存储引擎的非主键索引的叶子节点存储的内容是不同的。</p><ul><li>InnoDB非聚簇索引：叶子节点存储的是主键关键字，当聚簇索引发生页分裂或移动时(主键关键字未变)，非聚簇索引不需要改变</li><li>MyIsam非聚簇索引：所有索引的叶子节点存储的都是行数据的物理磁盘存储地址，只要行数据发生位置移动时，会引起所有的索引发生改变</li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><p>聚簇索引叶子节点存储的是行数据，非聚簇索引的叶子节点存储的是主键关键字或数据物理存储地址</p></li><li><p>InnoDB的主键索引是聚簇索引，InnoDB的二级索引和MyIsam的所有索引都是非聚簇索引</p></li><li><p>InnoDB非聚簇索引叶子节点存储的是主键关键字，MyIsam非聚簇索引叶子节点存储的是数据物理存储地址</p></li><li><p>聚簇索引尽量使用自增列，可以减少页分裂和行存储位置移动，提升性能</p></li></ul><p><img src="/images/image-20200409193050867.png" alt="image-20200409193050867"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;聚簇索引&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#聚簇索引&quot;&gt;&lt;/a&gt; 聚簇索引&lt;/h3&gt;
&lt;p&gt;聚簇索引是指叶子节点存储的是一整行记录，比如InnoDB的主键索引，主键和表数据存储在一起。聚簇索引并不是一种单独的索引类型，而是一
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
      <category term="索引" scheme="http://luxiaowan.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引类型</title>
    <link href="http://luxiaowan.github.io/2020/04/09/MySQL%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B/"/>
    <id>http://luxiaowan.github.io/2020/04/09/MySQL索引类型/</id>
    <published>2020-04-09T07:49:49.544Z</published>
    <updated>2020-04-09T09:38:13.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引类型"><a class="markdownIt-Anchor" href="#索引类型"></a> 索引类型</h3><p>MySQL中我们常用的索引类型有五种：</p><ol><li>普通索引</li><li>唯一索引</li><li>主键索引</li><li>组合索引</li><li>全文索引</li></ol><p>创建表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `INDEX_TEST` (</span><br><span class="line">  `id` int(11) DEFAULT NULL,</span><br><span class="line">  `name` varchar(11) DEFAULT NULL,</span><br><span class="line">  `idno` varchar(11) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `sex` varchar(11) DEFAULT NULL,</span><br><span class="line">  `content` varchar(500) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h3 id="普通索引"><a class="markdownIt-Anchor" href="#普通索引"></a> 普通索引</h3><p>最基本的一种索引，没有任何限制，可以为null，可以重复，普通索引的目的就是为了加快对数据的访问速度，为那些常被用来作查询条件的字段创建一个索引</p><p>SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE INDEX_TEST ADD INDEX idx_normal(name);</span><br></pre></td></tr></table></figure><h3 id="唯一索引"><a class="markdownIt-Anchor" href="#唯一索引"></a> 唯一索引</h3><p>与普通索引类似，但是不同点在于被索引的字段的值不能重复，但是可以为null，比如身份证、员工编号等必须唯一的信息，被设置了唯一索引的字段在整张表中都不能重复</p><p>SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE INDEX_TEST ADD UNIQUE idx_unique(idno);</span><br></pre></td></tr></table></figure><h3 id="主键索引"><a class="markdownIt-Anchor" href="#主键索引"></a> 主键索引</h3><p>与唯一索引类似，但是不同点是字段值不能为null，一般一张表只能有一个主键。实际上每张表都要有一个主键字段，通常情况下我们都是在创建表的时候手动添加，如果一张InnoDB引擎的表未明确主键字段，那么InnoDB引擎会自动为表创建一个隐式的自增主键，所以最优的情况下，我们最好手动创建一个自增主键。</p><p>SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE INDEX_TEST ADD PRIMARY KEY idx_pk(id);</span><br></pre></td></tr></table></figure><p>创建索引的时候，索引名称可以不写。</p><h3 id="组合索引"><a class="markdownIt-Anchor" href="#组合索引"></a> 组合索引</h3><p>组合索引是创建一个包含表中多个字段的索引，组合索引的使用遵循&quot;断桥原则&quot;，也叫&quot;最左前缀原则&quot;，我们在使用组合索引的时候，会从第一个往后匹配，使用顺序影响不大，因为MySQL的优化器会进行再次优化，如果中间有断桥(漏掉了中间一个或多个字段)，则断桥左侧的字段才会被用到索引。</p><p>比如索引字段(a, b, c)，有以下情况：</p><ul><li><p>where a and c and b：索引字段全部命中</p><img src="/images/image-20200409172431883.png" alt="image-20200409172431883" style="zoom:50%;"></li><li><p>where a and c：索引命中a</p><img src="/images/image-20200409172638836.png" alt="image-20200409172638836" style="zoom:50%;"></li><li><p>where a and b：索引命中a、b</p><img src="/images/image-20200409172717610.png" alt="image-20200409172717610" style="zoom:50%;"></li><li><p>where b and c：索引未命中</p><img src="/images/image-20200409172802182.png" alt="image-20200409172802182" style="zoom:50%;"></li><li><p>where a and b order by c：索引字段全部命中</p><img src="/images/image-20200409172431883.png" alt="image-20200409172431883" style="zoom:50%;"></li></ul><p>SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE INDEX_TEST ADD INDEX idx_cb(age, sex);</span><br></pre></td></tr></table></figure><h3 id="全文索引"><a class="markdownIt-Anchor" href="#全文索引"></a> 全文索引</h3><p>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多，因为建表的时候表中没有数据，而已经有了数据再创建的话，要将已存在的数据都先fulltext一下，所以慢。</p><p>SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE INDEX_TEST ADD FULLTEXT idx_fulltext(content);</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>最终我们的表创建语句变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `index_test` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(11) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `sex` varchar(11) DEFAULT NULL,</span><br><span class="line">  `content` varchar(500) DEFAULT NULL,</span><br><span class="line">  `idno` varchar(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),# 主键索引</span><br><span class="line">  UNIQUE KEY `idx_unique` (`idno`),# 唯一索引</span><br><span class="line">  KEY `normal_index` (`name`),# 普通索引</span><br><span class="line">  KEY `idx_cb` (`age`,`sex`),# 组合索引</span><br><span class="line">  FULLTEXT KEY `idx_fulltext` (`content`)# 全文索引</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#索引类型&quot;&gt;&lt;/a&gt; 索引类型&lt;/h3&gt;
&lt;p&gt;MySQL中我们常用的索引类型有五种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普通索引&lt;/li&gt;
&lt;li&gt;唯一索引&lt;/li&gt;
&lt;li&gt;主键索引&lt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
      <category term="索引" scheme="http://luxiaowan.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL自适应Hash索引</title>
    <link href="http://luxiaowan.github.io/2020/04/09/MySQL%E8%87%AA%E9%80%82%E5%BA%94Hash%E7%B4%A2%E5%BC%95/"/>
    <id>http://luxiaowan.github.io/2020/04/09/MySQL自适应Hash索引/</id>
    <published>2020-04-09T06:40:00.000Z</published>
    <updated>2020-04-09T07:45:31.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hash索引"><a class="markdownIt-Anchor" href="#hash索引"></a> Hash索引</h3><p>Hash是一种查找数据非常快的数据结构，在正常情况下这种查找的时间复杂度为O(1)，即一般仅需要一次查找就能定位数据，正常情况是指不存在哈希冲突的情况；而B+树的查找次数，取决于B+树的高度，B+树的高度一般为3<sub>4层，所以一般最少需要3</sub>4次的查询。</p><h3 id="innodb的hash索引"><a class="markdownIt-Anchor" href="#innodb的hash索引"></a> InnoDB的Hash索引</h3><p>InnoDB存储引擎会监控对表上各索引页的查询，如果监控到某个索引页被频繁查询，并诊断后发现如果为这一页的数据创建Hash索引会带来更大的性能提升，则会自动为这一页的数据创建Hash索引，并称之为自适应Hash索引。自适应Hash是通过缓冲池中B+树的页进行构建的，建立速度很快，不需要对整张表的数据都构建Hash索引，所以我们又可以把自适应Hash索引看成是索引的索引，。注意一点就是InnoDB只会对热点页构建自适应索引，且是由InnoDB自动创建和删除的，所以不能人为干预是否在一张InnoDB的表中创建Hash索引。</p><h3 id="自适应hash索引"><a class="markdownIt-Anchor" href="#自适应hash索引"></a> 自适应Hash索引</h3><p>官方有告诉我们每一种存储引擎所支持的索引结构，在https://dev.mysql.com/doc/refman/5.7/en/create-index.html中可以查看，我们截图保留下：</p><p><img src="/images/image-20200409150053986.png" alt="image-20200409150053986"></p><p>我们可以看到MyIsam和InnoDB仅支持BTree结构的索引，但是我们在创建的时候却有Hash结构可选择，这是因为啥？细心的话可以发现不论我们在创建索引的时候选择了Hash还是BTree，在保存的时候都会自动转换成BTree，就是这个原因。</p><p>但是我们又在官方的https://dev.mysql.com/doc/refman/5.7/en/innodb-adaptive-hash.html页面看到这么一句话：</p><p><img src="/images/image-20200409150834710.png" alt="image-20200409150834710"></p><p>大致意思是：自适应Hash索引特征能使InnoDB在具有适当的工作负载和足够缓冲池内存的系统上执行的更像内存中的数据库的操作，且不会牺牲事务特性或可靠性，MySQL能基于监视到的搜索规则，使用索引键的前缀构建Hash索引，前缀可以是任意长度，并且可能只有b+树中的某些值出现在Hash索引中，Hash索引其实就是对经常访问的索引页进行构建的。</p><p>这又说明其实InnoDB是支持Hash索引的，但并不是真正意义上的Hash，而是通过自己的监视情况自动对某些热点索引值构建的内存Hash。</p><h3 id="开启和关闭"><a class="markdownIt-Anchor" href="#开启和关闭"></a> 开启和关闭</h3><p>默认情况下自适应索引是开启状态，毕竟是可以提升性能的嘛，我们也可以通过命令开启和关闭，并可以查看自适应索引的</p><ul><li><p>开启</p><p>默认就是开启的，可以通过命令<code>show variables like 'innodb_adaptive_hash_index';</code>查看自适应哈希索引的状态，并可以在命令行通过<code>show engine innodb status\G</code>查看自适应Hash索引的使用信息(AHI的大小，使用情况，每秒使用AHI搜索的情况等等)</p><img src="/images/image-20200409154256344.png" alt="image-20200409154256344" style="zoom:50%;"></li><li><p>关闭</p><p>负载较重的情况下，就不太适合开启自适应Hash索引了，因为这样可以避免额外的索引维护带来的开销，可以在启动的时候通过参数<code>--skip-innodb-adaptive-hash-index</code>关闭</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;hash索引&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hash索引&quot;&gt;&lt;/a&gt; Hash索引&lt;/h3&gt;
&lt;p&gt;Hash是一种查找数据非常快的数据结构，在正常情况下这种查找的时间复杂度为O(1)，即一般仅需要一次查找就能定位数据，正
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
      <category term="索引" scheme="http://luxiaowan.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的Hash索引相关</title>
    <link href="http://luxiaowan.github.io/2020/04/09/MySQL%E7%9A%84Hash%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://luxiaowan.github.io/2020/04/09/MySQL的Hash索引相关/</id>
    <published>2020-04-09T02:20:00.000Z</published>
    <updated>2020-04-09T16:49:28.507Z</updated>
    
    <content type="html"><![CDATA[<p>hash索引结构使用方式较为局限，仅适用于=、IN和&lt;=&gt;三种，但是由于通过hash可以直接查找到具体的值，而不用像B+树那样每次都从root节点开始遍历，所以在通常情况下，hash的查找效率要比B+树高。</p><p>hash的缺陷：</p><h6 id="1-hash不能进行范围查找"><a class="markdownIt-Anchor" href="#1-hash不能进行范围查找"></a> 1. hash不能进行范围查找</h6><p>值在计算hash后，并不能保证计算后的hash值和计算前的大小排列一样，所以hash不适用于范围查找</p><h6 id="2-hash不能进行排序查询"><a class="markdownIt-Anchor" href="#2-hash不能进行排序查询"></a> 2. hash不能进行排序查询</h6><p>值计算后的hash值无法保证与原值大小顺序一样，所以无法进行排序</p><h6 id="3-组合索引不能使用部分字段查询"><a class="markdownIt-Anchor" href="#3-组合索引不能使用部分字段查询"></a> 3. 组合索引不能使用部分字段查询</h6><p>组合索引的hash值是所有索引字段的值组合在一起进行计算的，若仅使用部分字段进行查询的话，计算出的hash值基本不会与索引的hash值相同</p><h6 id="4-hash在出现大量值碰撞的时候性能会降低"><a class="markdownIt-Anchor" href="#4-hash在出现大量值碰撞的时候性能会降低"></a> 4. hash在出现大量值碰撞的时候，性能会降低</h6><p>hash出现大量的值相等的时候，需要进行表扫描以进行精确匹配，效率较低</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hash索引结构使用方式较为局限，仅适用于=、IN和&amp;lt;=&amp;gt;三种，但是由于通过hash可以直接查找到具体的值，而不用像B+树那样每次都从root节点开始遍历，所以在通常情况下，hash的查找效率要比B+树高。&lt;/p&gt;
&lt;p&gt;hash的缺陷：&lt;/p&gt;
&lt;h6 id=
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
      <category term="索引" scheme="http://luxiaowan.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎下的索引</title>
    <link href="http://luxiaowan.github.io/2020/04/09/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%8B%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://luxiaowan.github.io/2020/04/09/MySQL存储引擎下的索引/</id>
    <published>2020-04-09T01:55:00.000Z</published>
    <updated>2020-04-09T06:39:18.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql存储引擎"><a class="markdownIt-Anchor" href="#mysql存储引擎"></a> MySQL存储引擎</h3><p>MySQL支持多种存储引擎，我们可以通过<code>show engines</code>命令查看当前数据库所支持的存储引擎列表，那么不同存储引擎下的索引实现方式是否会有所不同？那是当然的，但只不过都大同小异而已，我们目前常用的存储引擎大多是InnoDB，主要是因为InnoDB支持事务、行锁、外键等功能，第二常用的就是MyIsam，但是在MySQL5.5版本之后，InnoDB就变成了默认的存储引擎，也可以看出InnoDB的强大和普适性。我们主要记录InnoDB和MyIsam下的索引实现。</p><h3 id="myisam下的索引"><a class="markdownIt-Anchor" href="#myisam下的索引"></a> MyIsam下的索引</h3><p>MyIsam使用B+树作为索引结构，叶子节点存储的是目标数据的内存地址，大致结构图如下：</p><img src="/images/image-20200409120924556.png" alt="image-20200409120924556" style="zoom: 33%;"><p>我们发现，每一个叶子节点内存储的都是指向具体数据的内存地址，可以通过地址直接找到数据。那么我们是不是可以推算出MyIsam的索引在磁盘上是怎么存储的？</p><p>第一：索引存储的是具体数据的地址，和数据没有关系，只要通过地址就可以找到具体数据了</p><p>第二：索引可以单独维护，数据也可以单独维护，就比如是两个微服务项目</p><p>由这两点，我们可以推断出MyIsam的索引和数据应该是分开存储的，即索引存储一个文件，数据存储一个文件，当然还应该有表结构定义要单独一个文件，那么一张表是可以创建非常多的索引，是所有的索引都放在一个文件里，还是每个索引都创建一个文件，文件怎么命名？我们去MySQL的data目录下看看</p><img src="/images/image-20200409111403166.png" alt="image-20200409111403166" style="zoom: 50%;"><p>这个目录下有很多的文件夹，每一个文件夹都对应了我们一个用户库，这说明每个库其实都是相互隔离的，隔离的方式就是以目录的形式，我们进到db_test目录下</p><img src="/images/image-20200409111450620.png" alt="image-20200409111450620" style="zoom:50%;"><p>我们事先在db_test库中创建了一张MyIsam引擎的表myisam_db(id, name)，并且创建了name字段的索引和id的主键索引，看到这一张表对应了三个文件，且文件是以表的名字命名的</p><ul><li>*.frm：记录描述表结构文件，字段长度等</li><li>*.MYI：索引信息文件，记录所有的索引，My Index</li><li>*.MYD：数据信息文件，存储数据信息， My Data</li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>MyIsam的索引是B+树的数据结构，叶子节点中存储的是数据的地址，实现了索引和数据分离，查询的过程中通过值找到数据地址，然后再根据数据地址将地址内存储的数据捞出返回。</p><p>其实我们可以单独的根据文件的存储方式反推出索引的存储策略了，自己反推试试</p><h3 id="innodb下的索引"><a class="markdownIt-Anchor" href="#innodb下的索引"></a> InnoDB下的索引</h3><p>InnoDB和MyIsam一样都是采用B+树作为索引的数据结构，不同的在于InnoDB的叶子节点存储的是具体数据，而不是内存地址</p><p><img src="/images/image-20200409120652368.png" alt="image-20200409120652368"></p><p>我们都知道MySQL的每张表都必须创建一个主键索引，如果建表时未指定主键，那么MySQL引擎会选择一个非空唯一索引来当主键，若非空唯一索引也没有，那就会自动给添加一个自增的列来作为虚主键，InnoDB和MyIsam在存储上最大的一个区别就是索引和数据在同一个文件中，我们看一下InnoDB的表在磁盘上是怎么存储的。我们先在db_test中创建一张使用InnoDB存储引擎的表innodb_db，然后到/data/db_test目录下查看文件</p><img src="/images/image-20200409121451757.png" alt="image-20200409121451757" style="zoom:50%;"><p>磁盘上针对innodb_test表仅生成了两个文件，*.frm是表结构和字段描述等基础信息文件，重点来说一下*.ibd文件。</p><ul><li>表空间(Tablespace)</li></ul><p>ibd是单表表空间文件，每个表使用一个表空间文件，存放用户数据库表数据、索引，InnoDB的每个数据文件都归属于一个表空间，不同的表空间都有唯一的标识space id来标记，系统表空间文件为ibdata1, ibdata2…，公用同一个表空间，用户创建的表产生的ibd文件都使用唯一的space id，只包含一个文件。</p><ul><li>页(Page)</li></ul><p>表空间文件，其中最基本的单位是页(Page)，每一个Page的大小默认为16k，所以ibd的大小必定是16k的整数倍，当然也可以通过<code>innodb_page_size</code>选项将页大小减少到8KB或4KB，或增加到32KB或64KB，但是只能在实例初始化之前设置，不支持动态设置。每个页由header、body、trailer等组成，header标识了类型和checksum信息，可以根据header的类型将body解析成对应的类型，body记录详细的内容，trailer则通过记录checksum等信息来确认该页是否已经写入完成。</p><ul><li>区(Extent)</li></ul><p>Extent用于管理Page，每64个Page组成一个Extent，大小默认为1M，一个Extent内的所有页都是连续的，当表空间页容量不足要分配新页的时候，不会一页一页的分配，会一次性分配一个Extent，也就是连续的64个Page</p><ul><li>段(Segment)</li></ul><p>Segment用于管理Extent，一个表至少会有两个Segment，一个用于管理叶子节点的Extent，一个用于管理非叶子节点的Extent，每增加一个索引就会多出两个Segment，一张表的Segment数量=索引数量*2</p><h3 id="memory下的索引"><a class="markdownIt-Anchor" href="#memory下的索引"></a> Memory下的索引</h3><p>memory存储引擎是MySQL中的一类特殊的存储引擎。其使用存储在内存中的内容来创建表，而且所有数据也放在内存中，很少用到，至今我没用到过，不过在information_schema库中有很多使用Memory引擎的表。</p><p>Memory存储引擎默认使用哈希(HASH)索引，其速度比使用B型树(BTREE)索引快。如果我们需要使用B型树索引，可以在创建索引时选择使用。</p><p>Hash索引基于哈希表实现，只有匹配所有列的查询才有效。对于每一行数据，存储引擎都会对所有索引列计算一个哈希码，哈希码是一个较小的值，不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时保存指向每个数据行的指针。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mysql存储引擎&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mysql存储引擎&quot;&gt;&lt;/a&gt; MySQL存储引擎&lt;/h3&gt;
&lt;p&gt;MySQL支持多种存储引擎，我们可以通过&lt;code&gt;show engines&lt;/code&gt;命令查看当前
      
    
    </summary>
    
    
    
      <category term="索引" scheme="http://luxiaowan.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引初识</title>
    <link href="http://luxiaowan.github.io/2020/04/08/MySQL%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86/"/>
    <id>http://luxiaowan.github.io/2020/04/08/MySQL索引初识/</id>
    <published>2020-04-08T14:10:00.000Z</published>
    <updated>2020-04-09T04:12:05.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引是什么"><a class="markdownIt-Anchor" href="#索引是什么"></a> 索引是什么</h3><p>索引是一种能够改变操作速度的特殊数据结构，索引的表达形式有很多种，生活中有很多用到索引的地方，我们举几个例子来理解：</p><ol><li>图书馆书目标签：给每一本书建立唯一的编号，将编号和书架位置做好一一映射，这样我们就可以通过&quot;类型-编号&quot;快速的找到我们想要的书；有的同学可能会说：我们在查找的时候都是通过书的名字去查询的，没有用书的编号去查询啊，但也能查出来，这又是为啥？艾玛~这不就是书名和编号又做了一对多映射了么(因为书名重复的时候会有多个编号，所以用一对多)，我们可以先通过书名找出书的编号，然后再根据编号找到书在书架的位置，然后一锤定音(了解过MySQL索引的这时候是不是立刻想到了回表这个词)。这里书编号、书名就是图书馆书目的索引</li><li>词典：我们这里说一下汉语词典，我们可以按拼音、笔画、偏旁部首等排序的目录快速查找到需要的字。这里拼音、笔画、偏旁部首等就是词典的索引</li><li>酒店房卡：我们住酒店的时候，如果自助办完手续后，自助机吐出给我们一张房卡，然后如果房卡上没有门牌号的话，我们需要挨个儿房间的去尝试，酒店要是有几百个房间且我们正巧是最后一个房间的话，那估计等找到房子已经该要退房了，哈哈~所以房卡上直接告诉了我们房号，我们可以根据房号直接找到我们要入住的房间。这里房间号就是酒店房间的索引。</li></ol><p>通过上面的例子，相信一定能理解索引是什么、作用是什么了吧，我们来总结一下：索引是标识一个物体/数据的特殊属性，这个属性可能是唯一的，也可能不是唯一的，可以是一个属性作索引，也可以是多个属性一起作索引。</p><h3 id="索引有什么用"><a class="markdownIt-Anchor" href="#索引有什么用"></a> 索引有什么用</h3><p>索引的作用是什么，我们为什么要用索引？</p><p>相信很多人都会有这个问题，其实在数据量很小的情况下，比如一眼就看得到所有数据，那就没必要用索引了，为什么没必要？因为本来数据量就少，如果创建了索引的话，我们每次还要去查索引，然后从索引再去查具体数据，是不是很麻烦？并且有新数据插入或者索引的数据变更的时候，还需要同步去修改索引的数值，不然就会造成索引出现脏数据和数据无对应的索引等情况；若不建立索引的话，遍历所有的数据去查询某一条或者某几条出来，耗时貌似也不大，并且还不用在修改插入数据的时候也不用耗时去维护索引。</p><p>但是在数据量较大的情况下，我们就必须要建立索引了，因为如果我们为了查找一条数据而要去遍历几十万条数据的话，耗时是相当大的，特别是如果恰巧我们要查的数据在倒数第一条，那就彻底崩溃了，所以我们需要为数据集依据查询条目建立索引，我们先根据条件查询出来索引，然后把索引指向的存储位置上的数据捞出来直接返回就行了，是不是很方便？当然插入更新数据引起的索引更新相对于无索引查询带来的消耗来说，微乎其微。</p><p>聊到这里，肯定有一个疑问：我们在查询索引时不一样是要遍历所有的索引吗？这和遍历数据集中的所有数据有什么区别？</p><h3 id="索引结构"><a class="markdownIt-Anchor" href="#索引结构"></a> 索引结构</h3><p>为了解决索引的快速查询和命中，我们有哈希和树两种结构，在不同的MySQL存储引擎中支持的索引结构不同，比如MyIsam支持Hash，InnoDB支持树，并且是B+树，当然也知道Hash，但是属于是变形的Hash，和MyIsam中的不同，且Hash索引的创建和维护完全由MySQL自己决定，只有在数据量达到一定数量的时候才会创建Hash，但是使用Hash结构也是有缺陷的：</p><h5 id="hash结构索引"><a class="markdownIt-Anchor" href="#hash结构索引"></a> Hash结构索引</h5><ol><li><p>优势</p><p>Hash索引实际上就是采用一定的Hash算法，把键值转换成哈希值，检索的时候不需要像树那样从根开始找起，能够根据哈希值一次性定位到位置，所以在哈希冲突不严重的情况下，检索效率远高于树</p></li><li><p>缺陷</p><ul><li>只能匹配是否相等，不能实现范围查找，只能用于=、IN和&lt;&gt;</li><li>无法使用Order By进行排序</li><li>组合索引的时候，无法实现最左匹配，因为组合索引会将所有的字段整合一起做Hash计算，所以如果仅部分索引字段进行Hash计算的话，可能匹配到其他数据</li><li>当数据量越来越大的时候，哈希冲突会越来越严重，性能会下降的很严重</li></ul></li><li><p>结构图</p><img src="/images/135122_hash.png" alt="img" style="zoom:50%;"></li></ol><h5 id="树结构"><a class="markdownIt-Anchor" href="#树结构"></a> 树结构</h5><p>树有多种，MySQL中使用的是B+树，这是由B树演变而来的，B树又是从AVL树演变而来，我们分别来看一下各种树的结构和检索方式，然后推导出为什么MySQL使用B+树。</p><ol><li><p>AVL树</p><ul><li><p>结构</p><p><img src="/images/AVLtreef.png" alt="AVL树"></p></li><li><p>特征</p><p>在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡</p></li><li><p>作为索引</p><ul><li>每个节点均能存储数据</li><li>每一个节点都需要进行一次磁盘IO</li><li>由于每一个节点最多只能有两个子节点，所以在数据量大的时候，树的高度会很大</li></ul></li></ul></li><li><p>B树 (B-树)</p><ul><li><p>结构</p><img src="/images/btree.png" alt="B树" style="zoom:67%;"></li><li><p>特征</p><p>B树，概括来说是一个一般化的二叉查找树（binary search tree）一个节点可以拥有2个以上的子节点。与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。</p></li><li><p>作为索引</p><ul><li>解决AVL树每个节点只能存储一个数据的问题</li><li>减少AVL树查询过程中的IO次数</li></ul></li></ul></li><li><p>B+树</p><ul><li><p>结构</p><p><img src="/images/image-20200409120652368.png" alt="image-20200409120652368"></p></li><li><p>特征</p><p>B+树在非叶子节点存储关键字和指向下一节点的指针，仅在叶子节点存储数据，叶子节点之间依据关键字从小到大有序排列成一个有序链表；</p><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找；</p><p>所有的叶子节点都在同一高度上，对于所有内部节点，子指针的数目总是与元素的数目相同。</p></li><li><p>作为索引</p><ul><li>非叶子节点不保存关键字记录的指针，只进行数据索引，这样使非叶子节点能保存大量的关键字</li><li>所有的数据或数据地址只有在叶子节点才能获取到，所以每次查询所有的路径相同，查询稳定</li><li>非叶子节点的关键字都是从小到大有序排列</li><li>所有的叶子节点形成有序链表，方便于范围查询</li></ul></li></ul></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>以上的内容带我们认识了什么是索引、索引有什么用、索引有哪些存储结构，基本上对索引有了一个最基本的认识，通过对几个存储结构的分析，我们可以看出为什么MySQL选择B+树：每一次的演变都是为了提供更快的查询，如何加快查询效率，就是减少IO的操作次数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#索引是什么&quot;&gt;&lt;/a&gt; 索引是什么&lt;/h3&gt;
&lt;p&gt;索引是一种能够改变操作速度的特殊数据结构，索引的表达形式有很多种，生活中有很多用到索引的地方，我们举几个例子来理解：&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
      <category term="索引" scheme="http://luxiaowan.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>getClassLoader能否为null</title>
    <link href="http://luxiaowan.github.io/2020/04/08/getClassLoader%E8%83%BD%E5%90%A6%E4%B8%BAnull/"/>
    <id>http://luxiaowan.github.io/2020/04/08/getClassLoader能否为null/</id>
    <published>2020-04-08T01:30:00.000Z</published>
    <updated>2020-04-08T13:58:13.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>我们Javaer都知道类想要被加载是需要一个个ClassLoader来帮助的，并且类加载的方案叫双亲委派模式，说是双亲，其实就是单亲，可能我们最初的翻译人想让我们的加载器的家庭更完整吧，所以翻译成双亲。默认的类加载器包括BootstrapClassLoader、ExtClassLoader、AppClassLoader，他们都定义在在rt.jar中的<code>sun.misc.Launcher</code>类中，他们的&quot;继承&quot;关系是AppClassLoader—&gt;ExtClassLoader—&gt;BootstrapClassLoader，ExtClassLoader的parent获取不到BootstrapClassLoader，只能获取到一个null。</p><img src="/images/classloader.png" alt="classloader" style="zoom:67%;"><ol><li>bootstrap是C++编写的类加载器，主要加载%JRE_HOME/lib/目录下的jar包</li><li>ExtClassLoader主要加载%JRE_HOME/lib/ext目录下的jar包</li><li>AppClassLoader主要加载java环境变量CLASSPATH所指定的路径下的jar包和class文件，通过System.getProperty(“java.class.path”)获取考验获取CLASSPATH路径</li><li>用户自定义ClassLoader，加载用户自己制定的类</li></ol><h3 id="getclassloader会不会为空"><a class="markdownIt-Anchor" href="#getclassloader会不会为空"></a> getClassLoader会不会为空</h3><p>说了这么多，其实就是想说getClassLoader当然可能会为空，是不是此时会有个疑惑：加载器都为空了，那这个类是怎么加载的，被谁加载的？答：被BootstrapClassLoader加载的。</p><p>我们知道BootstrapClassLoader是由C++编写的，我们是用Java代码获取不到的，BootstrapClassLoader也不是ExtClassLoader的父类，而是它的父亲，这里要搞清关系，父亲和父类是两码事，父类是有继承关系，父亲是上一层的关系，所以我们在获取String、Integer、int、double、BufferedInputStream等等一系列在rt.jar包中被BootstrapClassLoader加载的类的加载器时，返回的都是null。</p><h3 id="extclassloader是怎么成为appclassloader的父亲的"><a class="markdownIt-Anchor" href="#extclassloader是怎么成为appclassloader的父亲的"></a> ExtClassLoader是怎么成为AppClassLoader的父亲的</h3><p>类加载器并非是继承关系，而是父子关系，就像上面说的BootstrapClassLoader是ExtClassLoader的父亲，不是父类。关键点就在于ClassLoader的实例变量parent，这个parent指定了当前类加载器的父亲，但是翻遍了AppClassLoader的代码也没发现是在哪里把ExtClassLoader设置进去的，怎么parent就是ExtClassLoader了呢。</p><p>刚才我们说这些类加载器被定义在了Launcher类中，那么我们就去看下这个类的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Launcher.ExtClassLoader var1;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取ExtClassLoader</span></span><br><span class="line">    var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取AppClassLoader实例并赋值给loader，并把ExtClassLoader的实例传入到方法中，</span></span><br><span class="line">    <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回AppClassLoader实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Launcher的构造器我们看到关键点在AppClassLoader.getAppClassLoader(var1)这句，那我们就看这个方法是怎么写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">    <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">    <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">      <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">        <span class="comment">// 关键看这一句，调用了AppClassLoader的构造器，并把ExtClassLoader实例传了进去，那就跳到构造器去看</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造器</span></span><br><span class="line">  AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">    <span class="comment">// 调用了父类的构造器，他的父类是哪个？从定义上看应该是URLClassLoader没跑了</span></span><br><span class="line">    <span class="keyword">super</span>(var1, var2, Launcher.factory);</span><br><span class="line">    <span class="keyword">this</span>.ucp.initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实再往里的代码就不用在这闲扯了，里面就是不断的将var2往上传递，直到ClassLoader这个类的构造器中，在ClassLoader中完成的设置。</p><h4 id="那为什么extclassloader没通过这种形式将bootstrapclassloader设置给parent呢"><a class="markdownIt-Anchor" href="#那为什么extclassloader没通过这种形式将bootstrapclassloader设置给parent呢"></a> 那为什么ExtClassLoader没通过这种形式将BootstrapClassLoader设置给parent呢？</h4><p>是不是傻，上面刚说了BootstrapClassLoader是C++写的，Java代码不能直观的获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;我们Javaer都知道类想要被加载是需要一个个ClassLoader来帮助的，并且类加载的方案叫双亲委派模式，说是双亲，其实就是单亲，可能我们最
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java获取项目中的文件</title>
    <link href="http://luxiaowan.github.io/2020/04/07/Java%E8%8E%B7%E5%8F%96%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>http://luxiaowan.github.io/2020/04/07/Java获取项目中的文件/</id>
    <published>2020-04-07T15:17:00.000Z</published>
    <updated>2020-04-07T15:43:48.016Z</updated>
    
    <content type="html"><![CDATA[<h3 id="classgetresource与classloadergetresource的区别"><a class="markdownIt-Anchor" href="#classgetresource与classloadergetresource的区别"></a> Class.getResource()与ClassLoader.getResource()的区别</h3><p><code>Class.getResource()</code>是指<code>AAA.class.getResource()</code></p><ol><li><p>Class.getResource(String name)：在当前class类的同一路径下查找资源</p></li><li><p>ClassLoader.getResource(String name)：在根目录下查找该资源文件，即&quot;/&quot;或classpath目录</p></li></ol><h3 id="粗解"><a class="markdownIt-Anchor" href="#粗解"></a> 粗解</h3><ol><li><p>在当前项目目录下查找指定的文件，此方式只能加载当前项目classpath下的文件，用.表示当前目录，不能以/开头，会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">URL url = ClassLoader.getSystemResource(<span class="string">"."</span>);</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">url = LoaderResourceTest.class.getClassLoader().getResource(<span class="string">"."</span>);</span><br></pre></td></tr></table></figure><p>url会输出当前class文件所在的根目录，比如当前我输出的结果就是<code>file:/Users/chuan/Documents/projects_code/java-project/demo/demo-core/target/classes/</code></p></li><li><p>以当前类所在的目录为基础，在当前目录查找并加载指定名称的资源文件，比如当前类LoaderResourceTest在项目的<code>cc.kevinlu.demo.core.loader</code>包中，若是我们以<code>LoaderResourceTest.class.getResource(&quot;LoaderT.class&quot;)</code>的方式加载一个文件，则首先会在<code>cc.kevinlu.demo.core.loader</code>包中查找LoaderT.class文件，若查找不到则返回null，如果我们想要加载其他包中的文件，则可以使用&quot;/&quot;开头并加上文件在项目中的完整包路径，比如<code>LoaderResourceTest.class.getResource(&quot;/cc/kevinlu/demo/core/gof/facade/FacadeTest.class&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前类所在的包目录</span></span><br><span class="line">url = LoaderResourceTest.class.getResource(<span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取其他包内的文件</span></span><br><span class="line">url = LoaderResourceTest.class.getResource(<span class="string">"/cc/kevinlu/demo/core/gof/facade/FacadeTest.class"</span>);</span><br></pre></td></tr></table></figure><p>这两条语句的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file:/Users/chuan/Documents/projects_code/java-project/demo/demo-core/target/classes/cc/kevinlu/demo/core/loader/</span><br><span class="line"></span><br><span class="line">file:/Users/chuan/Documents/projects_code/java-project/demo/demo-core/target/classes/cc/kevinlu/demo/core/gof/facade/FacadeTest.class</span><br></pre></td></tr></table></figure><p>由此可以很明显的看出Class的getResource是获取当前类所在的包目录，如果不同的包中都有相同名称的资源文件，但是仅针对当前包可用，那么就可以使用这种方式去加载读取，不会出现读到其他目录的文件的情况，但是这仅受限于我们写的类，不适用于jar包中的。</p></li><li><p>如果我们想读取项目中引用的jar包内的文件，那么怎么办？其实和读取项目中自己写的文件是相同的办法，因为在系统启动的时候会将jar包中的文件加载到classpath目录下，所以读取方式一样的。</p></li><li><p>以上讲解的只是读取单个资源，那么要是想把所有匹配到的资源都获取到，则可以使用<code>Class.getClassLoader().getResources()</code>和<code>ClassLoader.getSystemResources()</code>两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = LoaderResourceTest.class.getClassLoader().getResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">  System.out.println(urls.nextElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--ClassLoader.getSystemResources--"</span>);</span><br><span class="line">urls = ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">  System.out.println(urls.nextElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读取资源文件内容方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = LoaderResourceTest.class.getClassLoader().getResourceAsStream(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">  System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="整个测试文件代码"><a class="markdownIt-Anchor" href="#整个测试文件代码"></a> 整个测试文件代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.kevinlu.demo.core.loader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.admin.SpringApplicationAdminMXBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoaderResourceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前项目目录下查找指定的文件，此方式只能加载当前项目classpath下的文件，用.表示当前目录，不能以/开头，会报错</span></span><br><span class="line">        URL url = ClassLoader.getSystemResource(<span class="string">"."</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此方式和ClassLoader.getSystemResource一样</span></span><br><span class="line">        url = LoaderResourceTest.class.getClassLoader().getResource(<span class="string">"."</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以当前类所在的目录为基础，在当前目录查找并加载指定名称的资源文件，比如当前类LoaderResourceTest在</span></span><br><span class="line">        <span class="comment">// 项目的cc.kevinlu.demo.core.loader包中，若是我们以LoaderResourceTest.class.getResource("LoaderT.class")的</span></span><br><span class="line">        <span class="comment">// 方式加载一个文件，则首先会在cc.kevinlu.demo.core.loader包中查找LoaderT.class文件，若查找不到则返回null，如果我们想要加载其他包中的文件，</span></span><br><span class="line">        <span class="comment">// 则可以使用/开头并加上文件在项目中的完整包路径，比如LoaderResourceTest.class.getResource("/cc/kevinlu/demo/core/gof/facade/FacadeTest.class")                                                                                              </span></span><br><span class="line">        url = LoaderResourceTest.class.getResource(<span class="string">"."</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        url = LoaderResourceTest.class.getResource(<span class="string">"/cc/kevinlu/demo/core/gof/facade/FacadeTest.class"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取jar包内的文件有以下方式</span></span><br><span class="line">        <span class="comment">// 1. 使用Class.getClassLoader().getResource()，这种方式只能获取第一个匹配到的文件</span></span><br><span class="line">        System.out.println(<span class="string">"************"</span>);</span><br><span class="line">        url = LoaderResourceTest.class.getClassLoader().getResource(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        System.out.println(<span class="string">"************"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用Class.getResource()，这种方式也只能获取第一个匹配到的文件</span></span><br><span class="line">        url = LoaderResourceTest.class.getResource(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用ClassLoader.getSystemResource()方法，这种也仅仅只是获取第一个匹配的文件</span></span><br><span class="line">        url = ClassLoader.getSystemResource(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 那我们如果想要获取到所有匹配到的文件要怎么办呢？那么就使用Class.getClassLoader().getResources()，这个方法会返回一个Enumeration&lt;URL&gt;实例，</span></span><br><span class="line">        <span class="comment">// 我们迭代返回的这个实例就可以读取所有匹配到的所有文件了，如果没有匹配到任何文件也可以大胆的去迭代，不用判空，因为在getResources方法中进行了非空封装</span></span><br><span class="line">        System.out.println(<span class="string">"-----"</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; urls = LoaderResourceTest.class.getClassLoader().getResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            System.out.println(urls.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----"</span>);</span><br><span class="line">        urls = ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            System.out.println(urls.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果想要读取文件的具体内容，那么我们就要用到文件流了，常用的方法就是使用BufferedReader去读了</span></span><br><span class="line">        <span class="comment">// getResourceAsStream()方法，它相当于你用getResource()取得File文件后，再new InputStream(file)一样的结果</span></span><br><span class="line">        InputStream is = LoaderResourceTest.class.getClassLoader().getResourceAsStream(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i == <span class="number">1</span> &amp;&amp; (line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******"</span>);</span><br><span class="line">        url = SpringApplicationAdminMXBean.class.getResource(<span class="string">"."</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;classgetresource与classloadergetresource的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#classgetresource与classloadergetresource的区别&quot;&gt;&lt;/a&gt; Cla
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>运行Jar包时指定启动端口</title>
    <link href="http://luxiaowan.github.io/2020/04/02/%E8%BF%90%E8%A1%8Cjar%E5%8C%85%E6%97%B6%E6%8C%87%E5%AE%9A%E5%90%AF%E5%8A%A8%E7%AB%AF%E5%8F%A3/"/>
    <id>http://luxiaowan.github.io/2020/04/02/运行jar包时指定启动端口/</id>
    <published>2020-04-02T13:30:00.000Z</published>
    <updated>2020-04-02T13:32:00.255Z</updated>
    
    <content type="html"><![CDATA[<p>java -jar xxx.jar --server.port=9090</p><blockquote><p>–server.port一定要在最后</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java -jar xxx.jar --server.port=9090&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;–server.port一定要在最后&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>聊一聊SPI</title>
    <link href="http://luxiaowan.github.io/2020/04/02/%E8%81%8A%E4%B8%80%E8%81%8ASPI/"/>
    <id>http://luxiaowan.github.io/2020/04/02/聊一聊SPI/</id>
    <published>2020-04-01T17:10:00.000Z</published>
    <updated>2020-04-05T14:06:22.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>SPI全称是Service Provider Interface，是一种服务发现机制（哎，服务发现机制？和Zookeeper什么关系？）。SPI 的本质是将接口实现类的全限定名配置在文件META-INFO/services目录下以接口全限定名命名的文件中，并由服务加载器(ServiceLoader)读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p><p><img src="/images/image-20200405012001538.png" alt="image-20200405012001538"></p><h3 id="使用方式"><a class="markdownIt-Anchor" href="#使用方式"></a> 使用方式</h3><ul><li><p>场景</p><p>如果在使用过程中需要动态替换接口类的实现逻辑，那么比较适合使用SPI。比如<code>java.sql.Driver</code>。</p></li><li><p>方式</p><ol><li>在服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以接口全限定名为命名的文件，内容为实现类的全限定名</li><li>通过maven引入接口实现类所在的jar包，或者将jar包放到应用的classpath中</li><li>通过java.util.ServiceLoder动态装载接口实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM</li><li>SPI的实现类必须有一个无参的public构造器</li></ol></li><li><p>疑问</p><ul><li><p>为什么要把定义放在META-INF/services目录下？</p><p>这个目录位置是在ServiceLoader中定义的，并且还是final不能修改的，所以还是乖乖遵守吧，因为ServiceLoader也是final的，所以也不能从这个类进行扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么需要一个无参的public构造器？</p><p>ServiceLoader内部实例化扫描到的类是通过<code>LazyIterator</code>迭代器在迭代的时候使用Class的newInstance()方法，所以这里必须要有一个无参的public构造器，否则实例化的时候会报错。</p></li><li><p>如果引入的多个jar包中均有目标接口的实现类及SPI定义，咋整？</p><p>全部都会被加载，只要是在项目中被引入了，就会全部被加载。</p></li><li><p>运行过程是什么样子的？</p><img src="/images/spi.png" alt="spi" style="zoom:46%;"></li></ul></li></ul><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3><ol><li><p>服务方</p><ul><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.kevinlu.spidemo.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SPIUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 领导实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderServiceImpl</span> <span class="keyword">implements</span> <span class="title">SPIUserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"领导发话了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 员工实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SPIUserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"员工暴怒了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>spi文件</p><p>在实现类所在的项目中的resources目录下创建文件夹META-INF/services文件夹，然后创建文件<code>cc.kevinlu.spidemo.spi.SPIUserService</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cc.kevinlu.spidemoimpl.spi.LeaderServiceImpl</span></span><br><span class="line"><span class="attr">cc.kevinlu.spidemoimpl.spi.EmployeeServiceImpl</span></span><br></pre></td></tr></table></figure></li><li><p>项目结构</p><img src="/images/image-20200405175109421.png" alt="image-20200405175109421" style="zoom:50%;"></li></ul></li><li><p>调用方</p><ul><li><p>pom.xml引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.kevinlu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spi-demo-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;SPIUserService&gt; services = ServiceLoader.load(SPIUserService.class);</span><br><span class="line"><span class="comment">// 隐式迭代器方式</span></span><br><span class="line"><span class="keyword">for</span> (SPIUserService service : services) &#123;</span><br><span class="line">  service.name();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line"><span class="comment">// 显式迭代器方式</span></span><br><span class="line">Iterator&lt;SPIUserService&gt; iterator = services.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  SPIUserService service = iterator.next();</span><br><span class="line">  service.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MySQL</h3><p>在mysql-connector-java包中的META-INFO/services目录下可以找到以接口<code>java.sql.Driver</code>为名的文件，文件内容是<code>com.mysql.jdbc.Driver</code>或者<code>com.mysql.cj.jdbc.Driver</code>。再来我们就需要找到是在哪里对这个类进行加载的，我们从<code>com.mysql.jdbc.Driver</code>可以进入到<code>java.sql.DriverManager</code>，哦哟~原来是在DriverManager类中的静态代码块实现的对目标类的加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the initial JDBC drivers by checking the System property</span></span><br><span class="line"><span class="comment"> * jdbc.properties and then use the &#123;<span class="doctag">@code</span> ServiceLoader&#125; mechanism</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  loadInitialDrivers();</span><br><span class="line">  println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String drivers;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the driver is packaged as a Service Provider, load it.</span></span><br><span class="line">  <span class="comment">// Get all the drivers through the classloader</span></span><br><span class="line">  <span class="comment">// exposed as a java.sql.Driver.class service.</span></span><br><span class="line">  <span class="comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span></span><br><span class="line">  AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">      Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Load these drivers, so that they can be instantiated.</span></span><br><span class="line"><span class="comment">       * It may be the case that the driver class may not be there</span></span><br><span class="line"><span class="comment">       * i.e. there may be a packaged driver with the service class</span></span><br><span class="line"><span class="comment">       * as implementation of java.sql.Driver but the actual class</span></span><br><span class="line"><span class="comment">       * may be missing. In that case a java.util.ServiceConfigurationError</span></span><br><span class="line"><span class="comment">       * will be thrown at runtime by the VM trying to locate</span></span><br><span class="line"><span class="comment">       * and load the service.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * Adding a try catch block to catch those runtime errors</span></span><br><span class="line"><span class="comment">       * if driver not available in classpath but it's</span></span><br><span class="line"><span class="comment">       * packaged as service and that service is there in classpath.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">          driversIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  println(<span class="string">"DriverManager.initialize: jdbc.drivers = "</span> + drivers);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="疑"><a class="markdownIt-Anchor" href="#疑"></a> 疑</h2><p>前几天面试的时候，有个同学问我：我们订单类型分很多种，有美食、外卖、酒店、门票、火车票、机票等等，我们这边是做一个中台(中间平台)，为客户端提供统一下单、出单、订单等服务，但是订单需要流转到相对应的业务部门，怎么做？</p><p>我说SDK、微服务等形式，比如下单的时候由中台判断订单要流转的业务线，然后依据策略调用不同业务线提供的API服务。</p><p>然后又问我每个业务线提供的接口定义不同，调用起来会很麻烦，怎么办？</p><p>我说这个很简单啊，由中台定义接口，业务方引入中台的接口依赖，然后实现中台提供的接口，去编写自己的业务逻辑，并把该api暴露给中台去调用，这样中台对外的接口定义都一致，其实就是对外统一接口请求规范。</p><p>接着这位同学问了句：你知道SPI么？</p><p>艾玛~SPI会把业务方的实现代码依赖进来，如果某个业务方的处理逻辑改变了，或者他们的包版本变更了，岂不是所有的依赖方都要去更新依赖？这种方式其实不是不可取，只是会麻烦一些，并且我们把所有的业务方的实现都依赖进来了，那么我们使用ServiceLoader加载之后在使用的时候判断起来也麻烦。</p><p>是吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;SPI全称是Service Provider Interface，是一种服务发现机制（哎，服务发现机制？和Zookeeper什么关系？）。SPI
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈RPC</title>
    <link href="http://luxiaowan.github.io/2020/04/02/%E6%B5%85%E8%B0%88RPC/"/>
    <id>http://luxiaowan.github.io/2020/04/02/浅谈RPC/</id>
    <published>2020-04-01T17:10:00.000Z</published>
    <updated>2020-04-07T15:44:11.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>RPC是Remote Procedure Call的简称，译为远程过程调用，何为远程？就是从这个地方到另一个地方，也就是调用双方不在同一个进程或者不在同一台服务器上，由于双方不在一个内存空间中，所以需要借助网络来实现通信和数据传递。</p><h3 id="工作过程"><a class="markdownIt-Anchor" href="#工作过程"></a> 工作过程</h3><p>A服务器上的进程P1调用A服务器上的进程P2，或者A服务器上的进程P1调用B服务器上的P2，P1发起调用行为之后，进程被挂起，P2接收到请求之后开始执行，然后返回结果给P1，P1继续执行。P1可以使用参数将信息传递给P2，然后通过P2传回的消息得到结果。</p><p><img src="/images/45366c44f775abfd0ac3b43bccc1abc3_1440w.png" alt="img"></p><ol><li>Client function中像调用本地方法一样调用远程服务</li><li>Client stub接收到调用请求后，将方法、参数序列化</li><li>Client通过Socket将消息发送到远程服务</li><li>Server接收到消息后转发给Server stub，Server stub将消息进行解码（反序列化）</li><li>Server stub根据解码后的内容调用本地Server服务</li><li>Server执行完本地方法后，将执行结果返回给Server stub</li><li>Server stub将结果进行编码（序列化），然后传给Socket</li><li>然后通过Socket将消息发送给Client</li><li>Client接收到返回的消息后转发给Client stub，随之进行解码（反序列化）</li><li>Client接收到返回数据做最终处理</li></ol><p>以上就是一次RPC请求的全过程，整个RPC调用过程有同步和异步两种方式，同步也就是Client在接收到Server返回的消息之前一直将请求保持在运行中状态，例如IO和BIO；异步则是Client将请求发出去之后就将请求挂起，然后Server执行完后再发消息过来通知服务唤醒对应的请求继续处理，例如NIO和AIO。</p><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><p>在RPC理论被提出时就被赋予了简单、高效、通用三个特点。</p><p>简单：RPC概念语义清晰，使建立分布式应用更加简单，服务之间调用方式简单</p><p>高效：过程调用使用起来很高效，会隐藏底层的通信细节，不需要我们之间去处理Socket通信</p><p>通用：RPC是一个请求响应模型，调用双方可以使用不同的编程语言去实现，选择合适的序列化方式即可</p><p>简单点说，就是RPC能够使我们像调用本地方法一样去调用远程方法，并且调用者不需要知道远程服务到底部署在何处，达到像傻子一样去编程。</p><h3 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h3><p>在说到RPC调用过程的时候，有反复的提到序列化和反序列化，RPC支持的数据序列化方式有Java序列化、JSON、Hessian、Kryo等，还有我们很早之前WebService常用的XML。</p><ul><li>JSON：<ul><li>可读性较高</li><li>无法表示数据内的引用关系</li><li>统一JSON字段命名规范较困难</li></ul></li><li>Hessian二进制<ul><li>几乎无可读性而言</li><li>支持的语言不够多，比如直接忽略了对js的支持</li><li>二进制兼容性较高</li><li>二进制传输速度比XML、JSON快</li></ul></li></ul><h3 id="rpc框架"><a class="markdownIt-Anchor" href="#rpc框架"></a> RPC框架</h3><ul><li><p>Dubbo</p><p>阿里研发的，后由当当网扩展出了Dubbox，阿里的已经不维护了，现在丢给Apache了</p></li><li><p>Feign</p><p>Netflix的一套，由Spring Cloud拓展出来了一套轻量级的，很好的融合于Spring Cloud，微服务中还是常用的，适用于Java</p></li><li><p>gRPC</p><p>谷歌的一套RPC框架，基于HTTP/2 协议传输，在多语言服务之间交互时常被采用</p></li><li><p>Java RMI</p><p>较古老的一款RPC框架，仅适用于Java程序，无法跨语言，用起来也不方便</p></li><li><p>Thrift</p><p>Facebook开源的一套RPC框架，它主要是一种接口描述语言和二进制通信协议，跨语言协作，现在丢给Apache了</p></li><li><p>SOAP</p><p>由XML-RPC演变而来，不常用，老项目里可能会用到</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;RPC是Remote Procedure Call的简称，译为远程过程调用，何为远程？就是从这个地方到另一个地方，也就是调用双方不在同一个进程或
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud全家桶初探</title>
    <link href="http://luxiaowan.github.io/2020/04/01/SpringCloud%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%88%9D%E6%8E%A2/"/>
    <id>http://luxiaowan.github.io/2020/04/01/SpringCloud全家桶初探/</id>
    <published>2020-04-01T14:56:00.000Z</published>
    <updated>2020-04-05T14:07:16.784Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是spring-cloud"><a class="markdownIt-Anchor" href="#什么是spring-cloud"></a> 什么是Spring Cloud</h3><p>官网上面有一段话：Spring Cloud为开发人员提供了快速构建分布式系统中的一些常见模式的工具(例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导选举、分布式会话、集群状态)。</p><ul><li>Spring Boot是Spring的一套快速配置脚手架，可以基于Spring Boot快速开发一个微服务应用，而Spring Cloud是一个基于Spring Boot实现云应用的开发工具；</li><li>Spring Boot专注于快速、方便的创建单个微服务，Spring Cloud专注于微服务全局的服务治理框架；</li><li>Spring Boot使用了约定大于配置的理念，大部分集成方案都预设好了，不需要过多的配置，或者说能不配置就不配置，而Spring Cloud是基于Spring Boot来实现的，也就是说Spring Boot可以独立于Spring Cloud，而Spring Cloud强依赖于Spring Boot。</li></ul><h3 id="什么是微服务"><a class="markdownIt-Anchor" href="#什么是微服务"></a> 什么是微服务</h3><ol><li><p>微服务架构</p><ul><li>分散：不同的功能模块部署在不同的服务器/容器中，减轻功能模块高并发带来的压力</li><li>集群：不同服务器/容器中部署相同的功能模块，通过负载均衡服务配置实现功能模块的高可用</li><li>微服务：微服务架构简单来说就是将web应用拆分成一系列小的服务应用，这些应用可以独立的编译、部署，应用之间通过暴露各自的API实现通信，共同组成一个完整的web应用</li></ul></li><li><p>微服务的特点</p><ul><li>单一职责：每一个微服务模块都对应不同的服务功能，负责单一业务的业务实现</li><li>微/细：服务拆分的粒度很小，但依据分久必合合久必分原则，微服务之间也是可以进行再拆分或合并的</li><li>面向服务：每个服务应用对外暴露自己的API，调用者不需要关注具体的业务实现</li><li>自我治理：<ul><li>服务独立，研发团队独立</li><li>技术独立：只要提供相应的API即可，实现技术和实现语言不必一致</li><li>前后端分离</li><li>配置独立</li><li>解耦：独立部署，通过RPC或REST方式通信，耦合影响较小</li><li>服务容错、限流</li></ul></li></ul></li><li><p>微服务的劣势</p><ul><li>微服务使整个应用分散成多个服务应用，定位问题非常困难（trace解决定位难的问题）</li><li>稳定性下降，服务数量过多会导致整个应用出现问题的概率变大，其中一个服务挂掉就可能导致整个应用不可用，访问量越大出问题的可能性越大</li><li>服务数量过多，部署、管理的工作量变大</li><li>开发的过程中很难实现相互依赖的服务之间同步进行（mock解决此问题）</li><li>测试难度增大，由原先的单体应用测试变成服务间调用的测试，测试过程更加复杂</li><li>服务运行过程中可能会经常发生服务宕机，所以对于微服务必须建立完善的服务监控体系，尽可能的第一时间发现故障服务并进行故障通知、转移和恢复（Zookeeper、Eureka、Consul、Etcd等）</li></ul></li><li><p>微服务拆分依据</p><p>微服务拆分不是一蹴而就的，而是需要在开发过程中不断的去分析和理清每一个服务的边界。对于老工程中尚未分清拆分方向的，可先留于其中，最终可考虑将这些功能作为一个微服务。</p><ul><li>基于业务逻辑</li><li>基于可扩展</li><li>基于可靠性</li><li>基于性能</li></ul></li><li><p>微服务拆分规范</p><ul><li>粒度：先少后多，先粗后细</li><li>调用：保持单向调用，尽量禁止循环调用，比如订单—&gt;产品，产品—x&gt;订单</li><li>接口幂等：应保证接口的幂等性，避免出现脏数据</li><li>纵向拆分尽量少于三层，也即维持在控制层—&gt;业务服务层—&gt;基础服务层</li><li>先拆分服务，后拆分数据库</li></ul></li></ol><h3 id="基础元件"><a class="markdownIt-Anchor" href="#基础元件"></a> 基础元件</h3><ol><li><p>Config</p><p>分布式服务，由于服务数量较多，每一个服务都会有1+套配置文件，如果每个项目单独配置一个yml/properties文件，管理起来会很混乱，并且无法实现动态变更配置属性的值，所以我们需要一个分布式配置中心组件，Spring Cloud Config就因此应运而生，它支持配置信息放在配置服务的内存中，也支持放在远程的git/svn仓库中，Config分两个角色，一个Server和一个Client。</p><ul><li><p>Server：创建一个简单的Config Server，使用git作为配置中心，我们再git仓库中创建目录config，这个目录名称需要和<code>spring.cloud.config.server.git.search-paths</code>配置的一致，然后在目录中创建client1-dev.properties</p><ol><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">7701</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.uri</span>=<span class="string">http://gitlab.xx.com/spring-cloud/config-center.git</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.username</span>=<span class="string">xxxxx</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.password</span>=<span class="string">xxxxx</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.search-paths</span>=<span class="string">config</span></span><br></pre></td></tr></table></figure><ul><li>spring.cloud.config.server.git.uri：git仓库地址</li><li>spring.cloud.config.server.git.search-paths：git仓库地址下的相对地址，可以配置多个，用,分割</li><li>spring.cloud.config.server.git.username：git仓库登录用户名</li><li>spring.cloud.config.server.git.password：git仓库登录密码</li></ul></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再启动类加上<code>@EnableConfigServer</code>注解，表明该项目是Config Server项目，启动后访问<code>http://localhost:7701/client1/dev</code>，如果返回如下，则表示我们已经配置正常，可以使用：</p><blockquote><p>{<br>“name”: “client1”,<br>“profiles”: [<br>“dev”<br>],<br>“label”: null,<br>“version”: “e3741fe5e48b303c80f34c1b8a44c0ef2999e22b”,<br>“state”: null,<br>“propertySources”: [<br>{<br>“name”: “<a href="http://gitlab.xxx.com/spring-cloud/config-demo.git/config/client1-dev.yml" target="_blank" rel="noopener">http://gitlab.xxx.com/spring-cloud/config-demo.git/config/client1-dev.yml</a>”,<br>“source”: {<br>“name”: “cc”<br>}<br>}<br>]<br>}</p></blockquote><p>☆说明：</p><blockquote><p>仓库中的配置文件会被转换成 Web 接口，访问可以参照以下的规则：</p><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><p>上面的 URL 会映射 <code>{application}-{profile}.yml</code> 对应的配置文件，其中 <code>{label}</code> 对应 Git 上不同的分支，默认为 master。以 config-client-dev.yml 为例子，它的 application 是 config-client，profile 是 dev。</p></blockquote></li></ol></li><li><p>Client</p><ol><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web项目 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 动态刷新配置信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们引入了actuator，目的是可以在修改了git仓库中的配置信息之后，可以手动刷新，让项目读取最新的配置信息，而不需要重启我们的应用</p></li><li><p>bootstrap.properties</p><p>config的配置必须配置在bootstrap.properties文件中，这样才能被正确的加载，按照springboot的配置文件加载顺序来看，会先加载bootstrap，然后再加载application，并且我们的config的配置要优先于项目中的其他内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.profile</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.config.label</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.config.uri</span>=<span class="string">http://127.0.0.1:7701/</span></span><br><span class="line"><span class="meta">spring.cloud.config.name</span>=<span class="string">client1</span></span><br></pre></td></tr></table></figure><ul><li>label：对应git仓库的分支名称，默认是master，我们这里dev表示我们使用的是dev分支，若分支不存在，则报错</li><li>profile：环境，对应文件后缀</li><li>uri：Config Server地址</li><li>name：配置中心的项目文件夹名称，若配置一个不存在的文件名，则会报错</li></ul></li><li><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">client1</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">health, info, refresh</span></span><br></pre></td></tr></table></figure><p>在application.properties中指定端口和项目名称，因为我们引入的actuator，但是它默认暴露的接口是health和info两个接口，其他的都涉及到安全所以需要手动将接口暴露出来，因为我们要可以动态刷新，所以将refresh接口也暴露出来，以POST方式请求该接口：<code>curl -X POST http://127.0.0.1:8080/actuator/refresh</code></p></li><li><p>TestController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/one"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解<code>@RefreshScope</code>是指明该类下的属性注入可以动态刷新</p></li></ol></li><li><p>测试</p><ol><li>访问http://127.0.0.1:8080/index/one</li><li>修改client-dev.properties文件中name=one_1</li><li>刷新：<code>curl -X POST http://127.0.0.1:8080/actuator/refresh</code></li><li>访问http://127.0.0.1:8080/index/one</li></ol></li></ul></li><li><p>Eureka</p><p>服务注册发现中心，基于CAP理论的AP实现，一个基于REST的服务，用于服务的发现和定位，以实现云端中间层服务发现和故障转移。Eureka的AP原则保证了注册中心的高可用，它是一个去中心化的架构，也就是集群中的所有节点都无主从之分，每一个节点都是平等的，可以相互注册，每一个节点都需要添加一个或多个serviceUrl指向其他节点，每个节点都可以视为其他节点的副本，这一特点实现了Eureka的高可用。</p><p>当有一台Server宕机后，Eureka Client会将请求自动转发到其他的Server节点上，当故障的Server节点恢复之后，Eureka会将其再次加入到服务器集群中。</p><p>当一个新的Server启动并加入进群后，会首先从其他的临近节点获取所有的可用服务列表信息完成初始化。</p><ul><li><p>Server：创建一个Eureka Server中心只需要在启动类上加上注解<code>@EnableEurekaServer</code>即可，启动服务之后通过访问<code>http://127.0.0.1:8080/</code>进入eureka控制中心，我们需要在<code>pom.xml</code>中引入一个jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> ↓(内嵌)</span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> ↓(内嵌)</span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@SpringBootApplication</span></span><br><span class="line"> <span class="meta">@EnableEurekaServer</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们仅仅是部署一个Eureka Server，那么我们还需要修改一下eureka.client前缀的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"> <span class="meta">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p>这些配置信息对应的类是在<code>spring-cloud-netflix-eureka-client.jar</code>包中的<code>org.springframework.cloud.netflix.eureka.EurekaClientConfigBean</code>类中，看下这个类中上面三个参数的默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@ConfigurationProperties</span>(EurekaClientConfigBean.PREFIX)</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientConfigBean</span> <span class="keyword">implements</span> <span class="title">EurekaClientConfig</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 默认的eureka客户端配置前缀，就用在上面↑</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"eureka.client"</span>;</span><br><span class="line">   <span class="comment">// Eureka默认的访问地址，如果我们不修改这个配置的话，就可以通过8761端口的这个地址去访问</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_URL = <span class="string">"http://localhost:8761"</span> + DEFAULT_PREFIX</span><br><span class="line"> + <span class="string">"/"</span>;</span><br><span class="line">   <span class="comment">// 如果没设置zone就使用下面这个默认的</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_ZONE = <span class="string">"defaultZone"</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 指定是否将当前服务注册到Eureka Server以被其他服务发现和使用</span></span><br><span class="line"> <span class="comment">// 如果不想使当前应用被其他服务发现，则修改此属性为false</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> registerWithEureka = <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 指定当前服务是否从Eureka Server拉取监听的服务列表</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> fetchRegistry = <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Eureka Server访问地址，一个Map，可以存储很多值</span></span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, String&gt; serviceUrl = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">// 将默认的server地址放入服务地址Map中</span></span><br><span class="line"><span class="keyword">this</span>.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client：创建一个Eureka Client很简单，在启动类上加上注解<code>@EnableEurekaClient</code>即可，如果Eureka Server服务的端口并不是使用的8761，那么则需要修改一下配置信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://127.0.0.1:8080/eureka/</span></span><br></pre></td></tr></table></figure><p>仅仅只需要修改折一个配置即可，因为其他的默认都为true，不用再配置了，这就是Spring Boot所说的约定大于配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@SpringBootApplication</span></span><br><span class="line"> <span class="meta">@EnableEurekaClient</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自我保护模式</p><ul><li>Eureka Server在运行期间会不断的统计心跳失败比例，如果再15分钟内有超过85%的client未正常发送心跳过来(单机模式很容易满足，生产环境如果出现这个情况则一般是网络通信出现了问题)，那么Eureka Server就会认为自己和客户端出现了网络故障，就会进入自我保护模式</li><li>自我保护模式的原则是宁可放过不可错杀，意思就是即使服务宕机了，我们在注册中心看到的服务状态依然是UP</li><li>自我保护模式使的Eureka实现了CAP中的AP，默认是开启的，可以通过参数<code>eureka.server.enable-self-preservation=false</code>进行关闭，但是在实际生产环境中不建议关闭，因为如果关闭的话，可能就直接导致服务不可用了</li><li>在正常情况下，如果超过默认的90秒未接收到某client的心跳，则将该client做下线处理，并从服务列表中移除掉；但是在保护模式下，不会将无心跳的client从服务列表中移除</li><li>自我保护模式下，当前Server节点依然可以接收通信正常的服务的注册和发现，但是不会将新注册的服务同步给集群中的其他Server节点，只有待网络恢复且退出自我保护模式之后，才会将自我保护模式期间新注册的服务同步给其他节点</li><li>Eureka的服务健康检查是通过actuator的/info和/health来实现的</li></ul><p><img src="/images/image-20200402211128777.png" alt="image-20200402211128777"></p></li></ul></li><li><p>Consul</p><ul><li><p>Consul用于实现分布式系统的服务发现与配置，其它分布式服务注册与发现的方案，满足CAP的CP，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（ZooKeeper等），Consul可以与Docker完美融合使用Go语言开发，基于 Mozilla Public License 2.0 的协议开源。</p></li><li><p>Consul工作原理</p><img src="/images/consol_service.png" alt="img" style="zoom:67%;"><ul><li>Producer启动的时候，会向Consul发送自己的服务信息，比如IP、port等</li><li>Consul每隔10秒(默认)会向Producer发送一个心跳监控请求，检测Producer是否健康</li><li>Consumer每隔10秒(默认)会向Consul拉取一次服务列表缓存在本地，Consumer的请求都基于本地的服务缓存列表进行请求</li></ul></li><li><p>安装Consul服务</p><ul><li><p>Docker运行（单机版）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 查询consul可用镜像</span></span><br><span class="line">docker search consul</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 拉取consul镜像</span></span><br><span class="line">docker pull consul:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 启动镜像</span></span><br><span class="line">docker run \</span><br><span class="line">--name consul \</span><br><span class="line">-p 8599:8500 \</span><br><span class="line">-v /data/consul/conf/:/consul/conf/ \</span><br><span class="line">-v /data/consul/data/:/consul/data/ \</span><br><span class="line">-d consul</span><br></pre></td></tr></table></figure></li><li><p>正常安装</p><p>下载地址：<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">https://www.consul.io/downloads.html</a></p><p>帮助文档：<a href="https://learn.hashicorp.com/consul/getting-started/install" target="_blank" rel="noopener">https://learn.hashicorp.com/consul/getting-started/install</a></p></li><li><p>访问consul：<a href="http://127.0.0.1:8599" target="_blank" rel="noopener">http://127.0.0.1:8599</a></p><p><img src="/images/consul.png" alt="image-20200402161855088"></p></li></ul></li><li><p>Consul与客户端集成</p><ul><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web包，必须引入，否则服务无法注册到注册中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- consul discovery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 心跳 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">7702</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consul-demo</span></span><br><span class="line"><span class="meta">spring.cloud.consul.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="comment">#spring.cloud.consul.discovery.health-check-path=/health</span></span><br></pre></td></tr></table></figure><ul><li>spring.cloud.consul.host：consul服务IP</li><li>spring.cloud.consul.port：consul服务端口</li><li>spring.cloud.consul.discovery.health-check-path：consul心跳地址，默认为actuator/health，我们可以自定义</li></ul></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用注解@EnableDiscoveryClient开启服务自动注册和发现</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudConsulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudConsulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200402170513327.png" alt="image-20200402170513327"></p></li></ul></li><li><p>运行机制</p><ul><li>Consul的一致性算法采用了Raft，比Zookeeper的Paxos算法简单很多</li><li>强一致性给Consul带来了可用性的下降<ul><li>当一个服务注册到leader节点时，因为Raft算法要求所有节点数投票同意过半才能将服务真正的注册进来，所以新服务注册的时间被拉长了；</li><li>当leader节点挂掉之后，需要根据Raft算法选举出新的leader节点，选举的过程中，Consul服务不可用</li></ul></li></ul></li></ul></li><li><p>Ribbon</p><p>负载均衡(Load Balance)是用于解决一个服务节点无法处理所有请求的算法，Ribbon是一款基于TCP和HTTP的客户端负载均衡工具，基于Netflix Ribbon，由Spring Cloud进行了再封装，将我们的REST模板的请求均转换为客户端负载均衡的服务调用，Ribbon仅仅只是一个工具，包含在每一个Spring Cloud应用中，无需单独的部署其他服务。</p><p>由于Ribbon属于是客户端负载均衡，所以需要在客户端维护一份服务端列表信息，而这些列表信息来自于服务注册中心，如Eureka、Consul等，客户端的服务端列表信息也需要不断的去更新，保证服务列表中服务的可用性，这个过程并不是在客户端去检测各个服务端的心跳，而是通过与服务注册中心进行数据交换来维护服务端的健康。</p><p>Spring Cloud默认会自动加载和配置Ribbon的一切，我们只需要去解读一下<code>org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration</code>和<code>org.springframework.cloud.consul.discovery.RibbonConsulAutoConfiguration</code>就可以知道一切了，这里不做源码解释</p><ul><li><p>如何在Spring Cloud中使用Ribbon</p><ul><li>服务端启动多个实例，并注册到同一个服务注册中心，或者同一个集群</li><li>客户端的RestTemplate实例创建的时候通过注解<code>@LoadBalanced</code>修饰</li></ul></li><li><p>Ribbon带来的好处</p><ul><li>当集群中某一个服务宕掉后，整个服务集群依然可以正常提供服务</li><li>可以选择合适的负载算法保证服务的良性使用，避免在流量激增的时候拖垮CPU</li></ul></li><li><p>负载均衡算法</p><ul><li><p>权重</p><p>为每台机器设置在集群中的比重，请求过来后按照比重分配进行轮询</p></li><li><p>随机</p><p>对集群中的机器随机访问，通过随机数定位要访问的机器</p></li><li><p>哈希</p><p>请求按照一定规则映射到要访问的机器上</p></li><li><p>轮询</p><p>轮询是指将请求轮流分配给每台服务器，当服务器群中各服务器的处理能力相同时，且每笔业务处理量差异不大时，最适合使用这种算法</p></li></ul></li><li><p>Ribbon工作原理</p><ol><li><p>获取被<code>@LoadBalanced</code>修饰的RestTemplate</p><p>我们知道SpringBoot中的自配装配都是通过MATE-INF/spring.factories文件中<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>指定的类来实现的，在注解<code>@LoadBalanced</code>所在的包中我们找到了<code>org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration</code>，其实整个EnableAutoConfiguration的列表中只有这一个和LoadBalance有关，所以很容易找，我们看下LoadBalanceAutoConfiguration的代码是怎么写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br></pre></td></tr></table></figure><p>我们知道<code>@Autowired</code>可以将对象赋值给一个对象，也可以赋值给一个对象的集合，这里我们不做解释，可以去了解一下<code>@Autowired</code>和<code>@Qualifier</code>。</p></li><li><p>为RestTemplate添加一个拦截器，也就是<code>org.springframework.cloud.client.loadbalancer.LoadBalancerInterceptor</code>，拦截每一次的RestTemplate请求</p><p>我们看下LoadBalancerInterceptor的创建过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SmartInitializingSingleton <span class="title">loadBalancedRestTemplateInitializerDeprecated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="keyword">this</span>.restTemplates) &#123;</span><br><span class="line">      <span class="keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">        <span class="comment">// 触发LoadBalancerInterceptorConfig.restTemplateCustomizer的执行</span></span><br><span class="line">        customizer.customize(restTemplate);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建拦截器</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">    LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为RestTemplate实例添加拦截器</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">      List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">        restTemplate.getInterceptors());</span><br><span class="line">      list.add(loadBalancerInterceptor);</span><br><span class="line">      <span class="comment">// 拦截器设置点</span></span><br><span class="line">      restTemplate.setInterceptors(list);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在拦截器中获取服务所有的列表，根据负载规则选择一台机器提供服务</p><p>通过上面的分析，我们可以看到只要为RestTemplate添加了拦截器之后，根据拦截器的工作性质，往后通过RestTemplate实例的每一次请求都会先走到这个拦截器的intercept()方法中，在intercept()方法中调用了<code>LoadBalancerClient.execute()</code>进行了Server选举。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取服务列表，检测服务是否存活，每一次请求均需要检测一次，所有的路由均实现于ILoadBalancer</span></span><br><span class="line">  ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">  <span class="comment">// 根据配置的路由规则选择最终要提供的服务的地址，所有的规则都实现于IRule</span></span><br><span class="line">  Server server = getServer(loadBalancer);</span><br><span class="line">  <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server, serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发送请求获取结果，然后将结果返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Server server = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">server = ((RibbonServer)serviceInstance).getServer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">.getLoadBalancerContext(serviceId);</span><br><span class="line">RibbonStatsRecorder statsRecorder = <span class="keyword">new</span> RibbonStatsRecorder(context, server);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 最终请求语句</span></span><br><span class="line">T returnVal = request.apply(serviceInstance);</span><br><span class="line">statsRecorder.recordStats(returnVal);</span><br><span class="line"><span class="keyword">return</span> returnVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">statsRecorder.recordStats(ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">statsRecorder.recordStats(ex);</span><br><span class="line">ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借他人的一张图来说明一下请求流程：</p><p><img src="/images/e9998448e095176c2454fafd66ea57ab1511332.png" alt="img"></p></li></ol></li><li><p>配置负载策略</p><p>Ribbon默认的负载策略为ZoneAwareLoadBalancer，我们可以通过配置修改策略方案</p><ol><li><p>使用Ribbon中已存在的负载策略</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">u-service.ribbon.NFLoadBalancerRuleClassName</span>=<span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>所有的策略都实现于IRule接口</p><p><img src="/images/rule.png" alt="img"></p><p>这里单独说一下WeightedResponseTimeRule这个策略，我们在使用Nginx的时候，可以手动预先设置好每一台服务器的权重，但是在Ribbon中，权重是依据服务器响应时间动态设置的，在应用运行期间，这个权重有可能会改变，在WeightedResponseTimeRule类中有一个内部类DynamicServerWeightTask，它是一个定时器，调度时间默认为30秒一次，如果想要修改这个时间，则可以使用自定义负载规则。</p></li><li><p>使用自定义负载策略</p><ul><li><p>创建自定义配置器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 使用权重规则</span></span><br><span class="line">        WeightedResponseTimeRule rule = <span class="keyword">new</span> WeightedResponseTimeRule();</span><br><span class="line">        IClientConfig config = <span class="keyword">new</span> DefaultClientConfigImpl();</span><br><span class="line">        config.loadDefaultValues();</span><br><span class="line">      <span class="comment">// 修改权重定时器执行时间</span></span><br><span class="line">        config.set(WeightedResponseTimeRule.WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY, <span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">      <span class="comment">// 调用方法修改配置</span></span><br><span class="line">        rule.initWithNiwsConfig(config);</span><br><span class="line">        <span class="keyword">return</span> rule;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明要使用该规则的服务</p><p>在启动类上加入<code>@RibbonClient(name = &quot;user-service&quot;, configuration = MyRule.class)</code>，name属性指定服务名称，configuration指定要使用的规则</p></li></ul></li></ol></li></ul></li><li><p>Hystrix</p><p>Spring Cloud Hystrix是从Netflix Hystrix延伸出的一个轻量级的组件，主要功能是服务容错和线程隔离。</p><p>在微服务架构中，服务之间通过远程调用的方式进行通信，会出现一个请求走过多个服务的情况，在请求链路中，一旦某个服务出现故障，那么所有依赖这个服务的其他服务均会发生故障，严重的情况下会导致整个系统全部瘫痪，这与我们做微服务的初衷是相悖的。Hystrix的断路器模式帮我们提升了服务的故障容错能力，当某个服务或某个接口出现故障时，通过断路器的监控，给调用方返回一个指定的错误响应，避免调用方因为长期等待一直占用线程而造成的故障蔓延。</p><p>Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并和服务监控等功能，我们常用的大多就是降级和熔断了。</p><ul><li><p>服务熔断降级</p><p>服务熔断是指在下游服务变得不可用或响应时间过长而导致调用方放弃继续调用转而直接返回的一种处理方式，目的是为了保证上游服务的可用性和稳定性。然后我们创建一个具有熔断器的项目，下游服务的代码不做解释，我们看下上游服务如何开启熔断。</p><ol><li><p>pom.xml</p><p>我们要使用Hystrix的第一步当然是要引入jar包，我们在pom.xml文件中引入依赖jar：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- euraka --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hystrix --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么要引入eureka？因为服务端是注册到eureka里面的啊，所以要引入eureka去做服务发现。那么可以不用eureka么？当然可以。</p></li><li><p>API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"faultMethod"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cuser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String obj = restTemplate.getForObject(<span class="string">"http://cuser-service/user/1"</span>, String.class);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">faultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"服务熔断"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API的定义和我们平时写的不太一样，多了一个注解<code>@HystrixCommand</code>，这个注解的作用就是在我们API内发生异常的时候进行熔断，参数<code>fallbackMethod</code>指定的就是在发生异常的时候跳转的熔断方法，这个方法参数和返回类型需要和被熔断的方法如出一辙，否则就会报错。</p><ul><li>注解<code>@HystrixCommand</code>参数解析<ol><li>fallbackMethod：指定服务降级处理方法；</li><li>ignoreExceptions：忽略某些异常，不发生服务降级；</li><li>commandKey：命令名称，用于区分不同的命令；</li><li>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；</li><li>threadPoolKey：线程池名称，用于划分线程池。</li></ol></li></ul></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudCuserConsumerHystrixApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudCuserConsumerHystrixApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解<code>@EnableHystrix</code>的作用是为应用开启Hystrix的能力，等于一个开关。老版本中使用的是注解<code>@EnableCircuitBreaker</code>，新版本中可以看到EnableHystrix中已经集成在一起了，所以我们使用这一个注解就行了。</p><p>运行过程就不用说了，也就是eureka、server、client都启动了，然后访问<code>http://127.0.0.1:8090/cuser</code>，接着把server停掉，然后再访问，会发现接口发生了熔断。</p></li><li><p>高级参数配置</p><p>注解<code>@HystrixCommand</code>中可以通过参数commandProperties、threadPoolProperties设置熔断降级相关的参数，参数名称在类<code>com.netflix.hystrix.contrib.javanica.conf.HystrixPropertiesManager</code>中有指定，并且类中也说明了这两个属性所适用的参数名称，太多了，写两个比较常用的吧</p><ul><li>threadPoolProperties<ul><li>coreSize：线程池核心线程数</li><li>keepAliveTimeMinutes：线程最大存活时间，单位为分钟</li><li>maxQueueSize：最大等待线程队列容量</li><li>queueSizeRejectionThreshold：等待队列拒绝添加的阈值</li></ul></li><li>commandProperties<ul><li>execution.isolation.thread.timeoutInMilliseconds：设置调用者等待命令执行的超时限制，超过此时间，HystrixCommand被标记为TIMEOUT，并执行回退逻辑。</li></ul></li></ul></li></ol></li><li><p>服务限流</p><p>服务接口限流我们可以通过设置注解<code>@HystrixCommand</code>的threadPoolProperties的参数来实现，限制请求的线程池数量来达到限流的作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>   index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"faultMethod"</span>, threadPoolProperties = &#123;</span><br><span class="line">  <span class="meta">@HystrixProperty</span>(name = <span class="string">"coreSize"</span>, value = <span class="string">"1"</span>),</span><br><span class="line">  <span class="meta">@HystrixProperty</span>(name = <span class="string">"queueSizeRejectionThreshold"</span>, value = <span class="string">"2"</span>),</span><br><span class="line">  <span class="meta">@HystrixProperty</span>(name = <span class="string">"maxQueueSize"</span>, value = <span class="string">"1"</span>) &#125;, commandProperties = &#123;</span><br><span class="line">  <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"2000"</span>) &#125;)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cuser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span> (index % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  String obj = restTemplate.getForObject(<span class="string">"http://cuser-service/user/1"</span>, String.class);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">faultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"服务熔断"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们用index来模拟一个请求挂起的操作，我们线程池核心数设置为1，最大等待队列长度为1，我们用JMeter来模拟45个并发，会发现最终只有3个请求顺利通过，其他的全部都被熔断了。</p><p>然后我们修改一下线程池大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"faultMethod"</span>, threadPoolProperties = &#123;</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"coreSize"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"queueSizeRejectionThreshold"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"maxQueueSize"</span>, value = <span class="string">"100"</span>) &#125;, commandProperties = &#123;</span><br><span class="line">&gt;                     <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"2000"</span>) &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>把核心数和队列数都增大，然后还是45个并发，会发现全部请求都正常了，把并发改为200后，会发现有那么一两个请求会被熔断</p><p>再改一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"faultMethod"</span>, threadPoolProperties = &#123;</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"coreSize"</span>, value = <span class="string">"2"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"queueSizeRejectionThreshold"</span>, value = <span class="string">"2"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"maxQueueSize"</span>, value = <span class="string">"10"</span>) &#125;, commandProperties = &#123;</span><br><span class="line">&gt;                     <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"2000"</span>) &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>150个并发，大概平均每次会有32个请求正常访问，其他的全部被熔断，我们的请求熔断过期时间是2秒，一开始会有2个请求进入核心线程去处理，后续会有10个请求进入等待队列，依次去请求</p><p>问题：如果我们想把接口限制并发20，怎么办？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"faultMethod"</span>, threadPoolProperties = &#123;</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"coreSize"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"queueSizeRejectionThreshold"</span>, value = <span class="string">"2"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"maxQueueSize"</span>, value = <span class="string">"10"</span>) &#125;, commandProperties = &#123;</span><br><span class="line">&gt;                     <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"150000"</span>) &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>我们只能大概的控制一下，并不能如此严谨的设置</p></blockquote></li></ul></li><li><p>Feign</p><p>Spring Cloud Feign是从Netflix Feign扩展出来的一套通过声明式服务调用客户端的组件，使用Feign可用帮助我们更简单的构建一个Web服务，我们只需要通过注解来编写接口，就可以完成对服务接口的绑定。Feign对Hystrix有依赖关系，它只是一个简单的REST框架，最终还是需要通过Ribbon去做负载均衡，通过上面的内容可以看出Feign+Eureka+Ribbon是一家人，Feign通过整合Eureka和Ribbon来实现支持负载均衡的客户端服务。</p><p>使用Feign，我们需要将下游服务的接口定义引入到当前应用中，毕竟Java是一个面向对象的语言，即便是RPC调用，我们也需要使用相同的参数类型，并且尽量保证我们参与传递的参数都能够被序列化，所以既然我们要引入下游服务的接口定义，那么我们尽量在下游接口定义中定义FeignClient，这样做的好处是，服务可以被多个客户端使用，不需要每个客户端都定义一次 Feign 接口。</p><p>客户端需要在启动类上使用注解<code>@EnableFeignClients</code>开启Feign，Feign最终仍然是使用HTTP方式去发起请求。</p><blockquote><p>上游服务A，下游服务B</p><p>B：interface(feign client)—&gt;controller</p><p>A：dependency#A—&gt;enable discovery client &amp;&amp; enable feign clients</p></blockquote><ul><li><p>客户端调用</p><ul><li>定义要调用的目标API接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"cuser-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CUserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function">String <span class="title">getUser</span><span class="params">(@PathVariable(name = <span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要定义接口即可，接口的参数和请求路径都需要和对应的API一致，接口由注解<code>@FeignClient</code>标注。</p><ul><li>调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cuser/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(@PathVariable(name = <span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Feign支持多种注解方式：Feign、JAX-RS、SpringMVC。</p></li></ol><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是spring-cloud&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是spring-cloud&quot;&gt;&lt;/a&gt; 什么是Spring Cloud&lt;/h3&gt;
&lt;p&gt;官网上面有一段话：Spring Cloud为开发人员提供了快速构建
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringCloud" scheme="http://luxiaowan.github.io/tags/SpringCloud/"/>
    
  </entry>
  
</feed>
