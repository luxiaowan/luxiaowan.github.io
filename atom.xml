<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2019-10-31T17:23:56.890Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis基本命令使用::list篇</title>
    <link href="http://luxiaowan.github.io/2019/10/31/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E2%80%94list%E7%AF%87/"/>
    <id>http://luxiaowan.github.io/2019/10/31/Redis基本命令使用—list篇/</id>
    <published>2019-10-31T04:55:00.000Z</published>
    <updated>2019-10-31T17:23:56.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)</p></blockquote><p><strong>redis在线体验地址：<a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></strong></p><h2 id="列表list"><a class="markdownIt-Anchor" href="#列表list"></a> 列表(List)</h2><blockquote><p>介绍:</p></blockquote><p>Redis的列表就是一个简单的字符串列表，我们可以往列表的头部和尾部添加新数据，要可以根据下标修改下标对应的值，列表是按照插入顺序有序的（按插入顺序倒序，类似于栈），并且列表可以出现重复数据。可以做消息队列，不过需要注意的是可能需要消息去重(后面有更牛的)。</p><blockquote><p>创建缓存</p></blockquote><ol><li><p>创建一个列表缓存</p><ul><li><p>命令格式：<code>lpush key value [value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpush c1 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将<span class="number">1</span>~<span class="number">9</span>放入c1列表中，此时列表中存储顺序为<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>向列表左侧新增值</p><ul><li><p>命令格式：<code>lpush key value [value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpush c1 <span class="number">10</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将<span class="number">10</span>放入到c1列表头部，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>向列表右侧新增值</p><ul><li><p>命令格式：<code>rpush key value [value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpush c1 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将<span class="number">0</span>放入到c1列表尾部，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><em><strong>以上两个命令很容易理解，lpush—&gt;left push, rpush—&gt;right push</strong></em></p><ol start="4"><li><p>在列表指定元素前/后插入数据</p><ul><li><p>命令格式：<code>linsert key BEFORE|AFTER pivot value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) linsert c1 after <span class="number">0</span> <span class="number">-1</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">-1</span>插入到元素值<span class="number">0</span>之前，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)linsert c1 before <span class="number">0</span> <span class="number">1</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">1</span>插入到元素值<span class="number">0</span>之前，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)linsert c1 before <span class="number">1</span> <span class="number">3</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">3</span>插入到元素值<span class="number">1</span>之前，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>)linsert c1 after <span class="number">1</span> <span class="number">4</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">4</span>插入到元素值<span class="number">1</span>之后，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>)linsert c1 after <span class="number">99</span> <span class="number">100</span></span><br><span class="line">---</span><br><span class="line">失败</span><br><span class="line"></span><br><span class="line">** 由<span class="number">3</span>、<span class="number">4</span>操作可以得出结论，当执行linsert指令时，列表是从头部开始进行遍历，直到查询到与pivot元素相同的值时停止，根据AFTER、BEFORE选择是插入到元素后还是元素前，所以划重点：若列表中存在pivot的重复元素，linsert只会以第一个遍历到的元素为准</span><br><span class="line">** 由<span class="number">5</span>可以得出结论，若指定的pivot元素不存在于列表中，则不进行任何设置</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过索引下标设置值</p><ul><li><p>命令格式：<code>lset key index value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)<span class="keyword">lset</span> c1 <span class="number">0</span> <span class="number">21</span></span><br><span class="line">---</span><br><span class="line">将下标为<span class="number">0</span>的元素修改为<span class="number">21</span>，此时列表中存储顺序为<span class="number">21</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)<span class="keyword">lset</span> c1 <span class="number">99</span> <span class="number">99</span></span><br><span class="line">---</span><br><span class="line">ERR index out of range,说明通过<span class="keyword">lset</span>命令，不能越界修改元素</span><br></pre></td></tr></table></figure></li></ul></li><li><p>向已存在的列表头部添加元素</p><ul><li><p>命令格式：<code>lpushx key value [value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)lpushx c1 <span class="number">22</span> <span class="number">23</span> <span class="number">24</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">22</span>、<span class="number">23</span>、<span class="number">24</span>添加到列表c1头部，列表变为：<span class="number">24</span> <span class="number">23</span> <span class="number">22</span> <span class="number">21</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)lpushx c2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">---</span><br><span class="line">因为列表c2不存在，所以设置失败，此时使用lrange查看c2会返回空</span><br></pre></td></tr></table></figure></li></ul></li><li><p>向已存在的列表尾部添加元素</p><ul><li><p>命令格式：<code>rpushx key value [value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)rpushx c1 <span class="number">-2</span> <span class="number">-3</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">-2</span>、<span class="number">-3</span>添加到列表c1尾部，列表变为：<span class="number">24</span> <span class="number">23</span> <span class="number">22</span> <span class="number">21</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">-2</span> <span class="number">-3</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)rpushx c2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">---</span><br><span class="line">因为列表c2不存在，所以设置失败，此时使用lrange查看c2会返回空</span><br></pre></td></tr></table></figure></li></ul></li><li><p>截取列表</p><ul><li><p>命令格式：<code>ltrim key start end</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ltrim c1 <span class="number">4</span> <span class="number">16</span></span><br><span class="line">---</span><br><span class="line">列表下标从<span class="number">0</span>开始，截取<span class="number">5</span>~<span class="number">17</span>位的元素，列表c1变为：<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>查看缓存</p></blockquote><ol><li><p>查看列表内所有元素</p><ul><li><p>命令格式：<code>lrange key 0 -1</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lrange c1 0 -1</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">获取列表c1的所有元素</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看列表某一范围内的元素</p><ul><li><p>命令格式：<code>lrange key start end</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lrange</span> <span class="string">c1</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">查看列表c1中弟2~4位上的元素</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出列表头部元素</p><ul><li><p>命令格式：<code>lpop key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpop c1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">弹出列表c1的头部元素<span class="number">9</span>，此时列表c1变为：<span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span>，头部的<span class="number">9</span>已经没有了，是不是很适合做消息队列</span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出列表尾部元素</p><ul><li><p>命令格式：<code>rpop key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpop c1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">弹出c1的尾部元素<span class="number">0</span>，此时列表c1变为：<span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>，尾部的<span class="number">0</span>已经没有了，是不是很适合做消息队列👀</span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出列表头部元素，若当前列表内无元素，则阻塞，直到获取到或达到超时时间</p><ul><li><p>命令格式：<code>blpop key [key ...] timeout</code>   timeout单位为***秒***</p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">blpop </span><span class="built_in">c1</span> <span class="built_in">c2</span> <span class="built_in">c3</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">弹出列表<span class="built_in">c1</span>或列表<span class="built_in">c2</span>/<span class="built_in">c3</span>的头部元素，只要<span class="built_in">c1</span>、<span class="built_in">c2</span>、<span class="built_in">c3</span>有一个列表中有元素被弹出，则结束阻塞</span><br><span class="line">若<span class="built_in">c1</span>、<span class="built_in">c2</span>、<span class="built_in">c3</span>均有元素，则返回第一个满足弹出条件的列表，然后结束阻塞</span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出列表尾部元素，若当前列表内无元素，则阻塞，直到获取到或达到超时时间</p><ul><li><p>命令格式：<code>brpop key [key ...] timeout</code>   timeout单位为***秒***</p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">blpop </span><span class="built_in">c1</span> <span class="built_in">c2</span> <span class="built_in">c3</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">弹出列表<span class="built_in">c1</span>或列表<span class="built_in">c2</span>/<span class="built_in">c3</span>的尾部元素，只要<span class="built_in">c1</span>、<span class="built_in">c2</span>、<span class="built_in">c3</span>有一个列表中有元素被弹出，则结束阻塞</span><br><span class="line">若<span class="built_in">c1</span>、<span class="built_in">c2</span>、<span class="built_in">c3</span>均有元素，则返回第一个满足弹出条件的列表，然后结束阻塞</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取列表指定位置的元素</p><ul><li><p>命令格式：<code>lindex key index</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1)lindex c1 2</span><br><span class="line">---</span><br><span class="line">返回列表c1中下标为2的元素，仅仅返回数据，不弹出，时间复杂度O(1)</span><br><span class="line"></span><br><span class="line">2)lindex c1 -1</span><br><span class="line">---</span><br><span class="line">返回列表最后一个元素。列表元素下标-1代表列表中最后一个元素，所以列表是可以通过负数下标从后往前遍历</span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出一个列表中的最后一个元素到另外一个列表头部，并返回这个元素——无阻塞</p><ul><li><p>命令格式：<code>rpoplpush source_key destination_key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">rpoplpush</span> <span class="string">c1</span> <span class="string">c2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">弹出列表c1的尾部元素插入到列表c2的头部，若c1为空，则返回nil，但不插入到c2中，是不是更适合做队列</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出一个列表中的最后一个元素到另外一个列表头部，并返回这个元素——阻塞</p><ul><li><p>命令格式：<code>brpoplpush source_key destination_key timeout</code>    timeout单位为***秒***</p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">brpoplpush</span> <span class="string">c3</span> <span class="string">c2</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">弹出列表c3的尾部元素插入到列表c2的头部，若c3为空，则阻塞等到列表c3中有值，否则等到了10秒后结束阻塞返回nil，是不是更适合做阻塞队列</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>其他命令</p></blockquote><ol><li><p>删除指定范围内等于某个值的所有元素</p><ul><li><p>命令格式：<code>lrem key index element</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1)lrem c1 -2 3</span><br><span class="line">---</span><br><span class="line">移除列表c1中，从倒数第二个元素到列表头部范围内所有的3</span><br><span class="line"></span><br><span class="line">2)lrem c1 3 2</span><br><span class="line">---</span><br><span class="line">移除列表c1中，从第四位元素到尾部范围内所有的2</span><br><span class="line"></span><br><span class="line">3)lrem c1 0 1</span><br><span class="line">---</span><br><span class="line">移除列表c1中所有的1</span><br><span class="line"></span><br><span class="line">4)lrem c1 -1 4</span><br><span class="line">---</span><br><span class="line">移除列表c1中所有的4</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看列表长度</p><ul><li><p>命令格式：<code>llen key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">llen</span> <span class="string">c1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">查看列表c1的总长度，若c1不存在，则返回0，不会报错，记住，若列表不存在也不会报错</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis在线体验地址：
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis基本命令使用::hash篇</title>
    <link href="http://luxiaowan.github.io/2019/10/30/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E2%80%94hash%E7%AF%87/"/>
    <id>http://luxiaowan.github.io/2019/10/30/Redis基本命令使用—hash篇/</id>
    <published>2019-10-30T15:55:00.000Z</published>
    <updated>2019-10-31T16:05:56.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)</p></blockquote><p><strong>redis在线体验地址：<a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></strong></p><h2 id="哈希hash"><a class="markdownIt-Anchor" href="#哈希hash"></a> 哈希(Hash)</h2><blockquote><p>介绍:</p></blockquote><p>Redis hash 是一个存储多个键值对的映射表，适用于存储对象的属性，比如存储用户信息、用户Session信息等。在实际项目中使用的频率比较多，之前主要用于存储用户基本信息、用户临时订单信息、产品信息等。</p><blockquote><p>创建缓存</p></blockquote><ol><li><p>创建一个缓存</p><ul><li><p>命令格式：<code>hset key field value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hset</span> <span class="string">cc</span> <span class="string">name</span> <span class="string">'cc'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">将cc的name属性的值设置为cc</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>批量创建缓存</p><ul><li><p>命令格式：<code>hmset key filed value [field value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hmset</span> <span class="string">cc</span> <span class="string">name</span> <span class="string">'cc'</span> <span class="string">age</span> <span class="number">19</span> <span class="string">avatar</span> <span class="string">'a.png'</span> <span class="string">status</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">设置cc对象的name、age、avatar、status属性的值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置一个key不存在field的value，若field已存在则不设置</p><ul><li><p>命令格式：<code>hsetnx key field value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hsetnx</span> <span class="string">cc</span> <span class="string">name</span> <span class="string">'yy'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">若对象cc的name属性不存在，则设置cc的name属性值为yy</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>查看缓存</p></blockquote><ol><li><p>查看key下所有属性+值</p><ul><li><p>命令格式：<code>hgetall key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hgetall</span> <span class="string">cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">获取对象cc的所有属性，返回数据格式：</span></span><br><span class="line"> <span class="string">field1</span></span><br><span class="line"> <span class="string">value1</span></span><br><span class="line"> <span class="string">field2</span></span><br><span class="line"> <span class="string">value2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看key下所有的值</p><ul><li><p>命令格式：<code>hvals key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hvals</span> <span class="string">cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">返回cc对象的所有属性的值，仅返回值，不返回属性名称</span></span><br><span class="line"><span class="string">等同于</span> <span class="string">”hmget</span> <span class="string">key</span> <span class="string">所有field“</span> <span class="string">命令</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看key下所有的field名称</p><ul><li><p>命令格式：<code>hkeys key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hkeys</span> <span class="string">cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">返回对象cc的所有属性名</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看key的某一field的值</p><ul><li><p>命令格式：<code>hget key field</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hget</span> <span class="string">cc</span> <span class="string">name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">返回对象cc的name属性的值，若对象无此属性，则返回nil</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看key的多个field的值</p><ul><li><p>命令格式：<code>hmget key field [field ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hmget</span> <span class="string">cc</span> <span class="string">name</span> <span class="string">age</span> <span class="string">status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">返回对象cc的name、age、status属性</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>迭代对象的所有属性(适用于大对象)</p><ul><li><p>命令格式：<code>hscan key course [MATCH pattern] [COUNT num]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hscan cc <span class="number">0</span> MATCH *e COUNT <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看对象的属性数</p><ul><li><p>命令格式：<code>hlen key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hlen</span> <span class="string">cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">返回对象cc的属性数量</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>其他命令</p></blockquote><ol><li><p>删除一个/多个属性</p><ul><li><p>命令格式：<code>hdel key field [field ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hdel</span> <span class="string">cc</span> <span class="string">name</span> <span class="string">age</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">删除对象cc的name、age属性</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看对象属性是否存在</p><ul><li><p>命令格式：<code>hexists key field</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hexists</span> <span class="string">cc</span> <span class="string">name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">对象cc若存在属性name，则返回1，不存在则返回0</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis在线体验地址：
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis基本命令使用::string篇</title>
    <link href="http://luxiaowan.github.io/2019/10/29/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E2%80%94string%E7%AF%87/"/>
    <id>http://luxiaowan.github.io/2019/10/29/Redis基本命令使用—string篇/</id>
    <published>2019-10-29T15:55:00.000Z</published>
    <updated>2019-10-30T16:43:50.550Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)</p></blockquote><p><strong>redis在线体验地址：<a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></strong></p><h2 id="字符串string"><a class="markdownIt-Anchor" href="#字符串string"></a> 字符串(String)</h2><blockquote><p>介绍:</p></blockquote><p>字符串是Redis中最基本的数据类型，数据以二进制的形式存储于内存中，所以Redis的字符串可以是任何形式的数据，比如JPEG图像、序列化的Ruby对象等。</p><p>字符串最大可存储512MB的数据，但一般一个字符串容量过大，会直接影响存储和查询的效率。字符串有两种编码方式：raw和embstr，根据字符串长度自动选择使用哪一种编码，目前最新版的长度是44个字节，字符串长度小于等于44个字节，则使用embstr编码，大于44个字节则使用raw编码，两种编码方式这里就不作详解，有兴趣的可以谷歌一下。</p><blockquote><p>创建缓存</p></blockquote><ol><li><p>创建一个缓存</p><ul><li><p>命令格式：<code>set key value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">set</span> <span class="string">cc</span> <span class="string">'niubility'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">创建一个key为cc，值为niubility的缓存</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>批量创建缓存</p><ul><li><p>命令格式：<code>mset key value [key value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mset</span> <span class="string">cc1</span> <span class="number">1</span> <span class="string">cc2</span> <span class="number">2</span> <span class="string">cc3</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">创建三个缓存，key:value分别为cc1:1,</span> <span class="attr">cc2:2,</span> <span class="attr">cc3:3</span></span><br></pre></td></tr></table></figure></li><li><p>命令格式：<code>msetnx key value [key value ...]</code></p><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">msetnx</span> <span class="string">cc1</span> <span class="number">11</span> <span class="string">cc2</span> <span class="number">22</span> <span class="string">cc5</span> <span class="number">5</span> <span class="string">cc6</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">此命令只会将尚不存在的key值创建到缓存中，已经存在的key则忽略</span></span><br><span class="line"><span class="string">*</span> <span class="string">cc1、cc2已存在于缓存中，所以不会创建/更新成功，cc5、cc6不存在于缓存中，会创建</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建一个带过期时间的缓存</p><ul><li><p>命令格式：<code>setex key time value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">setex</span> <span class="string">cc1</span> <span class="number">10</span> <span class="number">234</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">设置key:value为cc1:234且过期时间为10秒的缓存</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置一个不存在key的value，若key已存在则不设置</p><ul><li><p>命令格式：<code>setnx key value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">setnx</span> <span class="string">cc5</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">若cc5的key不存在于缓存中，则创建key:value为cc5:12的缓存，否则不执行创建</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>组合创建一个缓存(缓存过期时间、是否覆盖)</p><ul><li><p>命令格式：<code>set key value [EX|PX time] [NX|XX]</code></p><blockquote><p>解析：</p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   EX：表明过期时间为秒</span><br><span class="line">   </span><br><span class="line">PX：表明过期时间为毫秒</span><br><span class="line">   </span><br><span class="line">   NX：若<span class="built_in">key</span>不存在则执行，否则不执行，与XX相反</span><br><span class="line">   </span><br><span class="line">   XX：若<span class="built_in">key</span>存在则执行，否则不执行，与NX相反</span><br></pre></td></tr></table></figure></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">set</span> <span class="string">cc1</span> <span class="number">123</span> <span class="string">EX</span> <span class="number">20</span> <span class="string">XX</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">---</span></span><br><span class="line">  <span class="string">若cc1已存在则创建过期时间为20秒的key:value</span> <span class="string">=</span> <span class="attr">cc1:123</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>将key设置为新值的同时返回原值</p><ul><li><p>命令格式：<code>getset key value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">getset</span> <span class="string">cc1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">若key不存在，则返回nil</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>读取缓存</p></blockquote><ol><li><p>读取一个key的缓存值</p><ul><li><p>命令格式：<code>get key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">get</span> <span class="string">cc1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">读取key=cc1的值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>批量读取一批数据</p><ul><li><p>命令格式：<code>mget key [key ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget <span class="keyword">cc</span><span class="number">1</span> <span class="keyword">cc</span><span class="number">2</span> <span class="keyword">cc</span><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>截取字符串并返回</p><ul><li><p>命令格式：<code>getrange key start end</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">getrange</span> <span class="string">cc1</span> <span class="number">1</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">字符串下标以0开始，若start超出字符串长度或key不存在，则返回空字符串</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>其他操作</p></blockquote><ol><li><p>将value加1( value必须为整数 )[ 可用于阅读量、点赞数等简单统计类的功能应用 ]</p><ul><li><p>命令格式：<code>incr key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">incr</span> <span class="string">cc1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">每次调用均对value进行+1操作</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>给value加上某个数( num必须为整数 )</p><ul><li><p>命令格式：<code>incrby key num</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">incrby</span> <span class="string">cc1</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">给cc1的值加上100</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>给value加上某个浮点数</p><ul><li><p>命令格式：<code>incrbyfloat key num</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrbyfloat cc1 <span class="number">0.2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>给value减1</p><ul><li><p>命令格式：<code>decr key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">decr</span> <span class="string">cc1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">每次调用均对value进行-1操作</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>给value减去某个数( num必须为整数 )</p><ul><li><p>命令格式：<code>descby key num</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">decrby</span> <span class="string">cc1</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">给cc1的值减去100</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看value的长度</p><ul><li><p>命令格式：<code>strlen key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span> cc1</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>目前先整理这些，都是一些基础的命令，随后再写一篇Java中使用Jedis操作字符串的随笔。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis在线体验地址：
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis数据在内存中是如何存储的</title>
    <link href="http://luxiaowan.github.io/2019/10/29/Redis%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/"/>
    <id>http://luxiaowan.github.io/2019/10/29/Redis数据在内存中是如何存储的/</id>
    <published>2019-10-29T08:50:00.000Z</published>
    <updated>2019-10-29T15:02:17.269Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL索引什么时候用hash</title>
    <link href="http://luxiaowan.github.io/2019/10/28/MySQL%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8hash/"/>
    <id>http://luxiaowan.github.io/2019/10/28/MySQL索引什么时候用hash/</id>
    <published>2019-10-28T11:06:00.000Z</published>
    <updated>2019-10-29T14:10:04.447Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL索引是在面试中常被问到的知识点，常用的两种索引方法有Hash和B+Tree，树的结构我们改天再扯，今天说收Hash。</p><blockquote><p>为什么使用hash</p></blockquote><p>Hash索引可以根据数据的hash值直接定位到索引数据的存储位置，就相当于我知道了数组的下标，然后根据下标去取数据，这个效率可以说是最高的了，使用hash就是为了如此。</p><blockquote><p>支持hash的存储引擎</p></blockquote><p>目前支持hash的引擎有MEMORY(这里需要谷歌)，其他的引擎都通过各自的方式去支持hash方法。如InnoDB有一套自适应hash算法，内部实现还是采用了BT的方式，可以理解为BT索引的索引</p><blockquote><p>InnoDB中hash索引支持的开启/关闭</p></blockquote><p>hash索引虽然非常快速，但是在InnoDB中确实支持的不是很好，并且索引的具体创建是由引擎决定的(创建后存在于内存中)，非DBA可控，所以一般情况下建议关闭hash支持，使用BT也能够满足性能要求。</p><p>​<code>set global innodb_adaptive_hash_index=off/on</code></p><blockquote><p>hash的使用场景</p></blockquote><p>hash使用场景比较局限</p><ol><li>hash索引仅适用于‘=’、‘&lt;=&gt;’和‘in’操作，所以hash仅仅适用于精确查找。</li><li>不适用于查询排序，因为hash后的数据并不会像原数据一样保持有序。</li><li>不适用于模糊查询，也就是不能使用like关键字。</li><li>既然不支持排序，也肯定不支持范围查询咯</li></ol><blockquote><p>解决hash冲突</p></blockquote><p>不论hash的算法多么精确，当数据量大的时候都有可能发生hash碰撞，解决hash碰撞的方法有很多，比如再hash、链表叠加等，MySQL采用的是链表叠加的方式，也就是类似于HashMap解决hash碰撞的方法。所以在发生hash碰撞过多的情况下，使用hash索引会影响查询性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL索引是在面试中常被问到的知识点，常用的两种索引方法有Hash和B+Tree，树的结构我们改天再扯，今天说收Hash。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么使用hash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hash索引可以根据数据的hash值直接定位
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Session和Redis实现Session共享</title>
    <link href="http://luxiaowan.github.io/2019/10/24/Spring-Session%E5%92%8CRedis%E5%AE%9E%E7%8E%B0Session%E5%85%B1%E4%BA%AB/"/>
    <id>http://luxiaowan.github.io/2019/10/24/Spring-Session和Redis实现Session共享/</id>
    <published>2019-10-24T11:30:00.000Z</published>
    <updated>2019-10-24T15:18:45.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>需求</p><blockquote><p>现在大部分服务都以集群负载均衡的方式部署，几乎很难再遇到单点部署的项目，因为大家都要保证最基本的HA，说到HA，第一要考虑的就是各系统之间的Session共享的问题，如何解决呢？负载均衡当前使用Nginx</p></blockquote></blockquote><hr><blockquote><p>分析</p><blockquote><p><img src="/images/image-20191024193415981.png" alt></p></blockquote><blockquote><ol><li>不同的POD之间如果需要达到数据共享的目的，那么则需要使用同一个存储媒介，一开始想到使用MySQL来存储登录session，但是每次请求都去MySQL中查询数据，开销还是非常大的；然后最近使用MongoDB比较嗨，想着用MongoDB，但是MongoDB查询起来也不方便，况且我们这个Session也不是量级很大的数据集，最终采用了内存级的Redis来解决这个问题。</li><li>使用Redis的基本操作是将jsessionId为key，用户信息为value，使用jedis或者redisTemplate来操作Redis的读写行为。但是这种方式侵入了业务代码，并不是最优解，查了部分资料之后，发现spring-session.jar包中有一个非常有特色的注解@EnableRedisHttpSession，可以不需要侵入业务代码就能使用redis实现session共享的问题。</li></ol></blockquote></blockquote><ul><li>我们看一下@EnableRedisHttpSession的源码是怎么说的：</li></ul><p><img src="/images/image-20191024223839113.png" alt="image-20191024223839113"></p><blockquote><p>将此注释添加到一个单独的类上，该类必须加上@Configuration注解。使用方式在注释里也给出了demo代码。</p></blockquote><hr><blockquote><p>实现</p></blockquote><ol><li>修改pom.xml文件，引入我们需要的jar包</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改application.yml文件，配置redis信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line">spring.redis.host=localhost</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">spring.redis.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisHttpSessionConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们使用Redis实现Session共享的所有配置和代码都已经写完了，可以看到我们没有侵入到任何业务代码中，从头到尾也很简单。</p><blockquote><p>扩展</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGemFireHttpSession</span></span><br><span class="line"><span class="meta">@EnableSpringHttpSession</span></span><br><span class="line"><span class="meta">@EnableMongoHttpSession</span></span><br><span class="line"><span class="meta">@EnableJdbcHttpSession</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;需求&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在大部分服务都以集群负载均衡的方式部署，几乎很难再遇到单点部署的项目，因为大家都要保证最基本的HA，说到HA，第一要考虑的就是各系统之间的Session共享的问题，如何解决呢？负载均衡当前使用Ngin
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>Java简单操作MongoDB</title>
    <link href="http://luxiaowan.github.io/2019/10/24/Java%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9CMongoDB/"/>
    <id>http://luxiaowan.github.io/2019/10/24/Java简单操作MongoDB/</id>
    <published>2019-10-24T02:16:00.000Z</published>
    <updated>2019-10-24T13:20:12.762Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面已经掌握了mongo最基本的一些命令，对各个命令也都实操过，理解各命令的意思，也对mongo有了最基本的理解，但大部分猿还是想使用Java去连接mongo，串串也不例外</p></blockquote><ul><li><p>在pom.xml中加入mongodb-java-driver.jar的依赖</p><ul><li><p>Maven项目依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.0.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>SpringBoot项目依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>连接mongo</p><ul><li><p>认证连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建验证信息，根据加密方式选择MongoCredential内对应的加密方式</span></span><br><span class="line">List&lt;MongoCredential&gt; credentials = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">MongoCredential credential = MongoCredential.createCredential(<span class="string">"admin"</span>, <span class="string">"test1"</span>, <span class="string">"admin"</span>.toCharArray());</span><br><span class="line">credentials.add(credential);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建mongo服务地址</span></span><br><span class="line">ServerAddress serverAddress = <span class="keyword">new</span> ServerAddress(<span class="string">"localhost"</span>, <span class="number">27017</span>);</span><br><span class="line">MongoClient mongoClient = <span class="keyword">new</span> MongoClient(serverAddress, credentials);</span><br></pre></td></tr></table></figure></li><li><p>无需认证连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoClient client = <span class="keyword">new</span> MongoClient(<span class="string">"localhost"</span>, <span class="number">27017</span>);</span><br></pre></td></tr></table></figure><p>然后就可以通过MongoClient的实例方法对mongo进行相关操作了</p></li></ul></li><li><p>创建数据库连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoDatabase db = client.getDatabase(<span class="string">"test1"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>mongo特性是不管数据库事先是否存在，都可以正常创建数据库连接，不会像MySQL一样报错，连接成功后，在mongo服务器上执行<code>show dbs</code>，会发现仍然查不到我们连接的这个数据库，这是正常情况，只有在数据库中有数据的时候，才会查得出来，<code>client.getDatabase(&quot;test&quot;) === use test命令</code></p></blockquote></li><li><p>创建集合</p><ul><li>使用数据库连接实例方法创建一个空的集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(<span class="string">"base_info"</span>);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  命令：db.createCollection(<span class="string">"base_info"</span>)</span><br></pre></td></tr></table></figure><ul><li>直接向创建的集合中插入数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MongoCollection&lt;Document&gt; collection = db.getCollection(<span class="string">"base_info"</span>);</span><br><span class="line">collection.insertOne(<span class="keyword">new</span> Document(<span class="string">"name"</span>, <span class="string">"lxl"</span>));</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  命令：db.base_info.insert(&#123;<span class="string">"name"</span>: <span class="string">"lxl"</span>&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>以上两种方式均可创建一个集合，区别在于第一种方式创建的是空集合，</p></blockquote></li><li><p>删除集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">collection.drop();</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  命令：db.base_info.drop()</span><br></pre></td></tr></table></figure></li></ul><h4 id="对集合的crud"><a class="markdownIt-Anchor" href="#对集合的crud"></a> 对集合的CRUD</h4><ul><li><p>新增数据</p><ul><li><p>单条新增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Document document = <span class="keyword">new</span> Document().append(<span class="string">"name"</span>,<span class="string">"cc"</span>).append(<span class="string">"age"</span>,<span class="number">30</span>).append(<span class="string">"location"</span>,<span class="string">"SZ"</span>);</span><br><span class="line">collection.insertOne(document);</span><br></pre></td></tr></table></figure></li><li><p>批量新增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Document&gt; documentList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  Document doc = <span class="keyword">new</span> Document().append(<span class="string">"name"</span>, <span class="string">"cc"</span> + i).append(<span class="string">"age"</span>, <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>)).append(<span class="string">"location"</span>, <span class="string">"SZ"</span>);</span><br><span class="line">  documentList.add(doc);</span><br><span class="line">&#125;</span><br><span class="line">collection.insertMany(documentList);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>insertOne(Document)方法每次插入一条数据</p><p>insertMany(List<document>)方法批量插入数据，并且可以通过参数InsertManyOptions设置是否排序</document></p></blockquote></li><li><p>删除数据</p><ul><li>删除第一条匹配的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">99</span>);</span><br><span class="line">collection.deleteOne(condition);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  命令：db.base_info.deleteOne(&#123;<span class="string">"age"</span>: <span class="number">99</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>删除所有匹配数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">99</span>);</span><br><span class="line">collection.deleteMany(condition);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  命令：db.base_info.deleteMany(&#123;<span class="string">"ag"</span>: <span class="number">99</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>查询数据</p><ul><li><p>查询返回第一条匹配的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">16</span>);</span><br><span class="line">FindIterable&lt;Document&gt; vals = collection.find(condition);</span><br><span class="line">Document document = vals.first();</span><br><span class="line">System.out.println(document.toJson());</span><br></pre></td></tr></table></figure><blockquote><p>通过调用FindIterable的实例方法first()取第一条数据</p></blockquote></li><li><p>查询返回所有匹配数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">16</span>);</span><br><span class="line">FindIterable&lt;Document&gt; vals = collection.find(condition);</span><br><span class="line"><span class="keyword">for</span> (Document val : vals) &#123;</span><br><span class="line">  System.out.println(val.toJson());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>find()方法返回所有匹配数据</p></blockquote></li><li><p>分页查询</p><p>分页查询是我们日常开发中经常用到的功能，尤其是mongo这种量级较大的存储，分页使用limit()和skip()两个方法来实现，limit指定查询的条数，skip进行分页，参数为从第几条开始，需要使用当前页码和分页条数进行计算(pageNo - 1) * pageSize</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.lt(<span class="string">"age"</span>, <span class="number">2</span>);</span><br><span class="line">FindIterable&lt;Document&gt; vals = collection.find(condition).limit(<span class="number">10</span>).skip(<span class="number">10</span>).sort(Sorts.descending(<span class="string">"age"</span>));</span><br><span class="line"><span class="keyword">for</span> (Document val : vals) &#123;</span><br><span class="line">  System.out.println(val.toJson());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>limit(10): 每页取10条数据</p><p>skip(10): 从第11条开始查询，起始位置为0</p><p>sort(Sorts.descending(“age”)): 以列age倒序</p><blockquote><p>对应MySQL：select * from base_info where age &lt; 2 order by age desc limit 7, 7</p></blockquote></blockquote></li></ul></li><li><p>更新数据</p><ul><li><p>更新第一条匹配数据中的某些字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">15</span>);</span><br><span class="line">Document document = <span class="keyword">new</span> Document(<span class="string">"$set"</span>, <span class="keyword">new</span> Document(<span class="string">"location"</span>, <span class="string">"XZ"</span>));</span><br><span class="line">collection.updateOne(condition, document);</span><br></pre></td></tr></table></figure><blockquote><p>注意这里有一个<code>$set</code>，这个指令是必须的，相对应的指令还有<code>$inc</code></p></blockquote></li><li><p>替换第一条匹配数据全部内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">15</span>);</span><br><span class="line">Document document = <span class="keyword">new</span> Document(<span class="string">"location"</span>, <span class="string">"XZ"</span>);</span><br><span class="line">collection.updateOne(condition, document);</span><br></pre></td></tr></table></figure><blockquote><p>没有<code>$set</code>指令,则表示使用参数document替换掉第一条匹配到的数据</p></blockquote></li><li><p>第一条匹配的数据中指定字段数量+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"location"</span>, <span class="string">"XZ"</span>);</span><br><span class="line">Document document = <span class="keyword">new</span> Document(<span class="string">"$inc"</span>, <span class="keyword">new</span> Document(<span class="string">"age"</span>, <span class="number">1</span>));</span><br><span class="line">collection.updateOne(condition, document);</span><br></pre></td></tr></table></figure></li><li><p>更新所有匹配数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">15</span>);</span><br><span class="line">Document document = <span class="keyword">new</span> Document(<span class="string">"$set"</span>, <span class="keyword">new</span> Document(<span class="string">"location"</span>, <span class="string">"XZ"</span>));</span><br><span class="line">collection.updateMany(condition, document);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="全部代码"><a class="markdownIt-Anchor" href="#全部代码"></a> 全部代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.bson.Document;</span><br><span class="line"><span class="keyword">import</span> org.bson.conversions.Bson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClient;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.FindIterable;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoCollection;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.model.Filters;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.model.Sorts;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConnectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MongoClient client = <span class="keyword">new</span> MongoClient(<span class="string">"localhost"</span>, <span class="number">27017</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // 创建验证信息，根据加密方式选择MongoCredential内对应的加密方式</span></span><br><span class="line"><span class="comment">            List&lt;MongoCredential&gt; credentials = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">            MongoCredential credential = MongoCredential.createCredential("admin", "test", "".toCharArray());</span></span><br><span class="line"><span class="comment">            credentials.add(credential);</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            // 创建mongo服务地址</span></span><br><span class="line"><span class="comment">            ServerAddress serverAddress = new ServerAddress("localhost", 27017);</span></span><br><span class="line"><span class="comment">            MongoClient mongoClient = new MongoClient(serverAddress, credentials);*/</span></span><br><span class="line"></span><br><span class="line">            MongoDatabase db = client.getDatabase(<span class="string">"test1"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建集合</span></span><br><span class="line">            <span class="comment">// 方式1</span></span><br><span class="line">            <span class="comment">// db.createCollection("base_info2");</span></span><br><span class="line">            <span class="comment">// 方式2</span></span><br><span class="line">            MongoCollection&lt;Document&gt; collection = db.getCollection(<span class="string">"base_info"</span>);</span><br><span class="line">            <span class="comment">// collection.insertOne(new Document("name", "lxl"));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除集合</span></span><br><span class="line">            <span class="comment">// collection.drop();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新增数据</span></span><br><span class="line">            <span class="comment">// 单条新增</span></span><br><span class="line">            <span class="comment">/*Document document = new Document().append("name", "cc").append("age", 30).append("location", "SZ");</span></span><br><span class="line"><span class="comment">            collection.insertOne(document);</span></span><br><span class="line"><span class="comment">            // 批量新增</span></span><br><span class="line"><span class="comment">            List&lt;Document&gt; documentList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">            for (int i = 0; i &lt; 1000; i++) &#123;</span></span><br><span class="line"><span class="comment">                Document doc = new Document().append("name", "cc" + i).append("age", new Random().nextInt(100))</span></span><br><span class="line"><span class="comment">                        .append("location", "SZ");</span></span><br><span class="line"><span class="comment">                documentList.add(doc);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            collection.insertMany(documentList);*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除数据</span></span><br><span class="line">            <span class="comment">// 删除第一条匹配数据</span></span><br><span class="line">            <span class="comment">/*Bson condition = Filters.eq("age", 99);</span></span><br><span class="line"><span class="comment">            collection.deleteOne(condition);</span></span><br><span class="line"><span class="comment">            // 删除所有匹配数据</span></span><br><span class="line"><span class="comment">            collection.deleteMany(condition);*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改数据</span></span><br><span class="line">            <span class="comment">// 修改第一条匹配数据</span></span><br><span class="line">            <span class="comment">/*Bson condition = Filters.eq("age", 15);</span></span><br><span class="line"><span class="comment">            Document document = new Document("$set", new Document("location", "XZ"));</span></span><br><span class="line"><span class="comment">            collection.updateOne(condition, document);</span></span><br><span class="line"><span class="comment">            collection.updateMany(condition, document);*/</span></span><br><span class="line">            <span class="comment">// 年龄+1</span></span><br><span class="line">            <span class="comment">/*Bson condition = Filters.eq("location", "XZ");</span></span><br><span class="line"><span class="comment">            Document document = new Document("$inc", new Document("age", 1));</span></span><br><span class="line"><span class="comment">            collection.updateOne(condition, document);*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询返回第一条匹配数据</span></span><br><span class="line">            Bson condition = Filters.lt(<span class="string">"age"</span>, <span class="number">2</span>);</span><br><span class="line">            FindIterable&lt;Document&gt; vals = collection.find(condition).sort(Sorts.descending(<span class="string">"age"</span>)).limit(<span class="number">7</span>).skip(<span class="number">7</span>);</span><br><span class="line">            <span class="comment">// Document document = vals.first();</span></span><br><span class="line">            <span class="comment">// System.out.println(document.toJson());</span></span><br><span class="line">            <span class="keyword">for</span> (Document val : vals) &#123;</span><br><span class="line">                System.out.println(val.toJson());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前面已经掌握了mongo最基本的一些命令，对各个命令也都实操过，理解各命令的意思，也对mongo有了最基本的理解，但大部分猿还是想使用Java去连接mongo，串串也不例外&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在pom.x
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://luxiaowan.github.io/categories/MongoDB/"/>
    
    
      <category term="Java与MongoDB" scheme="http://luxiaowan.github.io/tags/Java%E4%B8%8EMongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB监控、分片及备份恢复</title>
    <link href="http://luxiaowan.github.io/2019/10/24/MongoDB%E7%9B%91%E6%8E%A7%E3%80%81%E5%88%86%E7%89%87%E5%8F%8A%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"/>
    <id>http://luxiaowan.github.io/2019/10/24/MongoDB监控、分片及备份恢复/</id>
    <published>2019-10-23T16:00:00.000Z</published>
    <updated>2019-10-24T13:20:12.764Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://luxiaowan.github.io/categories/MongoDB/"/>
    
    
      <category term="监控" scheme="http://luxiaowan.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB基本指令</title>
    <link href="http://luxiaowan.github.io/2019/10/23/MongoDB%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
    <id>http://luxiaowan.github.io/2019/10/23/MongoDB基本指令/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-10-24T13:20:12.763Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>查看所有的db</p><p><code>show dbs</code></p></li><li><p>切换db</p><p><code>user &lt;db_name&gt;</code></p></li><li><p>查看当前所在db名称</p><p><code>db</code></p></li><li><p>删除db**(必须在要删除的db中操作)**</p><p><code>db.dropDatabase()</code></p></li><li><p>查看db下所有的集合</p><p><code>show tables</code></p><p><code>show collections</code></p></li><li><p>创建集合</p><ul><li><code>db.createCollection(&quot;abc&quot;)</code></li><li><code>db.createCollection(&quot;def&quot;, {capped: true, autoIndexId: true, size: 1024, max: 100})</code></li><li>往一张不存在的集合中插入一条数据，会自动创建集合<ul><li><code>db.test.insert({title: 123})</code></li></ul></li></ul></li><li><p>删除集合</p><p><code>db.&lt;collection_name&gt;.drop()</code></p><p>例：<code>db.abc.drop()</code></p></li><li><p>插入文档</p><ul><li><p><code>db.&lt;collection_name&gt;.insert({title: 1234})</code></p></li><li><p><code>doc=({title: 12345, name: &quot;MongoDB指南&quot;})</code></p><p><code>db.&lt;collection_name&gt;.insert(doc)</code></p></li><li><p><code>db.&lt;collection_name&gt;.save({name: &quot;MongoDB简单指令&quot;}})</code></p></li><li><p><code>doc2=({name: &quot;MongoDB从入门到放弃&quot;})</code></p><p><code>db.&lt;collection_name&gt;.save(doc2)</code></p></li><li><p><code>doc3=({_id: &quot;edrftgyhjkgjhfgv2ryuoio&quot;, name: &quot;MongoDB从入门到放弃&quot;})</code></p><p><code>db.&lt;collection_name&gt;.save(doc3)</code>// 若_id对应值的数据已经存在，则更新这条数据，否则新增一条数据</p></li></ul></li><li><p>更新文档</p><ul><li><code>db.&lt;collection_name&gt;.update({title: 1234}, {$set:{title: &quot;4321&quot;}})</code></li></ul><blockquote><p>格式：</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.update(</span><br><span class="line">&lt;where&gt;,<span class="regexp">//</span> 相当于MySQL的where</span><br><span class="line">&lt;update&gt;,<span class="regexp">//</span> 相当于MySQL的update语句的set，需要跟一些指令：<span class="variable">$,</span><span class="variable">$inc</span>,<span class="variable">$set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="symbol">upsert:</span> <span class="keyword">true</span>,<span class="regexp">//</span> <span class="keyword">true</span>：如果不存在记录，则新增；<span class="keyword">false</span>相反，默认</span><br><span class="line"><span class="symbol">multi:</span> <span class="keyword">true</span>,<span class="regexp">//</span> <span class="keyword">true</span>：只更新第一条匹配的记录；<span class="keyword">false</span>相反，全部更新， 默认</span><br><span class="line"><span class="symbol">writeConcern:</span> &lt;document&gt;<span class="regexp">//</span> 异常级别</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 1. 只更新第一条记录：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 1 &#125; &#125; , &#123; <span class="variable">$set</span> : &#123; <span class="string">"test2"</span> : <span class="string">"OK"</span>&#125; &#125; );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2. 全部更新：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 3 &#125; &#125; , &#123; <span class="variable">$set</span> : &#123; <span class="string">"test2"</span> : <span class="string">"OK"</span>&#125; &#125;,<span class="literal">false</span>,<span class="literal">true</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 3. 只添加第一条：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 4 &#125; &#125; , &#123; <span class="variable">$set</span> : &#123; <span class="string">"test5"</span> : <span class="string">"OK"</span>&#125; &#125;,<span class="literal">true</span>,<span class="literal">false</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 4. 全部添加进去:</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 5 &#125; &#125; , &#123; <span class="variable">$set</span> : &#123; <span class="string">"test5"</span> : <span class="string">"OK"</span>&#125; &#125;,<span class="literal">true</span>,<span class="literal">true</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 5. 全部更新：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 15 &#125; &#125; , &#123; <span class="variable">$inc</span> : &#123; <span class="string">"count"</span> : 1&#125; &#125;,<span class="literal">false</span>,<span class="literal">true</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 6. 只更新第一条记录：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 10 &#125; &#125; , &#123; <span class="variable">$inc</span> : &#123; <span class="string">"count"</span> : 1&#125; &#125;,<span class="literal">false</span>,<span class="literal">false</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><ul><li><p><code>db.&lt;collection_name&gt;.save()</code></p><p>调用save指令一般需要指定_id</p></li></ul></li><li><p>删除文档</p><p><code>db.&lt;collection_name&gt;.remove({title: &quot;4321&quot;}, true)</code></p><blockquote><p>格式</p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="params">&lt;collection_name&gt;</span>.remove(</span><br><span class="line"><span class="params">&lt;where&gt;</span>,<span class="comment">// 相当于MySQL的where</span></span><br><span class="line"><span class="params">&lt;justOne&gt;</span><span class="comment">// true：只删除一条匹配条件的数据；false：匹配条件的数据全部删除，默认</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>删除集合中所有数据</p><p><code>db.&lt;collection_name&gt;.remove({})</code></p></li><li><p>新函数：</p><ul><li><code>db.&lt;collection_name&gt;.deleteMany({})</code></li><li><code>db.&lt;collection_name&gt;.deleteOne({title: &quot;12345&quot;})</code></li></ul></li></ul></li><li><p>查询文档</p><ol><li>普通查询</li></ol><blockquote><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.&lt;collection_name&gt;.find(</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;<span class="built_in">where</span>&gt;, // 查询条件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;colName&gt;// 返回字段名称</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> )</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><ul><li>创建一个集合，插入三条数据</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.insert([&#123;<span class="string">name:</span> <span class="string">"cc"</span>, <span class="string">age:</span> <span class="string">"29"</span>, <span class="string">gender:</span> <span class="number">1</span>&#125;, &#123;<span class="string">name:</span> <span class="string">"ccc"</span>, <span class="string">age:</span> <span class="string">"30"</span>, <span class="string">gender:</span> <span class="number">2</span>&#125;, &#123;<span class="string">name:</span> <span class="string">"c"</span>, <span class="string">age:</span> <span class="string">"28"</span>, <span class="string">gender:</span> <span class="number">1</span>&#125;])</span><br></pre></td></tr></table></figure><ul><li><p>查询集合中全部数据</p><p>普通显示：<code>db.user.find()</code></p><p>格式化显示：<code>db.user.find().pretty()</code></p></li><li><p>查询name=&quot;c&quot;的信息</p><p><code>db.user.find({name: &quot;c&quot;}).pretty()</code></p></li><li><p>查询只返回第一个匹配到的数据</p><p><code>db.user.findOne({name: &quot;c&quot;})</code></p></li></ul><ol start="2"><li><p>AND查询</p><p><code>db.user.find({key: value, key: value})</code></p><p>And查询即是在where条件里面用逗号&quot;,&quot;分隔</p><blockquote><p>栗子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.<span class="builtin-name">find</span>(&#123;name:<span class="string">"cc"</span>, gender:1&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; ---</span><br><span class="line">&gt; 等同于MySQL：</span><br><span class="line">&gt; select * <span class="keyword">from</span><span class="built_in"> user </span>where name = <span class="string">"c"</span> <span class="keyword">AND</span> gender = 1</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>OR查询</p><p><code>db.user.find({$or:[{key:value}, {key:value}]})</code></p><blockquote><p>栗子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.<span class="builtin-name">find</span>(&#123;</span><br><span class="line">&gt; <span class="variable">$or</span>:[&#123;name:<span class="string">"c"</span>&#125;, &#123;gender:2&#125;]</span><br><span class="line">&gt; &#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; ---</span><br><span class="line">&gt; 等同于MySQL：</span><br><span class="line">&gt; select * <span class="keyword">from</span><span class="built_in"> user </span>where name = <span class="string">"c"</span> <span class="keyword">OR</span> gender = 2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>AND和OR组合查询</p><p><code>db.user.find({key:value, $or:[{key:value}, {key:value}]})</code></p><blockquote><p>栗子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.<span class="builtin-name">find</span>(&#123;gender:1, <span class="variable">$or</span>:[&#123;name: <span class="string">"c"</span>&#125;, &#123;age: <span class="string">"28"</span>&#125;]&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; ---</span><br><span class="line">&gt; 等同于MySQL：</span><br><span class="line">&gt; select * <span class="keyword">from</span><span class="built_in"> user </span>where gender = 1 <span class="keyword">AND</span> (name = <span class="string">"c"</span> <span class="keyword">OR</span> age = <span class="string">"28"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p>运算符</p><table><thead><tr><th>运算符</th><th>格式</th><th>案例</th><th>MySQL对应语句</th></tr></thead><tbody><tr><td>等于</td><td>{key:value}<br>{key:{$eq:value}}</td><td>db.user.find({age:“29”})<br>db.user.find({age:{$eq:“29”}})</td><td>where age = “29”</td></tr><tr><td>大于</td><td>{key:{$gt: value}}</td><td>db.user.find({age:{$gt:“30”}})</td><td>where age &gt; “30”</td></tr><tr><td>小于</td><td>{key:{$lt: value}}</td><td>db.user.find({age:{$lt: “30”}})</td><td>where age &lt; “30”</td></tr><tr><td>大于等于</td><td>{key:{$gte: value}}</td><td>db.user.find({age:{$gte:“30”}})</td><td>where age &gt;= “30”</td></tr><tr><td>小于等于</td><td>{key:{$lte: value}}</td><td>db.user.find({age:{$lte:“30”}})</td><td>where age &lt;= “30”</td></tr><tr><td>不等于</td><td><span class="katex-error" title="ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: {key:{">{key:{</span>ne: value}}</td><td>db.user.find({age:{$ne:“29”}})</td><td>where age != “30”</td></tr></tbody></table></blockquote><ol start="5"><li><p>模糊查询</p><ul><li>查询age包含0的：<code>db.user.find({age:/0/})</code></li><li>查询age以2开头的：db.user.find({age:/^2/})</li><li>查询age以8结束的：db.user.find({age:/8$/})</li></ul></li><li><p>分页查询</p><blockquote><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.&lt;collection_name&gt;.find().<span class="built_in">limit</span>(Number).skip(Number)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">limit</span>(Number)表示查询多少条数据</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> skip(Number)表示从第几条开始查询</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><ul><li><p>查询一条数据</p><ul><li>第一种方法：<code>db.user.findOne({})</code></li><li>第二种方法：<code>db.user.find({}).limit(1)</code></li></ul></li><li><p>从第二条数据开始查询一条数据</p><p><code>db.user.find().limit(1).skip(2)</code></p></li></ul></li><li><p>查询排序</p><blockquote><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.&lt;collection_name&gt;.find().sort(&#123;&lt;key_name&gt;:-1/1&#125;)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;key_name&gt;：排序字段</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -1：倒序</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1：正序</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><ul><li><p>按照年龄倒序</p><p><code>db.user.find().sort({age:-1})</code></p></li><li><p>按照年龄倒序、性别正序</p><p><code>db.user.find().sort({age:-1, gender:1})</code></p></li></ul></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看所有的db&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show dbs&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换db&lt;/p&gt;
&lt;p&gt;&lt;code&gt;user &amp;lt;db_name&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看当前所在db
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://luxiaowan.github.io/categories/MongoDB/"/>
    
    
      <category term="基本指令" scheme="http://luxiaowan.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB连接报错java.lang.NoSuchFieldError ACKNOWLEDGED</title>
    <link href="http://luxiaowan.github.io/2019/10/23/MongoDB%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99java.lang.NoSuchFieldError-ACKNOWLEDGED/"/>
    <id>http://luxiaowan.github.io/2019/10/23/MongoDB连接报错java.lang.NoSuchFieldError-ACKNOWLEDGED/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-10-24T13:20:12.764Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BUG描述</p></blockquote><p>使用SpringBoot整合MongoDB时，正要运行代码连接mongo，就赤红赤红的报了个错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.NoSuchFieldError</span>: ACKNOWLEDGED</span><br><span class="line">at com<span class="selector-class">.mongodb</span><span class="selector-class">.MongoClientOptions</span><span class="variable">$Builder</span>.&lt;init&gt;(MongoClientOptions<span class="selector-class">.java</span>:<span class="number">960</span>)</span><br><span class="line">at com<span class="selector-class">.mongodb</span><span class="selector-class">.MongoClient</span>.&lt;init&gt;(MongoClient<span class="selector-class">.java</span>:<span class="number">155</span>)</span><br><span class="line">at com<span class="selector-class">.mongodb</span><span class="selector-class">.MongoClient</span>.&lt;init&gt;(MongoClient<span class="selector-class">.java</span>:<span class="number">145</span>)</span><br><span class="line">at com<span class="selector-class">.example</span><span class="selector-class">.demo</span><span class="selector-class">.mongo</span><span class="selector-class">.MongoConnectTest</span><span class="selector-class">.main</span>(MongoConnectTest<span class="selector-class">.java</span>:<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>这一下就傻眼了，对于刚接触mongo的人来说，是很懵圈的，大脑知识库中没有这个异常信息的解决办法，只能谷歌了，没想到有那么多人遇到过这个问题</p><hr><blockquote><p>BUG解决</p></blockquote><p>在Stack Overflow上找到一个帖子：</p><blockquote><p><a href="https://stackoverflow.com/questions/13593614/mongodb-java-lang-nosuchfielderror" target="_blank" rel="noopener">https://stackoverflow.com/questions/13593614/mongodb-java-lang-nosuchfielderror</a></p></blockquote><p>其中jyemin的回答可以说是直击要害了，顺利的解决了这个问题，我把截图贴上，以防帖子被删</p><blockquote><blockquote><p><img src="/images/image-20191023182806521.png" alt="image-20191023182806521"></p></blockquote></blockquote><p><strong>其实就是在工程中引入了多个版本不同的mongo-java-driver，所以导致程序混乱，只要保留自己真正使用的那个版本，其他的都删除即可</strong></p><blockquote><p>我的配置：</p><blockquote><p><img src="/images/image-20191023183034949.png" alt="image-20191023183034949"></p></blockquote><p>将2.7.1版本的依赖删除就可以正常运行了</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;BUG描述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用SpringBoot整合MongoDB时，正要运行代码连接mongo，就赤红赤红的报了个错：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://luxiaowan.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB错误记录" scheme="http://luxiaowan.github.io/tags/MongoDB%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB基础应用</title>
    <link href="http://luxiaowan.github.io/2019/10/23/MongoDB%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    <id>http://luxiaowan.github.io/2019/10/23/MongoDB基础应用/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-10-24T13:20:12.764Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h3><blockquote><p>说明：索引是为了加快查询速度，可以对集合中的一列或多列设置索引。</p><p>– 无索引：扫描整个集合的文档，查找符合条件的文档</p><p>– 有索引：查找索引，根据索引取出文档数据</p></blockquote><ol><li><p>创建索引</p><p><code>db.&lt;collection_name&gt;.createIndex(keys, option)</code></p><blockquote><p>栗子：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 单索引</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.user</span><span class="selector-class">.createIndex</span>(&#123;<span class="attribute">age</span>:-<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">---</span></span><br><span class="line"><span class="selector-tag">age</span>:索引列名</span><br><span class="line"><span class="selector-tag">-1</span>:倒序索引</span><br><span class="line">1:正序索引</span><br><span class="line"></span><br><span class="line">2. 多索引(复合索引)</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.user</span><span class="selector-class">.createIndex</span>(&#123;<span class="attribute">age</span>:<span class="number">1</span>, gender:-<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>可选参数</li></ul><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>background</td><td>Boolean</td><td>指定创建索引时是否阻塞集合的其他操作。true:后台执行，不阻塞；false:阻塞，默认</td></tr><tr><td>unique</td><td>Boolean</td><td>指定索引是否为唯一索引。true:唯一索引；false:不唯一，默认</td></tr><tr><td>name</td><td>String</td><td>索引名称，默认为字段名+索引顺序</td></tr><tr><td>v</td><td>index<br>version</td><td>索引版本号，默认为当前mongo的版本号</td></tr><tr><td>weights</td><td>Integer</td><td>1~99999之间，值越大权重越大</td></tr><tr><td>expireAfterSeconds</td><td>Integer</td><td>指定集合生存时间。秒级，TTL</td></tr><tr><td>sparse</td><td>Boolean</td><td>指定是否忽略不存在的字段。true:不查出不包含查询字段的文档；false:查询所有文档，默认</td></tr></tbody></table><blockquote><p>栗子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.create<span class="constructor">Index(&#123;<span class="params">name</span>:1&#125;, &#123;<span class="params">background</span>: <span class="params">true</span>, <span class="params">unique</span>: <span class="params">true</span>, <span class="params">name</span>: <span class="string">"idx_user_name"</span>, <span class="params">v</span>: 1, <span class="params">weights</span>: 99, <span class="params">sparse</span>: <span class="params">true</span>&#125;)</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; ---</span><br><span class="line">&gt; 后台不阻塞集合的方式创建一个name列正序,版本号为<span class="number">1</span>,权重<span class="number">99</span>,忽略无name字段的文档的唯一索引idx_user_name</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>查看所有索引</p><p><code>db.&lt;collection_name&gt;.getIndexes()</code></p><blockquote><p>栗子：</p><p><code>db.user.getIndexes()</code></p></blockquote></li><li><p>重建索引</p><ul><li><p>方法1：<code>db.&lt;collection_name&gt;.reIndex()</code></p></li><li><p>方法2：先删除原索引，然后再创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="tag">&lt;<span class="name">collection_name</span>&gt;</span>.dropIndex(<span class="tag">&lt;<span class="name">idx_name</span>&gt;</span>)</span><br><span class="line">db.<span class="tag">&lt;<span class="name">collection_name</span>&gt;</span>.createIndex(...)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除索引</p><ul><li><p>删除指定名称的索引：</p><p><code>db.user.dropIndex(&lt;idx_name&gt;)</code></p></li><li><p>删除集合中所有索引</p><p><code>db.user.dropIndexes()</code></p><blockquote><p>说明：只会删除自建的索引，集合中_id列的索引不会被删除</p></blockquote></li></ul></li></ol><hr><h3 id="聚合查询"><a class="markdownIt-Anchor" href="#聚合查询"></a> 聚合查询</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">创建集合并插入数据：</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.agg</span><span class="selector-class">.save</span>([&#123;</span><br><span class="line">   <span class="attribute">title</span>: <span class="string">'MongoDB Overview'</span>, </span><br><span class="line">   <span class="attribute">description</span>: <span class="string">'MongoDB is no sql database'</span>,</span><br><span class="line">   <span class="attribute">by_user</span>: <span class="string">'runoob.com'</span>,</span><br><span class="line">   <span class="attribute">url</span>: <span class="string">'http://www.runoob.com'</span>,</span><br><span class="line">   <span class="attribute">tags</span>: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   <span class="attribute">likes</span>: <span class="number">100</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">title</span>: <span class="string">'NoSQL Overview'</span>, </span><br><span class="line">   <span class="attribute">description</span>: <span class="string">'No sql database is very fast'</span>,</span><br><span class="line">   <span class="attribute">by_user</span>: <span class="string">'runoob.com'</span>,</span><br><span class="line">   <span class="attribute">url</span>: <span class="string">'http://www.runoob.com'</span>,</span><br><span class="line">   <span class="attribute">tags</span>: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   <span class="attribute">likes</span>: <span class="number">10</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">title</span>: <span class="string">'Neo4j Overview'</span>, </span><br><span class="line">   <span class="attribute">description</span>: <span class="string">'Neo4j is no sql database'</span>,</span><br><span class="line">   <span class="attribute">by_user</span>: <span class="string">'Neo4j'</span>,</span><br><span class="line">   <span class="attribute">url</span>: <span class="string">'http://www.neo4j.com'</span>,</span><br><span class="line">   <span class="attribute">tags</span>: [<span class="string">'neo4j'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   <span class="attribute">likes</span>: <span class="number">750</span></span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure><blockquote><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.&lt;collection_name&gt;.aggregate(condition)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> condition:</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [&#123;<span class="variable">$group</span>:&#123;_id:<span class="string">"$&lt;key&gt;"</span>, num_tutorial:&#123;$&lt;fun_expression&gt;:<span class="string">"$&lt;key&gt;"</span>&#125;&#125;&#125;]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="variable">$group</span>:一个组</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> _id:组合列，类同于MySQL的group by后面的字段，默认_id的列会在查询结果中显示</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> num_tutorial:输出的列名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $&lt;fun_expression&gt;:聚合表达式</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $&lt;key&gt;:运算的列名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>关键字：aggregate</p><p>说明：聚合查询就是求和、最大、最小、最前、最后、平均数的统称，类似于MySQL的count()、sum()、avg()</p></blockquote><blockquote><p>栗子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.aggregate([&#123;<span class="variable">$group</span>: <span class="variable">$&#123;_id:"$gender", num_tutorial:&#123;$sum:1&#125;</span>&#125;&#125;])</span><br><span class="line">&gt; </span><br><span class="line">&gt; ---</span><br><span class="line">&gt; 等同于MySQL：select gender, count(1) <span class="keyword">from</span><span class="built_in"> user group </span>by gender</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ol><li>聚合表达式</li></ol><table><thead><tr><th>表达式</th><th>描述</th><th>案例</th></tr></thead><tbody><tr><td>$sum</td><td>计算总和</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$sum:&quot;$likes&quot;}}}])</code><br>—<br>等同于MySQL：<code>select by_user, sum(likes) from agg group by by_user</code></td></tr><tr><td>$avg</td><td>计算平均值</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$avg:&quot;$likes&quot;}}}])</code><br>—<br>等同于MySQL：<code>select by_user, avg(likes) from agg group by by_user</code></td></tr><tr><td>$min</td><td>获取集合中指定列的最小值记录</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$min:&quot;$like&quot;}}}])</code><br>—<br>等同于MySQL：<code>select by_user, min(likes) from agg group by by_user</code></td></tr><tr><td>$max</td><td>获取集合中指定列的最大值记录</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$max:&quot;$likes&quot;}}}])</code><br>—<br>等同于MySQL：<code>select by_user, max(likes) from agg group by by_user</code></td></tr><tr><td>$push</td><td>在结果文档中插入值到数组</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$push:&quot;$url&quot;}}}])</code><br>—<br>等同于MySQL：查出所有数据，然后取字段url写入同一个列表中，url不去重，然后输出</td></tr><tr><td>$addToSet</td><td>在结果文档中插入值到一个数组中，但不创建副本</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$addToSet:&quot;$url&quot;}}}])</code><br>—<br>等同于MySQL：查出所有数据，然后取字段url写入同一个列表中，url去重，然后输出</td></tr><tr><td>$first</td><td>根据资源文档的排序获取第一个文档数据</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$first:&quot;$title&quot;}}}])</code></td></tr><tr><td>$last</td><td>根据资源文档的排序获取最后一个文档数据</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$last:&quot;$title&quot;}}}])</code></td></tr></tbody></table><hr><h3 id="管道函数"><a class="markdownIt-Anchor" href="#管道函数"></a> 管道函数</h3><blockquote><p>说明：管道函数类似于Linux系统中的管道操作，将上一步的运算结果作为下一步的输入值，最终达到理想计算结果的运算方式</p></blockquote><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>$project</td><td>指定需要输出的列，默认显示_id，格式：{$project:{by_user:1, title:1, url:1, _id:0<code>不显示id</code>}},</td></tr><tr><td>$limit</td><td>限制查询返回的文档数，格式：{$limit: 1},只返回一个文档</td></tr><tr><td>$skip</td><td>跳过指定数量的文档，返回之后的所有文档，格式：{$skip: 1},从第二个文档开始输出</td></tr><tr><td>$match</td><td>条件筛选，格式：{<span class="katex-error" title="ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …atch: {likes: {">match: {likes: {</span>gte: 10}}}</td></tr><tr><td>$group</td><td>聚合条件，格式：{<span class="katex-error" title="ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: group: {_id: &quot;">group: {_id: &quot;</span>by_user&quot;, count: {$sum: -1}}}</td></tr><tr><td>$sort</td><td>排序，格式：{$sort: {likes: -1}}，-1:倒序; 1:正序</td></tr><tr><td>$unwind</td><td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值</td></tr><tr><td>$geoNear</td><td>输出接近某一地理位置的有序文档。</td></tr></tbody></table><blockquote><p>栗子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.agg.aggregate(&#123;<span class="variable">$match</span>: &#123;likes: &#123;<span class="variable">$gte</span>: 10&#125;&#125;&#125;, &#123; <span class="variable">$project</span>: &#123;_id: 0, title: 1, by_user: 1, likes: 1&#125;&#125;, &#123;<span class="variable">$limit</span>: 5&#125;, &#123;<span class="variable">$skip</span>: 1&#125;, &#123;<span class="variable">$sort</span>: &#123;likes: -1&#125;&#125;)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 等同于MySQL: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> select title, by_user, likes from agg <span class="built_in">where</span> likes &gt;= 10 order by likes desc <span class="built_in">limit</span> 1,5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#索引&quot;&gt;&lt;/a&gt; 索引&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：索引是为了加快查询速度，可以对集合中的一列或多列设置索引。&lt;/p&gt;
&lt;p&gt;– 无索引：扫描整个集合的文档，查找符
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://luxiaowan.github.io/categories/MongoDB/"/>
    
    
      <category term="基础应用" scheme="http://luxiaowan.github.io/tags/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Git Stash用法</title>
    <link href="http://luxiaowan.github.io/2019/10/22/git%20stash%E5%91%BD%E4%BB%A4/"/>
    <id>http://luxiaowan.github.io/2019/10/22/git stash命令/</id>
    <published>2019-10-21T16:00:00.000Z</published>
    <updated>2019-10-24T13:20:12.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建仓库"><a class="markdownIt-Anchor" href="#创建仓库"></a> 创建仓库</h3><ol><li>git init</li><li>echo 123 &gt; test.txt</li><li>git add .</li><li>git commit -m “add test file”</li><li>git remote add origin git@git.xx.xx.xx:xxx/xxx.git</li><li>git push origin master</li></ol><p><em>以上内容比较简单，就不作详细讲述，如果上面的内容看不懂，下面的请放弃</em></p><h3 id="使用git-stash暂存"><a class="markdownIt-Anchor" href="#使用git-stash暂存"></a> 使用git stash暂存</h3><ol><li><p>随意修改test.txt文件的内容，比如：画个心形，你正热火朝天修改中……</p></li><li><p>这时领导走过来拍了拍你的肩膀说到：”小伙子啊，创建个<code>朕.txt</code>文件提交上来，内容就写<code>我还想再活五百年</code>，test.txt文件这一版不作修改“。</p></li><li><p><strong>你面露笑容的回答：“好的，没问题！”，内心却是：“MMP,MMP,MMP……”</strong></p></li><li><p>辛辛苦苦修改的<code>test.txt</code>文件怎么办？眼瞅着就要完成了，难道复制出去，然后等解决领导需求后再粘贴回来？low不low？肯定<code>不low</code>啊，一个文件而已，这种方法很简单，*但是当你实际项目中修改了几十个文件的时候呢？*挨个儿复制出去？累傻小子呐？！！！！！</p></li><li><p><code>git stash</code>命令帮你解决问题，stash是存储的意思，也就是将当前工作区内的所有东西都存储起来，然后工作区所有文件恢复到修改之前的状态(并不是最新状态，不会和仓库中进行自动同步，需要你自己去pull)，然后你就可以继续完成任务了。(<font color="red">在执行git stash之前需要先执行git add命令</font>)</p><p>stash可以进行多次操作，每次操作都会将当前工作区的文件情况暂存起来，stash是类栈存储，每次stash的序号都为0，此次之前stash的序号会自动+1</p></li></ol><h3 id="使用git-stash-pop取出"><a class="markdownIt-Anchor" href="#使用git-stash-pop取出"></a> 使用git stash pop取出</h3><ol><li><code>git stash pop</code>取出栈顶元素，也就是序号为0的那个，即最近一次执行<code>git stash</code>保存的内容。pop之后，暂存列表中就会自动将其清除掉，这个时候你再执行<code>git stash list</code>会发现毛都没有</li><li>这个时候可能就会纳闷了，我保存了好几次，但是我这次是想使用最开始stash的那份内容，怎么办？一直pop，直到最后一次？当然不行，上面刚讲过pop之后暂存列表中就没有stash的信息了，已经被pop出去的就找不回来了，等于是自杀式攻击，那咋整呢？</li><li><code>git stash apply stash@{序号}</code>可以将指定序号的stash内容弹出到工作区，此时工作区里文件的状态就和<code>stash@{序号}</code>里的一致了，但是这个命令<strong>无法将stash记录从暂存列表中删除，仅仅只是将文件恢复而已</strong></li><li><code>git stash drop stash@{序号}</code>来丢弃暂存列表中的记录，可以配合apply使用</li></ol><h3 id="查看暂存记录中的信息"><a class="markdownIt-Anchor" href="#查看暂存记录中的信息"></a> 查看暂存记录中的信息</h3><ol><li>查看暂存列表：<code>git stash list</code>查看当前stash的列表</li><li>查看暂存内容：<code>git stash show stash@{序号}</code>查看指定序号的stash的内容</li></ol><h3 id="git-stash-save-msg"><a class="markdownIt-Anchor" href="#git-stash-save-msg"></a> git stash save ‘msg’</h3><p>等于是在stash的时候打了个标签，妖娆！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;创建仓库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#创建仓库&quot;&gt;&lt;/a&gt; 创建仓库&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;git init&lt;/li&gt;
&lt;li&gt;echo 123 &amp;gt; test.txt&lt;/li&gt;
&lt;li&gt;git add .&lt;
      
    
    </summary>
    
    
      <category term="Git" scheme="http://luxiaowan.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Hash索引相关</title>
    <link href="http://luxiaowan.github.io/2019/10/12/Hash%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://luxiaowan.github.io/2019/10/12/Hash索引相关/</id>
    <published>2019-10-12T15:42:43.000Z</published>
    <updated>2019-10-21T15:48:05.043Z</updated>
    
    <content type="html"><![CDATA[<p>hash索引结构使用方式较为局限，仅适用于=、IN和&lt;=&gt;三种，但是由于通过hash可以直接查找到具体的值，而不用像BT那样每次都从root节点开始遍历，所以在通常情况下，hash的查找效率要比BT高。</p><p>hash的缺陷：</p><h6 id="1-hash不能进行范围查找"><a class="markdownIt-Anchor" href="#1-hash不能进行范围查找"></a> 1. hash不能进行范围查找</h6><p>值在计算hash后，并不能保证计算后的hash值和计算前的大小排列一样，所以hash不适用于范围查找</p><h6 id="2-hash不能进行排序查询"><a class="markdownIt-Anchor" href="#2-hash不能进行排序查询"></a> 2. hash不能进行排序查询</h6><p>值计算后的hash值无法保证与原值大小顺序一样，所以无法进行排序</p><h6 id="3-组合索引不能使用部分字段查询"><a class="markdownIt-Anchor" href="#3-组合索引不能使用部分字段查询"></a> 3. 组合索引不能使用部分字段查询</h6><p>组合索引的hash值是所有索引字段的值组合在一起进行计算的，若仅使用部分字段进行查询的话，计算出的hash值基本不会与索引的hash值相同</p><h6 id="4-hash在出现大量值碰撞的时候性能会降低"><a class="markdownIt-Anchor" href="#4-hash在出现大量值碰撞的时候性能会降低"></a> 4. hash在出现大量值碰撞的时候，性能会降低</h6><p>hash出现大量的值相等的时候，需要进行表扫描以进行精确匹配，效率较低</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hash索引结构使用方式较为局限，仅适用于=、IN和&amp;lt;=&amp;gt;三种，但是由于通过hash可以直接查找到具体的值，而不用像BT那样每次都从root节点开始遍历，所以在通常情况下，hash的查找效率要比BT高。&lt;/p&gt;
&lt;p&gt;hash的缺陷：&lt;/p&gt;
&lt;h6 id=&quot;1
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="Java基础知识" scheme="http://luxiaowan.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Char和varchar简单介绍</title>
    <link href="http://luxiaowan.github.io/2019/10/12/char%E4%B8%8Evarchar%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://luxiaowan.github.io/2019/10/12/char与varchar简单介绍/</id>
    <published>2019-10-12T04:10:43.000Z</published>
    <updated>2019-10-21T16:19:50.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据长度"><a class="markdownIt-Anchor" href="#1-数据长度"></a> 1. 数据长度</h2><h3 id="1-char最大长度255个字节"><a class="markdownIt-Anchor" href="#1-char最大长度255个字节"></a> 1) char(<code>最大长度255个字节</code>)</h3><p>长度固定（字段存入数据长度始终等于字段长度）</p><h3 id="2-varchar最大长度65535个字节"><a class="markdownIt-Anchor" href="#2-varchar最大长度65535个字节"></a> 2) varchar(<code>最大长度65535个字节</code>)</h3><p>可变长度，存入数据长度为N个字节，则实际使用了N+1(255以上长度则+2)个字节的空间，多出来的1字节是用来存储数据实际长度。</p><ul><li>存入数据对比<ul><li>存入<code>&quot;ab&quot;</code><ul><li>char查询出<code>&quot;ab&quot;</code></li><li>varchar查询出<code>&quot;ab&quot;</code></li></ul></li><li>存入<code>&quot;ab &quot;</code>，<code>ab</code>后面有两个空格，<ul><li>char查询出<code>&quot;ab&quot;</code></li><li>varchar查询出<code>&quot;ab &quot;</code></li></ul></li></ul></li></ul><hr><blockquote><p>解析：</p></blockquote><p>​在入库时，数据库会自动在ab后面添加两位空格，让入库的数据长度保证等于4 <em><code>char(4)</code></em> ，这种操作很容易理解，但是如果你去数据表里面去查这条数据，会发现表中数据并没有空格，所以可以推断出这里是逻辑追加，所以在查询数据的时候会并不会出现引擎自动添加的空格。</p><hr><h2 id="2-实操技术一定要font-colorred实操font"><a class="markdownIt-Anchor" href="#2-实操技术一定要font-colorred实操font"></a> 2. 实操(技术一定要**<font color="red">实操</font>**)</h2><h4 id="1无空格数据"><a class="markdownIt-Anchor" href="#1无空格数据"></a> 1）无空格数据</h4><blockquote><p>先创建一张表</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table cv(c char(4), v varchar(4));</span><br></pre></td></tr></table></figure><blockquote><p>插入数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into cv values(&quot;ab&quot;, &quot;ab&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>查询数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(&apos;(&apos;, c, &apos;)&apos;) AS c, concat(&apos;(&apos;, v, &apos;)&apos;) AS v from cv;</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><p><img src="/images/image-20191012152503483.png" alt="image-20191012152503483"></p><blockquote><blockquote><p>结果中char和varchar均查出来为无空格的ab</p></blockquote></blockquote><p>####2）有空格数据</p><blockquote><p>插入数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into cv values(&quot;ab  &quot;, &quot;ab  &quot;);</span><br></pre></td></tr></table></figure><blockquote><p>查询数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(&apos;(&apos;, c, &apos;)&apos;) AS c, concat(&apos;(&apos;, v, &apos;)&apos;) AS v from cv;</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><p><img src="/images/image-20191012152809508.png" alt="image-20191012152809508"></p><blockquote><blockquote><p>结果中可以看出，char类型将数据后面的空格自动去掉了，varchar则保留了所有的空格</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-数据长度&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-数据长度&quot;&gt;&lt;/a&gt; 1. 数据长度&lt;/h2&gt;
&lt;h3 id=&quot;1-char最大长度255个字节&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL使用查询缓存</title>
    <link href="http://luxiaowan.github.io/2019/10/11/MySQL%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/"/>
    <id>http://luxiaowan.github.io/2019/10/11/MySQL使用查询缓存/</id>
    <published>2019-10-11T05:01:23.000Z</published>
    <updated>2019-10-21T15:48:59.282Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>查询服务是否已开启缓存</p><blockquote><p>执行<code>show variables like '%query_cache%';</code>查看缓存状态</p></blockquote><blockquote><blockquote><p><img src="/images/image-20191011131957961.png" alt="image-20191011131957961"></p></blockquote></blockquote><p>Variable_name: query_cache_type为缓存状态，ON表示开启，OFF表示关闭</p></li><li><p>开启/关闭使用查询缓存</p><blockquote><p>修改my.cnf文件进行开启和关闭</p></blockquote><p>[mysqld]中添加/修改：<br>query_cache_size = 20M<br>query_cache_type = ON/OFF</p><blockquote><p>**修改完成后重启MySQL服务：<code>service mysql restart/systemctl mysql restart</code> **</p></blockquote></li><li><p>查询缓存使用情况</p><blockquote><p>执行<code>show status like 'qcache%';</code>查询缓存使用情况</p><blockquote><p><img src="/images/image-20191011132634921.png" alt="image-20191011132634921"></p></blockquote></blockquote><p>因为本机MySQL未开启查询缓存，所以此处和使用相关的属性均为0</p><hr><p><em><strong>属性解释:</strong></em></p><table><thead><tr><th>属性</th><th>释义</th></tr></thead><tbody><tr><td>Qcache_free_blocks</td><td>缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。</td></tr><tr><td>Qcache_free_memory</td><td>缓存中空闲内存大小</td></tr><tr><td>Qcache_hits</td><td>缓存命中次数，命中一次就+1</td></tr><tr><td>Qcache_inserts</td><td>查询次数，命中次数/查询次数=缓存命中率</td></tr><tr><td>Qcache_lowmem_prunes</td><td>缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数，如果数字不断增长，就可能碎片非常严重，或者内存很少，通过Qcache_free_blocks、Qcache_free_memory来分析具体情况</td></tr><tr><td>Qcache_not_cached</td><td>不适合进行缓存的查询的数量</td></tr><tr><td>Qcache_queries_in_cache</td><td>当前缓存的查询(和响应)的数量</td></tr><tr><td>Qcache_total_blocks</td><td>缓存中块的数量</td></tr></tbody></table></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查询服务是否已开启缓存&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行&lt;code&gt;show variables like &#39;%query_cache%&#39;;&lt;/code&gt;查看缓存状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;block
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础面试题</title>
    <link href="http://luxiaowan.github.io/2019/10/10/%E8%9A%82%E8%9A%81Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://luxiaowan.github.io/2019/10/10/蚂蚁Java基础面试题/</id>
    <published>2019-10-10T15:21:56.000Z</published>
    <updated>2019-10-21T15:49:27.313Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一"><a class="markdownIt-Anchor" href="#一"></a> 一</h3><ol start="2"><li><p>map怎么实现hashcode和equals,为什么重写equals必须重写hashcode</p></li><li><p>使用过concurrent包下的哪些类，使用场景等等。</p></li><li><p>concurrentHashMap怎么实现？concurrenthashmap在1.8和1.7里面有什么区别</p></li><li><p>CountDownLatch、LinkedHashMap、AQS实现原理</p></li><li><p>线程池有哪些RejectedExecutionHandler,分别对应的使用场景</p></li><li><p>多线程的锁？怎么优化的？偏向锁、轻量级锁、重量级锁？</p></li><li><p>组合索引？B+树如何存储的？</p></li><li><p>为什么缓存更新策略是先更新数据库后删除缓存</p></li><li><p>OOM说一下？怎么排查？哪些会导致OOM?</p></li><li><p><code>OSI七层结构</code>，每层结构都是干什么的？</p></li><li><p>java的线程安全queue需要注意的点</p></li><li><p>死锁的原因，如何避免</p></li></ol><h3 id="二"><a class="markdownIt-Anchor" href="#二"></a> 二</h3><ol><li><p>jvm虚拟机老年代什么情况下会发生gc，给你一个场景，一台4核8G的服务器，每隔两个小时就要出现一次老年代gc，现在有日志，怎么分析是哪里出了问题</p></li><li><p>数据库索引有哪些？底层怎么实现的？数据库怎么优化？</p></li><li><p>数据库的事务，四个性质说一下，分别有什么用，怎么实现的？</p></li><li><p>服务器如何负载均衡，有哪些算法，哪个比较好，一致性哈希原理，怎么避免DDOS攻击请求打到少数机器</p></li><li><p>volatile讲讲</p></li><li><p>哪些设计模式？装饰器、代理讲讲？</p></li><li><p>redis集群会吗？</p></li><li><p>mysql存储引擎</p></li><li><p>事务隔离级别</p></li><li><p>不可重复度和幻读，怎么避免，底层怎么实现（行锁表锁）</p></li></ol><h3 id="三"><a class="markdownIt-Anchor" href="#三"></a> 三</h3><ol><li><p>项目介绍</p></li><li><p>分布式锁是怎么实现的</p></li><li><p>MySQL有哪几种join方式，底层原理是什么</p></li><li><p>Redis有哪些数据结构？底层的编码有哪些？有序链表采用了哪些不同的编码？</p></li><li><p>Redis扩容，失效key清理策略</p></li><li><p>Redis的持久化怎么做，aof和rdb，有什么区别，有什么优缺点。</p></li><li><p>MySQL数据库怎么实现分库分表，以及数据同步？</p></li><li><p>单点登录如何是实现？</p></li><li><p>谈谈SpringBoot和SpringCloud的理解</p></li><li><p>未来的技术职业怎么规划？</p></li><li><p>为什么选择我们公司？</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一&quot;&gt;&lt;/a&gt; 一&lt;/h3&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;map怎么实现hashcode和equals,为什么重写equals必须重写hashcode&lt;/p&gt;
&lt;/li
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="面试" scheme="http://luxiaowan.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="阿里" scheme="http://luxiaowan.github.io/tags/%E9%98%BF%E9%87%8C/"/>
    
  </entry>
  
</feed>
