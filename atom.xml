<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2020-04-07T15:43:48.016Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java获取项目中的文件</title>
    <link href="http://luxiaowan.github.io/2020/04/07/Java%E8%8E%B7%E5%8F%96%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>http://luxiaowan.github.io/2020/04/07/Java获取项目中的文件/</id>
    <published>2020-04-07T15:17:00.000Z</published>
    <updated>2020-04-07T15:43:48.016Z</updated>
    
    <content type="html"><![CDATA[<h3 id="classgetresource与classloadergetresource的区别"><a class="markdownIt-Anchor" href="#classgetresource与classloadergetresource的区别"></a> Class.getResource()与ClassLoader.getResource()的区别</h3><p><code>Class.getResource()</code>是指<code>AAA.class.getResource()</code></p><ol><li><p>Class.getResource(String name)：在当前class类的同一路径下查找资源</p></li><li><p>ClassLoader.getResource(String name)：在根目录下查找该资源文件，即&quot;/&quot;或classpath目录</p></li></ol><h3 id="粗解"><a class="markdownIt-Anchor" href="#粗解"></a> 粗解</h3><ol><li><p>在当前项目目录下查找指定的文件，此方式只能加载当前项目classpath下的文件，用.表示当前目录，不能以/开头，会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">URL url = ClassLoader.getSystemResource(<span class="string">"."</span>);</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">url = LoaderResourceTest.class.getClassLoader().getResource(<span class="string">"."</span>);</span><br></pre></td></tr></table></figure><p>url会输出当前class文件所在的根目录，比如当前我输出的结果就是<code>file:/Users/chuan/Documents/projects_code/java-project/demo/demo-core/target/classes/</code></p></li><li><p>以当前类所在的目录为基础，在当前目录查找并加载指定名称的资源文件，比如当前类LoaderResourceTest在项目的<code>cc.kevinlu.demo.core.loader</code>包中，若是我们以<code>LoaderResourceTest.class.getResource(&quot;LoaderT.class&quot;)</code>的方式加载一个文件，则首先会在<code>cc.kevinlu.demo.core.loader</code>包中查找LoaderT.class文件，若查找不到则返回null，如果我们想要加载其他包中的文件，则可以使用&quot;/&quot;开头并加上文件在项目中的完整包路径，比如<code>LoaderResourceTest.class.getResource(&quot;/cc/kevinlu/demo/core/gof/facade/FacadeTest.class&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前类所在的包目录</span></span><br><span class="line">url = LoaderResourceTest.class.getResource(<span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取其他包内的文件</span></span><br><span class="line">url = LoaderResourceTest.class.getResource(<span class="string">"/cc/kevinlu/demo/core/gof/facade/FacadeTest.class"</span>);</span><br></pre></td></tr></table></figure><p>这两条语句的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file:/Users/chuan/Documents/projects_code/java-project/demo/demo-core/target/classes/cc/kevinlu/demo/core/loader/</span><br><span class="line"></span><br><span class="line">file:/Users/chuan/Documents/projects_code/java-project/demo/demo-core/target/classes/cc/kevinlu/demo/core/gof/facade/FacadeTest.class</span><br></pre></td></tr></table></figure><p>由此可以很明显的看出Class的getResource是获取当前类所在的包目录，如果不同的包中都有相同名称的资源文件，但是仅针对当前包可用，那么就可以使用这种方式去加载读取，不会出现读到其他目录的文件的情况，但是这仅受限于我们写的类，不适用于jar包中的。</p></li><li><p>如果我们想读取项目中引用的jar包内的文件，那么怎么办？其实和读取项目中自己写的文件是相同的办法，因为在系统启动的时候会将jar包中的文件加载到classpath目录下，所以读取方式一样的。</p></li><li><p>以上讲解的只是读取单个资源，那么要是想把所有匹配到的资源都获取到，则可以使用<code>Class.getClassLoader().getResources()</code>和<code>ClassLoader.getSystemResources()</code>两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = LoaderResourceTest.class.getClassLoader().getResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">  System.out.println(urls.nextElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--ClassLoader.getSystemResources--"</span>);</span><br><span class="line">urls = ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">  System.out.println(urls.nextElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读取资源文件内容方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = LoaderResourceTest.class.getClassLoader().getResourceAsStream(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">  System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="整个测试文件代码"><a class="markdownIt-Anchor" href="#整个测试文件代码"></a> 整个测试文件代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.kevinlu.demo.core.loader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.admin.SpringApplicationAdminMXBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoaderResourceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前项目目录下查找指定的文件，此方式只能加载当前项目classpath下的文件，用.表示当前目录，不能以/开头，会报错</span></span><br><span class="line">        URL url = ClassLoader.getSystemResource(<span class="string">"."</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此方式和ClassLoader.getSystemResource一样</span></span><br><span class="line">        url = LoaderResourceTest.class.getClassLoader().getResource(<span class="string">"."</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以当前类所在的目录为基础，在当前目录查找并加载指定名称的资源文件，比如当前类LoaderResourceTest在</span></span><br><span class="line">        <span class="comment">// 项目的cc.kevinlu.demo.core.loader包中，若是我们以LoaderResourceTest.class.getResource("LoaderT.class")的</span></span><br><span class="line">        <span class="comment">// 方式加载一个文件，则首先会在cc.kevinlu.demo.core.loader包中查找LoaderT.class文件，若查找不到则返回null，如果我们想要加载其他包中的文件，</span></span><br><span class="line">        <span class="comment">// 则可以使用/开头并加上文件在项目中的完整包路径，比如LoaderResourceTest.class.getResource("/cc/kevinlu/demo/core/gof/facade/FacadeTest.class")                                                                                              </span></span><br><span class="line">        url = LoaderResourceTest.class.getResource(<span class="string">"."</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        url = LoaderResourceTest.class.getResource(<span class="string">"/cc/kevinlu/demo/core/gof/facade/FacadeTest.class"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取jar包内的文件有以下方式</span></span><br><span class="line">        <span class="comment">// 1. 使用Class.getClassLoader().getResource()，这种方式只能获取第一个匹配到的文件</span></span><br><span class="line">        System.out.println(<span class="string">"************"</span>);</span><br><span class="line">        url = LoaderResourceTest.class.getClassLoader().getResource(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        System.out.println(<span class="string">"************"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用Class.getResource()，这种方式也只能获取第一个匹配到的文件</span></span><br><span class="line">        url = LoaderResourceTest.class.getResource(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用ClassLoader.getSystemResource()方法，这种也仅仅只是获取第一个匹配的文件</span></span><br><span class="line">        url = ClassLoader.getSystemResource(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 那我们如果想要获取到所有匹配到的文件要怎么办呢？那么就使用Class.getClassLoader().getResources()，这个方法会返回一个Enumeration&lt;URL&gt;实例，</span></span><br><span class="line">        <span class="comment">// 我们迭代返回的这个实例就可以读取所有匹配到的所有文件了，如果没有匹配到任何文件也可以大胆的去迭代，不用判空，因为在getResources方法中进行了非空封装</span></span><br><span class="line">        System.out.println(<span class="string">"-----"</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; urls = LoaderResourceTest.class.getClassLoader().getResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            System.out.println(urls.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----"</span>);</span><br><span class="line">        urls = ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            System.out.println(urls.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果想要读取文件的具体内容，那么我们就要用到文件流了，常用的方法就是使用BufferedReader去读了</span></span><br><span class="line">        <span class="comment">// getResourceAsStream()方法，它相当于你用getResource()取得File文件后，再new InputStream(file)一样的结果</span></span><br><span class="line">        InputStream is = LoaderResourceTest.class.getClassLoader().getResourceAsStream(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i == <span class="number">1</span> &amp;&amp; (line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******"</span>);</span><br><span class="line">        url = SpringApplicationAdminMXBean.class.getResource(<span class="string">"."</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;classgetresource与classloadergetresource的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#classgetresource与classloadergetresource的区别&quot;&gt;&lt;/a&gt; Cla
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>运行Jar包时指定启动端口</title>
    <link href="http://luxiaowan.github.io/2020/04/02/%E8%BF%90%E8%A1%8Cjar%E5%8C%85%E6%97%B6%E6%8C%87%E5%AE%9A%E5%90%AF%E5%8A%A8%E7%AB%AF%E5%8F%A3/"/>
    <id>http://luxiaowan.github.io/2020/04/02/运行jar包时指定启动端口/</id>
    <published>2020-04-02T13:30:00.000Z</published>
    <updated>2020-04-02T13:32:00.255Z</updated>
    
    <content type="html"><![CDATA[<p>java -jar xxx.jar --server.port=9090</p><blockquote><p>–server.port一定要在最后</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java -jar xxx.jar --server.port=9090&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;–server.port一定要在最后&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>聊一聊SPI</title>
    <link href="http://luxiaowan.github.io/2020/04/02/%E8%81%8A%E4%B8%80%E8%81%8ASPI/"/>
    <id>http://luxiaowan.github.io/2020/04/02/聊一聊SPI/</id>
    <published>2020-04-01T17:10:00.000Z</published>
    <updated>2020-04-05T14:06:22.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>SPI全称是Service Provider Interface，是一种服务发现机制（哎，服务发现机制？和Zookeeper什么关系？）。SPI 的本质是将接口实现类的全限定名配置在文件META-INFO/services目录下以接口全限定名命名的文件中，并由服务加载器(ServiceLoader)读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p><p><img src="/images/image-20200405012001538.png" alt="image-20200405012001538"></p><h3 id="使用方式"><a class="markdownIt-Anchor" href="#使用方式"></a> 使用方式</h3><ul><li><p>场景</p><p>如果在使用过程中需要动态替换接口类的实现逻辑，那么比较适合使用SPI。比如<code>java.sql.Driver</code>。</p></li><li><p>方式</p><ol><li>在服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以接口全限定名为命名的文件，内容为实现类的全限定名</li><li>通过maven引入接口实现类所在的jar包，或者将jar包放到应用的classpath中</li><li>通过java.util.ServiceLoder动态装载接口实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM</li><li>SPI的实现类必须有一个无参的public构造器</li></ol></li><li><p>疑问</p><ul><li><p>为什么要把定义放在META-INF/services目录下？</p><p>这个目录位置是在ServiceLoader中定义的，并且还是final不能修改的，所以还是乖乖遵守吧，因为ServiceLoader也是final的，所以也不能从这个类进行扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么需要一个无参的public构造器？</p><p>ServiceLoader内部实例化扫描到的类是通过<code>LazyIterator</code>迭代器在迭代的时候使用Class的newInstance()方法，所以这里必须要有一个无参的public构造器，否则实例化的时候会报错。</p></li><li><p>如果引入的多个jar包中均有目标接口的实现类及SPI定义，咋整？</p><p>全部都会被加载，只要是在项目中被引入了，就会全部被加载。</p></li><li><p>运行过程是什么样子的？</p><img src="/images/spi.png" alt="spi" style="zoom:46%;"></li></ul></li></ul><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3><ol><li><p>服务方</p><ul><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.kevinlu.spidemo.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SPIUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 领导实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderServiceImpl</span> <span class="keyword">implements</span> <span class="title">SPIUserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"领导发话了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 员工实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SPIUserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"员工暴怒了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>spi文件</p><p>在实现类所在的项目中的resources目录下创建文件夹META-INF/services文件夹，然后创建文件<code>cc.kevinlu.spidemo.spi.SPIUserService</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cc.kevinlu.spidemoimpl.spi.LeaderServiceImpl</span></span><br><span class="line"><span class="attr">cc.kevinlu.spidemoimpl.spi.EmployeeServiceImpl</span></span><br></pre></td></tr></table></figure></li><li><p>项目结构</p><img src="/images/image-20200405175109421.png" alt="image-20200405175109421" style="zoom:50%;"></li></ul></li><li><p>调用方</p><ul><li><p>pom.xml引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.kevinlu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spi-demo-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;SPIUserService&gt; services = ServiceLoader.load(SPIUserService.class);</span><br><span class="line"><span class="comment">// 隐式迭代器方式</span></span><br><span class="line"><span class="keyword">for</span> (SPIUserService service : services) &#123;</span><br><span class="line">  service.name();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line"><span class="comment">// 显式迭代器方式</span></span><br><span class="line">Iterator&lt;SPIUserService&gt; iterator = services.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  SPIUserService service = iterator.next();</span><br><span class="line">  service.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MySQL</h3><p>在mysql-connector-java包中的META-INFO/services目录下可以找到以接口<code>java.sql.Driver</code>为名的文件，文件内容是<code>com.mysql.jdbc.Driver</code>或者<code>com.mysql.cj.jdbc.Driver</code>。再来我们就需要找到是在哪里对这个类进行加载的，我们从<code>com.mysql.jdbc.Driver</code>可以进入到<code>java.sql.DriverManager</code>，哦哟~原来是在DriverManager类中的静态代码块实现的对目标类的加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the initial JDBC drivers by checking the System property</span></span><br><span class="line"><span class="comment"> * jdbc.properties and then use the &#123;<span class="doctag">@code</span> ServiceLoader&#125; mechanism</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  loadInitialDrivers();</span><br><span class="line">  println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String drivers;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the driver is packaged as a Service Provider, load it.</span></span><br><span class="line">  <span class="comment">// Get all the drivers through the classloader</span></span><br><span class="line">  <span class="comment">// exposed as a java.sql.Driver.class service.</span></span><br><span class="line">  <span class="comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span></span><br><span class="line">  AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">      Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Load these drivers, so that they can be instantiated.</span></span><br><span class="line"><span class="comment">       * It may be the case that the driver class may not be there</span></span><br><span class="line"><span class="comment">       * i.e. there may be a packaged driver with the service class</span></span><br><span class="line"><span class="comment">       * as implementation of java.sql.Driver but the actual class</span></span><br><span class="line"><span class="comment">       * may be missing. In that case a java.util.ServiceConfigurationError</span></span><br><span class="line"><span class="comment">       * will be thrown at runtime by the VM trying to locate</span></span><br><span class="line"><span class="comment">       * and load the service.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * Adding a try catch block to catch those runtime errors</span></span><br><span class="line"><span class="comment">       * if driver not available in classpath but it's</span></span><br><span class="line"><span class="comment">       * packaged as service and that service is there in classpath.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">          driversIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  println(<span class="string">"DriverManager.initialize: jdbc.drivers = "</span> + drivers);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="疑"><a class="markdownIt-Anchor" href="#疑"></a> 疑</h2><p>前几天面试的时候，有个同学问我：我们订单类型分很多种，有美食、外卖、酒店、门票、火车票、机票等等，我们这边是做一个中台(中间平台)，为客户端提供统一下单、出单、订单等服务，但是订单需要流转到相对应的业务部门，怎么做？</p><p>我说SDK、微服务等形式，比如下单的时候由中台判断订单要流转的业务线，然后依据策略调用不同业务线提供的API服务。</p><p>然后又问我每个业务线提供的接口定义不同，调用起来会很麻烦，怎么办？</p><p>我说这个很简单啊，由中台定义接口，业务方引入中台的接口依赖，然后实现中台提供的接口，去编写自己的业务逻辑，并把该api暴露给中台去调用，这样中台对外的接口定义都一致，其实就是对外统一接口请求规范。</p><p>接着这位同学问了句：你知道SPI么？</p><p>艾玛~SPI会把业务方的实现代码依赖进来，如果某个业务方的处理逻辑改变了，或者他们的包版本变更了，岂不是所有的依赖方都要去更新依赖？这种方式其实不是不可取，只是会麻烦一些，并且我们把所有的业务方的实现都依赖进来了，那么我们使用ServiceLoader加载之后在使用的时候判断起来也麻烦。</p><p>是吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;SPI全称是Service Provider Interface，是一种服务发现机制（哎，服务发现机制？和Zookeeper什么关系？）。SPI
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈RPC</title>
    <link href="http://luxiaowan.github.io/2020/04/02/%E6%B5%85%E8%B0%88RPC/"/>
    <id>http://luxiaowan.github.io/2020/04/02/浅谈RPC/</id>
    <published>2020-04-01T17:10:00.000Z</published>
    <updated>2020-04-07T15:44:11.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>RPC是Remote Procedure Call的简称，译为远程过程调用，何为远程？就是从这个地方到另一个地方，也就是调用双方不在同一个进程或者不在同一台服务器上，由于双方不在一个内存空间中，所以需要借助网络来实现通信和数据传递。</p><h3 id="工作过程"><a class="markdownIt-Anchor" href="#工作过程"></a> 工作过程</h3><p>A服务器上的进程P1调用A服务器上的进程P2，或者A服务器上的进程P1调用B服务器上的P2，P1发起调用行为之后，进程被挂起，P2接收到请求之后开始执行，然后返回结果给P1，P1继续执行。P1可以使用参数将信息传递给P2，然后通过P2传回的消息得到结果。</p><p><img src="/images/45366c44f775abfd0ac3b43bccc1abc3_1440w.png" alt="img"></p><ol><li>Client function中像调用本地方法一样调用远程服务</li><li>Client stub接收到调用请求后，将方法、参数序列化</li><li>Client通过Socket将消息发送到远程服务</li><li>Server接收到消息后转发给Server stub，Server stub将消息进行解码（反序列化）</li><li>Server stub根据解码后的内容调用本地Server服务</li><li>Server执行完本地方法后，将执行结果返回给Server stub</li><li>Server stub将结果进行编码（序列化），然后传给Socket</li><li>然后通过Socket将消息发送给Client</li><li>Client接收到返回的消息后转发给Client stub，随之进行解码（反序列化）</li><li>Client接收到返回数据做最终处理</li></ol><p>以上就是一次RPC请求的全过程，整个RPC调用过程有同步和异步两种方式，同步也就是Client在接收到Server返回的消息之前一直将请求保持在运行中状态，例如IO和BIO；异步则是Client将请求发出去之后就将请求挂起，然后Server执行完后再发消息过来通知服务唤醒对应的请求继续处理，例如NIO和AIO。</p><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><p>在RPC理论被提出时就被赋予了简单、高效、通用三个特点。</p><p>简单：RPC概念语义清晰，使建立分布式应用更加简单，服务之间调用方式简单</p><p>高效：过程调用使用起来很高效，会隐藏底层的通信细节，不需要我们之间去处理Socket通信</p><p>通用：RPC是一个请求响应模型，调用双方可以使用不同的编程语言去实现，选择合适的序列化方式即可</p><p>简单点说，就是RPC能够使我们像调用本地方法一样去调用远程方法，并且调用者不需要知道远程服务到底部署在何处，达到像傻子一样去编程。</p><h3 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h3><p>在说到RPC调用过程的时候，有反复的提到序列化和反序列化，RPC支持的数据序列化方式有Java序列化、JSON、Hessian、Kryo等，还有我们很早之前WebService常用的XML。</p><ul><li>JSON：<ul><li>可读性较高</li><li>无法表示数据内的引用关系</li><li>统一JSON字段命名规范较困难</li></ul></li><li>Hessian二进制<ul><li>几乎无可读性而言</li><li>支持的语言不够多，比如直接忽略了对js的支持</li><li>二进制兼容性较高</li><li>二进制传输速度比XML、JSON快</li></ul></li></ul><h3 id="rpc框架"><a class="markdownIt-Anchor" href="#rpc框架"></a> RPC框架</h3><ul><li><p>Dubbo</p><p>阿里研发的，后由当当网扩展出了Dubbox，阿里的已经不维护了，现在丢给Apache了</p></li><li><p>Feign</p><p>Netflix的一套，由Spring Cloud拓展出来了一套轻量级的，很好的融合于Spring Cloud，微服务中还是常用的，适用于Java</p></li><li><p>gRPC</p><p>谷歌的一套RPC框架，基于HTTP/2 协议传输，在多语言服务之间交互时常被采用</p></li><li><p>Java RMI</p><p>较古老的一款RPC框架，仅适用于Java程序，无法跨语言，用起来也不方便</p></li><li><p>Thrift</p><p>Facebook开源的一套RPC框架，它主要是一种接口描述语言和二进制通信协议，跨语言协作，现在丢给Apache了</p></li><li><p>SOAP</p><p>由XML-RPC演变而来，不常用，老项目里可能会用到</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;RPC是Remote Procedure Call的简称，译为远程过程调用，何为远程？就是从这个地方到另一个地方，也就是调用双方不在同一个进程或
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud全家桶初探</title>
    <link href="http://luxiaowan.github.io/2020/04/01/SpringCloud%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%88%9D%E6%8E%A2/"/>
    <id>http://luxiaowan.github.io/2020/04/01/SpringCloud全家桶初探/</id>
    <published>2020-04-01T14:56:00.000Z</published>
    <updated>2020-04-05T14:07:16.784Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是spring-cloud"><a class="markdownIt-Anchor" href="#什么是spring-cloud"></a> 什么是Spring Cloud</h3><p>官网上面有一段话：Spring Cloud为开发人员提供了快速构建分布式系统中的一些常见模式的工具(例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导选举、分布式会话、集群状态)。</p><ul><li>Spring Boot是Spring的一套快速配置脚手架，可以基于Spring Boot快速开发一个微服务应用，而Spring Cloud是一个基于Spring Boot实现云应用的开发工具；</li><li>Spring Boot专注于快速、方便的创建单个微服务，Spring Cloud专注于微服务全局的服务治理框架；</li><li>Spring Boot使用了约定大于配置的理念，大部分集成方案都预设好了，不需要过多的配置，或者说能不配置就不配置，而Spring Cloud是基于Spring Boot来实现的，也就是说Spring Boot可以独立于Spring Cloud，而Spring Cloud强依赖于Spring Boot。</li></ul><h3 id="什么是微服务"><a class="markdownIt-Anchor" href="#什么是微服务"></a> 什么是微服务</h3><ol><li><p>微服务架构</p><ul><li>分散：不同的功能模块部署在不同的服务器/容器中，减轻功能模块高并发带来的压力</li><li>集群：不同服务器/容器中部署相同的功能模块，通过负载均衡服务配置实现功能模块的高可用</li><li>微服务：微服务架构简单来说就是将web应用拆分成一系列小的服务应用，这些应用可以独立的编译、部署，应用之间通过暴露各自的API实现通信，共同组成一个完整的web应用</li></ul></li><li><p>微服务的特点</p><ul><li>单一职责：每一个微服务模块都对应不同的服务功能，负责单一业务的业务实现</li><li>微/细：服务拆分的粒度很小，但依据分久必合合久必分原则，微服务之间也是可以进行再拆分或合并的</li><li>面向服务：每个服务应用对外暴露自己的API，调用者不需要关注具体的业务实现</li><li>自我治理：<ul><li>服务独立，研发团队独立</li><li>技术独立：只要提供相应的API即可，实现技术和实现语言不必一致</li><li>前后端分离</li><li>配置独立</li><li>解耦：独立部署，通过RPC或REST方式通信，耦合影响较小</li><li>服务容错、限流</li></ul></li></ul></li><li><p>微服务的劣势</p><ul><li>微服务使整个应用分散成多个服务应用，定位问题非常困难（trace解决定位难的问题）</li><li>稳定性下降，服务数量过多会导致整个应用出现问题的概率变大，其中一个服务挂掉就可能导致整个应用不可用，访问量越大出问题的可能性越大</li><li>服务数量过多，部署、管理的工作量变大</li><li>开发的过程中很难实现相互依赖的服务之间同步进行（mock解决此问题）</li><li>测试难度增大，由原先的单体应用测试变成服务间调用的测试，测试过程更加复杂</li><li>服务运行过程中可能会经常发生服务宕机，所以对于微服务必须建立完善的服务监控体系，尽可能的第一时间发现故障服务并进行故障通知、转移和恢复（Zookeeper、Eureka、Consul、Etcd等）</li></ul></li><li><p>微服务拆分依据</p><p>微服务拆分不是一蹴而就的，而是需要在开发过程中不断的去分析和理清每一个服务的边界。对于老工程中尚未分清拆分方向的，可先留于其中，最终可考虑将这些功能作为一个微服务。</p><ul><li>基于业务逻辑</li><li>基于可扩展</li><li>基于可靠性</li><li>基于性能</li></ul></li><li><p>微服务拆分规范</p><ul><li>粒度：先少后多，先粗后细</li><li>调用：保持单向调用，尽量禁止循环调用，比如订单—&gt;产品，产品—x&gt;订单</li><li>接口幂等：应保证接口的幂等性，避免出现脏数据</li><li>纵向拆分尽量少于三层，也即维持在控制层—&gt;业务服务层—&gt;基础服务层</li><li>先拆分服务，后拆分数据库</li></ul></li></ol><h3 id="基础元件"><a class="markdownIt-Anchor" href="#基础元件"></a> 基础元件</h3><ol><li><p>Config</p><p>分布式服务，由于服务数量较多，每一个服务都会有1+套配置文件，如果每个项目单独配置一个yml/properties文件，管理起来会很混乱，并且无法实现动态变更配置属性的值，所以我们需要一个分布式配置中心组件，Spring Cloud Config就因此应运而生，它支持配置信息放在配置服务的内存中，也支持放在远程的git/svn仓库中，Config分两个角色，一个Server和一个Client。</p><ul><li><p>Server：创建一个简单的Config Server，使用git作为配置中心，我们再git仓库中创建目录config，这个目录名称需要和<code>spring.cloud.config.server.git.search-paths</code>配置的一致，然后在目录中创建client1-dev.properties</p><ol><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">7701</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.uri</span>=<span class="string">http://gitlab.xx.com/spring-cloud/config-center.git</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.username</span>=<span class="string">xxxxx</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.password</span>=<span class="string">xxxxx</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.search-paths</span>=<span class="string">config</span></span><br></pre></td></tr></table></figure><ul><li>spring.cloud.config.server.git.uri：git仓库地址</li><li>spring.cloud.config.server.git.search-paths：git仓库地址下的相对地址，可以配置多个，用,分割</li><li>spring.cloud.config.server.git.username：git仓库登录用户名</li><li>spring.cloud.config.server.git.password：git仓库登录密码</li></ul></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再启动类加上<code>@EnableConfigServer</code>注解，表明该项目是Config Server项目，启动后访问<code>http://localhost:7701/client1/dev</code>，如果返回如下，则表示我们已经配置正常，可以使用：</p><blockquote><p>{<br>“name”: “client1”,<br>“profiles”: [<br>“dev”<br>],<br>“label”: null,<br>“version”: “e3741fe5e48b303c80f34c1b8a44c0ef2999e22b”,<br>“state”: null,<br>“propertySources”: [<br>{<br>“name”: “<a href="http://gitlab.xxx.com/spring-cloud/config-demo.git/config/client1-dev.yml" target="_blank" rel="noopener">http://gitlab.xxx.com/spring-cloud/config-demo.git/config/client1-dev.yml</a>”,<br>“source”: {<br>“name”: “cc”<br>}<br>}<br>]<br>}</p></blockquote><p>☆说明：</p><blockquote><p>仓库中的配置文件会被转换成 Web 接口，访问可以参照以下的规则：</p><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><p>上面的 URL 会映射 <code>{application}-{profile}.yml</code> 对应的配置文件，其中 <code>{label}</code> 对应 Git 上不同的分支，默认为 master。以 config-client-dev.yml 为例子，它的 application 是 config-client，profile 是 dev。</p></blockquote></li></ol></li><li><p>Client</p><ol><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web项目 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 动态刷新配置信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们引入了actuator，目的是可以在修改了git仓库中的配置信息之后，可以手动刷新，让项目读取最新的配置信息，而不需要重启我们的应用</p></li><li><p>bootstrap.properties</p><p>config的配置必须配置在bootstrap.properties文件中，这样才能被正确的加载，按照springboot的配置文件加载顺序来看，会先加载bootstrap，然后再加载application，并且我们的config的配置要优先于项目中的其他内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.profile</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.config.label</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.config.uri</span>=<span class="string">http://127.0.0.1:7701/</span></span><br><span class="line"><span class="meta">spring.cloud.config.name</span>=<span class="string">client1</span></span><br></pre></td></tr></table></figure><ul><li>label：对应git仓库的分支名称，默认是master，我们这里dev表示我们使用的是dev分支，若分支不存在，则报错</li><li>profile：环境，对应文件后缀</li><li>uri：Config Server地址</li><li>name：配置中心的项目文件夹名称，若配置一个不存在的文件名，则会报错</li></ul></li><li><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">client1</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">health, info, refresh</span></span><br></pre></td></tr></table></figure><p>在application.properties中指定端口和项目名称，因为我们引入的actuator，但是它默认暴露的接口是health和info两个接口，其他的都涉及到安全所以需要手动将接口暴露出来，因为我们要可以动态刷新，所以将refresh接口也暴露出来，以POST方式请求该接口：<code>curl -X POST http://127.0.0.1:8080/actuator/refresh</code></p></li><li><p>TestController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/one"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解<code>@RefreshScope</code>是指明该类下的属性注入可以动态刷新</p></li></ol></li><li><p>测试</p><ol><li>访问http://127.0.0.1:8080/index/one</li><li>修改client-dev.properties文件中name=one_1</li><li>刷新：<code>curl -X POST http://127.0.0.1:8080/actuator/refresh</code></li><li>访问http://127.0.0.1:8080/index/one</li></ol></li></ul></li><li><p>Eureka</p><p>服务注册发现中心，基于CAP理论的AP实现，一个基于REST的服务，用于服务的发现和定位，以实现云端中间层服务发现和故障转移。Eureka的AP原则保证了注册中心的高可用，它是一个去中心化的架构，也就是集群中的所有节点都无主从之分，每一个节点都是平等的，可以相互注册，每一个节点都需要添加一个或多个serviceUrl指向其他节点，每个节点都可以视为其他节点的副本，这一特点实现了Eureka的高可用。</p><p>当有一台Server宕机后，Eureka Client会将请求自动转发到其他的Server节点上，当故障的Server节点恢复之后，Eureka会将其再次加入到服务器集群中。</p><p>当一个新的Server启动并加入进群后，会首先从其他的临近节点获取所有的可用服务列表信息完成初始化。</p><ul><li><p>Server：创建一个Eureka Server中心只需要在启动类上加上注解<code>@EnableEurekaServer</code>即可，启动服务之后通过访问<code>http://127.0.0.1:8080/</code>进入eureka控制中心，我们需要在<code>pom.xml</code>中引入一个jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> ↓(内嵌)</span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> ↓(内嵌)</span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@SpringBootApplication</span></span><br><span class="line"> <span class="meta">@EnableEurekaServer</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们仅仅是部署一个Eureka Server，那么我们还需要修改一下eureka.client前缀的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"> <span class="meta">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p>这些配置信息对应的类是在<code>spring-cloud-netflix-eureka-client.jar</code>包中的<code>org.springframework.cloud.netflix.eureka.EurekaClientConfigBean</code>类中，看下这个类中上面三个参数的默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@ConfigurationProperties</span>(EurekaClientConfigBean.PREFIX)</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientConfigBean</span> <span class="keyword">implements</span> <span class="title">EurekaClientConfig</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 默认的eureka客户端配置前缀，就用在上面↑</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"eureka.client"</span>;</span><br><span class="line">   <span class="comment">// Eureka默认的访问地址，如果我们不修改这个配置的话，就可以通过8761端口的这个地址去访问</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_URL = <span class="string">"http://localhost:8761"</span> + DEFAULT_PREFIX</span><br><span class="line"> + <span class="string">"/"</span>;</span><br><span class="line">   <span class="comment">// 如果没设置zone就使用下面这个默认的</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_ZONE = <span class="string">"defaultZone"</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 指定是否将当前服务注册到Eureka Server以被其他服务发现和使用</span></span><br><span class="line"> <span class="comment">// 如果不想使当前应用被其他服务发现，则修改此属性为false</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> registerWithEureka = <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 指定当前服务是否从Eureka Server拉取监听的服务列表</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> fetchRegistry = <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Eureka Server访问地址，一个Map，可以存储很多值</span></span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, String&gt; serviceUrl = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">// 将默认的server地址放入服务地址Map中</span></span><br><span class="line"><span class="keyword">this</span>.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client：创建一个Eureka Client很简单，在启动类上加上注解<code>@EnableEurekaClient</code>即可，如果Eureka Server服务的端口并不是使用的8761，那么则需要修改一下配置信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://127.0.0.1:8080/eureka/</span></span><br></pre></td></tr></table></figure><p>仅仅只需要修改折一个配置即可，因为其他的默认都为true，不用再配置了，这就是Spring Boot所说的约定大于配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@SpringBootApplication</span></span><br><span class="line"> <span class="meta">@EnableEurekaClient</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自我保护模式</p><ul><li>Eureka Server在运行期间会不断的统计心跳失败比例，如果再15分钟内有超过85%的client未正常发送心跳过来(单机模式很容易满足，生产环境如果出现这个情况则一般是网络通信出现了问题)，那么Eureka Server就会认为自己和客户端出现了网络故障，就会进入自我保护模式</li><li>自我保护模式的原则是宁可放过不可错杀，意思就是即使服务宕机了，我们在注册中心看到的服务状态依然是UP</li><li>自我保护模式使的Eureka实现了CAP中的AP，默认是开启的，可以通过参数<code>eureka.server.enable-self-preservation=false</code>进行关闭，但是在实际生产环境中不建议关闭，因为如果关闭的话，可能就直接导致服务不可用了</li><li>在正常情况下，如果超过默认的90秒未接收到某client的心跳，则将该client做下线处理，并从服务列表中移除掉；但是在保护模式下，不会将无心跳的client从服务列表中移除</li><li>自我保护模式下，当前Server节点依然可以接收通信正常的服务的注册和发现，但是不会将新注册的服务同步给集群中的其他Server节点，只有待网络恢复且退出自我保护模式之后，才会将自我保护模式期间新注册的服务同步给其他节点</li><li>Eureka的服务健康检查是通过actuator的/info和/health来实现的</li></ul><p><img src="/images/image-20200402211128777.png" alt="image-20200402211128777"></p></li></ul></li><li><p>Consul</p><ul><li><p>Consul用于实现分布式系统的服务发现与配置，其它分布式服务注册与发现的方案，满足CAP的CP，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（ZooKeeper等），Consul可以与Docker完美融合使用Go语言开发，基于 Mozilla Public License 2.0 的协议开源。</p></li><li><p>Consul工作原理</p><img src="/images/consol_service.png" alt="img" style="zoom:67%;"><ul><li>Producer启动的时候，会向Consul发送自己的服务信息，比如IP、port等</li><li>Consul每隔10秒(默认)会向Producer发送一个心跳监控请求，检测Producer是否健康</li><li>Consumer每隔10秒(默认)会向Consul拉取一次服务列表缓存在本地，Consumer的请求都基于本地的服务缓存列表进行请求</li></ul></li><li><p>安装Consul服务</p><ul><li><p>Docker运行（单机版）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 查询consul可用镜像</span></span><br><span class="line">docker search consul</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 拉取consul镜像</span></span><br><span class="line">docker pull consul:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 启动镜像</span></span><br><span class="line">docker run \</span><br><span class="line">--name consul \</span><br><span class="line">-p 8599:8500 \</span><br><span class="line">-v /data/consul/conf/:/consul/conf/ \</span><br><span class="line">-v /data/consul/data/:/consul/data/ \</span><br><span class="line">-d consul</span><br></pre></td></tr></table></figure></li><li><p>正常安装</p><p>下载地址：<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">https://www.consul.io/downloads.html</a></p><p>帮助文档：<a href="https://learn.hashicorp.com/consul/getting-started/install" target="_blank" rel="noopener">https://learn.hashicorp.com/consul/getting-started/install</a></p></li><li><p>访问consul：<a href="http://127.0.0.1:8599" target="_blank" rel="noopener">http://127.0.0.1:8599</a></p><p><img src="/images/consul.png" alt="image-20200402161855088"></p></li></ul></li><li><p>Consul与客户端集成</p><ul><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web包，必须引入，否则服务无法注册到注册中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- consul discovery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 心跳 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">7702</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consul-demo</span></span><br><span class="line"><span class="meta">spring.cloud.consul.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="comment">#spring.cloud.consul.discovery.health-check-path=/health</span></span><br></pre></td></tr></table></figure><ul><li>spring.cloud.consul.host：consul服务IP</li><li>spring.cloud.consul.port：consul服务端口</li><li>spring.cloud.consul.discovery.health-check-path：consul心跳地址，默认为actuator/health，我们可以自定义</li></ul></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用注解@EnableDiscoveryClient开启服务自动注册和发现</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudConsulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudConsulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200402170513327.png" alt="image-20200402170513327"></p></li></ul></li><li><p>运行机制</p><ul><li>Consul的一致性算法采用了Raft，比Zookeeper的Paxos算法简单很多</li><li>强一致性给Consul带来了可用性的下降<ul><li>当一个服务注册到leader节点时，因为Raft算法要求所有节点数投票同意过半才能将服务真正的注册进来，所以新服务注册的时间被拉长了；</li><li>当leader节点挂掉之后，需要根据Raft算法选举出新的leader节点，选举的过程中，Consul服务不可用</li></ul></li></ul></li></ul></li><li><p>Ribbon</p><p>负载均衡(Load Balance)是用于解决一个服务节点无法处理所有请求的算法，Ribbon是一款基于TCP和HTTP的客户端负载均衡工具，基于Netflix Ribbon，由Spring Cloud进行了再封装，将我们的REST模板的请求均转换为客户端负载均衡的服务调用，Ribbon仅仅只是一个工具，包含在每一个Spring Cloud应用中，无需单独的部署其他服务。</p><p>由于Ribbon属于是客户端负载均衡，所以需要在客户端维护一份服务端列表信息，而这些列表信息来自于服务注册中心，如Eureka、Consul等，客户端的服务端列表信息也需要不断的去更新，保证服务列表中服务的可用性，这个过程并不是在客户端去检测各个服务端的心跳，而是通过与服务注册中心进行数据交换来维护服务端的健康。</p><p>Spring Cloud默认会自动加载和配置Ribbon的一切，我们只需要去解读一下<code>org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration</code>和<code>org.springframework.cloud.consul.discovery.RibbonConsulAutoConfiguration</code>就可以知道一切了，这里不做源码解释</p><ul><li><p>如何在Spring Cloud中使用Ribbon</p><ul><li>服务端启动多个实例，并注册到同一个服务注册中心，或者同一个集群</li><li>客户端的RestTemplate实例创建的时候通过注解<code>@LoadBalanced</code>修饰</li></ul></li><li><p>Ribbon带来的好处</p><ul><li>当集群中某一个服务宕掉后，整个服务集群依然可以正常提供服务</li><li>可以选择合适的负载算法保证服务的良性使用，避免在流量激增的时候拖垮CPU</li></ul></li><li><p>负载均衡算法</p><ul><li><p>权重</p><p>为每台机器设置在集群中的比重，请求过来后按照比重分配进行轮询</p></li><li><p>随机</p><p>对集群中的机器随机访问，通过随机数定位要访问的机器</p></li><li><p>哈希</p><p>请求按照一定规则映射到要访问的机器上</p></li><li><p>轮询</p><p>轮询是指将请求轮流分配给每台服务器，当服务器群中各服务器的处理能力相同时，且每笔业务处理量差异不大时，最适合使用这种算法</p></li></ul></li><li><p>Ribbon工作原理</p><ol><li><p>获取被<code>@LoadBalanced</code>修饰的RestTemplate</p><p>我们知道SpringBoot中的自配装配都是通过MATE-INF/spring.factories文件中<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>指定的类来实现的，在注解<code>@LoadBalanced</code>所在的包中我们找到了<code>org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration</code>，其实整个EnableAutoConfiguration的列表中只有这一个和LoadBalance有关，所以很容易找，我们看下LoadBalanceAutoConfiguration的代码是怎么写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br></pre></td></tr></table></figure><p>我们知道<code>@Autowired</code>可以将对象赋值给一个对象，也可以赋值给一个对象的集合，这里我们不做解释，可以去了解一下<code>@Autowired</code>和<code>@Qualifier</code>。</p></li><li><p>为RestTemplate添加一个拦截器，也就是<code>org.springframework.cloud.client.loadbalancer.LoadBalancerInterceptor</code>，拦截每一次的RestTemplate请求</p><p>我们看下LoadBalancerInterceptor的创建过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SmartInitializingSingleton <span class="title">loadBalancedRestTemplateInitializerDeprecated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="keyword">this</span>.restTemplates) &#123;</span><br><span class="line">      <span class="keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">        <span class="comment">// 触发LoadBalancerInterceptorConfig.restTemplateCustomizer的执行</span></span><br><span class="line">        customizer.customize(restTemplate);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建拦截器</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">    LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为RestTemplate实例添加拦截器</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">      List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">        restTemplate.getInterceptors());</span><br><span class="line">      list.add(loadBalancerInterceptor);</span><br><span class="line">      <span class="comment">// 拦截器设置点</span></span><br><span class="line">      restTemplate.setInterceptors(list);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在拦截器中获取服务所有的列表，根据负载规则选择一台机器提供服务</p><p>通过上面的分析，我们可以看到只要为RestTemplate添加了拦截器之后，根据拦截器的工作性质，往后通过RestTemplate实例的每一次请求都会先走到这个拦截器的intercept()方法中，在intercept()方法中调用了<code>LoadBalancerClient.execute()</code>进行了Server选举。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取服务列表，检测服务是否存活，每一次请求均需要检测一次，所有的路由均实现于ILoadBalancer</span></span><br><span class="line">  ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">  <span class="comment">// 根据配置的路由规则选择最终要提供的服务的地址，所有的规则都实现于IRule</span></span><br><span class="line">  Server server = getServer(loadBalancer);</span><br><span class="line">  <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server, serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发送请求获取结果，然后将结果返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Server server = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">server = ((RibbonServer)serviceInstance).getServer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">.getLoadBalancerContext(serviceId);</span><br><span class="line">RibbonStatsRecorder statsRecorder = <span class="keyword">new</span> RibbonStatsRecorder(context, server);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 最终请求语句</span></span><br><span class="line">T returnVal = request.apply(serviceInstance);</span><br><span class="line">statsRecorder.recordStats(returnVal);</span><br><span class="line"><span class="keyword">return</span> returnVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">statsRecorder.recordStats(ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">statsRecorder.recordStats(ex);</span><br><span class="line">ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借他人的一张图来说明一下请求流程：</p><p><img src="/images/e9998448e095176c2454fafd66ea57ab1511332.png" alt="img"></p></li></ol></li><li><p>配置负载策略</p><p>Ribbon默认的负载策略为ZoneAwareLoadBalancer，我们可以通过配置修改策略方案</p><ol><li><p>使用Ribbon中已存在的负载策略</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">u-service.ribbon.NFLoadBalancerRuleClassName</span>=<span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>所有的策略都实现于IRule接口</p><p><img src="/images/rule.png" alt="img"></p><p>这里单独说一下WeightedResponseTimeRule这个策略，我们在使用Nginx的时候，可以手动预先设置好每一台服务器的权重，但是在Ribbon中，权重是依据服务器响应时间动态设置的，在应用运行期间，这个权重有可能会改变，在WeightedResponseTimeRule类中有一个内部类DynamicServerWeightTask，它是一个定时器，调度时间默认为30秒一次，如果想要修改这个时间，则可以使用自定义负载规则。</p></li><li><p>使用自定义负载策略</p><ul><li><p>创建自定义配置器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 使用权重规则</span></span><br><span class="line">        WeightedResponseTimeRule rule = <span class="keyword">new</span> WeightedResponseTimeRule();</span><br><span class="line">        IClientConfig config = <span class="keyword">new</span> DefaultClientConfigImpl();</span><br><span class="line">        config.loadDefaultValues();</span><br><span class="line">      <span class="comment">// 修改权重定时器执行时间</span></span><br><span class="line">        config.set(WeightedResponseTimeRule.WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY, <span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">      <span class="comment">// 调用方法修改配置</span></span><br><span class="line">        rule.initWithNiwsConfig(config);</span><br><span class="line">        <span class="keyword">return</span> rule;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明要使用该规则的服务</p><p>在启动类上加入<code>@RibbonClient(name = &quot;user-service&quot;, configuration = MyRule.class)</code>，name属性指定服务名称，configuration指定要使用的规则</p></li></ul></li></ol></li></ul></li><li><p>Hystrix</p><p>Spring Cloud Hystrix是从Netflix Hystrix延伸出的一个轻量级的组件，主要功能是服务容错和线程隔离。</p><p>在微服务架构中，服务之间通过远程调用的方式进行通信，会出现一个请求走过多个服务的情况，在请求链路中，一旦某个服务出现故障，那么所有依赖这个服务的其他服务均会发生故障，严重的情况下会导致整个系统全部瘫痪，这与我们做微服务的初衷是相悖的。Hystrix的断路器模式帮我们提升了服务的故障容错能力，当某个服务或某个接口出现故障时，通过断路器的监控，给调用方返回一个指定的错误响应，避免调用方因为长期等待一直占用线程而造成的故障蔓延。</p><p>Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并和服务监控等功能，我们常用的大多就是降级和熔断了。</p><ul><li><p>服务熔断降级</p><p>服务熔断是指在下游服务变得不可用或响应时间过长而导致调用方放弃继续调用转而直接返回的一种处理方式，目的是为了保证上游服务的可用性和稳定性。然后我们创建一个具有熔断器的项目，下游服务的代码不做解释，我们看下上游服务如何开启熔断。</p><ol><li><p>pom.xml</p><p>我们要使用Hystrix的第一步当然是要引入jar包，我们在pom.xml文件中引入依赖jar：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- euraka --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hystrix --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么要引入eureka？因为服务端是注册到eureka里面的啊，所以要引入eureka去做服务发现。那么可以不用eureka么？当然可以。</p></li><li><p>API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"faultMethod"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cuser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String obj = restTemplate.getForObject(<span class="string">"http://cuser-service/user/1"</span>, String.class);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">faultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"服务熔断"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API的定义和我们平时写的不太一样，多了一个注解<code>@HystrixCommand</code>，这个注解的作用就是在我们API内发生异常的时候进行熔断，参数<code>fallbackMethod</code>指定的就是在发生异常的时候跳转的熔断方法，这个方法参数和返回类型需要和被熔断的方法如出一辙，否则就会报错。</p><ul><li>注解<code>@HystrixCommand</code>参数解析<ol><li>fallbackMethod：指定服务降级处理方法；</li><li>ignoreExceptions：忽略某些异常，不发生服务降级；</li><li>commandKey：命令名称，用于区分不同的命令；</li><li>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；</li><li>threadPoolKey：线程池名称，用于划分线程池。</li></ol></li></ul></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudCuserConsumerHystrixApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudCuserConsumerHystrixApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解<code>@EnableHystrix</code>的作用是为应用开启Hystrix的能力，等于一个开关。老版本中使用的是注解<code>@EnableCircuitBreaker</code>，新版本中可以看到EnableHystrix中已经集成在一起了，所以我们使用这一个注解就行了。</p><p>运行过程就不用说了，也就是eureka、server、client都启动了，然后访问<code>http://127.0.0.1:8090/cuser</code>，接着把server停掉，然后再访问，会发现接口发生了熔断。</p></li><li><p>高级参数配置</p><p>注解<code>@HystrixCommand</code>中可以通过参数commandProperties、threadPoolProperties设置熔断降级相关的参数，参数名称在类<code>com.netflix.hystrix.contrib.javanica.conf.HystrixPropertiesManager</code>中有指定，并且类中也说明了这两个属性所适用的参数名称，太多了，写两个比较常用的吧</p><ul><li>threadPoolProperties<ul><li>coreSize：线程池核心线程数</li><li>keepAliveTimeMinutes：线程最大存活时间，单位为分钟</li><li>maxQueueSize：最大等待线程队列容量</li><li>queueSizeRejectionThreshold：等待队列拒绝添加的阈值</li></ul></li><li>commandProperties<ul><li>execution.isolation.thread.timeoutInMilliseconds：设置调用者等待命令执行的超时限制，超过此时间，HystrixCommand被标记为TIMEOUT，并执行回退逻辑。</li></ul></li></ul></li></ol></li><li><p>服务限流</p><p>服务接口限流我们可以通过设置注解<code>@HystrixCommand</code>的threadPoolProperties的参数来实现，限制请求的线程池数量来达到限流的作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>   index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"faultMethod"</span>, threadPoolProperties = &#123;</span><br><span class="line">  <span class="meta">@HystrixProperty</span>(name = <span class="string">"coreSize"</span>, value = <span class="string">"1"</span>),</span><br><span class="line">  <span class="meta">@HystrixProperty</span>(name = <span class="string">"queueSizeRejectionThreshold"</span>, value = <span class="string">"2"</span>),</span><br><span class="line">  <span class="meta">@HystrixProperty</span>(name = <span class="string">"maxQueueSize"</span>, value = <span class="string">"1"</span>) &#125;, commandProperties = &#123;</span><br><span class="line">  <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"2000"</span>) &#125;)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cuser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span> (index % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  String obj = restTemplate.getForObject(<span class="string">"http://cuser-service/user/1"</span>, String.class);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">faultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"服务熔断"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们用index来模拟一个请求挂起的操作，我们线程池核心数设置为1，最大等待队列长度为1，我们用JMeter来模拟45个并发，会发现最终只有3个请求顺利通过，其他的全部都被熔断了。</p><p>然后我们修改一下线程池大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"faultMethod"</span>, threadPoolProperties = &#123;</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"coreSize"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"queueSizeRejectionThreshold"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"maxQueueSize"</span>, value = <span class="string">"100"</span>) &#125;, commandProperties = &#123;</span><br><span class="line">&gt;                     <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"2000"</span>) &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>把核心数和队列数都增大，然后还是45个并发，会发现全部请求都正常了，把并发改为200后，会发现有那么一两个请求会被熔断</p><p>再改一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"faultMethod"</span>, threadPoolProperties = &#123;</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"coreSize"</span>, value = <span class="string">"2"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"queueSizeRejectionThreshold"</span>, value = <span class="string">"2"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"maxQueueSize"</span>, value = <span class="string">"10"</span>) &#125;, commandProperties = &#123;</span><br><span class="line">&gt;                     <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"2000"</span>) &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>150个并发，大概平均每次会有32个请求正常访问，其他的全部被熔断，我们的请求熔断过期时间是2秒，一开始会有2个请求进入核心线程去处理，后续会有10个请求进入等待队列，依次去请求</p><p>问题：如果我们想把接口限制并发20，怎么办？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"faultMethod"</span>, threadPoolProperties = &#123;</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"coreSize"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"queueSizeRejectionThreshold"</span>, value = <span class="string">"2"</span>),</span><br><span class="line">&gt;             <span class="meta">@HystrixProperty</span>(name = <span class="string">"maxQueueSize"</span>, value = <span class="string">"10"</span>) &#125;, commandProperties = &#123;</span><br><span class="line">&gt;                     <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"150000"</span>) &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>我们只能大概的控制一下，并不能如此严谨的设置</p></blockquote></li></ul></li><li><p>Feign</p><p>Spring Cloud Feign是从Netflix Feign扩展出来的一套通过声明式服务调用客户端的组件，使用Feign可用帮助我们更简单的构建一个Web服务，我们只需要通过注解来编写接口，就可以完成对服务接口的绑定。Feign对Hystrix有依赖关系，它只是一个简单的REST框架，最终还是需要通过Ribbon去做负载均衡，通过上面的内容可以看出Feign+Eureka+Ribbon是一家人，Feign通过整合Eureka和Ribbon来实现支持负载均衡的客户端服务。</p><p>使用Feign，我们需要将下游服务的接口定义引入到当前应用中，毕竟Java是一个面向对象的语言，即便是RPC调用，我们也需要使用相同的参数类型，并且尽量保证我们参与传递的参数都能够被序列化，所以既然我们要引入下游服务的接口定义，那么我们尽量在下游接口定义中定义FeignClient，这样做的好处是，服务可以被多个客户端使用，不需要每个客户端都定义一次 Feign 接口。</p><p>客户端需要在启动类上使用注解<code>@EnableFeignClients</code>开启Feign，Feign最终仍然是使用HTTP方式去发起请求。</p><blockquote><p>上游服务A，下游服务B</p><p>B：interface(feign client)—&gt;controller</p><p>A：dependency#A—&gt;enable discovery client &amp;&amp; enable feign clients</p></blockquote><ul><li><p>客户端调用</p><ul><li>定义要调用的目标API接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"cuser-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CUserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function">String <span class="title">getUser</span><span class="params">(@PathVariable(name = <span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要定义接口即可，接口的参数和请求路径都需要和对应的API一致，接口由注解<code>@FeignClient</code>标注。</p><ul><li>调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cuser/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(@PathVariable(name = <span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Feign支持多种注解方式：Feign、JAX-RS、SpringMVC。</p></li></ol><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是spring-cloud&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是spring-cloud&quot;&gt;&lt;/a&gt; 什么是Spring Cloud&lt;/h3&gt;
&lt;p&gt;官网上面有一段话：Spring Cloud为开发人员提供了快速构建
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringCloud" scheme="http://luxiaowan.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中的设计模式</title>
    <link href="http://luxiaowan.github.io/2020/03/29/MyBatis%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://luxiaowan.github.io/2020/03/29/MyBatis中的设计模式/</id>
    <published>2020-03-29T15:55:00.000Z</published>
    <updated>2020-04-01T17:06:16.344Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Builder模式</p><p>SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder</p></li><li><p>工厂模式</p><p>SqlSessionFactory、ObjectFactory、MapperProxyFactory</p></li><li><p>单例模式</p><p>ErrorContext和LogFactory</p></li><li><p>代理模式</p><p>Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果</p></li><li><p>组合模式</p><p>SqlNode和各个子类ChooseSqlNode等</p></li><li><p>模板方法模式</p><p>BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler</p></li><li><p>适配器模式</p><p>Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现</p></li><li><p>装饰者模式</p><p>Cache包中的cache.decorators子包中等各个装饰者的实现</p></li><li><p>迭代器模式</p><p>迭代器模式PropertyTokenizer</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Builder模式&lt;/p&gt;
&lt;p&gt;SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://luxiaowan.github.io/categories/MyBatis/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring解决循环依赖</title>
    <link href="http://luxiaowan.github.io/2020/03/29/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://luxiaowan.github.io/2020/03/29/Spring解决循环依赖/</id>
    <published>2020-03-29T15:35:00.000Z</published>
    <updated>2020-04-07T15:44:04.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是循环依赖"><a class="markdownIt-Anchor" href="#什么是循环依赖"></a> 什么是循环依赖</h3><p>循环依赖的关键点在循环，为了直观一点，我们看个图</p><img src="/images/image-20200405224151194.png" alt="image-20200405224151194" style="zoom:50%;"><p>从图中我们看到，要想实例化类A，必须先要实例化类B，但是在实例化B之前也必须先实例化C，可想要实例化C，就要先实例化A，喏，死循环了，三个类相互引用又相互等待。</p><h3 id="循环依赖如何产生的"><a class="markdownIt-Anchor" href="#循环依赖如何产生的"></a> 循环依赖如何产生的</h3><p>循环依赖的产生可能有多种情况：</p><ol><li>A的构造器中依赖了B的实例，B的构造器中依赖了A的实例</li><li>A的构造器中依赖了B的实例，B的属性或者setter依赖了A的实例</li><li>A的属性或setter依赖了B的实例，B的属性或者setter依赖了A的实例</li></ol><h3 id="spring-ioc解决办法"><a class="markdownIt-Anchor" href="#spring-ioc解决办法"></a> Spring IOC解决办法</h3><p>Spring并不是能解决所有的循环依赖情况，比如上方的情况1是无法解决的，并且如果Bean的scope是protype的，也无法解决。</p><ol><li><p>scope=prototype</p><p>此种情况无法解决循环依赖，因为如果获取bean实例的时候，如果类正在创建中，则会抛出异常，详情查看<code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释我们就可以看出：如果创建bean实例失败则多半因为存在循环依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return whether the specified prototype bean is currently in creation</span></span><br><span class="line"><span class="comment"> * (within the current thread).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPrototypeCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  Object curVal = <span class="keyword">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line">  <span class="keyword">return</span> (curVal != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">          (curVal.equals(beanName) || (curVal <span class="keyword">instanceof</span> Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prototype类型的Bean在创建之前会进行标记和创建之后进行解标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">  <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">  Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    beforePrototypeCreation(beanName);</span><br><span class="line">    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    afterPrototypeCreation(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforePrototypeCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  Object curVal = <span class="keyword">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line">  <span class="keyword">if</span> (curVal == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.prototypesCurrentlyInCreation.set(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterPrototypeCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  Object curVal = <span class="keyword">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line">  <span class="keyword">if</span> (curVal <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="keyword">this</span>.prototypesCurrentlyInCreation.remove();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>scope=singleton</p><p>Spring通过三级缓存的模式解决非构造器注入引起的循环依赖，详情查看<code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object sharedInstance = getSingleton(beanName);</span><br></pre></td></tr></table></figure><p>我们看下getSingleton方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一级缓存获取</span></span><br><span class="line">  Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="comment">// 第一级未找到缓存且bean处于创建中(例如A定义的构造函数依赖了B对象，得先去创建B对象，或者在populatebean过程中依赖了B对象，得先去创建B对象，此时A处于创建中)</span></span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="comment">// 第二级未找到缓存并允许循环依赖即从工厂类获取对象</span></span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          <span class="comment">// 将三级缓存移入二级缓存</span></span><br><span class="line">          <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">          <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在singleton方法中出现了三个属性：<code>singletonObjects</code>,<code>earlySingletonObjects</code>,<code>singletonFactories</code>，这也就是上面说的三级缓存，这个方法的逻辑是先获取一级缓存，若一级缓存中不存在，则获取第二级缓存，二级缓存若也不存在则获取三级缓存，若三级缓存都不存在，则在getBean方法中当成prototype处理。那么这三级缓存中主要存的是什么东西呢？</p><ul><li>一级缓存：已经初始化完成的bean对象Cache</li><li>二级缓存：提前曝光的bean对象Cache</li><li>三级缓存：ObjectFactory工厂bean缓存, 存储实例化后的bean factory</li></ul><p>Spring创建一个Bean的实例大致经过三个步骤：</p><ol><li>createBeanInstance：调用Bean的构造器进行实例化，调用构造器并未填充属性</li><li>populateBean：填充属性，也就是setter所有的property</li><li>initializeBean：初始化Bean，会调用指定的init方法，或者afterPropertiesSet方法，这个时候类属性已经注入完成了</li></ol><h4 id="三级缓存何时设置的"><a class="markdownIt-Anchor" href="#三级缓存何时设置的"></a> 三级缓存何时设置的</h4><p>三级缓存的设置点是什么时候？我们来看下类的创建过程<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. Instantiate the bean.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 创建三级缓存</span></span><br><span class="line">  <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                    isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                   <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取Bean的ObjectFactory并放入三级缓存</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">  Object exposedObject = bean;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 填充属性</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">// 初始化Bean</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到第三级缓存是在createBeanInstance方法之后就被设置，这个时候Bean的对象已经被创建出来了，只不过是还不够完美，只是一个壳，但是在容器中已经可以根据对象引用被认出来了；</li><li>第二级缓存是在getSingleton方法之后，若第三级缓存中已经存在，则将对象从三级缓存中转移到二级缓存中；</li><li>完全初始化之后将自己放入到一级缓存singletonObjects中</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是循环依赖&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是循环依赖&quot;&gt;&lt;/a&gt; 什么是循环依赖&lt;/h3&gt;
&lt;p&gt;循环依赖的关键点在循环，为了直观一点，我们看个图&lt;/p&gt;
&lt;img src=&quot;/images/image-2020
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://luxiaowan.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <link href="http://luxiaowan.github.io/2020/03/29/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://luxiaowan.github.io/2020/03/29/TCP三次握手和四次挥手/</id>
    <published>2020-03-29T12:20:00.000Z</published>
    <updated>2020-03-29T15:32:38.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>传输控制协议(Transmission Control Protocol，简称TCP)是一种面向连接的、可靠的、基于字节流的传输层通信协议，应用层向TCP层发送用于网间传输的用8位字节表示的数据流，TCP将数据流做分隔处理后透传给IP层，然后由IP层将数据传输给目标端TCP层。</p><p>TCP为保证不发生丢包，会对所有的包进行编号，接收端依据编号按序接收，全部数据包接收完成后按序号进行合并，这里可能会发生粘包、拆包的问题(暂不介绍)。接收端在每次接收到数据包的时候都会返回给发送端一个确认信息(ACK)，若发送端在一定时间内未接收到ACK信息，则主观认为数据发送失败或数据丢失，会重新发送丢失序号的包。</p><h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3><p>TCP在发送数据之前，需要先建立连接，客户端主动，TCP使用三次握手的方式建立连接，三次握手的意思就是客户端和服务端进行三次通信，三次握手的目的是为了确认通信双方的发送和接收能力是否正常。主要过程：</p><img src="/images/tcp_connect.png" alt="tcp_connect" style="zoom:67%;"><ul><li><p>第一次握手：客户端：服务端，我想要向你发送数据</p><ul><li>客户端向服务端发送一个SYN包，并指明客户端的初始化序列号ISN，随后客户端进入SYN_SEND状态。</li><li>同部位SYN=1，初始序列号seq=x，此报文不能携带任何的数据，却会消耗掉一个序列号</li></ul></li><li><p>第二次握手：服务端：客户端，我准备好了，你可以把数据发过来了</p><ul><li>服务端接收到客户端发送的消息，需要返回一个SYN/ACK包进行响应，否则客户端会以为消息跑丢了造成重发，SYN/ACK以服务端的为准，SYN=1, ACK=x+1</li><li>服务端响应消息也属于是一次通信，所以服务端需要将自己的序列号放入到报文中携带给客户端，初始化序列号seq=y</li><li>总的响应报文：SYN=1 ACK=x+1 seq=y</li><li>服务端进入SYN_RECV状态</li></ul></li><li><p>第三次握手：客户端：服务端，我知道了，敌人还有三秒到达战场</p><ul><li>客户端接收到服务端的响应之后，要告诉服务端老子收到你的响应了，不要以为消息丢了，等着接收数据吧您嘞</li><li>这次握手等于是服务端响应的翻版，报文包括ACK=y+1 seq=x+1</li><li>客户端和服务端均进入ESTABLISHED（TCP连接成功）状态</li></ul></li></ul><blockquote><p>为什么使用三次握手，两次是否可以？</p><p>*** 之所以进行三次握手，是保证客户端和服务端均可以进行一次发送、接收和发送接收反馈，目的是让客户端和服务端各自确认自己的发送和接收能力都正常**</p></blockquote><h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3><p>TCP发送完数据之后，需要将连接断开，当然断开连接的也需要客户端主动发起，因为数据是否发送完毕只有发送者知道。断开连接需要通过四次挥手(也可以叫四次握手)来保证合理性。</p><img src="/images/tcp_disconnect.png" alt="tcp_disconnect" style="zoom:67%;"><ul><li>第一次挥手：客户端：我数据发送完了，可以断开连接了，我先进入准备断开状态<ul><li>客户端发送完数据之后，向服务端发送断开请求报文，FIN=1 seq=u</li><li>客户端进入FIN-WAIT-1状态，等待服务端的响应</li><li>表示客户端没有数据要发给服务端了</li></ul></li><li>第二次挥手：服务端：我收到了，我同意你的请求，但我要看下我是否还有数据尚在发送，你等会<ul><li>服务端接收到客户端的断开请求之后，根据序列号进行反馈，ACK=1 seq=v ack=u+1</li><li>服务端反馈之后进入CLOSE-WAIT状态，客户端接收到反馈之后进入FIN-WAIT-2状态，等待服务端的确认断开请求</li></ul></li><li>第三次挥手：服务端：我的数据也都发完了，可以断开了<ul><li>服务端再处理完自己的事情之后，向客户端发送确认断开报文，FIN=1 ACK=1 seq=w ack=u+1</li><li>这里的ack=u+1，发现和第二次挥手时候的ack一模一样，这也就是和客户端的断开请求对应起来，否则把别的给断开了岂不是很尴尬</li><li>服务端进入LAST-ACK状态，等待客户端的回应</li></ul></li><li>第四次挥手：客户端：我知道了，断开<ul><li>客户端接收到确认断开报文后，向服务端反馈断开报文，ACK=1 seq=u+1 ack=w+1</li><li>服务端接收到反馈后关闭连接</li><li>客户端等待2MSL后关闭连接</li></ul></li></ul><p>看一个官方描述图片：</p><img src="/images/tcp_disconnect.jpg" alt="tcp_disconnect" style="zoom:75%;"><h5 id="为什么要等待2msl"><a class="markdownIt-Anchor" href="#为什么要等待2msl"></a> 为什么要等待2MSL</h5><ul><li><p>目的是防止ACK消息丢失，服务端重发消息后可以再次接收并反馈；</p></li><li><p>如果在第三次挥手反馈后客户端立刻关闭，如果反馈报文丢失，那么服务端可能就会一直处于重发第三次挥手的报文中，服务端将无法正常进入关闭状态</p></li><li><p>如果第四次挥手的报文丢失，服务端会再次发送确认关闭消息，客户端重新等待2MSL</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h3&gt;
&lt;p&gt;传输控制协议(Transmission Control Protocol，简称TCP)是一种面向连接的、可靠的、基于字节流的传输层通信协议，应用
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis哨兵简介</title>
    <link href="http://luxiaowan.github.io/2020/03/29/Redis%E5%93%A8%E5%85%B5%E7%AE%80%E4%BB%8B/"/>
    <id>http://luxiaowan.github.io/2020/03/29/Redis哨兵简介/</id>
    <published>2020-03-28T17:05:00.000Z</published>
    <updated>2020-03-28T19:20:52.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>Redis Sentinel是Redis官方建议的高可用(HA)解决方案，在我们搭建Redis集群时，Redis本身并未集成主备切换功能，sentinel本身是独立运行的，能够监控多个Redis集群，发现master宕机后能够自动切换，选举一个slave成为新的master，当原master恢复之后，sentinel会自动将其作为slave加入到集群中，整个过程不需要人工参与，完全自动化。</p><h3 id="主要介绍"><a class="markdownIt-Anchor" href="#主要介绍"></a> 主要介绍</h3><ol><li><p>sentinel主要功能</p><ul><li>定期监控Redis服务是否运行正常</li><li>定期监控其他sentinel服务是否正常</li><li>能够自动切换master节点</li><li>sentinel节点不存储数据</li></ul></li><li><p>sentinel集群</p><p>这个不难理解，如果我们用一个非高可用的sentinel去实现Redis的高可用，明显是不科学的，当这一台sentinel宕机之后，Redis显然无法继续保持它的高可用，所以我们在部署sentinel的时候也会采用集群的方式</p><blockquote><p>优势：</p><p>​即使有sentinel服务宕机，只要还有一台sentinel运行正常，就可以使Redis继续保持高可用</p></blockquote></li><li><p>sentinel版本问题</p><p>sentinel在Redis2.6版本中引入的，当时是sentinel 1，貌似有蛮多问题，毕竟初版</p><p>在Redis2.8版本中升级到sentinel 2，之后就非常稳定了</p><p>不过现在Redis已经发展了很久，版本也越来越高，sentinel已经非常值得信赖了</p></li><li><p>sentinel中的定时任务</p><ul><li>每隔10秒向各个Redis服务器(master和slave节点)发送INFO命令，根据回应获取master和slave信息，通过master的回复可以获取到新增的slave节点</li><li>每隔02秒向Redis的master服务器发送命令(hello消息)，用于发现和监视其他sentinel，sentinel之间的监控不在额外创建订阅</li><li>每隔01秒向Redis和sentinel所有服务发送PING消息(sentinel本身的ip、端口、id等内容)，通过回复PONG判断服务是否在线</li></ul></li><li><p>下线判断</p><ul><li>主观下线：当前sentinel断定master下线</li><li>客观下线：满足sentinel配置文件中quorum数量的sentinel均断定master下线</li></ul></li><li><p>配置文件解读</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel运行的端口，默认为26379</span></span><br><span class="line"><span class="attr">port</span> <span class="string">26377      </span></span><br><span class="line"></span><br><span class="line"><span class="attr">dir</span> <span class="string">"/private/tmp"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logfile</span> <span class="string">"/var/log/redis/sentinel_26377.log"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以守护进程执行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 守护进程运行的pid保存文件</span></span><br><span class="line"><span class="attr">pidfile</span> <span class="string">"/var/run/redis-sentinel.pid"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line"><span class="comment"># 该行的意思是：&lt;master-name&gt;：自定义</span></span><br><span class="line"><span class="comment">#&lt;ip&gt;：master主机的IP</span></span><br><span class="line"><span class="comment">#&lt;redis-port&gt;：master的端口</span></span><br><span class="line"><span class="comment">#&lt;quorum&gt;：表示在sentinel集群中，使master由主观下线变为客观下线的sentinel数量。</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor cc_master 127.0.0.1 6379 2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line"><span class="comment"># sentinel会向master发送心跳PING来确认master是否存活，如果master在&lt;milliseconds&gt;时间内回应的不是PONG，那么这个sentinel会主观地认为这个master下线了。&lt;milliseconds&gt;的单位是毫秒，默认30秒。</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">down-after-milliseconds cc_master 15000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line"><span class="comment"># failover过期时间，当failover开始后，在此时间内仍然没有触发任何failover操作，当前sentinel将会认为此次failoer失败。默认180秒，即3分钟。</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">failover-timeout cc_master 60000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numreplicas&gt;</span></span><br><span class="line"><span class="comment"># 在发生failover主备切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">parallel-syncs cc_master 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line"><span class="comment"># sentinel连接的master节点的登录密码</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">auth-pass cc_master redis</span></span><br></pre></td></tr></table></figure></li><li><p>故障转移</p><ul><li>sentinel使用Raft投票选举出一个leader去执行故障转移<ul><li>每一个将master标记为主观下线的sentinel节点发起投票</li><li>其他sentinel节点收到投票后，若尚未参与投票(也就是尚未投票给其他sentinel)，则同意，否则拒绝</li><li>最终收到过半同意的sentinel节点作为leader</li><li>若有两个sentinel收到了过半投票，那么就再重新选举</li></ul></li><li>选举新的master节点<ul><li>选择replica-priority配置数字最高的slave节点为master，默认为100</li><li>若replica-priority相同，则选择偏移量最大的slave节点，偏移量是指slave从master同步的进度，偏移量越大说明数据越完整，可以通过Redis的info命令查看(slave_repl_offset)当前slave的偏移量</li><li>若偏移量相同，则选择最先启动的slave作为master</li><li>更改master后，通知其他slave节点同步为新的master节点的slave节点</li><li>原master节点恢复之后自动加入到集群中，成为新master的slave节点</li></ul></li></ul></li></ol><h3 id="实战"><a class="markdownIt-Anchor" href="#实战"></a> 实战</h3><p>在本机上启动3个Redis实例，采用1主2从的模式，以下只记录redis.conf和sentinel.conf中关键内容</p><ol><li><p>redis.conf</p><ul><li><p>redis-master.conf配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br></pre></td></tr></table></figure></li><li><p>redis-slave1.conf配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">63791</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="comment"># 从节点归属的master节点</span></span><br><span class="line"><span class="attr">replicaof</span> <span class="string">127.0.0.1 6379</span></span><br></pre></td></tr></table></figure></li><li><p>redis-slave2.conf配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">63792</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="comment"># 从节点归属的master节点</span></span><br><span class="line"><span class="attr">replicaof</span> <span class="string">127.0.0.1 6379</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>sentinel.conf</p><ul><li><p>sentinel0.conf</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">26379</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">myid 842c9102c48eb0cedeb06fe55e7d2258595ac267</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控master</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor cc_master 127.0.0.1 6379 2</span></span><br></pre></td></tr></table></figure></li><li><p>sentinel1.conf</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">26378</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">myid 842c9102c48eb0cedeb06fe55e7d2258595ac266</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控master</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor cc_master 127.0.0.1 6379 2</span></span><br></pre></td></tr></table></figure></li><li><p>sentinel2.conf</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">26377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">myid 842c9102c48eb0cedeb06fe55e7d2258595ac265</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控master</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor cc_master 127.0.0.1 6379 2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动</p><ol><li><p>启动sentinel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel ~/Documents/develop_tools/tools/redis-5.0.5/sentinel0.conf</span><br><span class="line"></span><br><span class="line">redis-sentinel ~/Documents/develop_tools/tools/redis-5.0.5/sentinel1.conf</span><br><span class="line"></span><br><span class="line">redis-sentinel ~/Documents/develop_tools/tools/redis-5.0.5/sentinel2.conf</span><br></pre></td></tr></table></figure></li><li><p>启动Redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server ~/Documents/develop_tools/tools/redis-5.0.5/redis-master.conf</span><br><span class="line"></span><br><span class="line">redis-server ~/Documents/develop_tools/tools/redis-5.0.5/redis-slave1.conf</span><br><span class="line"></span><br><span class="line">redis-server ~/Documents/develop_tools/tools/redis-5.0.5/redis-slave2.conf</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="redis通过info查看信息"><a class="markdownIt-Anchor" href="#redis通过info查看信息"></a> Redis通过info查看信息</h3><p>127.0.0.1:6379&gt;info all</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Server服务器信息</span></span><br><span class="line"><span class="attr">redis_version</span>:<span class="string">5.0.5# Redis 服务器版本</span></span><br><span class="line"><span class="attr">redis_git_sha1</span>:<span class="string">00000000 # Git SHA1</span></span><br><span class="line"><span class="attr">redis_git_dirty</span>:<span class="string">0# Git dirty flag</span></span><br><span class="line"><span class="attr">redis_build_id</span>:<span class="string">6c6e38af7cea0726# Redis构建ID</span></span><br><span class="line"><span class="attr">redis_mode</span>:<span class="string">standalone# Redis运行模式</span></span><br><span class="line"><span class="attr">os</span>:<span class="string">Darwin 19.3.0 x86_64# 运行环境操作系统版本</span></span><br><span class="line"><span class="attr">arch_bits</span>:<span class="string">64# 架构（32 或 64 位）</span></span><br><span class="line"><span class="attr">multiplexing_api</span>:<span class="string">kqueue# Redis 所使用的事件处理机制</span></span><br><span class="line"><span class="attr">atomicvar_api</span>:<span class="string">atomic-builtin</span></span><br><span class="line"><span class="attr">gcc_version</span>:<span class="string">4.2.1# 编译的GCC版本</span></span><br><span class="line"><span class="attr">process_id</span>:<span class="string">61985# 服务器进程的 PID</span></span><br><span class="line"><span class="attr">run_id</span>:<span class="string">433b78ec513c8b782f3a46ba6b4ade1f12439aca# Redis 服务器的随机标识符(用于Sentinel和集群)</span></span><br><span class="line"><span class="attr">tcp_port</span>:<span class="string">6379# Redis端口</span></span><br><span class="line"><span class="attr">uptime_in_seconds</span>:<span class="string">108# Redis运行时长，秒</span></span><br><span class="line"><span class="attr">uptime_in_days</span>:<span class="string">0# Redis运行市场，天</span></span><br><span class="line"><span class="attr">hz</span>:<span class="string">10</span></span><br><span class="line"><span class="attr">configured_hz</span>:<span class="string">10</span></span><br><span class="line"><span class="attr">lru_clock</span>:<span class="string">8363059# 以分钟为单位进行自增的时钟，用于 LRU 管理</span></span><br><span class="line"><span class="attr">executable</span>:<span class="string">/Users/chuan/redis-server# 运行命令</span></span><br><span class="line"><span class="attr">config_file</span>:<span class="string"># 启动使用的配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line"><span class="attr">connected_clients</span>:<span class="string">7# 已连接客户端的数量</span></span><br><span class="line"><span class="attr">client_recent_max_input_buffer</span>:<span class="string">2# 当前连接的客户端当中，最长的输出列表</span></span><br><span class="line"><span class="attr">client_recent_max_output_buffer</span>:<span class="string">0# 当前连接的客户端当中，最大输入缓存</span></span><br><span class="line"><span class="attr">blocked_clients</span>:<span class="string">0# 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory (太多了，不做解释了)</span></span><br><span class="line"><span class="attr">used_memory</span>:<span class="string">2235920# 由 Redis 分配器分配的内存总量，以字节（byte）为单位</span></span><br><span class="line"><span class="attr">used_memory_human</span>:<span class="string">2.13M# 以可读的格式返回 Redis 分配的内存总量</span></span><br><span class="line"><span class="attr">used_memory_rss</span>:<span class="string">3153920# 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和top 、 ps 等命令的输出一致。</span></span><br><span class="line"><span class="attr">used_memory_rss_human</span>:<span class="string">3.01M # 以可读的格式返回rss</span></span><br><span class="line"><span class="attr">used_memory_peak</span>:<span class="string">2317840# Redis 的内存消耗峰值（以字节为单位）</span></span><br><span class="line"><span class="attr">used_memory_peak_human</span>:<span class="string">2.21M</span></span><br><span class="line"><span class="attr">used_memory_peak_perc</span>:<span class="string">96.47%</span></span><br><span class="line"><span class="attr">used_memory_overhead</span>:<span class="string">2221526</span></span><br><span class="line"><span class="attr">used_memory_startup</span>:<span class="string">987776</span></span><br><span class="line"><span class="attr">used_memory_dataset</span>:<span class="string">14394</span></span><br><span class="line"><span class="attr">used_memory_dataset_perc</span>:<span class="string">1.15%</span></span><br><span class="line"><span class="attr">allocator_allocated</span>:<span class="string">2271808</span></span><br><span class="line"><span class="attr">allocator_active</span>:<span class="string">3116032</span></span><br><span class="line"><span class="attr">allocator_resident</span>:<span class="string">3116032</span></span><br><span class="line"><span class="attr">total_system_memory</span>:<span class="string">17179869184</span></span><br><span class="line"><span class="attr">total_system_memory_human</span>:<span class="string">16.00G</span></span><br><span class="line"><span class="attr">used_memory_lua</span>:<span class="string">37888</span></span><br><span class="line"><span class="attr">used_memory_lua_human</span>:<span class="string">37.00K</span></span><br><span class="line"><span class="attr">used_memory_scripts</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">used_memory_scripts_human</span>:<span class="string">0B</span></span><br><span class="line"><span class="attr">number_of_cached_scripts</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">maxmemory</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">maxmemory_human</span>:<span class="string">0B</span></span><br><span class="line"><span class="attr">maxmemory_policy</span>:<span class="string">noeviction</span></span><br><span class="line"><span class="attr">allocator_frag_ratio</span>:<span class="string">1.37</span></span><br><span class="line"><span class="attr">allocator_frag_bytes</span>:<span class="string">844224</span></span><br><span class="line"><span class="attr">allocator_rss_ratio</span>:<span class="string">1.00</span></span><br><span class="line"><span class="attr">allocator_rss_bytes</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">rss_overhead_ratio</span>:<span class="string">1.01</span></span><br><span class="line"><span class="attr">rss_overhead_bytes</span>:<span class="string">37888</span></span><br><span class="line"><span class="attr">mem_fragmentation_ratio</span>:<span class="string">1.39</span></span><br><span class="line"><span class="attr">mem_fragmentation_bytes</span>:<span class="string">882112</span></span><br><span class="line"><span class="attr">mem_not_counted_for_evict</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">mem_replication_backlog</span>:<span class="string">1048576</span></span><br><span class="line"><span class="attr">mem_clients_slaves</span>:<span class="string">33844</span></span><br><span class="line"><span class="attr">mem_clients_normal</span>:<span class="string">151226</span></span><br><span class="line"><span class="attr">mem_aof_buffer</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">mem_allocator</span>:<span class="string">libc</span></span><br><span class="line"><span class="attr">active_defrag_running</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">lazyfree_pending_objects</span>:<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line"><span class="attr">loading</span>:<span class="string">0# 服务器是否正在载入持久化文件</span></span><br><span class="line"><span class="attr">rdb_changes_since_last_save</span>:<span class="string">1# 距离最后一次成功创建持久化文件之后，改变了多少个键值</span></span><br><span class="line"><span class="attr">rdb_bgsave_in_progress</span>:<span class="string">0# 服务器是否正在创建RDB文件</span></span><br><span class="line"><span class="attr">rdb_last_save_time</span>:<span class="string">1585421263# 最近一次成功创建RDB文件的UNIX时间</span></span><br><span class="line"><span class="attr">rdb_last_bgsave_status</span>:<span class="string">ok# 最后一次创建RDB文件的结果是成功还是失败</span></span><br><span class="line"><span class="attr">rdb_last_bgsave_time_sec</span>:<span class="string">0# 最后一次创建RDB文件耗费的秒数</span></span><br><span class="line"><span class="attr">rdb_current_bgsave_time_sec</span>:<span class="string">-1# 记录当前创建RDB操作已经耗费了多长时间（单位为秒）</span></span><br><span class="line"><span class="attr">rdb_last_cow_size</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">aof_enabled</span>:<span class="string">0# AOF是否处于打开状态</span></span><br><span class="line"><span class="attr">aof_rewrite_in_progress</span>:<span class="string">0# 服务器是否正在创建AOF文件</span></span><br><span class="line"><span class="attr">aof_rewrite_scheduled</span>:<span class="string">0# 是否需要执行预约的AOF重写操作</span></span><br><span class="line"><span class="attr">aof_last_rewrite_time_sec</span>:<span class="string">-1# 最后一次重启AOF的秒数</span></span><br><span class="line"><span class="attr">aof_current_rewrite_time_sec</span>:<span class="string">-1# 记录当前正在重写AOF的秒数</span></span><br><span class="line"><span class="attr">aof_last_bgrewrite_status</span>:<span class="string">ok# 最后一次重写AOF文件的结果</span></span><br><span class="line"><span class="attr">aof_last_write_status</span>:<span class="string">ok# 最后一次写入结果</span></span><br><span class="line"><span class="attr">aof_last_cow_size</span>:<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats(可以不做了解)</span></span><br><span class="line"><span class="attr">total_connections_received</span>:<span class="string">9</span></span><br><span class="line"><span class="attr">total_commands_processed</span>:<span class="string">720</span></span><br><span class="line"><span class="attr">instantaneous_ops_per_sec</span>:<span class="string">6</span></span><br><span class="line"><span class="attr">total_net_input_bytes</span>:<span class="string">34197</span></span><br><span class="line"><span class="attr">total_net_output_bytes</span>:<span class="string">229238</span></span><br><span class="line"><span class="attr">instantaneous_input_kbps</span>:<span class="string">0.34</span></span><br><span class="line"><span class="attr">instantaneous_output_kbps</span>:<span class="string">1.19</span></span><br><span class="line"><span class="attr">rejected_connections</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">sync_full</span>:<span class="string">2# 主从完全同步成功次数</span></span><br><span class="line"><span class="attr">sync_partial_ok</span>:<span class="string">0# 主从部分同步成功次数</span></span><br><span class="line"><span class="attr">sync_partial_err</span>:<span class="string">0# 主从部分同步失败次数</span></span><br><span class="line"><span class="attr">expired_keys</span>:<span class="string">0# 运行以来过期的key的数量</span></span><br><span class="line"><span class="attr">expired_stale_perc</span>:<span class="string">0.00# 过期的比率</span></span><br><span class="line"><span class="attr">expired_time_cap_reached_count</span>:<span class="string">0# 过期计数</span></span><br><span class="line"><span class="attr">evicted_keys</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">keyspace_hits</span>:<span class="string">1</span></span><br><span class="line"><span class="attr">keyspace_misses</span>:<span class="string">1</span></span><br><span class="line"><span class="attr">pubsub_channels</span>:<span class="string">1</span></span><br><span class="line"><span class="attr">pubsub_patterns</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">latest_fork_usec</span>:<span class="string">278</span></span><br><span class="line"><span class="attr">migrate_cached_sockets</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">slave_expires_tracked_keys</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">active_defrag_hits</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">active_defrag_misses</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">active_defrag_key_hits</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">active_defrag_key_misses</span>:<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication（master节点）</span></span><br><span class="line"><span class="attr">role</span>:<span class="string">master# 角色 master和slave</span></span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="string">2# slave节点数</span></span><br><span class="line"><span class="attr">slave0</span>:<span class="string">ip=127.0.0.1,port=63791,state=online,offset=20163,lag=1# 从节点1</span></span><br><span class="line"><span class="attr">slave1</span>:<span class="string">ip=127.0.0.1,port=63792,state=online,offset=20163,lag=0# 从节点2</span></span><br><span class="line"><span class="attr">master_replid</span>:<span class="string">895f219aa1e7ed5ecda50dcb1f77eea9f1ef9c3d# 主实例启动随机字符串</span></span><br><span class="line"><span class="attr">master_replid2</span>:<span class="string">0000000000000000000000000000000000000000# 主实例启动随机字符串2</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="string">20163# 主从同步偏移量,此值如果和上面的offset相同说明主从一致没延迟，与master_replid可被用来标识主实例复制流中的位置。</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:<span class="string">-1# 主从同步偏移量2,此值如果和上面的offset相同说明主从一致没延迟</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="string">1# 复制积压缓冲区是否开启</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="string">1048576# 复制积压缓冲大小</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="string">1# 复制缓冲区里偏移量的大小</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="string">20163# 此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication（slave节点）</span></span><br><span class="line"><span class="attr">role</span>:<span class="string">slave# 角色 master和slave</span></span><br><span class="line"><span class="attr">master_host</span>:<span class="string">127.0.0.1# master节点IP</span></span><br><span class="line"><span class="attr">master_port</span>:<span class="string">6379# master节点端口</span></span><br><span class="line"><span class="attr">master_link_status</span>:<span class="string">up# master通信</span></span><br><span class="line"><span class="attr">master_last_io_seconds_ago</span>:<span class="string">1# 主库多少秒未发送数据到从库</span></span><br><span class="line"><span class="attr">master_sync_in_progress</span>:<span class="string">0# 从服务器是否在与主服务器进行同步</span></span><br><span class="line"><span class="attr">slave_repl_offset</span>:<span class="string">42262# slave复制偏移量</span></span><br><span class="line"><span class="attr">slave_priority</span>:<span class="string">100# slave优先级</span></span><br><span class="line"><span class="attr">slave_read_only</span>:<span class="string">1# 从库是否设置只读</span></span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="string">0# 连接的slave实例个数</span></span><br><span class="line"><span class="attr">master_replid</span>:<span class="string">895f219aa1e7ed5ecda50dcb1f77eea9f1ef9c3d</span></span><br><span class="line"><span class="attr">master_replid2</span>:<span class="string">0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="string">42262# master偏移量，与slave_repl_offset相同则表示同步完整</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:<span class="string">-1</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="string">1# 复制积压缓冲区是否开启</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="string">1048576# 复制积压缓冲大小</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="string">1# 复制缓冲区里偏移量的大小</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="string">42262# 此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line"><span class="attr">used_cpu_sys</span>:<span class="string">0.104404# 将所有redis主进程在核心态所占用的CPU时求和累计起来</span></span><br><span class="line"><span class="attr">used_cpu_user</span>:<span class="string">0.079472# 将所有redis主进程在用户态所占用的CPU时求和累计起来</span></span><br><span class="line"><span class="attr">used_cpu_sys_children</span>:<span class="string">0.002037# 将后台进程在核心态所占用的CPU时求和累计起来</span></span><br><span class="line"><span class="attr">used_cpu_user_children</span>:<span class="string">0.000648# 将后台进程在用户态所占用的CPU时求和累计起来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster</span></span><br><span class="line"><span class="attr">cluster_enabled</span>:<span class="string">0# 实例是否启用集群模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line"><span class="attr">db0</span>:<span class="string">keys=1,expires=0,avg_ttl=0# db0的key的数量,以及带有生存期的key的数,平均存活时间</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;Redis Sentinel是Redis官方建议的高可用(HA)解决方案，在我们搭建Redis集群时，Redis本身并未集成主备切换功能，sen
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
      <category term="Sentinel" scheme="http://luxiaowan.github.io/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>线程池运行的线程和队列中等待的线程是同一个吗</title>
    <link href="http://luxiaowan.github.io/2020/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%AD%E7%AD%89%E5%BE%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%90%97/"/>
    <id>http://luxiaowan.github.io/2020/03/28/线程池运行的线程和队列中等待的线程是同一个吗/</id>
    <published>2020-03-27T16:52:00.000Z</published>
    <updated>2020-03-27T18:42:31.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3><p>在高并发场景下，线程池是会被频繁使用到的，简单介绍下线程池：</p><ul><li><p>线程池基础参数：核心线程数、最大线程数、线程最大存活时间、时间单位、阻塞队列、线程池工厂、拒绝策略</p></li><li><p>创建方式：</p><ul><li>ThreadPoolExecutor类：ThreadPoolExecutor tpe = new ThreadPoolExecutor(1, 1, 0, TimeUtil.SECONDS, new ArrayBlockingQueue(), new DefaultThreadFactory())</li><li>Executors类：<ul><li>newFixedThreadPool(1);</li><li>newSingleThreadExecutor();</li><li>newCachedThreadPool();</li><li>newScheduledThreadPool(1);</li></ul></li><li>等待队列：<ul><li>ArrayBlockingQueue：由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：由链表结构组成的有界阻塞队列</li><li>DelayQueue：使用优先级队列实现的无界阻塞队列</li><li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li><li>SynchronousQueue：不存储元素的阻塞队列</li></ul></li><li>拒绝策略：<ul><li>DiscardPolicy：丢弃被拒绝任务</li><li>DiscardOldestPolicy：丢弃队列头部的任务</li><li>AbortPolicy：抛出RejectedExecutionException</li><li>CallerRunsPolicy：在调用execute方法的线程中运行被拒绝的任务</li></ul></li></ul></li><li><p>工作原理：</p><p><img src="/images/tpe-process.png" alt="tpe-process"></p></li></ul><h3 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h3><ul><li><p>线程池创建过程</p><ol><li><p>创建语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pools = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUtil.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">  核心线程数：<span class="number">5</span></span><br><span class="line">  最大线程数：<span class="number">10</span></span><br><span class="line">  非核心线程最大存活时间：<span class="number">10</span>秒</span><br><span class="line">  阻塞队列：LinkedBlockingQueue</span><br><span class="line">  线程池工厂：DefaultThreadFactory</span><br><span class="line">  拒绝策略：AbortPolicy</span><br></pre></td></tr></table></figure></li><li><p>在线程池真正运行之前，核心线程尚未创建，因为默认是在实际使用的时候才会去创建，但是如果我们想要在线程池创建的时候就初始化核心线程，可以调用ThreadPoolExecutor的实例方法<code>prestartAllCoreThreads()</code>，如果我们想要让核心线程在空闲时可以过期，那么我们可以调用ThreadPoolExecutor的实例方法<code>allowCoreThreadTimeOut(boolean value)</code>来设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置核心线程是否允许过期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 若value为true，但是线程最大存活时间不大于0，那么则抛异常</span></span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">  <span class="comment">// 如果设置的新值和当前值不同，则执行计划</span></span><br><span class="line">  <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">    allowCoreThreadTimeOut = value;</span><br><span class="line">    <span class="comment">// 若value为true，则终止线程池内的所有空闲Worker</span></span><br><span class="line">    <span class="keyword">if</span> (value)</span><br><span class="line">      interruptIdleWorkers();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化核心线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 循环创建工作线程Worker</span></span><br><span class="line">  <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">    ++n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建线程Worker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  retry:<span class="comment">// goto语法</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;<span class="comment">// 无限循环，循环体内控制退出</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">// 当前线程数</span></span><br><span class="line">      <span class="comment">// 校验当前正在执行的线程数是否超过了2^29 - 1，或者根据创建的是否为核心线程来与核心线程数和最大线程数做校验，如果已经超过了相关的值，则返回false拒绝创建</span></span><br><span class="line">      <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 改变当前运行的线程数，这里使用的CAS来保证线程安全，设置成功则跳出最外层循环</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">break</span> retry;</span><br><span class="line">      c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">      <span class="comment">// 当前线程池状态和方法最初的对比，若不等，则重新执行for循环体</span></span><br><span class="line">      <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">        <span class="keyword">continue</span> retry;</span><br><span class="line">      <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">  Worker w = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Worker线程实例</span></span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    <span class="comment">// Worker实例的属性，在Worker构造器中通过getThreadFactory().newThread(this);来创建</span></span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 加锁，保证线程安全</span></span><br><span class="line">      <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">        <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">        <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验rs是否为RUNNING，或者停止且队列中无任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">          <span class="comment">// 将新创建的Worker实例放入HashSet集合中</span></span><br><span class="line">          workers.add(w);</span><br><span class="line">          <span class="keyword">int</span> s = workers.size();</span><br><span class="line">          <span class="comment">// 更新最大线程运行数</span></span><br><span class="line">          <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = s;</span><br><span class="line">          workerAdded = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 工作线程创建成功后，调用线程的start()方法开启线程</span></span><br><span class="line">      <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">        t.start();<span class="comment">// tag-cc307</span></span><br><span class="line">        workerStarted = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 创建失败的话，则处理失败计划</span></span><br><span class="line">    <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">      addWorkerFailed(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由addWorker方法我们可以看出，线程池的核心执行器是Worker内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker类定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--</span></span><br><span class="line"><span class="class">  <span class="title">final</span>修饰：不可被扩展</span></span><br><span class="line"><span class="class">  继承自<span class="title">AQS</span>：保证线程运行的隔离性，线程池的线程安全核心</span></span><br><span class="line"><span class="class">  实现自<span class="title">Runnable</span>，所以<span class="title">Worker</span>也是一个线程类</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-- 构造器</span></span><br><span class="line"><span class="class">  <span class="title">Worker</span>(<span class="title">Runnable</span> <span class="title">firstTask</span>) </span>&#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">  <span class="comment">// 使用线程池工厂创建新线程，并将创建的线程赋值给实例属性thread，也就是在我们调用了thread的start()方法之后，会运行Worker类中的run()方法</span></span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看到这里，就应该去看Worker类中的run方法了，我们看到在run方法中调用了runWorker方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心关键方法，final修饰，不允许被overload和override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  Thread wt = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 全文搜索tag-cc307</span></span><br><span class="line">  Runnable task = w.firstTask;</span><br><span class="line">  w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 加锁前先释放锁，查看Worker中的tryRelease方法</span></span><br><span class="line">  w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">  <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 无限循环，这里的无限循环的实现方法主要在getTask()方法中，getTask()是从阻塞队列中获取等待的任务，这里我们可以看到阻塞队列中存储的是一个个Runnable实例</span></span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 线程加锁</span></span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">      <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">      <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">      <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">      <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">           (Thread.interrupted() &amp;&amp;</span><br><span class="line">            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">          !wt.isInterrupted())</span><br><span class="line">        wt.interrupt();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行前计划</span></span><br><span class="line">        beforeExecute(wt, task);</span><br><span class="line">        Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 直接调用任务的run方法，这里其实就是将队列中Runnable实例当成普通的非线程对象，我们都知道直接调用线程的run方法会以普通方法的形式去执行，这里之所以这样写，是因为我们当前已经处于一个线程中了，没必要再去启用一个线程去执行任务，否则线程池就没有存在的必要了</span></span><br><span class="line">          task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterExecute(task, thrown);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 记录线程Worker的成功任务数</span></span><br><span class="line">        w.completedTasks++;</span><br><span class="line">        w.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取队列中的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">      decrementWorkerCount();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心：判断是否允许核心线程过期 或 当前工作线程数是否超过了核心线程数，timed决定了是否回收核心线程</span></span><br><span class="line">    <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">        &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 若需要销毁工作线程，则使用poll方法使阻塞队列消失</span></span><br><span class="line">      <span class="comment">// 否则通过take方法继续阻塞，直到队列中有新数据</span></span><br><span class="line">      Runnable r = timed ?</span><br><span class="line">        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">      workQueue.take();</span><br><span class="line">      <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">      timedOut = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">      timedOut = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>从以上的内容中我们可以看出来：线程池运行的线程和队列中等待的线程不是同一个，线程池中实际运行的线程是Worker实例</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程池&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池&quot;&gt;&lt;/a&gt; 线程池&lt;/h3&gt;
&lt;p&gt;在高并发场景下，线程池是会被频繁使用到的，简单介绍下线程池：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线程池基础参数：核心线程数、最大线程数、线
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis相关东西</title>
    <link href="http://luxiaowan.github.io/2020/03/26/Redis%E7%9B%B8%E5%85%B3%E4%B8%9C%E8%A5%BF/"/>
    <id>http://luxiaowan.github.io/2020/03/26/Redis相关东西/</id>
    <published>2020-03-26T14:15:00.000Z</published>
    <updated>2020-03-28T16:03:57.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li>Redis是什么</li><li>五种数据类型</li><li>Redis为何这么快</li><li>Redis和Memcached的区别</li><li>淘汰策略</li><li>持久化</li><li>主从复制</li><li>哨兵</li></ul><hr><h4 id="redis是什么"><a class="markdownIt-Anchor" href="#redis是什么"></a> Redis是什么</h4><p>​Redis是由C语言编写的一个开源的高性能键值对的内存数据库，是一款NoSQL(not-only sql | no sql)数据库，可以用作缓存、数据库、消息中间件。</p><p>​Redis作为一款内存数据库，其优势为：</p><pre><code>1. 性能优秀，数据都存于内存中，读写速度快，理论读取速度能达到10W/秒；2. 单线程操作，线程安全，采用IO多路复用实现垃圾回收和持久化；3. 支持丰富的数据类型：字符串(string)、列表(list)、散列(hash)、集合(set)、有序集合(zset)；4. 支持数据持久化，并且提供RDB和AOF两种持久化方式；5. 可以用于分布式锁，也可以利用Redis的发布-订阅特性实现消息队列；6. 主从复制，哨兵，高可用。</code></pre><h4 id="五种数据类型"><a class="markdownIt-Anchor" href="#五种数据类型"></a> 五种数据类型</h4><ul><li>字符串(string)类型：Redis的字符串类型是最基本的类型，可以理解为一个key对应一个value，value可以是字符也可以是数字，该类型可以存储图片或者序列化后的对象等二进制数据，支持的value大小最大512M，当value小于44字节(3.2版本+是44，3.0版本-是39)时，字符串编码为embstr，大于的时候字符串编码为raw，常用的命令有set、get等。</li><li>散列(hash)类型：hash是一个键值对的集合，特别适合用于存储对象，可以直接获取到对象的某个属性的值，常用的命令有hset、hget、hgetall等。</li><li>列表(list)类型：</li><li>集合(set)类型：</li><li>有序集合(zset)类型：</li></ul><h4 id="redis为何那么快"><a class="markdownIt-Anchor" href="#redis为何那么快"></a> Redis为何那么快</h4><p>​Redis之所以是单线程的还那么快，完全是因为Redis是纯内存操作，没有CPU上下文切换带来的消耗，也没有磁盘寻址等带来的IO开销，官方理论QPS为10W+。</p><p>​既然Redis的性能瓶颈是内存和网络带宽，那么就没必要设计成多线程模式，否则会多出CPU切换，且只要涉及到多线程必然会因为资源竞争而衍生出资源锁的使用，频繁的加锁、释放锁还是非常浪费时间的，所以既然多线程会带来那么多问题，还是使用单线程得了，并且Redis本身就是K-V存储，查询时间复杂度限制在O(1)的情况，所以Redis才那么快。</p><h4 id="redis和memcached的区别"><a class="markdownIt-Anchor" href="#redis和memcached的区别"></a> Redis和Memcached的区别</h4><ul><li>存储方式：Memcache将数据存储在内存中，若服务器出现故障，则数据全部丢失，无法持久化。Redis提供了RDB和AOF两种方式进行数据持久化，就算是服务器宕机，在恢复之后依然可以保证数据的完整性；</li><li>数据类型：Memcache仅支持字符串存储，而Redis支持字符串、列表、散列、集合、有序集合等类型，使用起来更方便和多样化；</li><li>value大小：Redis的字符串类型可以存储512M的内容，而Memcache最高仅能存储1M的内容，不过虽然Redis支持很大的value，但是一般不会那么用；</li><li>底层协议不同：Redis拥有自己的VM，Memcache使用系统函数</li></ul><h4 id="淘汰策略"><a class="markdownIt-Anchor" href="#淘汰策略"></a> 淘汰策略</h4><p>Redis目前有6种淘汰策略，据说新版本中有8种</p><ul><li>volatile-lru：从设置了过期时间的所有key中将最近最少使用(least recently used)的key淘汰掉</li><li>volatile-ttl：从设置了过期时间的所有key中将剩余存活时间最少(time to live)的key淘汰掉</li><li>volatile-random：从设置了过期时间的所有key中随机淘汰掉部分key</li><li>allkeys-lru：从所有的key中将最近最少使用的key淘汰掉</li><li>allkeys-random：从所有的key中随机淘汰掉部分key</li><li>noeviction：不执行数据淘汰，当内存不足时直接拒绝新的插入请求，并返回错误信息</li><li>volatile-lfu：从设置了过期时间的所有key中将访问频率最少(least frequently used)的key淘汰掉</li><li>allkeys-lfu：从所有的key中将访问频率最少的key淘汰掉</li></ul><h4 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h4><p>Redis支持两种持久化方式，持久化的目的是将内存中的数据写入到磁盘中，防止服务出现故障后的数据丢失的情况。</p><ul><li><p>RDB方式：RDB是Redis的默认持久化方式，属于是定时保存，每隔一段时间将fork出一个子进程去将内存中的数据写入到一个临时dump.rdb(名字在配置文件中设置)文件中，待子进程执行完成之后，将这个临时的dump文件替换掉原来的dump文件，这样做的目的是可以实现copy-on-write，子进程运行过程中使用的内存资源与Redis主进程无关</p><p>*<em><font color="red"><em>通过bgsave和save命令可以手动触发执行RDB</em></font></em></p><p><img src="/images/image-20200327015702174.png" alt="image-20200327015702174"></p><p>配置信息：redis.conf文件中</p><blockquote><p>解读：</p><p>save 900 1：900秒内若至少有1个key发生变化，则触发备份</p><p>save 300 10：300秒内若至少有10个key发生变化，则触发备份</p><p>save 60 10000：60秒内若至少有1万个key发生变化，则触发备份</p></blockquote><p><img src="/images/redis-rdb-conf.png" alt="image-20200327001846508"></p><blockquote><p>劣势：</p><ol><li>RDB持久化方式适合于整库备份，dump文件用于故障恢复，但是由于RDB方式并不是实时的整库备份，所以我们拿到的dump文件总是会和内存中的数据不一致，如果你想要避免服务器发生故障的时候丢失数据，那么仅仅使用RDB是万万不行的，需要配合AOF使用。</li><li>为了使用子进程在磁盘上持久存储，RDB经常需要fork()。如果数据集很大，Fork()可能很耗时，并且可能导致Redis停止为客户端提供服务几毫秒甚至一秒钟(如果数据集很大，而且CPU性能不是很好)。AOF还需要fork()，但是您可以调整重写日志的频率，而不需要牺牲持久性。</li></ol><p>优势：</p><ol><li><p>RDB是一个非常紧凑的单文件时间点表示您的Redis数据。RDB文件非常适合备份。例如，您可能希望在最近的24小时内每小时存档一次RDB文件，并在30天内每天保存一次RDB快照。这允许您在发生灾难时轻松地恢复不同版本的数据集。</p></li><li><p>RDB对于灾难恢复非常有用，它是一个紧凑的文件，可以传输到远程数据中心上。</p></li><li><p>RDB最大限度地提高了Redis性能，因为为了保持Redis父进程所需做的惟一工作就是创建一个将完成所有其余工作的子进程。父实例永远不会执行磁盘I/O或类似的操作。</p></li><li><p>与AOF相比，RDB允许对大数据集进行更快的重启。</p></li></ol></blockquote></li><li><p>AOF方式：AOF方式在Redis中是默认未开启的，在开启AOF后，会将内容写入到appendonly.aof文件中，文件的内容是服务器接收到的所有对数据进行修改的命令集合，按照时间顺序追加到文件尾部，并且在故障恢复的时候，会优先读取appendonly.aof文件中的内容，因为aof的默认策略是每秒钟写入一次，所以当采用aof进行持久化的时候，最多也仅仅丢失一秒的数据。</p><p>配置信息：redis.conf文件中</p><p><img src="/images/redis-aof-conf.png" alt="image-20200327003834988"></p><blockquote><p>劣势：</p><p>随着服务运行时间越来越久，内存中的数据变更次数越来越多，会造成aof文件越来越大，当然我们可以在配置文件redis.conf中设置aof文件重写策略，默认当aof文件大小达到64mb且增长比例超过了之前是100%的时候进行重写，重写的规则是将内存中的数据的当前值全部以对应的set命令写入到新的aof文件中，比如当前aof文件100mb，重写之后80mb，那么只有当文件再次达到160mb(160&gt;=80*2&amp;&amp;160&gt;64)的时候才会再次进行重写，</p><p><img src="/images/redis-aof-rewrite.png" alt="image-20200327005212374"></p></blockquote></li></ul><blockquote><p>AOF文件损坏修复：</p><p>​如果在AOF文件写入的过程中突然宕机，可能会导致aof文件损坏，我们可以使用redis-check-aof --fix命令来修复</p></blockquote><p>####### 故障恢复</p><ul><li><p>若同时开启了RDB和AOF，那么在故障恢复的时候先使用AOF文件进行恢复，这样可以保证丢失最少的数据，但是如果我们想尽快的恢复Redis服务，可以允许丢失一部分数据，那么可以禁用AOF，只使用RDB，使用RDB之所以比AOF快，是因为AOF是一条条命令的去执行的，直到最终状态，RDB是一次性把所有数据的最终状态刷到内存的</p></li><li><p>AOF日志文件的命令通过可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p></li><li></li></ul><h4 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制"></a> 主从复制</h4><p>​redis单节点存在单点故障问题，为了解决单点问题，一般都需要对redis配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率。</p><p>​<strong>复制过程</strong></p><ol><li><p>从节点执行slaveof [masterIP] [masterPort]，保存主节点信息 ；</p></li><li><p>从节点中的定时任务发现主节点信息，建立和主节点的socket连接；</p></li><li><p>从节点发送Ping信号，主节点返回Pong，两边能互相通信；</p></li><li><p>连接建立后，主节点将所有数据发送给从节点（数据同步）；</p></li><li><p>主节点把当前的数据同步给从节点后，便完成了复制的建立过程；</p></li><li><p>接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</p></li></ol><h4 id="哨兵"><a class="markdownIt-Anchor" href="#哨兵"></a> 哨兵</h4><ul><li>主从复制存在的问题<ol><li>一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预；</li><li>主节点的写能力受到单机的限制；</li><li>主节点的存储能力受到单机的限制；</li><li>原生复制的弊端在早期的版本中也会比较突出，比如：redis复制中断后，从节点会发起psync。此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</li></ol></li><li>改善方式</li></ul><p>哨兵模式是一种特殊的模式，Redis提供了哨兵命令，哨兵是一个独立的进程，原理是通过哨兵发送命令，然后等待Redis服务器的响应，进而实现对Redis实例的监控。</p><ul><li><p>运行方式</p><ul><li><p>通过命令的发送，Redis实例返回监控的运行状态，所有的Redis服务器</p></li><li><p>当master机器宕机后，会随机选择一个slave节点作为master，然后通过发布订阅模式通知其他slave节点，修改配置信息，更改跟随的主机</p></li><li><p>单哨兵模式相对来说不太可靠，毕竟会出现一言堂的情况，所以我们在使用哨兵的时候一般会采用多少兵模式，每一个哨兵都监控所有的Redis服务器，哨兵之间互相监控，当一个节点宕机后，只有指定数量的哨兵全部将其标记为下线，才会将节点移除</p></li></ul></li><li><p>故障切换过程</p><ul><li>主节点服务器宕机</li><li>哨兵1检测到主节点宕机，然后将其标记为客观下线，这个时候主节点还是主节点，并未进行failover过程</li><li>其他哨兵检测到主节点宕机，全部哨兵都会将主节点标记为客观下线</li><li>标记为客观下线的哨兵数量达到指定数量(sentinel.conf中配置，尽量设置为N/2+1)的时候，由一个哨兵(Raft选举)进行投票，根据投票结果决定是否进行主节点切换(选择优先级最高的，优先级可以通过slave-priority来设置，若优先级相同，则以复制偏移量最大的为主，若偏移量也全部相同，则选择服务ID最小的那个)</li><li>主节点切换完成之后，通过<em>发布订阅模式</em>让各个哨兵和从服务器更换主服务器配置，这个过程称为主观下线</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Redis是什么&lt;/li&gt;
&lt;li&gt;五种数据类型&lt;/li&gt;
&lt;li&gt;Redis为何这么快&lt;/li&gt;
&lt;li&gt;Redis和Memcac
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
      <category term="面试" scheme="http://luxiaowan.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>服务治理思考</title>
    <link href="http://luxiaowan.github.io/2020/03/24/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E6%80%9D%E8%80%83/"/>
    <id>http://luxiaowan.github.io/2020/03/24/服务治理思考/</id>
    <published>2020-03-24T05:21:00.000Z</published>
    <updated>2020-03-24T06:29:57.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>服务治理概念当下主要针对的是分布式架构下的多服务、微服务等。分布式系统由若干个大大小小的服务组成，服务之间通过HTTP或TCP的方式进行相互通信，促使整个系统活络起来。当分布式系统中的服务随着业务的发展不断变多时，我们就需要对服务进行相关的管理，不能一味的任由其野蛮增长。</p><h3 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h3><h4 id="1-节点管理即服务提供者在注册中心及客户端创建的服务节点"><a class="markdownIt-Anchor" href="#1-节点管理即服务提供者在注册中心及客户端创建的服务节点"></a> 1. 节点管理，即服务提供者在注册中心及客户端创建的服务节点。</h4><p>节点注册于注册中心，缓存于客户端，目的为若注册中心与服务端出现网络连通故障，但客户端与服务端网络连通正常，此时注册中心已将节点移除，但客户端在下一次同步注册中心节点之前仍可通过自身缓存的服务节点发送请求。</p><ul><li><p>注册中心管理：服务提供者定时向注册中心发送心跳通知来证明其是存活状态，每次收到心跳通知均与上一次收到通知的时间进行比较，如果时差超出注册中心允许的最大值，则认为该服务提供者发生故障，将其从注册中心移除，随即通知监听客户端。</p></li><li><p>客户端管理：若注册中心与服务端网络连通出现问题，但客户端与服务端网络连接正常，直至下一次与注册中心同步之前仍可继续使用该节点。若客户端与服务端网络连通故障，但注册中心与服务端网络连通正常，则客户端会将该节点从缓存中移除直至下一次与注册中心进行同步，周而复始。</p></li></ul><h4 id="2-负载均衡顾名思义平衡所有服务端处理请求的负载防止某个服务端因接受过多请求导致服务故障"><a class="markdownIt-Anchor" href="#2-负载均衡顾名思义平衡所有服务端处理请求的负载防止某个服务端因接受过多请求导致服务故障"></a> 2. 负载均衡，顾名思义：平衡所有服务端处理请求的负载，防止某个服务端因接受过多请求导致服务故障。</h4><ul><li><p>随机算法：字面意思，简洁明了，就是采用随机数的方式选择本次请求所要转发的服务端，此法非常公平，不会因为服务端配置的优劣而对其另眼相看，绝对的公平！</p></li><li><p>加权法：又叫轮询算法。本法则事在人为，完全按照主人的喜好行事，又称拍马屁，就好比食堂打饭，所有人围绕一个圈，如果打饭阿姨看到每个人的长相都一样，那么他对所有人都没有私心，从第一个开始每人给一勺，如此循环下去，谁都不会多谁也不会少，大家都均等，这就是大家的对注册中心来说权重都一样；如果打饭阿姨喜欢帅哥，看到长得帅的（比如我）每次都会多给一勺，其他人仍是一勺，此种情况对于注册中心而言，我的权重大于其他服务提供者，所以每一批请求中都会多分发给权重大的服务端。（此例不太恰当，换为吃饭：胖子和瘦子，胖子多吃，瘦子少吃，好像更好）。</p></li><li><p>最少活跃算法：这个拿吃饭来说吧，吃得多的碗落不下了，然后就少盛点，吃的少趁机多吃点均衡一下。上面也说了，打饭阿姨因为我长得帅，每次给别人打着饭呢都会不定时的拐到我这边给我加上一碗，递过来一碗饭，我桌子上的碗的数量就+1，等我吃完一碗饭将空碗回收后，桌子上的碗的数量就-1，但是打饭阿姨给的次数太过频繁，导致我面前很多碗，其他人面前的碗则很少，有人就向领导投诉，领导痛斥一顿后，阿姨则给面前碗最少的人开始打饭，这时此人碗的数量+1，然后阿姨重新统计，下一碗给统计后面前碗最少的人，这样大家都不至于被冷落，一旦落后，立刻照顾到。</p></li><li><p>一致性Hash算法：对每次请求的参数均计算hash，hash值相同的转发到同一个节点。上体育课1234报数排队，报到相同数字的站在一队，若某一队解散，由4队变成3队，则解散的这一队的人重新123报数，归并相关各队。（为什么不用吃饭举例了？因为再吃就撑死了！）</p></li></ul><h4 id="3-服务路由"><a class="markdownIt-Anchor" href="#3-服务路由"></a> 3. 服务路由</h4><ul><li><p>灰度访问：类似于单双号限行和不限行。一条马路刚修好，实行为期一个礼拜的单双号限行，一个礼拜之内无故障，则取消限行，大家都可以走。</p></li><li><p>就近原则：每次请求到达，客户端先关门在自己的局域网内查找可用的服务提供者，若有则直接调用，若未查到则出门浪。</p></li></ul><blockquote><p>配置分为静态配置和动态配置，这里不做解释了，字面意思！</p></blockquote><h4 id="4-服务容错有容奶大要有一颗包容的心没错是不是没发现奶非乃"><a class="markdownIt-Anchor" href="#4-服务容错有容奶大要有一颗包容的心没错是不是没发现奶非乃"></a> 4. 服务容错：有容奶大！要有一颗包容的心！没错，是不是没发现奶非乃！😳</h4><ul><li><p>failover：拆开来就是fail over，也就是请求服务端a，然后a故障了，那就直接将请求转发给服务端b，结果b也故障了，那就再转发给c，直到成功！当然也可以设置最大转发次数，比如设置最大转发次数是两次，那么（划重点）在服务端2也故障时就不会转发给c了，直接返回给客户端告知失败！此方式为幂等的，也就是每一个服务提供方返回的数据均相等。</p></li><li><p>failback：遇到请求故障，那么就告知客户端请求失败，不再重试，然后根据返回的指令进行下一步操作。</p></li><li><p>failcache：遇到故障，就把请求缓存起来，间隔一段时间再发起请求，防止频繁请求影响服务端恢复。</p></li><li><p>failfast：遇到故障就返回，管他誓言有多真！绝不重试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;服务治理概念当下主要针对的是分布式架构下的多服务、微服务等。分布式系统由若干个大大小小的服务组成，服务之间通过HTTP或TCP的方式进行相互通信
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="服务治理" scheme="http://luxiaowan.github.io/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OLTP和OLAP区别</title>
    <link href="http://luxiaowan.github.io/2020/03/24/OLTP%E5%92%8COLAP%E5%8C%BA%E5%88%AB/"/>
    <id>http://luxiaowan.github.io/2020/03/24/OLTP和OLAP区别/</id>
    <published>2020-03-24T03:15:00.000Z</published>
    <updated>2020-03-24T04:44:39.771Z</updated>
    
    <content type="html"><![CDATA[<p>我们在《<a href="http://luxiaowan.github.io/2020/03/24/MongoDB%E5%92%8CElasticsearch%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/">MongoDB和Elasticsearch简单对比</a>》一文中提到了OLAP和OLTP，然后我去问了几个技术人员，基本上知道这两个名词的人少之又少，当然这也情有可原，毕竟IT行业里名词太多了，我们来说一下这两者的区别</p><h3 id="词义"><a class="markdownIt-Anchor" href="#词义"></a> 词义</h3><ol><li>OLTP：on-line Transaction Processing，联机(在线)事务处理</li><li>OLAP：on-line Analytical Processing，联机(在线)分析处理</li></ol><blockquote><p>从名词上我们就可以看出，OLTP主要是执行日常基本的事务处理，OLAP主要是执行日常的数据分析</p></blockquote><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><ol><li>OLAP<ul><li>实时性不高。比如ES中常见的使用日期检索日志</li><li>数据量大。ES利用其倒排索引的特点强化全文检索能力，即使有大量的日志打到ES中，我们仍然可以很快的查询出对应数据，效率贼高</li><li>动态检索纬度。我们在做数据分析时，数据的检索纬度是非常重要的一个条件，因为我们一般都是需要依据某一纬度做数据分析，这样才能将分析出来的数据提供给决策使用，不同的决策者需要的纬度不同，所以OLAP需要支持动态的检索纬度</li></ul></li><li>OLTP<ul><li>实时性高。既然是联机事务处理，那么对实时性要求肯定是一个高指标要求，会尽量杜绝出现数据变更不实时的情况</li><li>数据量不是很大。数据量过大会影响CRUD的性能</li><li>对确定性的数据进行操作。</li><li>高并发且满足ACID。</li></ul></li></ol><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><ol><li>OLTP一般是指我们常说的关系型数据库，或者说是支持频繁CRUD的数据存储媒介。</li><li>OLAP一般用于大数据处理和数据仓库，目前OLAP系统内的数据大多是针对OLTP内存储的数据做出进一步分析和应用，然后提供信息支持最终决策，对其大多是查多改少</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在《&lt;a href=&quot;http://luxiaowan.github.io/2020/03/24/MongoDB%E5%92%8CElasticsearch%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/&quot;&gt;MongoDB和Elasticsea
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB和Elasticsearch对比</title>
    <link href="http://luxiaowan.github.io/2020/03/24/MongoDB%E5%92%8CElasticsearch%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://luxiaowan.github.io/2020/03/24/MongoDB和Elasticsearch简单对比/</id>
    <published>2020-03-24T02:09:00.000Z</published>
    <updated>2020-03-24T03:14:25.705Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>MongoDB和Elasticsearch都属于是NoSQL类型的数据存储媒介，两者有很大的一个相似度，但使用方式和场景还是有所区别的。</p><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><ol><li>MongoDB创立的初衷是为了干掉关系型数据库，和RDBMS算是竞争关系。</li><li>Elasticsearch起初就是以检索查询为主要应用场景出道，和RDBMS有点互相协助的意思。</li></ol><h3 id="相同点"><a class="markdownIt-Anchor" href="#相同点"></a> 相同点</h3><ol><li>数据存储格式为json</li><li>聚合和全文检索</li><li>CRUD</li><li>分片和复制</li><li>简单的join操作</li><li>适用于大数据量的处理</li><li>不支持事务</li></ol><h3 id="不同点"><a class="markdownIt-Anchor" href="#不同点"></a> 不同点</h3><ol><li>开发语言不同：ES的Java语言(restful)，Mongo是C++语言(driver)，从开发角度来看，ES对Java更方便</li><li>分片方式：ES是hash，Mongo是range和hash</li><li>分布式：ES的主副分片自动组合和配置，Mongo需要手动配置集群“路由+服务配置+sharding”</li><li>索引：ES自建倒排索引，检索力度强，Mongo手动创建索引（B树），不支持倒排索引，这点和RDBMS类似</li><li>检索字段：ES全文检索，可用的检索插件较多，Mongo对索引字段个数有限制，全文检索效率低乃至不采用</li><li>时效性：ES非实时，有丢数据的风险，Mongo实时，理论上无丢数据的风险</li></ol><h3 id="终"><a class="markdownIt-Anchor" href="#终"></a> 终</h3><p>ES偏向于检索、查询和数据分析，适用于OLAP（on-line Analytical Processing）系统，Mongo偏向于大数据下的CRUD，适用于OLTP（on-line Transaction Processing）系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;MongoDB和Elasticsearch都属于是NoSQL类型的数据存储媒介，两者有很大的一个相似度，但使用方式和场景还是有所区别的。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="NoSQL" scheme="http://luxiaowan.github.io/categories/NoSQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL简单优化技巧</title>
    <link href="http://luxiaowan.github.io/2020/03/23/MySQL%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <id>http://luxiaowan.github.io/2020/03/23/MySQL简单优化技巧/</id>
    <published>2020-03-22T18:08:00.000Z</published>
    <updated>2020-03-23T14:48:44.504Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>一提到MySQL优化，大多数同学都比较依赖于DBA，但是对于程序员来说，掌握SQL的编写技巧其实很重要。</p><h3 id="技巧"><a class="markdownIt-Anchor" href="#技巧"></a> 技巧</h3><ol><li>比较运算符能用“=”就不要用“&lt;&gt;”，因为“=”能够增大列索引的使用概率</li><li>如果只查询一条数据，那么就使用“limit 1”，告知查询游标找到第一个之后就返回，以免进行全表扫描</li><li>给列选择合适的类型，比如可以使用TINYINT代替INT，节省磁盘和内存的消耗</li><li>拆解复杂SQL，减少join的出现</li><li>若查询字段全部为某联合索引字段，则避免使用“SELECT * ”，*会造成回表</li><li>WHERE、ORDER BY、JOIN的列尽量使用索引字段</li><li>使用EXPLAIN查看执行计划</li><li>可以使用ENUM的时候不要用VARCHAR</li><li>字段尽量设置为NOT NULL，尤其是索引字段</li><li>长度比较大的字段尽量拆分为副表，如果这个字段不会被经常使用</li><li>经常发生变动的数据库尽量把查询缓存关闭，否则在每次变动的时候都要删除缓存，查询的时候也要查询和更新缓存，浪费时间</li><li>索引字段的长度尽量不要太长，毕竟一个索引数据页只有16k，如果一个索引内容过长，那么可能就会造成一个数据页只能存储一个索引字段，浪费空间</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;一提到MySQL优化，大多数同学都比较依赖于DBA，但是对于程序员来说，掌握SQL的编写技巧其实很重要。&lt;/p&gt;
&lt;h3 id=&quot;技巧&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器浅谈</title>
    <link href="http://luxiaowan.github.io/2020/03/22/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B5%85%E8%B0%88/"/>
    <id>http://luxiaowan.github.io/2020/03/22/JVM垃圾收集器浅谈/</id>
    <published>2020-03-22T03:15:00.000Z</published>
    <updated>2020-03-24T06:20:21.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>JVM是做Java的同学都必须要了解的东西，为什么这么说，因为我们只有知道了Java程序运行环境的配置和工作逻辑，才能对运行环境进行相关的优化和配置修改，让JVM在不同的服务器环境使用不同的配置，从而达到JVM环境最优化。</p><p>说到JVM就不得不说一下GC（garbage collection），垃圾收集的意思是找到垃圾并清理掉，但是常规的垃圾收集器却是找到正在被使用的对象，然后把其他的对象全部当作是垃圾对象清理掉。</p><p>写过C语言的同学都知道，在C语言中，我们需要手动的去管理内存，在使用内存之前我们需要先申请（malloc）一定大小的内存，使用完成之后需要手动的把使用的内存释放掉（free），如果忘记释放内存则很快会导致内存溢出，</p><h2 id="gc算法"><a class="markdownIt-Anchor" href="#gc算法"></a> GC算法</h2><ol><li><p>引用计数法</p><p>为每个对象添加一个引用计数器，在对象被引用时，计数器+1，引用结束后，计数器-1，最终清除掉引用计数器为0的对象，并级联删除该对象引用的所有的对象，只保留引用计数不为0的对象。</p><p>这种算法看起来是不是很屌，是的，非常简单，只需要在对象被引用的时候串行修改引用计数器的值即可，但也容易出现一种问题：循环引用！循环引用就是几个废对象之间循环引用，尽管他们的引用计数器都不为0，但是在整个程序中却没有被使用，但是他们永远不会被回收，这样的对象多了之后很容易造成内存泄漏。</p></li><li><p>标记-清除</p></li><li><p>标记-清理-整理</p></li><li><p>可达性分析法</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;JVM是做Java的同学都必须要了解的东西，为什么这么说，因为我们只有知道了Java程序运行环境的配置和工作逻辑，才能对运行环境进行相关的优化和
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="GC" scheme="http://luxiaowan.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>RMI远程服务调用简述</title>
    <link href="http://luxiaowan.github.io/2020/03/20/RMI%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%AE%80%E8%BF%B0/"/>
    <id>http://luxiaowan.github.io/2020/03/20/RMI远程服务调用简述/</id>
    <published>2020-03-19T16:15:00.000Z</published>
    <updated>2020-03-19T17:50:31.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rmi是什么"><a class="markdownIt-Anchor" href="#rmi是什么"></a> RMI是什么</h2><p>RMI(Remote Method Invocation)意为远程方式调用，顾名思义，是Java版的RPC实现技术，是建立分布式Java应用程序的方便途径。RMI是基于接口的，一般是接口定义和实现分开在不同的工程中。</p><p>相似：Hessian，Burlap，Httpinvoker，webservice</p><h2 id="为什么使用rmi"><a class="markdownIt-Anchor" href="#为什么使用rmi"></a> 为什么使用RMI</h2><p>它允许运行在一台虚拟机上的方法调用运行在另一台虚拟机上的对象方法，这样可以让每个任务运行在更适合的虚拟机上。</p><h2 id="rmi怎么用"><a class="markdownIt-Anchor" href="#rmi怎么用"></a> RMI怎么用</h2><ul><li>定义一个java.rmi.Remote的子接口，也就是定义一个接口AnimalService，继承自Remote，接口中的所有方法必须显式的抛出java.rmi.RemoteException异常，否则服务会注册失败，谨记!</li><li>创建AnimalService的实现类DogServiceImpl，这个类需要继承java.rmi.server.UnicastRemoteObject</li><li>将服务AnimalService注册到rmi中心</li><li>客户端引用接口定义jar包</li><li>客户端获取AnimalService的远程服务</li><li>进行相关方法调用</li></ul><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><p>因为RMI是Java版的RPC通讯技术，所以他只适用于Java程序上，如果想跨语言通讯，那就只能另谋它法了</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><ul><li>接口（工程：rmi-api）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中所有的方法必须声明throws RemoteException</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">laugh</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现（工程：rmi-service）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cc.kevinlu.spidemo.spi.AnimalService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">AnimalService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DogServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">laugh</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Server</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cc.kevinlu.spidemo.spi.AnimalService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AnimalService dogService = <span class="keyword">new</span> DogServiceImpl();</span><br><span class="line">        AnimalService lionService = <span class="keyword">new</span> LionServiceImpl();</span><br><span class="line">      <span class="comment">// 设置服务提供的端口</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">8891</span>);</span><br><span class="line">      <span class="comment">// 设置rmi的host为127.0.0.1，否则可能会出现connect refused错误</span></span><br><span class="line">        System.setProperty(<span class="string">"java.rmi.server.host"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">      <span class="comment">// 发布服务</span></span><br><span class="line">        Naming.bind(<span class="string">"rmi://127.0.0.1:8891/dogs"</span>, dogService);</span><br><span class="line">        System.out.println(<span class="string">"dog service publish success!"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端（rmi-client：引用rmi-api）</li></ul><ol><li><p>正常情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnimalService dogService = (AnimalService) Naming.lookup(<span class="string">"rmi://127.0.0.1:8891/dogs"</span>);</span><br><span class="line">dogService.laugh();</span><br></pre></td></tr></table></figure></li><li><p>反射的方式去回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = Naming.lookup(<span class="string">"rmi://127.0.0.1:8891/dogs"</span>);</span><br><span class="line">Method method = obj.getClass().getMethod(<span class="string">"laugh"</span>);</span><br><span class="line">method.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;rmi是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rmi是什么&quot;&gt;&lt;/a&gt; RMI是什么&lt;/h2&gt;
&lt;p&gt;RMI(Remote Method Invocation)意为远程方式调用，顾名思义，是Java版的RPC实现技术，是建
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>设置生成CGLib和JDK代理生成的class文件</title>
    <link href="http://luxiaowan.github.io/2020/03/17/%E8%AE%BE%E7%BD%AE%E7%94%9F%E6%88%90CGLib%E5%92%8CJDK%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6/"/>
    <id>http://luxiaowan.github.io/2020/03/17/设置生成CGLib和JDK代理生成的class文件/</id>
    <published>2020-03-17T13:20:00.000Z</published>
    <updated>2020-03-17T13:54:16.360Z</updated>
    
    <content type="html"><![CDATA[<p>jdk和cglib代理方式属于是老生常谈了，这里就不说了，我们说一下特别的。</p><p>我们都知道cglib是针对于类，jdk是针对于接口，</p><p>cglib在目标类被代理后会自动生成目标类的子类，也就是<code>xxxclass$$EnhancerByCGLIB$$c03f68c4.class</code></p><p>jdk代理后会自动生成目标接口的实现，也就是<code>$Proxy0.class</code></p><p>我们平时代码在编译过程中是不会生成代理类的class文件，只有在运行中才会生成</p><p>我们可以通过在启动类中设置代理类生成路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置CGLib代理类的生成位置</span></span><br><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"./cg"</span>);</span><br><span class="line"><span class="comment">// 设置JDK代理类的输出</span></span><br><span class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jdk和cglib代理方式属于是老生常谈了，这里就不说了，我们说一下特别的。&lt;/p&gt;
&lt;p&gt;我们都知道cglib是针对于类，jdk是针对于接口，&lt;/p&gt;
&lt;p&gt;cglib在目标类被代理后会自动生成目标类的子类，也就是&lt;code&gt;xxxclass$$EnhancerByCGL
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux更换yum源</title>
    <link href="http://luxiaowan.github.io/2020/03/12/Centos%E6%9B%B4%E6%8D%A2yum%E6%BA%90/"/>
    <id>http://luxiaowan.github.io/2020/03/12/Centos更换yum源/</id>
    <published>2020-03-12T05:05:00.000Z</published>
    <updated>2020-03-12T13:35:37.430Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们安装的Linux虚拟机或购买的云服务器上默认使用的yum源在国内有时候会传输很慢，现在大多我们在使用Linux之前都会修改一下yum源，以下以centos为例，将yum源修改为阿里云的。可以到https://developer.aliyun.com/mirror/中查看帮助</p></blockquote><h4 id="备份机器中的源文件"><a class="markdownIt-Anchor" href="#备份机器中的源文件"></a> 备份机器中的源文件</h4><p>备份的目的是为了操作失败后可以随时回滚</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure><h4 id="下载新的-centos-baserepo-到-etcyumreposd"><a class="markdownIt-Anchor" href="#下载新的-centos-baserepo-到-etcyumreposd"></a> 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</h4><p>我们的yum源配置文件在/etc/yum.repos.d/目录中，所以我们将阿里云的repo文件下载到该目录下（可以根据系统版本到http://mirrors.aliyun.com/repo/查看对应的文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要下载与系统版本一致的repo文件</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><h4 id="运行yum-makecache生成缓存"><a class="markdownIt-Anchor" href="#运行yum-makecache生成缓存"></a> 运行yum makecache生成缓存</h4><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>若出现Couldn’t resolve host '<a href="http://mirrors.cloud.aliyuncs.com" target="_blank" rel="noopener">mirrors.cloud.aliyuncs.com</a>’的信息，则表示网络不通，可以使用下面命令修改repo文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们安装的Linux虚拟机或购买的云服务器上默认使用的yum源在国内有时候会传输很慢，现在大多我们在使用Linux之前都会修改一下yum源，以下以centos为例，将yum源修改为阿里云的。可以到https://developer.aliyun.c
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://luxiaowan.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>kubernates调整nodePort端口范围</title>
    <link href="http://luxiaowan.github.io/2020/03/11/kubernates%E8%B0%83%E6%95%B4nodePort%E7%AB%AF%E5%8F%A3%E8%8C%83%E5%9B%B4/"/>
    <id>http://luxiaowan.github.io/2020/03/11/kubernates调整nodePort端口范围/</id>
    <published>2020-03-11T08:02:00.000Z</published>
    <updated>2020-03-11T08:12:05.657Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，k8s 集群 nodePort 分配的端口范围为：30000-32767，如果我们指定的端口不在这个范围就会报错：</p><blockquote><p>Error: release kong failed: Service “xxx” is invalid: spec.ports[0].nodePort: Invalid value: 12306: provided port is not in the valid range. The range of valid ports is 30000-32767</p></blockquote><p>所以我们修改 /etc/kubernetes/manifests/kube-apiserver.yaml 文件，在 command 下添加 <code>--service-node-port-range=1-65535</code> 参数，添加 nodePort 范围参数后会自动生效，无需进行其他操作：<br><code>vim /etc/kubernetes/manifests/kube-apiserver.yaml</code></p><p><img src="/images/image-20200311160941739.png" alt="image-20200311160941739"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默认情况下，k8s 集群 nodePort 分配的端口范围为：30000-32767，如果我们指定的端口不在这个范围就会报错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Error: release kong failed: Service “xxx” is invalid:
      
    
    </summary>
    
    
      <category term="kubernates" scheme="http://luxiaowan.github.io/categories/kubernates/"/>
    
    
  </entry>
  
</feed>
