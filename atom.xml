<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2019-11-25T17:05:09.009Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadLocal是怎么实现线程隔离的</title>
    <link href="http://luxiaowan.github.io/2019/11/20/ThreadLocal%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E7%9A%84/"/>
    <id>http://luxiaowan.github.io/2019/11/20/ThreadLocal是怎么实现线程隔离的/</id>
    <published>2019-11-20T15:21:56.000Z</published>
    <updated>2019-11-25T17:05:09.009Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal大家应该都不陌生，见过最多的使用场景应该是和SimpleDateFormat一起使用吧，因为这个SDF非线程安全的，所以需要使用ThreadLocal将它在线程之间隔离开，避免造成脏数据的🐞。那么ThreadLocal是怎么保证线程安全，又是如何操作的呢？</p><blockquote><p>案例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      threadLocal.set(<span class="number">1</span>);</span><br><span class="line">      threadLocal.set(<span class="number">2</span>);</span><br><span class="line">      System.out.println(<span class="string">"cc1: "</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"cc1"</span>).start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cc2: "</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"cc2"</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc1: <span class="number">2</span></span><br><span class="line">cc2: <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>哦哟~cc2打印出来null，也就是在cc1线程中设置的值在线程cc2中获取不到，这也就是所谓的线程隔离，我们来看下ThreadLocal具体的代码实现吧：</p><blockquote><p>ThreadLocal的set(T t)方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前线程</span></span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 获取当前线程的threadLocals属性，这个属性在Thread类中定义的，为Thread的实例变量</span></span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="comment">// 若线程的ThreadLocalMap已经存在，则调用ThreadLocalMap的set(ThreadLocal&lt;T&gt; key, Object value)方法</span></span><br><span class="line">  <span class="comment">// 否则创建新的ThreadLocalMap实例，并set对应的value</span></span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ThreadLocalMap的set(ThreadLocal<t> key, Object value)方法源码</t></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="keyword">int</span> len = tab.length;</span><br><span class="line">  <span class="comment">// 简单计算key所在的位置</span></span><br><span class="line">  <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 从key所在位置开始遍历table数组，找到具体key所在的位置</span></span><br><span class="line">  <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">    <span class="comment">// 获取Entry实例的key值，这里调用的是超类java.lang.ref.Reference中的get(T t)方法</span></span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">// 若k与传入的参数key是同一个，则用参数value替换Entry实例的value，然后结束方法</span></span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">      e.value = value;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 若获取的k为null，则表示这个变量已经被删除了，则去清理一下table数组，并对数组中元素进行清理并设置新的Entry实例</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">      replaceStaleEntry(key, value, i);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 代码走到这一步，说明该线程第一次设置数据，创建新的Entry实例放在table的第i个位置上</span></span><br><span class="line">  tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">  <span class="keyword">int</span> sz = ++size;</span><br><span class="line">  <span class="comment">// 清理table中的元素，若长度达到了扩容阈值，则对table进行扩容，扩容为原数组长度的2倍</span></span><br><span class="line">  <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ThreadLocal的createMap(Thread t, T firstValue)方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个ThreadLocalMap实例，并赋值给当前线程的实例变量threadLocals</span></span><br><span class="line">  <span class="comment">// 这里就是线程隔离的关键所在，每一个线程中的数据都是由线程独有的threadLocals变量存储的</span></span><br><span class="line">  t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ThreadLocalMap的构造器源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">  <span class="comment">// 实例化Entry数组，长度为初始长度16</span></span><br><span class="line">  table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">  <span class="comment">// 计算key在数组中的位置</span></span><br><span class="line">  <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 创建Entry实例，并放在table的i下标位置</span></span><br><span class="line">  table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">  <span class="comment">// 实际长度设置为1</span></span><br><span class="line">  size = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 设置数组扩容阈值（len * 2 / 3）</span></span><br><span class="line">  setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是ThreadLocal达到线程隔离的基本解析，讲解的比较基础，其实就是JDK源码鉴赏，还有什么不懂的地方就自己去看源码吧。</p><h4 id="延伸下"><a class="markdownIt-Anchor" href="#延伸下"></a> 延伸下</h4><blockquote><p>ThreadLocal的get()方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      T result = (T)e.value;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码比较简单，这里就不在进行解释了，我们着重看一下最后一句<code>setInitialValue()</code>这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T value = initialValue();</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现和set方法类似，只不过是将一个<code>null</code>当做value而已，所以我们在没给ThreadLocal设置值的情况下调用get方法，则会为其创建一个默认的null值并返回null。</p><h4 id="留一个思考题"><a class="markdownIt-Anchor" href="#留一个思考题"></a> 留一个思考题</h4><p>因为我们每个线程的ThreadLocal的key的hash值都是固定的，那么Thread的threadLocals变量的table中会有多少个非null元素呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ThreadLocal大家应该都不陌生，见过最多的使用场景应该是和SimpleDateFormat一起使用吧，因为这个SDF非线程安全的，所以需要使用ThreadLocal将它在线程之间隔离开，避免造成脏数据的🐞。那么ThreadLocal是怎么保证线程安全，又是如何操作
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>慎用ArrayList中的SubList</title>
    <link href="http://luxiaowan.github.io/2019/11/11/%E6%85%8E%E7%94%A8ArrayList%E4%B8%AD%E7%9A%84SubList/"/>
    <id>http://luxiaowan.github.io/2019/11/11/慎用ArrayList中的SubList/</id>
    <published>2019-11-10T17:11:00.000Z</published>
    <updated>2019-11-24T16:18:53.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>双十一了，大家都省了多少钱啊？</p><p>题外话：此处交给大家一个查看商品历史价格的小方法：</p><ul><li><p>在商品链接的域名后加上三个v就能查看到该商品的历史价格啦</p></li><li><p>🌰</p><blockquote><p><a href="http://shop.taobao.com/xxxx" target="_blank" rel="noopener">http://shop.taobao.com/xxxx</a></p><p>↓</p><p><a href="http://shop.taobaovvv.com/xxx" target="_blank" rel="noopener">http://shop.taobaovvv.com/xxx</a></p></blockquote></li></ul></blockquote><p>步入正题，为什么说我们在实际开发过程中要慎用ArrayList的subList呢？其实这也是阿里军规中的一条，原因其实很简单：不稳定！也许看到这里会觉得&quot;就是创建一个独立的新的SubList的实例，怎么会不稳定！&quot;，如果你是这么想的，那么恭喜你，这篇文章真的能够帮助到你，且往下看：</p><hr><h3 id="1-客观您上上眼看看sublist的set方法"><a class="markdownIt-Anchor" href="#1-客观您上上眼看看sublist的set方法"></a> 1. 客观您上上眼，看看SubList的set方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; sourceList = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                add(<span class="string">"H"</span>); add(<span class="string">"E"</span>); add(<span class="string">"L"</span>); add(<span class="string">"L"</span>); add(<span class="string">"O"</span>);</span><br><span class="line">                add(<span class="string">"W"</span>); add(<span class="string">"O"</span>); add(<span class="string">"R"</span>); add(<span class="string">"L"</span>); add(<span class="string">"D"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;String&gt; subList = sourceList.subList(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"sourceList: "</span> + sourceList);</span><br><span class="line">        System.out.println(<span class="string">"sourceList.subList(2, 5)得到: "</span> + subList);</span><br><span class="line"></span><br><span class="line">        subList.set(<span class="number">1</span>, <span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"sourceList: "</span> + sourceList);</span><br><span class="line">        System.out.println(<span class="string">"subList: "</span> + subList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的执行结果是什么？先不要看下面的答案，自己想一想。</p><blockquote><p>答案</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sourceList: [H, E, L, L, O, W, O, R, L, D]</span><br><span class="line">subList: [L, L, O]</span><br><span class="line">sourceList: [H, E, L, cc, O, W, O, R, L, D]</span><br><span class="line">subList: [L, cc, O]</span><br></pre></td></tr></table></figure><p>哦吼~！答案和你自己想的有没有出入？奇妙吧，为什么修改了subList中的元素，会影响到sourceList？我们来看下ArrayList的subList方法都做了些什么：</p><blockquote><p>JDK源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a view of the portion of this list between the specified</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> fromIndex&#125;, inclusive, and &#123;<span class="doctag">@code</span> toIndex&#125;, exclusive. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是检查我们的fromIndex和toIndex是否合法，然后调用ArrayList的内部类SubList创建一个SubList的实例。好像还真如我们之前想的一样，创建了一个独立的SubList的对象，没什么不对的，那我们来看一下SubList的构造器中都做了些什么吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubList(AbstractList&lt;E&gt; parent, <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">  <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">  <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">  <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个什么鬼？ArrayList的实例对象(也就是parent)竟然作为参数传到了SubList中，SubList的偏移量为0+fromIndex，大小size为toIndex - fromIndex（也就是和String的substring方法一样，fromIndex到(toIndex -1)的数据集），修改次数modCount和ArrayList的modCount相等，那么我们猜测一下：SubList实例的变动，是否和ArrayList有关呢？</p><p>我们看到subList方法的注释中有这么一句话：<font color="red">Returns a view of the portion of this list</font>。难道SubList仅仅是ArrayList的一个被fromIndex和toIndex的区间视图？</p><p>上面的例子中，subList调用了它的set方法，我们来看一下这个set方法内部逻辑是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);<span class="comment">// 下标校验</span></span><br><span class="line">  checkForComodification();<span class="comment">// 校验合法性</span></span><br><span class="line">  <span class="comment">// ***重点</span></span><br><span class="line">  <span class="comment">// 根据偏移量和下标，获取ArrayList对象的elementData数组中下标为(offset + index)的元素</span></span><br><span class="line">  <span class="comment">// offset是什么？从构造器中我们可以看到offset就是0 + fromIndex，也就是我们截取的起始下标，也就是SubList的set方法是直接在原ArrayList实例的内部数组上进行的操作</span></span><br><span class="line">  E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">  ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里就一目了然了，怪不得我们修改了SubList的元素会影响到创建它的对象的值。所以在使用SubList的时候，如果需要修改SubList里面的值，一定要注意一下是否会影响到原List中的数据所涉及的业务，否则这个坑一旦踩上了，不太容易排查啊。</p><h3 id="2-客观再上眼看看sublist的add方法"><a class="markdownIt-Anchor" href="#2-客观再上眼看看sublist的add方法"></a> 2. 客观再上眼，看看SubList的add方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; sourceList = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                add(<span class="string">"H"</span>); add(<span class="string">"E"</span>); add(<span class="string">"L"</span>); add(<span class="string">"L"</span>); add(<span class="string">"O"</span>);</span><br><span class="line">                add(<span class="string">"W"</span>); add(<span class="string">"O"</span>); add(<span class="string">"R"</span>); add(<span class="string">"L"</span>); add(<span class="string">"D"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;String&gt; subList = sourceList.subList(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"sourceList: "</span> + sourceList);</span><br><span class="line">        System.out.println(<span class="string">"sourceList.subList(2, 5)得到: "</span> + subList);</span><br><span class="line"></span><br><span class="line">        subList.add(<span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"sourceList: "</span> + sourceList);</span><br><span class="line">        System.out.println(<span class="string">"subList: "</span> + subList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的执行结果又是什么呢？如果我们稍微思考一下，大致能正确的分析出结果：</p><blockquote><p>答案</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sourceList: [H, E, L, L, O, W, O, R, L, D]</span><br><span class="line">subList: [L, L, O]</span><br><span class="line">sourceList: [H, E, L, L, O, cc, W, O, R, L, D]</span><br><span class="line">subList: [L, L, O, cc]</span><br></pre></td></tr></table></figure><p>我们向subList中添加一个元素，原列表sourceList在toIndex的位置插入了subList中add的元素，也就是我们在SubList中新增一个元素，同时会将这个元素添加到原List中。</p><blockquote><p>JDK源码</p></blockquote><p>我们查看SubList的源码，发现并没有add(E e)方法，那我们调用的add(“cc”)是调用到哪里去了呢？我们查看SubList类的声明，可以看到它是继承了<code>AbstractList</code>抽象类，所以这里应该是调用了超类里的add(E e)方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** AbstractList.java */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  add(size(), e);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到是调用了add(int index, E element)方法进行数据新增的，然而SubList里面实现了这个方法，那么我们来看下SubList中的这个方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验下标是否越界</span></span><br><span class="line">  rangeCheckForAdd(index);</span><br><span class="line">  <span class="comment">// 校验原List是否有过修改</span></span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="comment">// parent即是在构造器中注入的原List</span></span><br><span class="line">  parent.add(parentOffset + index, e);</span><br><span class="line">  <span class="comment">// 同步列表修改次数</span></span><br><span class="line">  <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">  <span class="comment">// 本列表的长度+1</span></span><br><span class="line">  <span class="keyword">this</span>.size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由SubList的源码可以看出，SubList实例的add方法实际上就是在修改原List，包括SubList中所有的方法均是在parent列表上进行操作。</p><h3 id="3-奇葩操作最坑的坑"><a class="markdownIt-Anchor" href="#3-奇葩操作最坑的坑"></a> 3. 奇葩操作，最坑的坑</h3><p>仔细分析如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; sourceList = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      add(<span class="string">"H"</span>); add(<span class="string">"E"</span>); add(<span class="string">"L"</span>); add(<span class="string">"L"</span>); add(<span class="string">"O"</span>);</span><br><span class="line">      add(<span class="string">"W"</span>); add(<span class="string">"O"</span>); add(<span class="string">"R"</span>); add(<span class="string">"L"</span>); add(<span class="string">"D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  List&lt;String&gt; subList = sourceList.subList(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">  System.out.println(<span class="string">"sourceList: "</span> + sourceList);</span><br><span class="line">  System.out.println(<span class="string">"subList: "</span> + subList);</span><br><span class="line"></span><br><span class="line">  sourceList.add(<span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"sourceList: "</span> + sourceList);</span><br><span class="line">  System.out.println(<span class="string">"subList: "</span> + subList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的执行结果是什么？在不执行这段代码的情况下，是不是以为是下面的结果？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sourceList: [H, E, L, L, O, W, O, R, L, D]</span><br><span class="line">subList: [L, L, O]</span><br><span class="line">sourceList: [H, E, L, L, O, W, O, R, L, D, cc]</span><br><span class="line">subList: [L, L, O]</span><br></pre></td></tr></table></figure><p>如果你说对，就是这个，那你可就说错咯，实际上在执行到<code>System.out.println(&quot;sourceList: &quot; + sourceList);</code>这一句代码的时候整个程序的输出都是正常的，但在执行最后一句代码的时候，就会报错了，错误信息是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$SubList.checkForComodification(ArrayList.java:<span class="number">1239</span>)</span><br><span class="line">at java.util.ArrayList$SubList.listIterator(ArrayList.java:<span class="number">1099</span>)</span><br><span class="line">at java.util.AbstractList.listIterator(AbstractList.java:<span class="number">299</span>)</span><br><span class="line">at java.util.ArrayList$SubList.iterator(ArrayList.java:<span class="number">1095</span>)</span><br><span class="line">at java.util.AbstractCollection.toString(AbstractCollection.java:<span class="number">454</span>)</span><br><span class="line">at java.lang.String.valueOf(String.java:<span class="number">2994</span>)</span><br><span class="line">at java.lang.StringBuilder.append(StringBuilder.java:<span class="number">131</span>)</span><br><span class="line">at cc.kevinlu.sublist.SubListTest.main(SubListTest.java:<span class="number">31</span>)</span><br></pre></td></tr></table></figure><p>哦吼~！竟然报错了，我们可以看到是在<code>ArrayList$SubList.checkForComodificatio</code>方法中报的错，我们来看一下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 比较原列表修改次数和SubList的修改次数是否相等</span></span><br><span class="line">  <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里抛出异常，说明这两个数是不相等的，那为什么会不相等呢？我们看SubList的add方法中有同步主、'子’列表的语句<code>this.modCount = parent.modCount;</code>，也就是说我们在修改subList的时候，会同步更新主列表的modCount，以保证主、'子’列表始终是一致的。</p><p>但是我们在修改主List的时候是不会去同步SubList的modCount的，我们输出SubList的实例实际上就是调用<code>iterator</code>方法，最终是调用了SubList的<code>public ListIterator&lt;E&gt; listIterator(final int index)</code>方法，该方法第一句就是调用<code>checkForComodification</code>方法检查modCount，这里自然就会报错咯！</p><h3 id="4-填坑"><a class="markdownIt-Anchor" href="#4-填坑"></a> 4. 填坑</h3><p>既然有坑，就有填坑的办法，不可能一直把坑放在那，是吧。</p><p>如果既想修改subList，又不想影响到原list。那么可以创建一个机遇subList的拷贝:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.创建新的List：</span><br><span class="line">  subList = Lists.newArrayList(subList);</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.lambda表达式：</span><br><span class="line">sourceList.stream().skip(fromIndex).limit(size).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h3 id="5-总结"><a class="markdownIt-Anchor" href="#5-总结"></a> 5. 总结</h3><p>并不是说使用SubList一定不妥，文章开头我们也说的是慎用，所以，根据具体业务进行选择吧。</p><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;双十一了，大家都省了多少钱啊？&lt;/p&gt;
&lt;p&gt;题外话：此处交给大家一个查看商品历史价格的小方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在商品链接的域名后加上三个v就能查看到该商品的历史价格啦&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🌰&lt;/p&gt;
&lt;blo
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis基本命令使用::zset篇</title>
    <link href="http://luxiaowan.github.io/2019/11/08/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E2%80%94zset%E7%AF%87/"/>
    <id>http://luxiaowan.github.io/2019/11/08/Redis基本命令使用—zset篇/</id>
    <published>2019-11-08T04:55:00.000Z</published>
    <updated>2019-11-21T16:05:02.245Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)</p></blockquote><p><strong>redis在线体验地址：<a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></strong></p><h2 id="有序集合zset"><a class="markdownIt-Anchor" href="#有序集合zset"></a> 有序集合(ZSet)</h2><blockquote><p>介绍:</p></blockquote><p>Redis的有序集合和集合一样是一个简单的字符串集合，但该集合是有序的，且集合内的元素都是唯一的，也就是集合内不会出现重复元素，与集合唯一不同的是，有序集合中每一个元素都有一个double类型的score属性，Redis通过score的大小对元素进行排序的。有序集合中元素不能重复，但是元素的score值可以重复。</p><p>常用于做排行榜功能。</p><p>Redis中的集合是通过哈希表来实现的，所以获取集合中元素的时间复杂度为O(1)。</p><blockquote><p>创建缓存</p></blockquote><ol><li><p>创建一个集合缓存，为集合新增元素</p><ul><li><p>命令格式：<code>zadd key score member [score member ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zadd zk1 1 c 1 cc 1 ccc 2 cccc</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">创建有序集合zk1，元素为：</span><br><span class="line">key: c, score: 1</span><br><span class="line">key: cc, score: 1</span><br><span class="line">key: ccc, score: 1</span><br><span class="line">key: cccc, score: 2</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建一个元素或修改元素的score值（一次只能修改一个元素）</p><ul><li><p>命令格式：<code>zincrby key increment member</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zincrby zk1 1 cc</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">1. 为集合zk1的元素cc的score进行+1操作</span><br><span class="line">2. 若集合zk1不存在，则创建</span><br><span class="line">3. 若元素cc不存在，则创建，且cc的score为1</span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>查询缓存</p></blockquote><ol><li><p>查询缓存中元素个数</p><ul><li><p>命令格式：<code>zcard key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zcard zk1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">查询集合zk1内的元素总个数</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查询集合指定范围的元素</p><ul><li><p>命令格式：<code>zrange key start stop [withscores]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 返回元素名称</span><br><span class="line">zrange zk1 0 1</span><br><span class="line">---</span><br><span class="line">返回集合zk1中从下标0到下标1的元素名称，start和stop都是从0开始</span><br><span class="line"></span><br><span class="line">2. 返回元素和元素score</span><br><span class="line">zrange zk1 0 -1 withscores</span><br><span class="line">---</span><br><span class="line">返回集合zk1中全部元素的名称和分数</span><br><span class="line">member1</span><br><span class="line">score1</span><br><span class="line">member2</span><br><span class="line">score2</span><br><span class="line">★常用于查询排行榜及分数</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查询集合中某元素的下标（下标从0开始）</p><ul><li><p>命令格式：<code>zrank key member</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zrank zk1 c</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">返回元素c在集合zk1中的下标</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查询集合中某元素的分数</p><ul><li><p>命令格式：<code>zscore key member</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zscore zk1 c</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">查询集合zk1中元素c的分数</span><br><span class="line">★常用于点赞数类别查询等</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查询集合中指定范围的元素，按照score从大到小排序</p><ul><li><p>命令格式：<code>zrevrange key start stop [withscores]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zrevrange zk1 0 3 withscore</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">返回集合zk1中从1~4位元素，按照score从大到小</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查询集合中某元素的排名</p><ul><li><p>命令格式：<code>zrevrank key member</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zrevrank zk1 c</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">返回元素c在集合zk1中的排名</span><br><span class="line">★常用于名次查询</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查询指定分数范围内的元素，可分页</p><ul><li><p>命令格式：<code>zrevrangebyscore key maxScore minScore [withscores] [limit offset count]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zrevrangebyscore zk1 3 2 withscores limit 0 1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">分页返回集合zk1中分数从2~3的元素</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查询指定成员区间内的成员</p><ul><li><p>命令格式：<code>zrangebylex key minChar maxChar [limit offset count]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zrangebylex zk1 - (c1 limit 0 12</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">返回从第一个元素到元素c1之间的位置</span><br></pre></td></tr></table></figure><table><thead><tr><th>指令</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>ZRANGEBYLEX</td><td>是</td><td>指令</td></tr><tr><td>key</td><td>是</td><td>有序集合键名称</td></tr><tr><td>minChar</td><td>是</td><td>字典中排序位置较小的成员,必须以”[“(包含)开头,或者以”(“(不包含)开头,可使用”-“代替，&quot;-&quot;表示取最小值</td></tr><tr><td>maxChar</td><td>是</td><td>字典中排序位置较大的成员,必须以”[“(包含)开头,或者以”(“(不包含)开头,可使用”+”代替，&quot;+&quot;表示取最大值</td></tr><tr><td>limit</td><td>否</td><td>返回结果是否分页,指令中包含LIMIT后offset、count必须输入</td></tr><tr><td>offset</td><td>否</td><td>返回结果起始位置</td></tr><tr><td>count</td><td>否</td><td>返回结果数量</td></tr></tbody></table></li></ul></li><li><p>查询指定分数区间内的元素数</p><ul><li><p>命令格式：<code>zcount key min max</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zcount zk1 1 2</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">返回score值为1~2的所有元素总数</span><br><span class="line">★计算排行榜中某一分数区间的数量</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查询指定元素区间内的元素总数</p><ul><li><p>命令格式：<code>zlexcount key min max</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zlexcount zk1 (c [cccc</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">查询c~cccc之间的元素总数，不包括c，但包括cccc</span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>移除缓存元素</p></blockquote><ol><li><p>移除集合中指定的元素</p><ul><li><p>命令格式：<code>zrem key member [member ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zrem zk1 cc c1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">移除集合zk1中的元素cc、c1</span><br></pre></td></tr></table></figure></li></ul></li><li><p>移除指定元素区间的所有成员</p><ul><li><p>命令格式：<code>zremrangebylex key min max</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zremrangebylex zk1 [c (ccc</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">移除集合zk1中元素c到元素ccc之间的所有成员，包括c，但不包括ccc</span><br></pre></td></tr></table></figure></li></ul></li><li><p>移除指定排名区间所有成员</p><ul><li><p>命令格式：<code>zremrangebyrank key start stop</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank zk1 0 1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">移除集合zk1中0~1下标的所有元素</span><br></pre></td></tr></table></figure></li></ul></li><li><p>移除指定分数区间所有成员</p><ul><li><p>命令格式：<code>zremrangebyscore key min max</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyscore zk1 0 1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">移除集合zk1中score值为0~1的所有元素</span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>特殊操作</p></blockquote><ol><li><p>计算多个集合的并集，并存入新的集合</p><ul><li><p>命令格式：<code>zunionstore destinationKey numkeys key[key ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zunionstore zku 2 zk1 zk2</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">合并集合zk1和zk2，将并集存入zku，集合zku中元素的score为所有参与计算的集合中相同的元素的score之和</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis在线体验地址：
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Java命令::jstat</title>
    <link href="http://luxiaowan.github.io/2019/11/08/Java%E5%91%BD%E4%BB%A4%E2%80%94jstat/"/>
    <id>http://luxiaowan.github.io/2019/11/08/Java命令—jstat/</id>
    <published>2019-11-08T04:00:00.000Z</published>
    <updated>2019-11-10T15:57:22.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jstat是用于监控虚拟机运行状态信息的命令，可以显示虚拟机进程中的类装载、内存使用、GC情况、JIT编译等运行状态数据，能够在Linux上快速定位虚拟机性能问题。</p><p>jstat命令在jdk的bin目录下，目录中还有很多实用的命令</p></blockquote><p><em><strong><font color="red">*以下分析是基于jdk1.8+</font></strong></em></p><p>jstat命令格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; &lt;pid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  option: 需要查看的虚拟机信息</span><br><span class="line">  pid: Java程序进程号</span><br><span class="line">    本地虚拟机: pid</span><br><span class="line">    远程虚拟机: [protocol:][<span class="comment">//] lvmid [@hostname[:port]/servername]</span></span><br><span class="line">  interval: 监控间隔时间，可选，默认立刻执行一次</span><br><span class="line">  count: 监控次数，可选，默认无限次</span><br></pre></td></tr></table></figure><table><thead><tr><th>option</th><th>说明</th></tr></thead><tbody><tr><td>class</td><td>查看类装载、卸载数量、总空间及类装载所耗时间</td></tr><tr><td>gc</td><td>查看Java堆状况，包括Eden、survivor、老年代、永久代的容量</td></tr><tr><td>gcutil</td><td>类似于gc，主要输出各区域空间使用占比</td></tr><tr><td>gccause</td><td>同gc，会多输出每次gc的原因</td></tr><tr><td>gccapacity</td><td>同gc，但输出的主要是Java堆各个区域使用到的最大、最小空间</td></tr><tr><td>gcnew</td><td>查看新生代的使用情况</td></tr><tr><td>gcnewcapacity</td><td>同gcnew，输出内容主要关注新生代的最大、最小空间</td></tr><tr><td>gcold</td><td>查看老年代的使用情况</td></tr><tr><td>gcoldcapacity</td><td>同gcold，输出内容主要关注老年代的最大、最小空间</td></tr><tr><td>gcpermcapacity</td><td>输出永久代使用到的最大、最小空间</td></tr><tr><td>compiler</td><td>输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td>printcompilation</td><td>输出已经被JIT编译的方法</td></tr></tbody></table><blockquote><p>🌰</p></blockquote><ol><li>jstat -class <pid> : 显示加载class的数量及所占空间等信息</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master0 ~]# jstat -class 19080</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line"> 11512 22276.9      268   421.6      18.41</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line">Loaded: 装载类的数量</span><br><span class="line">Bytes: 装载类所占用的字节数</span><br><span class="line">Unloaded: 卸载类的数量</span><br><span class="line">Bytes: 卸载类所占用的字节数</span><br><span class="line">Time: 装载和卸载类所花费的时间</span><br></pre></td></tr></table></figure><ol start="2"><li>jstat -gc <pid> : 显示gc的信息，查看gc的次数和时间</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">，等于YGCT + FGCT[root@master0 ~]# jstat -gc 19080 1000 1</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">6656.0 6656.0  0.0   3761.4 94208.0  51469.2   73728.0    50832.0     -      -      -      -     20207   92.896  37      7.833  100.729</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">[容量为字节]</span><br><span class="line">S0C: 年轻代第一个survivor区的总容量（survivor 0 capacity）</span><br><span class="line">S1C: 年轻代第二个survivor区的总容量（survivor 1 capacity）</span><br><span class="line">S0U: 年轻代第一个survivor区的已使用容量（survivor 0 using）</span><br><span class="line">S1U: 年轻代第二个survivor区的已使用容量（survivor 1 using）</span><br><span class="line">EC: 年轻代Eden区的总容量（Eden capacity）</span><br><span class="line">EU: 年轻代Eden区的已使用容量（Eden using）</span><br><span class="line">OC: 老年代的总容量（Old capacity）</span><br><span class="line">OU: 老年代已使用的容量（Old using）</span><br><span class="line">MC: Metaspace的总容量, jdk1.8+</span><br><span class="line">MU: Metaspace已使用的容量, jdk1.8+</span><br><span class="line">CCSC:压缩类空间容量, jdk1.8+</span><br><span class="line">CCSU:压缩类空间已使用的容量, jdk1.8+</span><br><span class="line">YGC: 服务启动至今年轻代gc的次数（young gc）</span><br><span class="line">YGCT: 服务启动至今年轻代gc使用的时间，秒（young gc time）</span><br><span class="line">FGC: 服务启动至今fullgc的次数</span><br><span class="line">FGCT: 服务启动至今fullgc使用的时间，秒</span><br><span class="line">GCT: 服务启动至今gc用的总时间，秒，等于YGCT + FGCT</span><br></pre></td></tr></table></figure><ol start="3"><li>jstat -gcutil <pid> : 统计gc信息</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@master0 ~]# jstat -gcutil 19080 1000 3</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00  48.90  20.83  69.35      -      -  20221   93.006    37    7.833  100.838</span><br><span class="line">  0.00  48.90  20.83  69.35      -      -  20221   93.006    37    7.833  100.838</span><br><span class="line">  0.00  48.90  20.83  69.35      -      -  20221   93.006    37    7.833  100.838</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">S0: 年轻代第一个survivor已使用容量比例</span><br><span class="line">S1: 年轻代第二个survivor已使用容量比例</span><br><span class="line">E: 年轻代Eden区已使用容量比例</span><br><span class="line">O: 老年代已使用容量比例</span><br><span class="line">M: 元空间已使用容量比例</span><br><span class="line">CCS: 压缩类空间已使用容量比例</span><br><span class="line">YGC: 服务启动至今年轻代gc次数</span><br><span class="line">YGCT: 服务启动至今年轻代gc所占用时间，秒</span><br><span class="line">FGC: 服务启动至今fullgc次数</span><br><span class="line">FGCT: 服务启动至今fullgc所占用时间，秒</span><br><span class="line">GCT: 服务启动至今gc总占用时间，秒，等于YGCT + FGCT</span><br></pre></td></tr></table></figure><ol start="4"><li>jstat -gccause <pid> : 查看gc原因</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@master0 ~]# jstat -gccause 19080</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 </span><br><span class="line"> 57.32   0.00  13.35  69.36      -      -  20222   93.015    37    7.833  100.848 Allocation Failure   No GC</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line">上述可以看到比-gcutil多处了一个LGCC和GCC</span><br><span class="line">LGCC: 最近一次gc发生的原因（last gc cause）</span><br><span class="line">GCC: 当前gc发生的原因</span><br></pre></td></tr></table></figure><ol start="5"><li>jstat -gccapacity <pid> : 查看虚拟机中对象的使用和容量大小</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master0 ~]# jstat -gccapacity 19080</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC </span><br><span class="line"> 20480.0 323584.0 112640.0 7680.0 6656.0  96768.0    40448.0   647168.0    73728.0    73728.0        -        -        -        -        -        -  20223    37</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">[容量单位为字节]</span><br><span class="line">NGC开头的表示：新生代空间容量</span><br><span class="line">OGC开头的表示：老年代空间容量</span><br><span class="line">MC开头的表示：元空间容量（Metaspace capacity）</span><br><span class="line">CCS开头的表示：类压缩空间</span><br></pre></td></tr></table></figure><ol start="6"><li>jstat -gcnew <pid> : 查看新生代gc情况</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@master0 ~]# jstat -gcnew 19080</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  </span><br><span class="line">7680.0 6656.0    0.0 6354.4 15  15 7680.0  96768.0  95634.9  20223   93.023</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">[容量单位为字节]</span><br><span class="line">TT: 老年化阈值，也可以理解为对象持有次数，就是在被移动到老年代之前，在新生代中存活的次数</span><br><span class="line">MTT: 最大老年化阈值</span><br><span class="line">DSS: Survivor区所需空间大小</span><br></pre></td></tr></table></figure><ol start="7"><li>jstat -gcnewcapacity <pid> : 查看新生代空间容量</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master0 ~]# jstat -gcnewcapacity 19080</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line">   20480.0   323584.0   112128.0 107520.0   7168.0 107520.0   7168.0   322560.0    97280.0 20225    37</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">[容量单位为字节]</span><br><span class="line">MN表示：最小</span><br><span class="line">MX表示：最大</span><br><span class="line">NGC开头表示：新生代空间总容量</span><br><span class="line">S0C开头：新生代第一个survivor区容量</span><br><span class="line">S1C开头：新生代第二个survivor区容量</span><br><span class="line">EC开头：新生代Eden区容量</span><br></pre></td></tr></table></figure><ol start="8"><li>jstat -gcold <pid> : 查看老年代gc情况</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master0 ~]# jstat -gcold 19080 1000</span><br><span class="line">   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT   </span><br><span class="line">       -        -        -        -     73728.0     51144.0  20234    37    7.833  100.943</span><br><span class="line">       -        -        -        -     73728.0     51144.0  20234    37    7.833  100.943</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">[容量单位为字节]</span><br></pre></td></tr></table></figure><ol start="9"><li>jstat -gcoldcapacity <pid> : 查看老年代容量</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master0 ~]# jstat -gcoldcapacity 19080 100 2</span><br><span class="line">   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT   </span><br><span class="line">    40448.0    647168.0     73728.0     73728.0 20235    37    7.833  100.949</span><br><span class="line">    40448.0    647168.0     73728.0     73728.0 20235    37    7.833  100.949</span><br></pre></td></tr></table></figure><ol start="10"><li>jstat -gcpermcapacity <pid> : 查看perm中对象的信息和容量</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdk1.8+以上去除了该命令，如果你当前使用的是jdk1.7-，那么自行谷歌吧</span><br></pre></td></tr></table></figure><ol start="11"><li>jstat -compiler <pid> : 查看虚拟机实时编译的信息</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@master0 ~]# jstat -compiler 19080</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    2737      0       0    41.90          0             </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">Compiled: 编译任务执行数量</span><br><span class="line">Failed: 编译任务执行失败数量</span><br><span class="line">Invalid: 编译任务执行失效数量</span><br><span class="line">Time: 编译任务消耗的时间</span><br><span class="line">FailedType: 最后一个编译失败任务的类型</span><br><span class="line">FailedMethod: 最后一个编译失败的任务所在类及方法</span><br></pre></td></tr></table></figure><ol start="12"><li>jstat -printcompilation <pid> : 查看虚拟机已经编译过的方法</pid></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@master0 ~]# jstat -printcompilation 19080</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">    2737   1562    1 sun/misc/FloatingDecimal dtoa</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">Compiled: 编译任务的数量</span><br><span class="line">Size: 方法生成字节码的大小（单位：字节）</span><br><span class="line">Type: 编译类型</span><br><span class="line">Method: 类名和方法名用来标识编译的方法</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;jstat是用于监控虚拟机运行状态信息的命令，可以显示虚拟机进程中的类装载、内存使用、GC情况、JIT编译等运行状态数据，能够在Linux上快速定位虚拟机性能问题。&lt;/p&gt;
&lt;p&gt;jstat命令在jdk的bin目录下，目录中还有很多实用的命令&lt;/p
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis基本命令使用::list篇</title>
    <link href="http://luxiaowan.github.io/2019/10/31/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E2%80%94list%E7%AF%87/"/>
    <id>http://luxiaowan.github.io/2019/10/31/Redis基本命令使用—list篇/</id>
    <published>2019-10-31T04:55:00.000Z</published>
    <updated>2019-10-31T17:23:56.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)</p></blockquote><p><strong>redis在线体验地址：<a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></strong></p><h2 id="列表list"><a class="markdownIt-Anchor" href="#列表list"></a> 列表(List)</h2><blockquote><p>介绍:</p></blockquote><p>Redis的列表就是一个简单的字符串列表，我们可以往列表的头部和尾部添加新数据，要可以根据下标修改下标对应的值，列表是按照插入顺序有序的（按插入顺序倒序，类似于栈），并且列表可以出现重复数据。可以做消息队列，不过需要注意的是可能需要消息去重(后面有更牛的)。</p><blockquote><p>创建缓存</p></blockquote><ol><li><p>创建一个列表缓存</p><ul><li><p>命令格式：<code>lpush key value [value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpush c1 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将<span class="number">1</span>~<span class="number">9</span>放入c1列表中，此时列表中存储顺序为<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>向列表左侧新增值</p><ul><li><p>命令格式：<code>lpush key value [value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpush c1 <span class="number">10</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将<span class="number">10</span>放入到c1列表头部，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>向列表右侧新增值</p><ul><li><p>命令格式：<code>rpush key value [value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpush c1 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将<span class="number">0</span>放入到c1列表尾部，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><em><strong>以上两个命令很容易理解，lpush—&gt;left push, rpush—&gt;right push</strong></em></p><ol start="4"><li><p>在列表指定元素前/后插入数据</p><ul><li><p>命令格式：<code>linsert key BEFORE|AFTER pivot value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) linsert c1 after <span class="number">0</span> <span class="number">-1</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">-1</span>插入到元素值<span class="number">0</span>之前，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)linsert c1 before <span class="number">0</span> <span class="number">1</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">1</span>插入到元素值<span class="number">0</span>之前，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)linsert c1 before <span class="number">1</span> <span class="number">3</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">3</span>插入到元素值<span class="number">1</span>之前，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>)linsert c1 after <span class="number">1</span> <span class="number">4</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">4</span>插入到元素值<span class="number">1</span>之后，此时列表中存储顺序为<span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>)linsert c1 after <span class="number">99</span> <span class="number">100</span></span><br><span class="line">---</span><br><span class="line">失败</span><br><span class="line"></span><br><span class="line">** 由<span class="number">3</span>、<span class="number">4</span>操作可以得出结论，当执行linsert指令时，列表是从头部开始进行遍历，直到查询到与pivot元素相同的值时停止，根据AFTER、BEFORE选择是插入到元素后还是元素前，所以划重点：若列表中存在pivot的重复元素，linsert只会以第一个遍历到的元素为准</span><br><span class="line">** 由<span class="number">5</span>可以得出结论，若指定的pivot元素不存在于列表中，则不进行任何设置</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过索引下标设置值</p><ul><li><p>命令格式：<code>lset key index value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)<span class="keyword">lset</span> c1 <span class="number">0</span> <span class="number">21</span></span><br><span class="line">---</span><br><span class="line">将下标为<span class="number">0</span>的元素修改为<span class="number">21</span>，此时列表中存储顺序为<span class="number">21</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)<span class="keyword">lset</span> c1 <span class="number">99</span> <span class="number">99</span></span><br><span class="line">---</span><br><span class="line">ERR index out of range,说明通过<span class="keyword">lset</span>命令，不能越界修改元素</span><br></pre></td></tr></table></figure></li></ul></li><li><p>向已存在的列表头部添加元素</p><ul><li><p>命令格式：<code>lpushx key value [value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)lpushx c1 <span class="number">22</span> <span class="number">23</span> <span class="number">24</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">22</span>、<span class="number">23</span>、<span class="number">24</span>添加到列表c1头部，列表变为：<span class="number">24</span> <span class="number">23</span> <span class="number">22</span> <span class="number">21</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)lpushx c2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">---</span><br><span class="line">因为列表c2不存在，所以设置失败，此时使用lrange查看c2会返回空</span><br></pre></td></tr></table></figure></li></ul></li><li><p>向已存在的列表尾部添加元素</p><ul><li><p>命令格式：<code>rpushx key value [value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)rpushx c1 <span class="number">-2</span> <span class="number">-3</span></span><br><span class="line">---</span><br><span class="line">将<span class="number">-2</span>、<span class="number">-3</span>添加到列表c1尾部，列表变为：<span class="number">24</span> <span class="number">23</span> <span class="number">22</span> <span class="number">21</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">-2</span> <span class="number">-3</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)rpushx c2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">---</span><br><span class="line">因为列表c2不存在，所以设置失败，此时使用lrange查看c2会返回空</span><br></pre></td></tr></table></figure></li></ul></li><li><p>截取列表</p><ul><li><p>命令格式：<code>ltrim key start end</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ltrim c1 <span class="number">4</span> <span class="number">16</span></span><br><span class="line">---</span><br><span class="line">列表下标从<span class="number">0</span>开始，截取<span class="number">5</span>~<span class="number">17</span>位的元素，列表c1变为：<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>查看缓存</p></blockquote><ol><li><p>查看列表内所有元素</p><ul><li><p>命令格式：<code>lrange key 0 -1</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lrange c1 0 -1</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">获取列表c1的所有元素</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看列表某一范围内的元素</p><ul><li><p>命令格式：<code>lrange key start end</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lrange</span> <span class="string">c1</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">查看列表c1中弟2~4位上的元素</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出列表头部元素</p><ul><li><p>命令格式：<code>lpop key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpop c1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">弹出列表c1的头部元素<span class="number">9</span>，此时列表c1变为：<span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">0</span>，头部的<span class="number">9</span>已经没有了，是不是很适合做消息队列</span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出列表尾部元素</p><ul><li><p>命令格式：<code>rpop key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpop c1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">弹出c1的尾部元素<span class="number">0</span>，此时列表c1变为：<span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>，尾部的<span class="number">0</span>已经没有了，是不是很适合做消息队列👀</span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出列表头部元素，若当前列表内无元素，则阻塞，直到获取到或达到超时时间</p><ul><li><p>命令格式：<code>blpop key [key ...] timeout</code>   timeout单位为***秒***</p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">blpop </span><span class="built_in">c1</span> <span class="built_in">c2</span> <span class="built_in">c3</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">弹出列表<span class="built_in">c1</span>或列表<span class="built_in">c2</span>/<span class="built_in">c3</span>的头部元素，只要<span class="built_in">c1</span>、<span class="built_in">c2</span>、<span class="built_in">c3</span>有一个列表中有元素被弹出，则结束阻塞</span><br><span class="line">若<span class="built_in">c1</span>、<span class="built_in">c2</span>、<span class="built_in">c3</span>均有元素，则返回第一个满足弹出条件的列表，然后结束阻塞</span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出列表尾部元素，若当前列表内无元素，则阻塞，直到获取到或达到超时时间</p><ul><li><p>命令格式：<code>brpop key [key ...] timeout</code>   timeout单位为***秒***</p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">blpop </span><span class="built_in">c1</span> <span class="built_in">c2</span> <span class="built_in">c3</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">弹出列表<span class="built_in">c1</span>或列表<span class="built_in">c2</span>/<span class="built_in">c3</span>的尾部元素，只要<span class="built_in">c1</span>、<span class="built_in">c2</span>、<span class="built_in">c3</span>有一个列表中有元素被弹出，则结束阻塞</span><br><span class="line">若<span class="built_in">c1</span>、<span class="built_in">c2</span>、<span class="built_in">c3</span>均有元素，则返回第一个满足弹出条件的列表，然后结束阻塞</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取列表指定位置的元素</p><ul><li><p>命令格式：<code>lindex key index</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1)lindex c1 2</span><br><span class="line">---</span><br><span class="line">返回列表c1中下标为2的元素，仅仅返回数据，不弹出，时间复杂度O(1)</span><br><span class="line"></span><br><span class="line">2)lindex c1 -1</span><br><span class="line">---</span><br><span class="line">返回列表最后一个元素。列表元素下标-1代表列表中最后一个元素，所以列表是可以通过负数下标从后往前遍历</span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出一个列表中的最后一个元素到另外一个列表头部，并返回这个元素——无阻塞</p><ul><li><p>命令格式：<code>rpoplpush source_key destination_key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">rpoplpush</span> <span class="string">c1</span> <span class="string">c2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">弹出列表c1的尾部元素插入到列表c2的头部，若c1为空，则返回nil，但不插入到c2中，是不是更适合做队列</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>弹出一个列表中的最后一个元素到另外一个列表头部，并返回这个元素——阻塞</p><ul><li><p>命令格式：<code>brpoplpush source_key destination_key timeout</code>    timeout单位为***秒***</p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">brpoplpush</span> <span class="string">c3</span> <span class="string">c2</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">弹出列表c3的尾部元素插入到列表c2的头部，若c3为空，则阻塞等到列表c3中有值，否则等到了10秒后结束阻塞返回nil，是不是更适合做阻塞队列</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>其他命令</p></blockquote><ol><li><p>删除指定范围内等于某个值的所有元素</p><ul><li><p>命令格式：<code>lrem key index element</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1)lrem c1 -2 3</span><br><span class="line">---</span><br><span class="line">移除列表c1中，从倒数第二个元素到列表头部范围内所有的3</span><br><span class="line"></span><br><span class="line">2)lrem c1 3 2</span><br><span class="line">---</span><br><span class="line">移除列表c1中，从第四位元素到尾部范围内所有的2</span><br><span class="line"></span><br><span class="line">3)lrem c1 0 1</span><br><span class="line">---</span><br><span class="line">移除列表c1中所有的1</span><br><span class="line"></span><br><span class="line">4)lrem c1 -1 4</span><br><span class="line">---</span><br><span class="line">移除列表c1中所有的4</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看列表长度</p><ul><li><p>命令格式：<code>llen key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">llen</span> <span class="string">c1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">查看列表c1的总长度，若c1不存在，则返回0，不会报错，记住，若列表不存在也不会报错</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis在线体验地址：
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis基本命令使用::set篇</title>
    <link href="http://luxiaowan.github.io/2019/10/31/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E2%80%94set%E7%AF%87/"/>
    <id>http://luxiaowan.github.io/2019/10/31/Redis基本命令使用—set篇/</id>
    <published>2019-10-31T04:55:00.000Z</published>
    <updated>2019-11-10T15:57:22.418Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)</p></blockquote><p><strong>redis在线体验地址：<a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></strong></p><h2 id="集合set"><a class="markdownIt-Anchor" href="#集合set"></a> 集合(Set)</h2><blockquote><p>介绍:</p></blockquote><p>Redis的集合就是一个简单的字符串集合，该集合是无序的，且集合内的元素都是唯一的，也就是集合内不会出现重复元素。Redis中的集合是通过哈希表来实现的，所以获取集合中元素的时间复杂度为O(1)。</p><blockquote><p>创建缓存</p></blockquote><ol><li><p>创建一个集合缓存，为集合新增元素</p><ul><li><p>命令格式：<code>sadd key member [member ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd s1 1 2 3 0 -1 redis mongodb zookeeper</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">创建集合s1,元素为：1 2 3 0 -1 redis mongodb zookeeper</span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>移除元素</p></blockquote><ol><li><p>随机移除集合中的一个元素并返回这个元素</p><ul><li><p>命令格式：<code>spop key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spop</span> <span class="string">s1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">移除之后，集合s1中就没有这个元素了</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>指定移除集合中一个或多个元素</p><ul><li><p>命令格式：<code>srem key member [member ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">srem s1 -1 0 99</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将元素-1、0、99从集合s1中移除，仅移除集合中存在的元素</span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>查询集合</p></blockquote><ol><li><p>查询集合中元素个数</p><ul><li><p>命令格式：<code>scard key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scard s1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">返回集合s1中元素总个数</span><br></pre></td></tr></table></figure></li></ul></li><li><p>返回集合中所有元素</p><ul><li><p>命令格式：<code>smembers key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">smembers s1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">返回集合s1中所有的元素</span><br></pre></td></tr></table></figure></li></ul></li><li><p>随机返回集合中的一个或多个元素</p><ul><li><p>命令格式：<code>srandmember key [count]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">srandmember s1 10</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">随机返回集合s1中的10个元素，若不指定数量，则默认返回一个元素</span><br></pre></td></tr></table></figure></li></ul></li><li><p>迭代集合中的元素</p><ul><li><p>命令格式：<code>sscan key cursor [MATCH pattern] [COUNT count]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sscan s1 0 match re* count 1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">迭代集合中re开头的所有元素，每次返回1个</span><br></pre></td></tr></table></figure></li></ul></li><li><p>判断元素是否存在于集合中</p><ul><li><p>命令格式：<code>sismember key member</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sismember s1 99</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">若99存在于s1中，则返回1，不存在则返回0</span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>多集合之间操作</p></blockquote><ol><li><p>查看多个集合的差集</p><ul><li><p>命令格式：<code>sdiff key [key ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sdiff s1 s2 s3</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">返回集合s1相对于s2、s3的差集，也就是只返回s1中所有不存在于s2、s3中的所有元素</span><br></pre></td></tr></table></figure></li></ul></li><li><p>多个集合的差集存储到指定集合中</p><ul><li><p>命令格式：<code>sdiffstore destination key [key ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sdiffstore ds1 s1 s2 s3</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将s1中不存在于s2、s3中的元素存储到集合ds1中</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看多个集合的并集，去重</p><ul><li><p>命令格式：<code>sunion key [key ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sunion s1 s2 s3</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将集合s1、s2、s3的元素合并去重后返回，所有元素均唯一</span><br></pre></td></tr></table></figure></li></ul></li><li><p>多个集合的并集存储到指定集合中</p><ul><li><p>命令格式：<code>sunionstore destination key [key ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sunionstore us1 s1 s2 s3</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">集合s1、s2、s3的并集存储到集合us1中，并返回集合us1中的元素个数</span><br></pre></td></tr></table></figure></li></ul></li><li><p>将一个集合中的某元素移动到另一个集合中</p><ul><li><p>命令格式：<code>smove source destination member</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">smove s1 s2 -2</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将s1中的元素-2移动到集合s2中，若s2不存在，则自动创建</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看多个集合的交集</p><ul><li><p>命令格式：<code>sinter key [key ...]</code>（intersection）</p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sinter s1 s3</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">返回集合s1和集合s3的交集，也就是两个集合中都存在的数据</span><br><span class="line"></span><br><span class="line">实际应用：查看两个人的共同好友；微信里查看和好友的共同群</span><br></pre></td></tr></table></figure></li></ul></li><li><p>多个集合的交集存储到指定集合中</p><ul><li><p>命令格式：<code>sinterstore destination key [key ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sinterstore is1 s1 s3</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">将s1和s3的交集元素存储到集合is1中</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis在线体验地址：
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis基本命令使用::hash篇</title>
    <link href="http://luxiaowan.github.io/2019/10/30/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E2%80%94hash%E7%AF%87/"/>
    <id>http://luxiaowan.github.io/2019/10/30/Redis基本命令使用—hash篇/</id>
    <published>2019-10-30T15:55:00.000Z</published>
    <updated>2019-10-31T16:05:56.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)</p></blockquote><p><strong>redis在线体验地址：<a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></strong></p><h2 id="哈希hash"><a class="markdownIt-Anchor" href="#哈希hash"></a> 哈希(Hash)</h2><blockquote><p>介绍:</p></blockquote><p>Redis hash 是一个存储多个键值对的映射表，适用于存储对象的属性，比如存储用户信息、用户Session信息等。在实际项目中使用的频率比较多，之前主要用于存储用户基本信息、用户临时订单信息、产品信息等。</p><blockquote><p>创建缓存</p></blockquote><ol><li><p>创建一个缓存</p><ul><li><p>命令格式：<code>hset key field value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hset</span> <span class="string">cc</span> <span class="string">name</span> <span class="string">'cc'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">将cc的name属性的值设置为cc</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>批量创建缓存</p><ul><li><p>命令格式：<code>hmset key filed value [field value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hmset</span> <span class="string">cc</span> <span class="string">name</span> <span class="string">'cc'</span> <span class="string">age</span> <span class="number">19</span> <span class="string">avatar</span> <span class="string">'a.png'</span> <span class="string">status</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">设置cc对象的name、age、avatar、status属性的值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置一个key不存在field的value，若field已存在则不设置</p><ul><li><p>命令格式：<code>hsetnx key field value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hsetnx</span> <span class="string">cc</span> <span class="string">name</span> <span class="string">'yy'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">若对象cc的name属性不存在，则设置cc的name属性值为yy</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>查看缓存</p></blockquote><ol><li><p>查看key下所有属性+值</p><ul><li><p>命令格式：<code>hgetall key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hgetall</span> <span class="string">cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">获取对象cc的所有属性，返回数据格式：</span></span><br><span class="line"> <span class="string">field1</span></span><br><span class="line"> <span class="string">value1</span></span><br><span class="line"> <span class="string">field2</span></span><br><span class="line"> <span class="string">value2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看key下所有的值</p><ul><li><p>命令格式：<code>hvals key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hvals</span> <span class="string">cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">返回cc对象的所有属性的值，仅返回值，不返回属性名称</span></span><br><span class="line"><span class="string">等同于</span> <span class="string">”hmget</span> <span class="string">key</span> <span class="string">所有field“</span> <span class="string">命令</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看key下所有的field名称</p><ul><li><p>命令格式：<code>hkeys key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hkeys</span> <span class="string">cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">返回对象cc的所有属性名</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看key的某一field的值</p><ul><li><p>命令格式：<code>hget key field</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hget</span> <span class="string">cc</span> <span class="string">name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">返回对象cc的name属性的值，若对象无此属性，则返回nil</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看key的多个field的值</p><ul><li><p>命令格式：<code>hmget key field [field ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hmget</span> <span class="string">cc</span> <span class="string">name</span> <span class="string">age</span> <span class="string">status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">返回对象cc的name、age、status属性</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>迭代对象的所有属性(适用于大对象)</p><ul><li><p>命令格式：<code>hscan key course [MATCH pattern] [COUNT num]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hscan cc <span class="number">0</span> MATCH *e COUNT <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看对象的属性数</p><ul><li><p>命令格式：<code>hlen key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hlen</span> <span class="string">cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">返回对象cc的属性数量</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>其他命令</p></blockquote><ol><li><p>删除一个/多个属性</p><ul><li><p>命令格式：<code>hdel key field [field ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hdel</span> <span class="string">cc</span> <span class="string">name</span> <span class="string">age</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">删除对象cc的name、age属性</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看对象属性是否存在</p><ul><li><p>命令格式：<code>hexists key field</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hexists</span> <span class="string">cc</span> <span class="string">name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">对象cc若存在属性name，则返回1，不存在则返回0</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis在线体验地址：
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis基本命令使用::string篇</title>
    <link href="http://luxiaowan.github.io/2019/10/29/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E2%80%94string%E7%AF%87/"/>
    <id>http://luxiaowan.github.io/2019/10/29/Redis基本命令使用—string篇/</id>
    <published>2019-10-29T15:55:00.000Z</published>
    <updated>2019-10-30T16:43:50.550Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)</p></blockquote><p><strong>redis在线体验地址：<a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></strong></p><h2 id="字符串string"><a class="markdownIt-Anchor" href="#字符串string"></a> 字符串(String)</h2><blockquote><p>介绍:</p></blockquote><p>字符串是Redis中最基本的数据类型，数据以二进制的形式存储于内存中，所以Redis的字符串可以是任何形式的数据，比如JPEG图像、序列化的Ruby对象等。</p><p>字符串最大可存储512MB的数据，但一般一个字符串容量过大，会直接影响存储和查询的效率。字符串有两种编码方式：raw和embstr，根据字符串长度自动选择使用哪一种编码，目前最新版的长度是44个字节，字符串长度小于等于44个字节，则使用embstr编码，大于44个字节则使用raw编码，两种编码方式这里就不作详解，有兴趣的可以谷歌一下。</p><blockquote><p>创建缓存</p></blockquote><ol><li><p>创建一个缓存</p><ul><li><p>命令格式：<code>set key value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">set</span> <span class="string">cc</span> <span class="string">'niubility'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">创建一个key为cc，值为niubility的缓存</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>批量创建缓存</p><ul><li><p>命令格式：<code>mset key value [key value ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mset</span> <span class="string">cc1</span> <span class="number">1</span> <span class="string">cc2</span> <span class="number">2</span> <span class="string">cc3</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">创建三个缓存，key:value分别为cc1:1,</span> <span class="attr">cc2:2,</span> <span class="attr">cc3:3</span></span><br></pre></td></tr></table></figure></li><li><p>命令格式：<code>msetnx key value [key value ...]</code></p><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">msetnx</span> <span class="string">cc1</span> <span class="number">11</span> <span class="string">cc2</span> <span class="number">22</span> <span class="string">cc5</span> <span class="number">5</span> <span class="string">cc6</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">此命令只会将尚不存在的key值创建到缓存中，已经存在的key则忽略</span></span><br><span class="line"><span class="string">*</span> <span class="string">cc1、cc2已存在于缓存中，所以不会创建/更新成功，cc5、cc6不存在于缓存中，会创建</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建一个带过期时间的缓存</p><ul><li><p>命令格式：<code>setex key time value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">setex</span> <span class="string">cc1</span> <span class="number">10</span> <span class="number">234</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">设置key:value为cc1:234且过期时间为10秒的缓存</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置一个不存在key的value，若key已存在则不设置</p><ul><li><p>命令格式：<code>setnx key value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">setnx</span> <span class="string">cc5</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">若cc5的key不存在于缓存中，则创建key:value为cc5:12的缓存，否则不执行创建</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>组合创建一个缓存(缓存过期时间、是否覆盖)</p><ul><li><p>命令格式：<code>set key value [EX|PX time] [NX|XX]</code></p><blockquote><p>解析：</p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   EX：表明过期时间为秒</span><br><span class="line">   </span><br><span class="line">PX：表明过期时间为毫秒</span><br><span class="line">   </span><br><span class="line">   NX：若<span class="built_in">key</span>不存在则执行，否则不执行，与XX相反</span><br><span class="line">   </span><br><span class="line">   XX：若<span class="built_in">key</span>存在则执行，否则不执行，与NX相反</span><br></pre></td></tr></table></figure></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">set</span> <span class="string">cc1</span> <span class="number">123</span> <span class="string">EX</span> <span class="number">20</span> <span class="string">XX</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">---</span></span><br><span class="line">  <span class="string">若cc1已存在则创建过期时间为20秒的key:value</span> <span class="string">=</span> <span class="attr">cc1:123</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>将key设置为新值的同时返回原值</p><ul><li><p>命令格式：<code>getset key value</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">getset</span> <span class="string">cc1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">若key不存在，则返回nil</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>读取缓存</p></blockquote><ol><li><p>读取一个key的缓存值</p><ul><li><p>命令格式：<code>get key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">get</span> <span class="string">cc1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">读取key=cc1的值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>批量读取一批数据</p><ul><li><p>命令格式：<code>mget key [key ...]</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget <span class="keyword">cc</span><span class="number">1</span> <span class="keyword">cc</span><span class="number">2</span> <span class="keyword">cc</span><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>截取字符串并返回</p><ul><li><p>命令格式：<code>getrange key start end</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">getrange</span> <span class="string">cc1</span> <span class="number">1</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">字符串下标以0开始，若start超出字符串长度或key不存在，则返回空字符串</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>其他操作</p></blockquote><ol><li><p>将value加1( value必须为整数 )[ 可用于阅读量、点赞数等简单统计类的功能应用 ]</p><ul><li><p>命令格式：<code>incr key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">incr</span> <span class="string">cc1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">每次调用均对value进行+1操作</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>给value加上某个数( num必须为整数 )</p><ul><li><p>命令格式：<code>incrby key num</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">incrby</span> <span class="string">cc1</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">给cc1的值加上100</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>给value加上某个浮点数</p><ul><li><p>命令格式：<code>incrbyfloat key num</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrbyfloat cc1 <span class="number">0.2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>给value减1</p><ul><li><p>命令格式：<code>decr key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">decr</span> <span class="string">cc1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">每次调用均对value进行-1操作</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>给value减去某个数( num必须为整数 )</p><ul><li><p>命令格式：<code>descby key num</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">decrby</span> <span class="string">cc1</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">给cc1的值减去100</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看value的长度</p><ul><li><p>命令格式：<code>strlen key</code></p></li><li><blockquote><p>🌰</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span> cc1</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>目前先整理这些，都是一些基础的命令，随后再写一篇Java中使用Jedis操作字符串的随笔。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redis有6大基本类型，分别是字符串(String)、列表(List)、集合(set)、哈希结构(hash)、有序集合(zset)和基数(HyperLogLog)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis在线体验地址：
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis数据在内存中是如何存储的</title>
    <link href="http://luxiaowan.github.io/2019/10/29/Redis%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/"/>
    <id>http://luxiaowan.github.io/2019/10/29/Redis数据在内存中是如何存储的/</id>
    <published>2019-10-29T08:50:00.000Z</published>
    <updated>2019-10-29T15:02:17.269Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL索引什么时候用hash</title>
    <link href="http://luxiaowan.github.io/2019/10/28/MySQL%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8hash/"/>
    <id>http://luxiaowan.github.io/2019/10/28/MySQL索引什么时候用hash/</id>
    <published>2019-10-28T11:06:00.000Z</published>
    <updated>2019-10-29T14:10:04.447Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL索引是在面试中常被问到的知识点，常用的两种索引方法有Hash和B+Tree，树的结构我们改天再扯，今天说收Hash。</p><blockquote><p>为什么使用hash</p></blockquote><p>Hash索引可以根据数据的hash值直接定位到索引数据的存储位置，就相当于我知道了数组的下标，然后根据下标去取数据，这个效率可以说是最高的了，使用hash就是为了如此。</p><blockquote><p>支持hash的存储引擎</p></blockquote><p>目前支持hash的引擎有MEMORY(这里需要谷歌)，其他的引擎都通过各自的方式去支持hash方法。如InnoDB有一套自适应hash算法，内部实现还是采用了BT的方式，可以理解为BT索引的索引</p><blockquote><p>InnoDB中hash索引支持的开启/关闭</p></blockquote><p>hash索引虽然非常快速，但是在InnoDB中确实支持的不是很好，并且索引的具体创建是由引擎决定的(创建后存在于内存中)，非DBA可控，所以一般情况下建议关闭hash支持，使用BT也能够满足性能要求。</p><p>​<code>set global innodb_adaptive_hash_index=off/on</code></p><blockquote><p>hash的使用场景</p></blockquote><p>hash使用场景比较局限</p><ol><li>hash索引仅适用于‘=’、‘&lt;=&gt;’和‘in’操作，所以hash仅仅适用于精确查找。</li><li>不适用于查询排序，因为hash后的数据并不会像原数据一样保持有序。</li><li>不适用于模糊查询，也就是不能使用like关键字。</li><li>既然不支持排序，也肯定不支持范围查询咯</li></ol><blockquote><p>解决hash冲突</p></blockquote><p>不论hash的算法多么精确，当数据量大的时候都有可能发生hash碰撞，解决hash碰撞的方法有很多，比如再hash、链表叠加等，MySQL采用的是链表叠加的方式，也就是类似于HashMap解决hash碰撞的方法。所以在发生hash碰撞过多的情况下，使用hash索引会影响查询性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL索引是在面试中常被问到的知识点，常用的两种索引方法有Hash和B+Tree，树的结构我们改天再扯，今天说收Hash。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么使用hash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hash索引可以根据数据的hash值直接定位
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Session和Redis实现Session共享</title>
    <link href="http://luxiaowan.github.io/2019/10/24/Spring-Session%E5%92%8CRedis%E5%AE%9E%E7%8E%B0Session%E5%85%B1%E4%BA%AB/"/>
    <id>http://luxiaowan.github.io/2019/10/24/Spring-Session和Redis实现Session共享/</id>
    <published>2019-10-24T11:30:00.000Z</published>
    <updated>2019-10-24T15:18:45.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>需求</p><blockquote><p>现在大部分服务都以集群负载均衡的方式部署，几乎很难再遇到单点部署的项目，因为大家都要保证最基本的HA，说到HA，第一要考虑的就是各系统之间的Session共享的问题，如何解决呢？负载均衡当前使用Nginx</p></blockquote></blockquote><hr><blockquote><p>分析</p><blockquote><p><img src="/images/image-20191024193415981.png" alt></p></blockquote><blockquote><ol><li>不同的POD之间如果需要达到数据共享的目的，那么则需要使用同一个存储媒介，一开始想到使用MySQL来存储登录session，但是每次请求都去MySQL中查询数据，开销还是非常大的；然后最近使用MongoDB比较嗨，想着用MongoDB，但是MongoDB查询起来也不方便，况且我们这个Session也不是量级很大的数据集，最终采用了内存级的Redis来解决这个问题。</li><li>使用Redis的基本操作是将jsessionId为key，用户信息为value，使用jedis或者redisTemplate来操作Redis的读写行为。但是这种方式侵入了业务代码，并不是最优解，查了部分资料之后，发现spring-session.jar包中有一个非常有特色的注解@EnableRedisHttpSession，可以不需要侵入业务代码就能使用redis实现session共享的问题。</li></ol></blockquote></blockquote><ul><li>我们看一下@EnableRedisHttpSession的源码是怎么说的：</li></ul><p><img src="/images/image-20191024223839113.png" alt="image-20191024223839113"></p><blockquote><p>将此注释添加到一个单独的类上，该类必须加上@Configuration注解。使用方式在注释里也给出了demo代码。</p></blockquote><hr><blockquote><p>实现</p></blockquote><ol><li>修改pom.xml文件，引入我们需要的jar包</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改application.yml文件，配置redis信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line">spring.redis.host=localhost</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">spring.redis.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisHttpSessionConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们使用Redis实现Session共享的所有配置和代码都已经写完了，可以看到我们没有侵入到任何业务代码中，从头到尾也很简单。</p><blockquote><p>扩展</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGemFireHttpSession</span></span><br><span class="line"><span class="meta">@EnableSpringHttpSession</span></span><br><span class="line"><span class="meta">@EnableMongoHttpSession</span></span><br><span class="line"><span class="meta">@EnableJdbcHttpSession</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;需求&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在大部分服务都以集群负载均衡的方式部署，几乎很难再遇到单点部署的项目，因为大家都要保证最基本的HA，说到HA，第一要考虑的就是各系统之间的Session共享的问题，如何解决呢？负载均衡当前使用Ngin
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://luxiaowan.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>Java简单操作MongoDB</title>
    <link href="http://luxiaowan.github.io/2019/10/24/Java%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9CMongoDB/"/>
    <id>http://luxiaowan.github.io/2019/10/24/Java简单操作MongoDB/</id>
    <published>2019-10-24T02:16:00.000Z</published>
    <updated>2019-10-24T13:20:12.762Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面已经掌握了mongo最基本的一些命令，对各个命令也都实操过，理解各命令的意思，也对mongo有了最基本的理解，但大部分猿还是想使用Java去连接mongo，串串也不例外</p></blockquote><ul><li><p>在pom.xml中加入mongodb-java-driver.jar的依赖</p><ul><li><p>Maven项目依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.0.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>SpringBoot项目依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>连接mongo</p><ul><li><p>认证连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建验证信息，根据加密方式选择MongoCredential内对应的加密方式</span></span><br><span class="line">List&lt;MongoCredential&gt; credentials = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">MongoCredential credential = MongoCredential.createCredential(<span class="string">"admin"</span>, <span class="string">"test1"</span>, <span class="string">"admin"</span>.toCharArray());</span><br><span class="line">credentials.add(credential);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建mongo服务地址</span></span><br><span class="line">ServerAddress serverAddress = <span class="keyword">new</span> ServerAddress(<span class="string">"localhost"</span>, <span class="number">27017</span>);</span><br><span class="line">MongoClient mongoClient = <span class="keyword">new</span> MongoClient(serverAddress, credentials);</span><br></pre></td></tr></table></figure></li><li><p>无需认证连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoClient client = <span class="keyword">new</span> MongoClient(<span class="string">"localhost"</span>, <span class="number">27017</span>);</span><br></pre></td></tr></table></figure><p>然后就可以通过MongoClient的实例方法对mongo进行相关操作了</p></li></ul></li><li><p>创建数据库连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoDatabase db = client.getDatabase(<span class="string">"test1"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>mongo特性是不管数据库事先是否存在，都可以正常创建数据库连接，不会像MySQL一样报错，连接成功后，在mongo服务器上执行<code>show dbs</code>，会发现仍然查不到我们连接的这个数据库，这是正常情况，只有在数据库中有数据的时候，才会查得出来，<code>client.getDatabase(&quot;test&quot;) === use test命令</code></p></blockquote></li><li><p>创建集合</p><ul><li>使用数据库连接实例方法创建一个空的集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(<span class="string">"base_info"</span>);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  命令：db.createCollection(<span class="string">"base_info"</span>)</span><br></pre></td></tr></table></figure><ul><li>直接向创建的集合中插入数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MongoCollection&lt;Document&gt; collection = db.getCollection(<span class="string">"base_info"</span>);</span><br><span class="line">collection.insertOne(<span class="keyword">new</span> Document(<span class="string">"name"</span>, <span class="string">"lxl"</span>));</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  命令：db.base_info.insert(&#123;<span class="string">"name"</span>: <span class="string">"lxl"</span>&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>以上两种方式均可创建一个集合，区别在于第一种方式创建的是空集合，</p></blockquote></li><li><p>删除集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">collection.drop();</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  命令：db.base_info.drop()</span><br></pre></td></tr></table></figure></li></ul><h4 id="对集合的crud"><a class="markdownIt-Anchor" href="#对集合的crud"></a> 对集合的CRUD</h4><ul><li><p>新增数据</p><ul><li><p>单条新增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Document document = <span class="keyword">new</span> Document().append(<span class="string">"name"</span>,<span class="string">"cc"</span>).append(<span class="string">"age"</span>,<span class="number">30</span>).append(<span class="string">"location"</span>,<span class="string">"SZ"</span>);</span><br><span class="line">collection.insertOne(document);</span><br></pre></td></tr></table></figure></li><li><p>批量新增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Document&gt; documentList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  Document doc = <span class="keyword">new</span> Document().append(<span class="string">"name"</span>, <span class="string">"cc"</span> + i).append(<span class="string">"age"</span>, <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>)).append(<span class="string">"location"</span>, <span class="string">"SZ"</span>);</span><br><span class="line">  documentList.add(doc);</span><br><span class="line">&#125;</span><br><span class="line">collection.insertMany(documentList);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>insertOne(Document)方法每次插入一条数据</p><p>insertMany(List<document>)方法批量插入数据，并且可以通过参数InsertManyOptions设置是否排序</document></p></blockquote></li><li><p>删除数据</p><ul><li>删除第一条匹配的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">99</span>);</span><br><span class="line">collection.deleteOne(condition);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  命令：db.base_info.deleteOne(&#123;<span class="string">"age"</span>: <span class="number">99</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>删除所有匹配数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">99</span>);</span><br><span class="line">collection.deleteMany(condition);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">  命令：db.base_info.deleteMany(&#123;<span class="string">"ag"</span>: <span class="number">99</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>查询数据</p><ul><li><p>查询返回第一条匹配的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">16</span>);</span><br><span class="line">FindIterable&lt;Document&gt; vals = collection.find(condition);</span><br><span class="line">Document document = vals.first();</span><br><span class="line">System.out.println(document.toJson());</span><br></pre></td></tr></table></figure><blockquote><p>通过调用FindIterable的实例方法first()取第一条数据</p></blockquote></li><li><p>查询返回所有匹配数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">16</span>);</span><br><span class="line">FindIterable&lt;Document&gt; vals = collection.find(condition);</span><br><span class="line"><span class="keyword">for</span> (Document val : vals) &#123;</span><br><span class="line">  System.out.println(val.toJson());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>find()方法返回所有匹配数据</p></blockquote></li><li><p>分页查询</p><p>分页查询是我们日常开发中经常用到的功能，尤其是mongo这种量级较大的存储，分页使用limit()和skip()两个方法来实现，limit指定查询的条数，skip进行分页，参数为从第几条开始，需要使用当前页码和分页条数进行计算(pageNo - 1) * pageSize</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.lt(<span class="string">"age"</span>, <span class="number">2</span>);</span><br><span class="line">FindIterable&lt;Document&gt; vals = collection.find(condition).limit(<span class="number">10</span>).skip(<span class="number">10</span>).sort(Sorts.descending(<span class="string">"age"</span>));</span><br><span class="line"><span class="keyword">for</span> (Document val : vals) &#123;</span><br><span class="line">  System.out.println(val.toJson());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>limit(10): 每页取10条数据</p><p>skip(10): 从第11条开始查询，起始位置为0</p><p>sort(Sorts.descending(“age”)): 以列age倒序</p><blockquote><p>对应MySQL：select * from base_info where age &lt; 2 order by age desc limit 7, 7</p></blockquote></blockquote></li></ul></li><li><p>更新数据</p><ul><li><p>更新第一条匹配数据中的某些字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">15</span>);</span><br><span class="line">Document document = <span class="keyword">new</span> Document(<span class="string">"$set"</span>, <span class="keyword">new</span> Document(<span class="string">"location"</span>, <span class="string">"XZ"</span>));</span><br><span class="line">collection.updateOne(condition, document);</span><br></pre></td></tr></table></figure><blockquote><p>注意这里有一个<code>$set</code>，这个指令是必须的，相对应的指令还有<code>$inc</code></p></blockquote></li><li><p>替换第一条匹配数据全部内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">15</span>);</span><br><span class="line">Document document = <span class="keyword">new</span> Document(<span class="string">"location"</span>, <span class="string">"XZ"</span>);</span><br><span class="line">collection.updateOne(condition, document);</span><br></pre></td></tr></table></figure><blockquote><p>没有<code>$set</code>指令,则表示使用参数document替换掉第一条匹配到的数据</p></blockquote></li><li><p>第一条匹配的数据中指定字段数量+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"location"</span>, <span class="string">"XZ"</span>);</span><br><span class="line">Document document = <span class="keyword">new</span> Document(<span class="string">"$inc"</span>, <span class="keyword">new</span> Document(<span class="string">"age"</span>, <span class="number">1</span>));</span><br><span class="line">collection.updateOne(condition, document);</span><br></pre></td></tr></table></figure></li><li><p>更新所有匹配数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bson condition = Filters.eq(<span class="string">"age"</span>, <span class="number">15</span>);</span><br><span class="line">Document document = <span class="keyword">new</span> Document(<span class="string">"$set"</span>, <span class="keyword">new</span> Document(<span class="string">"location"</span>, <span class="string">"XZ"</span>));</span><br><span class="line">collection.updateMany(condition, document);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="全部代码"><a class="markdownIt-Anchor" href="#全部代码"></a> 全部代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.bson.Document;</span><br><span class="line"><span class="keyword">import</span> org.bson.conversions.Bson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClient;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.FindIterable;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoCollection;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.model.Filters;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.model.Sorts;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConnectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MongoClient client = <span class="keyword">new</span> MongoClient(<span class="string">"localhost"</span>, <span class="number">27017</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // 创建验证信息，根据加密方式选择MongoCredential内对应的加密方式</span></span><br><span class="line"><span class="comment">            List&lt;MongoCredential&gt; credentials = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">            MongoCredential credential = MongoCredential.createCredential("admin", "test", "".toCharArray());</span></span><br><span class="line"><span class="comment">            credentials.add(credential);</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            // 创建mongo服务地址</span></span><br><span class="line"><span class="comment">            ServerAddress serverAddress = new ServerAddress("localhost", 27017);</span></span><br><span class="line"><span class="comment">            MongoClient mongoClient = new MongoClient(serverAddress, credentials);*/</span></span><br><span class="line"></span><br><span class="line">            MongoDatabase db = client.getDatabase(<span class="string">"test1"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建集合</span></span><br><span class="line">            <span class="comment">// 方式1</span></span><br><span class="line">            <span class="comment">// db.createCollection("base_info2");</span></span><br><span class="line">            <span class="comment">// 方式2</span></span><br><span class="line">            MongoCollection&lt;Document&gt; collection = db.getCollection(<span class="string">"base_info"</span>);</span><br><span class="line">            <span class="comment">// collection.insertOne(new Document("name", "lxl"));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除集合</span></span><br><span class="line">            <span class="comment">// collection.drop();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新增数据</span></span><br><span class="line">            <span class="comment">// 单条新增</span></span><br><span class="line">            <span class="comment">/*Document document = new Document().append("name", "cc").append("age", 30).append("location", "SZ");</span></span><br><span class="line"><span class="comment">            collection.insertOne(document);</span></span><br><span class="line"><span class="comment">            // 批量新增</span></span><br><span class="line"><span class="comment">            List&lt;Document&gt; documentList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">            for (int i = 0; i &lt; 1000; i++) &#123;</span></span><br><span class="line"><span class="comment">                Document doc = new Document().append("name", "cc" + i).append("age", new Random().nextInt(100))</span></span><br><span class="line"><span class="comment">                        .append("location", "SZ");</span></span><br><span class="line"><span class="comment">                documentList.add(doc);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            collection.insertMany(documentList);*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除数据</span></span><br><span class="line">            <span class="comment">// 删除第一条匹配数据</span></span><br><span class="line">            <span class="comment">/*Bson condition = Filters.eq("age", 99);</span></span><br><span class="line"><span class="comment">            collection.deleteOne(condition);</span></span><br><span class="line"><span class="comment">            // 删除所有匹配数据</span></span><br><span class="line"><span class="comment">            collection.deleteMany(condition);*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改数据</span></span><br><span class="line">            <span class="comment">// 修改第一条匹配数据</span></span><br><span class="line">            <span class="comment">/*Bson condition = Filters.eq("age", 15);</span></span><br><span class="line"><span class="comment">            Document document = new Document("$set", new Document("location", "XZ"));</span></span><br><span class="line"><span class="comment">            collection.updateOne(condition, document);</span></span><br><span class="line"><span class="comment">            collection.updateMany(condition, document);*/</span></span><br><span class="line">            <span class="comment">// 年龄+1</span></span><br><span class="line">            <span class="comment">/*Bson condition = Filters.eq("location", "XZ");</span></span><br><span class="line"><span class="comment">            Document document = new Document("$inc", new Document("age", 1));</span></span><br><span class="line"><span class="comment">            collection.updateOne(condition, document);*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询返回第一条匹配数据</span></span><br><span class="line">            Bson condition = Filters.lt(<span class="string">"age"</span>, <span class="number">2</span>);</span><br><span class="line">            FindIterable&lt;Document&gt; vals = collection.find(condition).sort(Sorts.descending(<span class="string">"age"</span>)).limit(<span class="number">7</span>).skip(<span class="number">7</span>);</span><br><span class="line">            <span class="comment">// Document document = vals.first();</span></span><br><span class="line">            <span class="comment">// System.out.println(document.toJson());</span></span><br><span class="line">            <span class="keyword">for</span> (Document val : vals) &#123;</span><br><span class="line">                System.out.println(val.toJson());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前面已经掌握了mongo最基本的一些命令，对各个命令也都实操过，理解各命令的意思，也对mongo有了最基本的理解，但大部分猿还是想使用Java去连接mongo，串串也不例外&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在pom.x
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://luxiaowan.github.io/categories/MongoDB/"/>
    
    
      <category term="Java与MongoDB" scheme="http://luxiaowan.github.io/tags/Java%E4%B8%8EMongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB监控、分片及备份恢复</title>
    <link href="http://luxiaowan.github.io/2019/10/24/MongoDB%E7%9B%91%E6%8E%A7%E3%80%81%E5%88%86%E7%89%87%E5%8F%8A%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"/>
    <id>http://luxiaowan.github.io/2019/10/24/MongoDB监控、分片及备份恢复/</id>
    <published>2019-10-23T16:00:00.000Z</published>
    <updated>2019-10-24T13:20:12.764Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://luxiaowan.github.io/categories/MongoDB/"/>
    
    
      <category term="监控" scheme="http://luxiaowan.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB基本指令</title>
    <link href="http://luxiaowan.github.io/2019/10/23/MongoDB%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
    <id>http://luxiaowan.github.io/2019/10/23/MongoDB基本指令/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-10-24T13:20:12.763Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>查看所有的db</p><p><code>show dbs</code></p></li><li><p>切换db</p><p><code>user &lt;db_name&gt;</code></p></li><li><p>查看当前所在db名称</p><p><code>db</code></p></li><li><p>删除db**(必须在要删除的db中操作)**</p><p><code>db.dropDatabase()</code></p></li><li><p>查看db下所有的集合</p><p><code>show tables</code></p><p><code>show collections</code></p></li><li><p>创建集合</p><ul><li><code>db.createCollection(&quot;abc&quot;)</code></li><li><code>db.createCollection(&quot;def&quot;, {capped: true, autoIndexId: true, size: 1024, max: 100})</code></li><li>往一张不存在的集合中插入一条数据，会自动创建集合<ul><li><code>db.test.insert({title: 123})</code></li></ul></li></ul></li><li><p>删除集合</p><p><code>db.&lt;collection_name&gt;.drop()</code></p><p>例：<code>db.abc.drop()</code></p></li><li><p>插入文档</p><ul><li><p><code>db.&lt;collection_name&gt;.insert({title: 1234})</code></p></li><li><p><code>doc=({title: 12345, name: &quot;MongoDB指南&quot;})</code></p><p><code>db.&lt;collection_name&gt;.insert(doc)</code></p></li><li><p><code>db.&lt;collection_name&gt;.save({name: &quot;MongoDB简单指令&quot;}})</code></p></li><li><p><code>doc2=({name: &quot;MongoDB从入门到放弃&quot;})</code></p><p><code>db.&lt;collection_name&gt;.save(doc2)</code></p></li><li><p><code>doc3=({_id: &quot;edrftgyhjkgjhfgv2ryuoio&quot;, name: &quot;MongoDB从入门到放弃&quot;})</code></p><p><code>db.&lt;collection_name&gt;.save(doc3)</code>// 若_id对应值的数据已经存在，则更新这条数据，否则新增一条数据</p></li></ul></li><li><p>更新文档</p><ul><li><code>db.&lt;collection_name&gt;.update({title: 1234}, {$set:{title: &quot;4321&quot;}})</code></li></ul><blockquote><p>格式：</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.update(</span><br><span class="line">&lt;where&gt;,<span class="regexp">//</span> 相当于MySQL的where</span><br><span class="line">&lt;update&gt;,<span class="regexp">//</span> 相当于MySQL的update语句的set，需要跟一些指令：<span class="variable">$,</span><span class="variable">$inc</span>,<span class="variable">$set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="symbol">upsert:</span> <span class="keyword">true</span>,<span class="regexp">//</span> <span class="keyword">true</span>：如果不存在记录，则新增；<span class="keyword">false</span>相反，默认</span><br><span class="line"><span class="symbol">multi:</span> <span class="keyword">true</span>,<span class="regexp">//</span> <span class="keyword">true</span>：只更新第一条匹配的记录；<span class="keyword">false</span>相反，全部更新， 默认</span><br><span class="line"><span class="symbol">writeConcern:</span> &lt;document&gt;<span class="regexp">//</span> 异常级别</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 1. 只更新第一条记录：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 1 &#125; &#125; , &#123; <span class="variable">$set</span> : &#123; <span class="string">"test2"</span> : <span class="string">"OK"</span>&#125; &#125; );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2. 全部更新：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 3 &#125; &#125; , &#123; <span class="variable">$set</span> : &#123; <span class="string">"test2"</span> : <span class="string">"OK"</span>&#125; &#125;,<span class="literal">false</span>,<span class="literal">true</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 3. 只添加第一条：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 4 &#125; &#125; , &#123; <span class="variable">$set</span> : &#123; <span class="string">"test5"</span> : <span class="string">"OK"</span>&#125; &#125;,<span class="literal">true</span>,<span class="literal">false</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 4. 全部添加进去:</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 5 &#125; &#125; , &#123; <span class="variable">$set</span> : &#123; <span class="string">"test5"</span> : <span class="string">"OK"</span>&#125; &#125;,<span class="literal">true</span>,<span class="literal">true</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 5. 全部更新：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 15 &#125; &#125; , &#123; <span class="variable">$inc</span> : &#123; <span class="string">"count"</span> : 1&#125; &#125;,<span class="literal">false</span>,<span class="literal">true</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 6. 只更新第一条记录：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : 10 &#125; &#125; , &#123; <span class="variable">$inc</span> : &#123; <span class="string">"count"</span> : 1&#125; &#125;,<span class="literal">false</span>,<span class="literal">false</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><ul><li><p><code>db.&lt;collection_name&gt;.save()</code></p><p>调用save指令一般需要指定_id</p></li></ul></li><li><p>删除文档</p><p><code>db.&lt;collection_name&gt;.remove({title: &quot;4321&quot;}, true)</code></p><blockquote><p>格式</p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="params">&lt;collection_name&gt;</span>.remove(</span><br><span class="line"><span class="params">&lt;where&gt;</span>,<span class="comment">// 相当于MySQL的where</span></span><br><span class="line"><span class="params">&lt;justOne&gt;</span><span class="comment">// true：只删除一条匹配条件的数据；false：匹配条件的数据全部删除，默认</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>删除集合中所有数据</p><p><code>db.&lt;collection_name&gt;.remove({})</code></p></li><li><p>新函数：</p><ul><li><code>db.&lt;collection_name&gt;.deleteMany({})</code></li><li><code>db.&lt;collection_name&gt;.deleteOne({title: &quot;12345&quot;})</code></li></ul></li></ul></li><li><p>查询文档</p><ol><li>普通查询</li></ol><blockquote><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.&lt;collection_name&gt;.find(</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;<span class="built_in">where</span>&gt;, // 查询条件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;colName&gt;// 返回字段名称</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> )</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><ul><li>创建一个集合，插入三条数据</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.insert([&#123;<span class="string">name:</span> <span class="string">"cc"</span>, <span class="string">age:</span> <span class="string">"29"</span>, <span class="string">gender:</span> <span class="number">1</span>&#125;, &#123;<span class="string">name:</span> <span class="string">"ccc"</span>, <span class="string">age:</span> <span class="string">"30"</span>, <span class="string">gender:</span> <span class="number">2</span>&#125;, &#123;<span class="string">name:</span> <span class="string">"c"</span>, <span class="string">age:</span> <span class="string">"28"</span>, <span class="string">gender:</span> <span class="number">1</span>&#125;])</span><br></pre></td></tr></table></figure><ul><li><p>查询集合中全部数据</p><p>普通显示：<code>db.user.find()</code></p><p>格式化显示：<code>db.user.find().pretty()</code></p></li><li><p>查询name=&quot;c&quot;的信息</p><p><code>db.user.find({name: &quot;c&quot;}).pretty()</code></p></li><li><p>查询只返回第一个匹配到的数据</p><p><code>db.user.findOne({name: &quot;c&quot;})</code></p></li></ul><ol start="2"><li><p>AND查询</p><p><code>db.user.find({key: value, key: value})</code></p><p>And查询即是在where条件里面用逗号&quot;,&quot;分隔</p><blockquote><p>栗子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.<span class="builtin-name">find</span>(&#123;name:<span class="string">"cc"</span>, gender:1&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; ---</span><br><span class="line">&gt; 等同于MySQL：</span><br><span class="line">&gt; select * <span class="keyword">from</span><span class="built_in"> user </span>where name = <span class="string">"c"</span> <span class="keyword">AND</span> gender = 1</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>OR查询</p><p><code>db.user.find({$or:[{key:value}, {key:value}]})</code></p><blockquote><p>栗子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.<span class="builtin-name">find</span>(&#123;</span><br><span class="line">&gt; <span class="variable">$or</span>:[&#123;name:<span class="string">"c"</span>&#125;, &#123;gender:2&#125;]</span><br><span class="line">&gt; &#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; ---</span><br><span class="line">&gt; 等同于MySQL：</span><br><span class="line">&gt; select * <span class="keyword">from</span><span class="built_in"> user </span>where name = <span class="string">"c"</span> <span class="keyword">OR</span> gender = 2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>AND和OR组合查询</p><p><code>db.user.find({key:value, $or:[{key:value}, {key:value}]})</code></p><blockquote><p>栗子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.<span class="builtin-name">find</span>(&#123;gender:1, <span class="variable">$or</span>:[&#123;name: <span class="string">"c"</span>&#125;, &#123;age: <span class="string">"28"</span>&#125;]&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; ---</span><br><span class="line">&gt; 等同于MySQL：</span><br><span class="line">&gt; select * <span class="keyword">from</span><span class="built_in"> user </span>where gender = 1 <span class="keyword">AND</span> (name = <span class="string">"c"</span> <span class="keyword">OR</span> age = <span class="string">"28"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p>运算符</p><table><thead><tr><th>运算符</th><th>格式</th><th>案例</th><th>MySQL对应语句</th></tr></thead><tbody><tr><td>等于</td><td>{key:value}<br>{key:{$eq:value}}</td><td>db.user.find({age:“29”})<br>db.user.find({age:{$eq:“29”}})</td><td>where age = “29”</td></tr><tr><td>大于</td><td>{key:{$gt: value}}</td><td>db.user.find({age:{$gt:“30”}})</td><td>where age &gt; “30”</td></tr><tr><td>小于</td><td>{key:{$lt: value}}</td><td>db.user.find({age:{$lt: “30”}})</td><td>where age &lt; “30”</td></tr><tr><td>大于等于</td><td>{key:{$gte: value}}</td><td>db.user.find({age:{$gte:“30”}})</td><td>where age &gt;= “30”</td></tr><tr><td>小于等于</td><td>{key:{$lte: value}}</td><td>db.user.find({age:{$lte:“30”}})</td><td>where age &lt;= “30”</td></tr><tr><td>不等于</td><td><span class="katex-error" title="ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: {key:{">{key:{</span>ne: value}}</td><td>db.user.find({age:{$ne:“29”}})</td><td>where age != “30”</td></tr></tbody></table></blockquote><ol start="5"><li><p>模糊查询</p><ul><li>查询age包含0的：<code>db.user.find({age:/0/})</code></li><li>查询age以2开头的：db.user.find({age:/^2/})</li><li>查询age以8结束的：db.user.find({age:/8$/})</li></ul></li><li><p>分页查询</p><blockquote><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.&lt;collection_name&gt;.find().<span class="built_in">limit</span>(Number).skip(Number)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">limit</span>(Number)表示查询多少条数据</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> skip(Number)表示从第几条开始查询</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><ul><li><p>查询一条数据</p><ul><li>第一种方法：<code>db.user.findOne({})</code></li><li>第二种方法：<code>db.user.find({}).limit(1)</code></li></ul></li><li><p>从第二条数据开始查询一条数据</p><p><code>db.user.find().limit(1).skip(2)</code></p></li></ul></li><li><p>查询排序</p><blockquote><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.&lt;collection_name&gt;.find().sort(&#123;&lt;key_name&gt;:-1/1&#125;)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;key_name&gt;：排序字段</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -1：倒序</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1：正序</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><ul><li><p>按照年龄倒序</p><p><code>db.user.find().sort({age:-1})</code></p></li><li><p>按照年龄倒序、性别正序</p><p><code>db.user.find().sort({age:-1, gender:1})</code></p></li></ul></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看所有的db&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show dbs&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换db&lt;/p&gt;
&lt;p&gt;&lt;code&gt;user &amp;lt;db_name&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看当前所在db
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://luxiaowan.github.io/categories/MongoDB/"/>
    
    
      <category term="基本指令" scheme="http://luxiaowan.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB基础应用</title>
    <link href="http://luxiaowan.github.io/2019/10/23/MongoDB%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    <id>http://luxiaowan.github.io/2019/10/23/MongoDB基础应用/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-10-24T13:20:12.764Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h3><blockquote><p>说明：索引是为了加快查询速度，可以对集合中的一列或多列设置索引。</p><p>– 无索引：扫描整个集合的文档，查找符合条件的文档</p><p>– 有索引：查找索引，根据索引取出文档数据</p></blockquote><ol><li><p>创建索引</p><p><code>db.&lt;collection_name&gt;.createIndex(keys, option)</code></p><blockquote><p>栗子：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 单索引</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.user</span><span class="selector-class">.createIndex</span>(&#123;<span class="attribute">age</span>:-<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">---</span></span><br><span class="line"><span class="selector-tag">age</span>:索引列名</span><br><span class="line"><span class="selector-tag">-1</span>:倒序索引</span><br><span class="line">1:正序索引</span><br><span class="line"></span><br><span class="line">2. 多索引(复合索引)</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.user</span><span class="selector-class">.createIndex</span>(&#123;<span class="attribute">age</span>:<span class="number">1</span>, gender:-<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>可选参数</li></ul><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>background</td><td>Boolean</td><td>指定创建索引时是否阻塞集合的其他操作。true:后台执行，不阻塞；false:阻塞，默认</td></tr><tr><td>unique</td><td>Boolean</td><td>指定索引是否为唯一索引。true:唯一索引；false:不唯一，默认</td></tr><tr><td>name</td><td>String</td><td>索引名称，默认为字段名+索引顺序</td></tr><tr><td>v</td><td>index<br>version</td><td>索引版本号，默认为当前mongo的版本号</td></tr><tr><td>weights</td><td>Integer</td><td>1~99999之间，值越大权重越大</td></tr><tr><td>expireAfterSeconds</td><td>Integer</td><td>指定集合生存时间。秒级，TTL</td></tr><tr><td>sparse</td><td>Boolean</td><td>指定是否忽略不存在的字段。true:不查出不包含查询字段的文档；false:查询所有文档，默认</td></tr></tbody></table><blockquote><p>栗子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.create<span class="constructor">Index(&#123;<span class="params">name</span>:1&#125;, &#123;<span class="params">background</span>: <span class="params">true</span>, <span class="params">unique</span>: <span class="params">true</span>, <span class="params">name</span>: <span class="string">"idx_user_name"</span>, <span class="params">v</span>: 1, <span class="params">weights</span>: 99, <span class="params">sparse</span>: <span class="params">true</span>&#125;)</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; ---</span><br><span class="line">&gt; 后台不阻塞集合的方式创建一个name列正序,版本号为<span class="number">1</span>,权重<span class="number">99</span>,忽略无name字段的文档的唯一索引idx_user_name</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>查看所有索引</p><p><code>db.&lt;collection_name&gt;.getIndexes()</code></p><blockquote><p>栗子：</p><p><code>db.user.getIndexes()</code></p></blockquote></li><li><p>重建索引</p><ul><li><p>方法1：<code>db.&lt;collection_name&gt;.reIndex()</code></p></li><li><p>方法2：先删除原索引，然后再创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="tag">&lt;<span class="name">collection_name</span>&gt;</span>.dropIndex(<span class="tag">&lt;<span class="name">idx_name</span>&gt;</span>)</span><br><span class="line">db.<span class="tag">&lt;<span class="name">collection_name</span>&gt;</span>.createIndex(...)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除索引</p><ul><li><p>删除指定名称的索引：</p><p><code>db.user.dropIndex(&lt;idx_name&gt;)</code></p></li><li><p>删除集合中所有索引</p><p><code>db.user.dropIndexes()</code></p><blockquote><p>说明：只会删除自建的索引，集合中_id列的索引不会被删除</p></blockquote></li></ul></li></ol><hr><h3 id="聚合查询"><a class="markdownIt-Anchor" href="#聚合查询"></a> 聚合查询</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">创建集合并插入数据：</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.agg</span><span class="selector-class">.save</span>([&#123;</span><br><span class="line">   <span class="attribute">title</span>: <span class="string">'MongoDB Overview'</span>, </span><br><span class="line">   <span class="attribute">description</span>: <span class="string">'MongoDB is no sql database'</span>,</span><br><span class="line">   <span class="attribute">by_user</span>: <span class="string">'runoob.com'</span>,</span><br><span class="line">   <span class="attribute">url</span>: <span class="string">'http://www.runoob.com'</span>,</span><br><span class="line">   <span class="attribute">tags</span>: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   <span class="attribute">likes</span>: <span class="number">100</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">title</span>: <span class="string">'NoSQL Overview'</span>, </span><br><span class="line">   <span class="attribute">description</span>: <span class="string">'No sql database is very fast'</span>,</span><br><span class="line">   <span class="attribute">by_user</span>: <span class="string">'runoob.com'</span>,</span><br><span class="line">   <span class="attribute">url</span>: <span class="string">'http://www.runoob.com'</span>,</span><br><span class="line">   <span class="attribute">tags</span>: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   <span class="attribute">likes</span>: <span class="number">10</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attribute">title</span>: <span class="string">'Neo4j Overview'</span>, </span><br><span class="line">   <span class="attribute">description</span>: <span class="string">'Neo4j is no sql database'</span>,</span><br><span class="line">   <span class="attribute">by_user</span>: <span class="string">'Neo4j'</span>,</span><br><span class="line">   <span class="attribute">url</span>: <span class="string">'http://www.neo4j.com'</span>,</span><br><span class="line">   <span class="attribute">tags</span>: [<span class="string">'neo4j'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   <span class="attribute">likes</span>: <span class="number">750</span></span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure><blockquote><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.&lt;collection_name&gt;.aggregate(condition)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> condition:</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [&#123;<span class="variable">$group</span>:&#123;_id:<span class="string">"$&lt;key&gt;"</span>, num_tutorial:&#123;$&lt;fun_expression&gt;:<span class="string">"$&lt;key&gt;"</span>&#125;&#125;&#125;]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="variable">$group</span>:一个组</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> _id:组合列，类同于MySQL的group by后面的字段，默认_id的列会在查询结果中显示</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> num_tutorial:输出的列名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $&lt;fun_expression&gt;:聚合表达式</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $&lt;key&gt;:运算的列名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>关键字：aggregate</p><p>说明：聚合查询就是求和、最大、最小、最前、最后、平均数的统称，类似于MySQL的count()、sum()、avg()</p></blockquote><blockquote><p>栗子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.aggregate([&#123;<span class="variable">$group</span>: <span class="variable">$&#123;_id:"$gender", num_tutorial:&#123;$sum:1&#125;</span>&#125;&#125;])</span><br><span class="line">&gt; </span><br><span class="line">&gt; ---</span><br><span class="line">&gt; 等同于MySQL：select gender, count(1) <span class="keyword">from</span><span class="built_in"> user group </span>by gender</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ol><li>聚合表达式</li></ol><table><thead><tr><th>表达式</th><th>描述</th><th>案例</th></tr></thead><tbody><tr><td>$sum</td><td>计算总和</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$sum:&quot;$likes&quot;}}}])</code><br>—<br>等同于MySQL：<code>select by_user, sum(likes) from agg group by by_user</code></td></tr><tr><td>$avg</td><td>计算平均值</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$avg:&quot;$likes&quot;}}}])</code><br>—<br>等同于MySQL：<code>select by_user, avg(likes) from agg group by by_user</code></td></tr><tr><td>$min</td><td>获取集合中指定列的最小值记录</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$min:&quot;$like&quot;}}}])</code><br>—<br>等同于MySQL：<code>select by_user, min(likes) from agg group by by_user</code></td></tr><tr><td>$max</td><td>获取集合中指定列的最大值记录</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$max:&quot;$likes&quot;}}}])</code><br>—<br>等同于MySQL：<code>select by_user, max(likes) from agg group by by_user</code></td></tr><tr><td>$push</td><td>在结果文档中插入值到数组</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$push:&quot;$url&quot;}}}])</code><br>—<br>等同于MySQL：查出所有数据，然后取字段url写入同一个列表中，url不去重，然后输出</td></tr><tr><td>$addToSet</td><td>在结果文档中插入值到一个数组中，但不创建副本</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$addToSet:&quot;$url&quot;}}}])</code><br>—<br>等同于MySQL：查出所有数据，然后取字段url写入同一个列表中，url去重，然后输出</td></tr><tr><td>$first</td><td>根据资源文档的排序获取第一个文档数据</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$first:&quot;$title&quot;}}}])</code></td></tr><tr><td>$last</td><td>根据资源文档的排序获取最后一个文档数据</td><td><code>db.agg.aggregate([{$group:{_id:&quot;$by_user&quot;, num_tutorial:{$last:&quot;$title&quot;}}}])</code></td></tr></tbody></table><hr><h3 id="管道函数"><a class="markdownIt-Anchor" href="#管道函数"></a> 管道函数</h3><blockquote><p>说明：管道函数类似于Linux系统中的管道操作，将上一步的运算结果作为下一步的输入值，最终达到理想计算结果的运算方式</p></blockquote><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>$project</td><td>指定需要输出的列，默认显示_id，格式：{$project:{by_user:1, title:1, url:1, _id:0<code>不显示id</code>}},</td></tr><tr><td>$limit</td><td>限制查询返回的文档数，格式：{$limit: 1},只返回一个文档</td></tr><tr><td>$skip</td><td>跳过指定数量的文档，返回之后的所有文档，格式：{$skip: 1},从第二个文档开始输出</td></tr><tr><td>$match</td><td>条件筛选，格式：{<span class="katex-error" title="ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …atch: {likes: {">match: {likes: {</span>gte: 10}}}</td></tr><tr><td>$group</td><td>聚合条件，格式：{<span class="katex-error" title="ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: group: {_id: &quot;">group: {_id: &quot;</span>by_user&quot;, count: {$sum: -1}}}</td></tr><tr><td>$sort</td><td>排序，格式：{$sort: {likes: -1}}，-1:倒序; 1:正序</td></tr><tr><td>$unwind</td><td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值</td></tr><tr><td>$geoNear</td><td>输出接近某一地理位置的有序文档。</td></tr></tbody></table><blockquote><p>栗子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.agg.aggregate(&#123;<span class="variable">$match</span>: &#123;likes: &#123;<span class="variable">$gte</span>: 10&#125;&#125;&#125;, &#123; <span class="variable">$project</span>: &#123;_id: 0, title: 1, by_user: 1, likes: 1&#125;&#125;, &#123;<span class="variable">$limit</span>: 5&#125;, &#123;<span class="variable">$skip</span>: 1&#125;, &#123;<span class="variable">$sort</span>: &#123;likes: -1&#125;&#125;)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 等同于MySQL: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> select title, by_user, likes from agg <span class="built_in">where</span> likes &gt;= 10 order by likes desc <span class="built_in">limit</span> 1,5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#索引&quot;&gt;&lt;/a&gt; 索引&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：索引是为了加快查询速度，可以对集合中的一列或多列设置索引。&lt;/p&gt;
&lt;p&gt;– 无索引：扫描整个集合的文档，查找符
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://luxiaowan.github.io/categories/MongoDB/"/>
    
    
      <category term="基础应用" scheme="http://luxiaowan.github.io/tags/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB连接报错java.lang.NoSuchFieldError ACKNOWLEDGED</title>
    <link href="http://luxiaowan.github.io/2019/10/23/MongoDB%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99java.lang.NoSuchFieldError-ACKNOWLEDGED/"/>
    <id>http://luxiaowan.github.io/2019/10/23/MongoDB连接报错java.lang.NoSuchFieldError-ACKNOWLEDGED/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-10-24T13:20:12.764Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BUG描述</p></blockquote><p>使用SpringBoot整合MongoDB时，正要运行代码连接mongo，就赤红赤红的报了个错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.NoSuchFieldError</span>: ACKNOWLEDGED</span><br><span class="line">at com<span class="selector-class">.mongodb</span><span class="selector-class">.MongoClientOptions</span><span class="variable">$Builder</span>.&lt;init&gt;(MongoClientOptions<span class="selector-class">.java</span>:<span class="number">960</span>)</span><br><span class="line">at com<span class="selector-class">.mongodb</span><span class="selector-class">.MongoClient</span>.&lt;init&gt;(MongoClient<span class="selector-class">.java</span>:<span class="number">155</span>)</span><br><span class="line">at com<span class="selector-class">.mongodb</span><span class="selector-class">.MongoClient</span>.&lt;init&gt;(MongoClient<span class="selector-class">.java</span>:<span class="number">145</span>)</span><br><span class="line">at com<span class="selector-class">.example</span><span class="selector-class">.demo</span><span class="selector-class">.mongo</span><span class="selector-class">.MongoConnectTest</span><span class="selector-class">.main</span>(MongoConnectTest<span class="selector-class">.java</span>:<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>这一下就傻眼了，对于刚接触mongo的人来说，是很懵圈的，大脑知识库中没有这个异常信息的解决办法，只能谷歌了，没想到有那么多人遇到过这个问题</p><hr><blockquote><p>BUG解决</p></blockquote><p>在Stack Overflow上找到一个帖子：</p><blockquote><p><a href="https://stackoverflow.com/questions/13593614/mongodb-java-lang-nosuchfielderror" target="_blank" rel="noopener">https://stackoverflow.com/questions/13593614/mongodb-java-lang-nosuchfielderror</a></p></blockquote><p>其中jyemin的回答可以说是直击要害了，顺利的解决了这个问题，我把截图贴上，以防帖子被删</p><blockquote><blockquote><p><img src="/images/image-20191023182806521.png" alt="image-20191023182806521"></p></blockquote></blockquote><p><strong>其实就是在工程中引入了多个版本不同的mongo-java-driver，所以导致程序混乱，只要保留自己真正使用的那个版本，其他的都删除即可</strong></p><blockquote><p>我的配置：</p><blockquote><p><img src="/images/image-20191023183034949.png" alt="image-20191023183034949"></p></blockquote><p>将2.7.1版本的依赖删除就可以正常运行了</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;BUG描述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用SpringBoot整合MongoDB时，正要运行代码连接mongo，就赤红赤红的报了个错：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://luxiaowan.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB错误记录" scheme="http://luxiaowan.github.io/tags/MongoDB%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Git Stash用法</title>
    <link href="http://luxiaowan.github.io/2019/10/22/git%20stash%E5%91%BD%E4%BB%A4/"/>
    <id>http://luxiaowan.github.io/2019/10/22/git stash命令/</id>
    <published>2019-10-21T16:00:00.000Z</published>
    <updated>2019-10-24T13:20:12.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建仓库"><a class="markdownIt-Anchor" href="#创建仓库"></a> 创建仓库</h3><ol><li>git init</li><li>echo 123 &gt; test.txt</li><li>git add .</li><li>git commit -m “add test file”</li><li>git remote add origin git@git.xx.xx.xx:xxx/xxx.git</li><li>git push origin master</li></ol><p><em>以上内容比较简单，就不作详细讲述，如果上面的内容看不懂，下面的请放弃</em></p><h3 id="使用git-stash暂存"><a class="markdownIt-Anchor" href="#使用git-stash暂存"></a> 使用git stash暂存</h3><ol><li><p>随意修改test.txt文件的内容，比如：画个心形，你正热火朝天修改中……</p></li><li><p>这时领导走过来拍了拍你的肩膀说到：”小伙子啊，创建个<code>朕.txt</code>文件提交上来，内容就写<code>我还想再活五百年</code>，test.txt文件这一版不作修改“。</p></li><li><p><strong>你面露笑容的回答：“好的，没问题！”，内心却是：“MMP,MMP,MMP……”</strong></p></li><li><p>辛辛苦苦修改的<code>test.txt</code>文件怎么办？眼瞅着就要完成了，难道复制出去，然后等解决领导需求后再粘贴回来？low不low？肯定<code>不low</code>啊，一个文件而已，这种方法很简单，*但是当你实际项目中修改了几十个文件的时候呢？*挨个儿复制出去？累傻小子呐？！！！！！</p></li><li><p><code>git stash</code>命令帮你解决问题，stash是存储的意思，也就是将当前工作区内的所有东西都存储起来，然后工作区所有文件恢复到修改之前的状态(并不是最新状态，不会和仓库中进行自动同步，需要你自己去pull)，然后你就可以继续完成任务了。(<font color="red">在执行git stash之前需要先执行git add命令</font>)</p><p>stash可以进行多次操作，每次操作都会将当前工作区的文件情况暂存起来，stash是类栈存储，每次stash的序号都为0，此次之前stash的序号会自动+1</p></li></ol><h3 id="使用git-stash-pop取出"><a class="markdownIt-Anchor" href="#使用git-stash-pop取出"></a> 使用git stash pop取出</h3><ol><li><code>git stash pop</code>取出栈顶元素，也就是序号为0的那个，即最近一次执行<code>git stash</code>保存的内容。pop之后，暂存列表中就会自动将其清除掉，这个时候你再执行<code>git stash list</code>会发现毛都没有</li><li>这个时候可能就会纳闷了，我保存了好几次，但是我这次是想使用最开始stash的那份内容，怎么办？一直pop，直到最后一次？当然不行，上面刚讲过pop之后暂存列表中就没有stash的信息了，已经被pop出去的就找不回来了，等于是自杀式攻击，那咋整呢？</li><li><code>git stash apply stash@{序号}</code>可以将指定序号的stash内容弹出到工作区，此时工作区里文件的状态就和<code>stash@{序号}</code>里的一致了，但是这个命令<strong>无法将stash记录从暂存列表中删除，仅仅只是将文件恢复而已</strong></li><li><code>git stash drop stash@{序号}</code>来丢弃暂存列表中的记录，可以配合apply使用</li></ol><h3 id="查看暂存记录中的信息"><a class="markdownIt-Anchor" href="#查看暂存记录中的信息"></a> 查看暂存记录中的信息</h3><ol><li>查看暂存列表：<code>git stash list</code>查看当前stash的列表</li><li>查看暂存内容：<code>git stash show stash@{序号}</code>查看指定序号的stash的内容</li></ol><h3 id="git-stash-save-msg"><a class="markdownIt-Anchor" href="#git-stash-save-msg"></a> git stash save ‘msg’</h3><p>等于是在stash的时候打了个标签，妖娆！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;创建仓库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#创建仓库&quot;&gt;&lt;/a&gt; 创建仓库&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;git init&lt;/li&gt;
&lt;li&gt;echo 123 &amp;gt; test.txt&lt;/li&gt;
&lt;li&gt;git add .&lt;
      
    
    </summary>
    
    
      <category term="Git" scheme="http://luxiaowan.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Hash索引相关</title>
    <link href="http://luxiaowan.github.io/2019/10/12/Hash%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://luxiaowan.github.io/2019/10/12/Hash索引相关/</id>
    <published>2019-10-12T15:42:43.000Z</published>
    <updated>2019-10-21T15:48:05.043Z</updated>
    
    <content type="html"><![CDATA[<p>hash索引结构使用方式较为局限，仅适用于=、IN和&lt;=&gt;三种，但是由于通过hash可以直接查找到具体的值，而不用像BT那样每次都从root节点开始遍历，所以在通常情况下，hash的查找效率要比BT高。</p><p>hash的缺陷：</p><h6 id="1-hash不能进行范围查找"><a class="markdownIt-Anchor" href="#1-hash不能进行范围查找"></a> 1. hash不能进行范围查找</h6><p>值在计算hash后，并不能保证计算后的hash值和计算前的大小排列一样，所以hash不适用于范围查找</p><h6 id="2-hash不能进行排序查询"><a class="markdownIt-Anchor" href="#2-hash不能进行排序查询"></a> 2. hash不能进行排序查询</h6><p>值计算后的hash值无法保证与原值大小顺序一样，所以无法进行排序</p><h6 id="3-组合索引不能使用部分字段查询"><a class="markdownIt-Anchor" href="#3-组合索引不能使用部分字段查询"></a> 3. 组合索引不能使用部分字段查询</h6><p>组合索引的hash值是所有索引字段的值组合在一起进行计算的，若仅使用部分字段进行查询的话，计算出的hash值基本不会与索引的hash值相同</p><h6 id="4-hash在出现大量值碰撞的时候性能会降低"><a class="markdownIt-Anchor" href="#4-hash在出现大量值碰撞的时候性能会降低"></a> 4. hash在出现大量值碰撞的时候，性能会降低</h6><p>hash出现大量的值相等的时候，需要进行表扫描以进行精确匹配，效率较低</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hash索引结构使用方式较为局限，仅适用于=、IN和&amp;lt;=&amp;gt;三种，但是由于通过hash可以直接查找到具体的值，而不用像BT那样每次都从root节点开始遍历，所以在通常情况下，hash的查找效率要比BT高。&lt;/p&gt;
&lt;p&gt;hash的缺陷：&lt;/p&gt;
&lt;h6 id=&quot;1
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="Java基础知识" scheme="http://luxiaowan.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Char和varchar简单介绍</title>
    <link href="http://luxiaowan.github.io/2019/10/12/char%E4%B8%8Evarchar%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://luxiaowan.github.io/2019/10/12/char与varchar简单介绍/</id>
    <published>2019-10-12T04:10:43.000Z</published>
    <updated>2019-10-21T16:19:50.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据长度"><a class="markdownIt-Anchor" href="#1-数据长度"></a> 1. 数据长度</h2><h3 id="1-char最大长度255个字节"><a class="markdownIt-Anchor" href="#1-char最大长度255个字节"></a> 1) char(<code>最大长度255个字节</code>)</h3><p>长度固定（字段存入数据长度始终等于字段长度）</p><h3 id="2-varchar最大长度65535个字节"><a class="markdownIt-Anchor" href="#2-varchar最大长度65535个字节"></a> 2) varchar(<code>最大长度65535个字节</code>)</h3><p>可变长度，存入数据长度为N个字节，则实际使用了N+1(255以上长度则+2)个字节的空间，多出来的1字节是用来存储数据实际长度。</p><ul><li>存入数据对比<ul><li>存入<code>&quot;ab&quot;</code><ul><li>char查询出<code>&quot;ab&quot;</code></li><li>varchar查询出<code>&quot;ab&quot;</code></li></ul></li><li>存入<code>&quot;ab &quot;</code>，<code>ab</code>后面有两个空格，<ul><li>char查询出<code>&quot;ab&quot;</code></li><li>varchar查询出<code>&quot;ab &quot;</code></li></ul></li></ul></li></ul><hr><blockquote><p>解析：</p></blockquote><p>​在入库时，数据库会自动在ab后面添加两位空格，让入库的数据长度保证等于4 <em><code>char(4)</code></em> ，这种操作很容易理解，但是如果你去数据表里面去查这条数据，会发现表中数据并没有空格，所以可以推断出这里是逻辑追加，所以在查询数据的时候会并不会出现引擎自动添加的空格。</p><hr><h2 id="2-实操技术一定要font-colorred实操font"><a class="markdownIt-Anchor" href="#2-实操技术一定要font-colorred实操font"></a> 2. 实操(技术一定要**<font color="red">实操</font>**)</h2><h4 id="1无空格数据"><a class="markdownIt-Anchor" href="#1无空格数据"></a> 1）无空格数据</h4><blockquote><p>先创建一张表</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table cv(c char(4), v varchar(4));</span><br></pre></td></tr></table></figure><blockquote><p>插入数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into cv values(&quot;ab&quot;, &quot;ab&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>查询数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(&apos;(&apos;, c, &apos;)&apos;) AS c, concat(&apos;(&apos;, v, &apos;)&apos;) AS v from cv;</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><p><img src="/images/image-20191012152503483.png" alt="image-20191012152503483"></p><blockquote><blockquote><p>结果中char和varchar均查出来为无空格的ab</p></blockquote></blockquote><p>####2）有空格数据</p><blockquote><p>插入数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into cv values(&quot;ab  &quot;, &quot;ab  &quot;);</span><br></pre></td></tr></table></figure><blockquote><p>查询数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(&apos;(&apos;, c, &apos;)&apos;) AS c, concat(&apos;(&apos;, v, &apos;)&apos;) AS v from cv;</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><p><img src="/images/image-20191012152809508.png" alt="image-20191012152809508"></p><blockquote><blockquote><p>结果中可以看出，char类型将数据后面的空格自动去掉了，varchar则保留了所有的空格</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-数据长度&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-数据长度&quot;&gt;&lt;/a&gt; 1. 数据长度&lt;/h2&gt;
&lt;h3 id=&quot;1-char最大长度255个字节&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL使用查询缓存</title>
    <link href="http://luxiaowan.github.io/2019/10/11/MySQL%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/"/>
    <id>http://luxiaowan.github.io/2019/10/11/MySQL使用查询缓存/</id>
    <published>2019-10-11T05:01:23.000Z</published>
    <updated>2019-10-21T15:48:59.282Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>查询服务是否已开启缓存</p><blockquote><p>执行<code>show variables like '%query_cache%';</code>查看缓存状态</p></blockquote><blockquote><blockquote><p><img src="/images/image-20191011131957961.png" alt="image-20191011131957961"></p></blockquote></blockquote><p>Variable_name: query_cache_type为缓存状态，ON表示开启，OFF表示关闭</p></li><li><p>开启/关闭使用查询缓存</p><blockquote><p>修改my.cnf文件进行开启和关闭</p></blockquote><p>[mysqld]中添加/修改：<br>query_cache_size = 20M<br>query_cache_type = ON/OFF</p><blockquote><p>**修改完成后重启MySQL服务：<code>service mysql restart/systemctl mysql restart</code> **</p></blockquote></li><li><p>查询缓存使用情况</p><blockquote><p>执行<code>show status like 'qcache%';</code>查询缓存使用情况</p><blockquote><p><img src="/images/image-20191011132634921.png" alt="image-20191011132634921"></p></blockquote></blockquote><p>因为本机MySQL未开启查询缓存，所以此处和使用相关的属性均为0</p><hr><p><em><strong>属性解释:</strong></em></p><table><thead><tr><th>属性</th><th>释义</th></tr></thead><tbody><tr><td>Qcache_free_blocks</td><td>缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。</td></tr><tr><td>Qcache_free_memory</td><td>缓存中空闲内存大小</td></tr><tr><td>Qcache_hits</td><td>缓存命中次数，命中一次就+1</td></tr><tr><td>Qcache_inserts</td><td>查询次数，命中次数/查询次数=缓存命中率</td></tr><tr><td>Qcache_lowmem_prunes</td><td>缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数，如果数字不断增长，就可能碎片非常严重，或者内存很少，通过Qcache_free_blocks、Qcache_free_memory来分析具体情况</td></tr><tr><td>Qcache_not_cached</td><td>不适合进行缓存的查询的数量</td></tr><tr><td>Qcache_queries_in_cache</td><td>当前缓存的查询(和响应)的数量</td></tr><tr><td>Qcache_total_blocks</td><td>缓存中块的数量</td></tr></tbody></table></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查询服务是否已开启缓存&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行&lt;code&gt;show variables like &#39;%query_cache%&#39;;&lt;/code&gt;查看缓存状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;block
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
</feed>
