<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2020-05-15T17:44:56.241Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot内置Tomcat启动时间</title>
    <link href="http://luxiaowan.github.io/2020/05/15/SpringBoot%E5%86%85%E7%BD%AETomcat%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    <id>http://luxiaowan.github.io/2020/05/15/SpringBoot内置Tomcat启动时间/</id>
    <published>2020-05-15T10:22:00.000Z</published>
    <updated>2020-05-15T17:44:56.241Z</updated>
    
    <content type="html"><![CDATA[<h4 id="疑惑"><a class="markdownIt-Anchor" href="#疑惑"></a> 疑惑</h4><p>SpringBoot中内置了Tomcat容器，那么Tomcat是在什么时间点启动的？是先扫描包加载类再启动Tomcat？，还是先启动Tomcat再扫描包加载类？</p><p>我们做一下假设：</p><ol><li>先启动Tomcat，再扫描包加载类</li><li>先扫描包加载类，再启动Tomcat</li></ol><p>接下来我们做一下验证。</p><h4 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h4><p>首先创建一个空的SpringBoot工程，然后启动它，查看一下控制台的输出日志：</p><img src="/images/image-20200515183550832.png" alt="image-20200515183550832" style="zoom:50%;"><p>从输出的日志中可以看到②中显示Tomcat进行初始化，并且正在启动中，然后③中进行初始化<code>WebApplicationContext</code>，紧接着就是初始化<code>WebApplicationContext</code>完成，然后是在④中报告我们Tomcat启动完成。</p><p>从日志上看，好像是先启动Tomcat再去扫描包的，具体是怎么回事，我们看一下源码，暂时先不揭晓。</p><ul><li><p>从启动类中进入到<code>SpringApplication.run()</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建启动监控类，监控启动过程用了多久，但是ms</span></span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  <span class="comment">// 开始计时，设置开始时间</span></span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="comment">// 上下文实例</span></span><br><span class="line">  ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 启动异常错误报告</span></span><br><span class="line">  Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 启用headless模式（headless模式是在系统缺少部分硬件支持的时候让服务自力更生）</span></span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line">  <span class="comment">// 获取spring.factories文件中配置的org.springframework.boot.SpringApplicationRunListener列表，原理是Spring的事件机制，所有的类都实现自ApplicationEvent，可以监听启动过程中的任意阶段</span></span><br><span class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">  <span class="comment">// 进入监听启动阶段</span></span><br><span class="line">  listeners.starting();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取JVM运行参数，也就是在使用java -jar xxx.jar命令启动时指定的其他参数</span></span><br><span class="line">    ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">    <span class="comment">// 准备运行环境，传入监听器和运行参数，获取环境变量，绑定到环境中</span></span><br><span class="line">    ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">    <span class="comment">// 配置spring.beaninfo.ignore属性，SpringBoot中默认为true</span></span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line">    <span class="comment">// 输出Banner信息，banner的输出方式有三种：none/console/log，默认为console，通过配置参数spring.main.banner-mode指定</span></span><br><span class="line">    Banner printedBanner = printBanner(environment);</span><br><span class="line">    <span class="comment">// ☆创建一个上下文实例，比较重点的地方☆</span></span><br><span class="line">    context = createApplicationContext();</span><br><span class="line">    <span class="comment">// 获取spring.factories文件中声明的SpringBootExceptionReporter</span></span><br><span class="line">    exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                                                     <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">    <span class="comment">// 创建上下文，设置环境变量和资源加载器，创建bean，加载到所有的listener中</span></span><br><span class="line">    prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">    <span class="comment">// 调用spring的refresh方法，并注册一个ShutdownHook（应用关闭时的动作，可以通过继承AbstractApplicationContext实现自定义）</span></span><br><span class="line">    refreshContext(context);</span><br><span class="line">    <span class="comment">// 空方法</span></span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line">    <span class="comment">// 启动完成，停止计时</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">      <span class="comment">// 输出启动信息，包括计时</span></span><br><span class="line">      <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入监听器的启动完成事件</span></span><br><span class="line">    listeners.started(context);</span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 进入监听器的运行中事件</span></span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中并未看到是在哪里启动了Tomcat容器，那么我们就看一下创建Spring上下文的方法中是否有关键字</p></li><li><p>createApplicationContext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">  <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">        <span class="keyword">case</span> SERVLET:</span><br><span class="line">          <span class="comment">// org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REACTIVE:</span><br><span class="line">          <span class="comment">// org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// org.springframework.context.annotation.AnnotationConfigApplicationContext</span></span><br><span class="line">          contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个创建<code>ApplicationContext</code>实例的方法，我们只看Tomcat的<code>AnnotationConfigServletWebServerApplicationContext</code>，他的继承关系如下</p><p><img src="/images/AnnotationConfigServletWebServerApplicationContext.png" alt="AnnotationConfigServletWebServerApplicationContext"></p><p>以上类中并没有在静态代码块中启动Tomcat，则说明不是在这里启动的，这里只是创建一个<code>ApplicationContext</code>上下文实例</p></li><li><p>prepareContext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置环境变量</span></span><br><span class="line">  context.setEnvironment(environment);</span><br><span class="line">  <span class="comment">// 处理上下文</span></span><br><span class="line">  postProcessApplicationContext(context);</span><br><span class="line">  <span class="comment">// 做refresh前的初始化准备</span></span><br><span class="line">  applyInitializers(context);</span><br><span class="line">  <span class="comment">// 进入到监听器的上下文准备阶段</span></span><br><span class="line">  listeners.contextPrepared(context);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">    logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">    logStartupProfileInfo(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建特殊的引导类实例，单例的</span></span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">  beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">  <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建Banner类实例，单例的</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">    ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">    .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">    context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Load the sources</span></span><br><span class="line">  Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">  Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">  load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">  listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法里整个过程都在创建各种类的实例，并未出现对Tomcat的启动操作，看来也不在这个方法中，那么就继续往下看</p></li><li><p>refreshContext()方法</p><p>这个方法最终是调用到<code>AbstractApplicationContext#refresh()</code>中，这就到了Spring基础框架中。我们在分析createApplicationContext()方法的时候，知道Tomcat使用的是<code>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</code>类，这个类继承自<code>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext</code>，在这个类中，重写了父类<code>AbstractApplicationContext</code>中的refresh()、onRefresh()和finishRefresh()方法，而在<code>AbstractApplicationContext#refresh()</code>方法中，调用了onRefresh()和finishRefresh()这两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用的onRefresh()和finishRefresh()实际上是调用了<code>ServletWebServerApplicationContext</code>中的方法，那么我们就来看下这个类中的这两个方法分别做了什么</p><ul><li>onRefresh()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类的onRefresh()方法</span></span><br><span class="line">  <span class="keyword">super</span>.onRefresh();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建WebServer</span></span><br><span class="line">    createWebServer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Unable to start web server"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">  ServletContext servletContext = getServletContext();</span><br><span class="line">  <span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取ServletWebServerFactory的实例，使用Tomcat的话会获取到tomcatServletWebServerFactory</span></span><br><span class="line">    ServletWebServerFactory factory = getWebServerFactory();</span><br><span class="line">    <span class="comment">// 获取WebServer实例，方法内创建Tomcat并准备Tomcat启动所需环境变量</span></span><br><span class="line">    <span class="keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getSelfInitializer().onStartup(servletContext);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化自定义的环境变量，涉及到servletContextInitParams和servletConfigInitParams</span></span><br><span class="line">  initPropertySources();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ServletWebServerFactory <span class="title">getWebServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用bean名称，这样我们就不会考虑层次结构</span></span><br><span class="line">  String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class="line">  <span class="keyword">if</span> (beanNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取Bean实例，这里获取到的就是TomcatServletWebServerFactory类的实例</span></span><br><span class="line">  <span class="keyword">return</span> getBeanFactory().getBean(beanNames[<span class="number">0</span>], ServletWebServerFactory.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码我们知道在onRefresh()方法中主要是创建Tomcat实例，准备Tomcat启动所需参数和配置信息，并未启动Tomcat</p><ul><li>finishRefresh()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.finishRefresh();</span><br><span class="line">  <span class="comment">// 启动WebServer，难道是这里启动的Tomcat？</span></span><br><span class="line">  WebServer webServer = startWebServer();</span><br><span class="line">  <span class="keyword">if</span> (webServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    publishEvent(<span class="keyword">new</span> ServletWebServerInitializedEvent(webServer, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> WebServer <span class="title">startWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">  <span class="keyword">if</span> (webServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 启动WebServer，这里调用的是TomcatWebServer#start()方法</span></span><br><span class="line">    webServer.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> webServer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TomcatWebServer#start()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">  <span class="comment">// 加锁防并发</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.started) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      addPreviouslyRemovedConnectors();</span><br><span class="line">      <span class="comment">// 获取Tomcat的Connector</span></span><br><span class="line">      Connector connector = <span class="keyword">this</span>.tomcat.getConnector();</span><br><span class="line">      <span class="keyword">if</span> (connector != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.autoStart) &#123;</span><br><span class="line">        <span class="comment">// 如果connector不为null，并且自动启动，则启动时执行延迟加载</span></span><br><span class="line">        <span class="comment">// 当端口大于0的时候，autoStart就为true</span></span><br><span class="line">        performDeferredLoadOnStartup();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查Connector是否已启动，若有未启动的Connector则抛异常</span></span><br><span class="line">      checkThatConnectorsHaveStarted();</span><br><span class="line">      <span class="comment">// 修改运行标识属性</span></span><br><span class="line">      <span class="keyword">this</span>.started = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 输出Tomcat启动成功日志</span></span><br><span class="line">      logger.info(<span class="string">"Tomcat started on port(s): "</span> + getPortsDescription(<span class="keyword">true</span>) + <span class="string">" with context path '"</span></span><br><span class="line">                  + getContextPath() + <span class="string">"'"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectorStartFailedException ex) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里好像也仅仅就是检测Tomcat服务是否启动成功了，并没有执行启动这个操作，看来也不在这里。</p><p>这就奇怪了，我们几乎翻遍了整个启动类的代码，都没有Tomcat启动的代码，那么Tomcat是怎么启动的呢？是不是我们遗漏了什么？我们来回顾一下上面的分析，TomcatWebServer实例的获取的地方<code>ServletWebServerFactory#getWebServer()</code>方法内我们好像没有看，是不是在创建TomcatWebServer实例的时候直接就启动了，然后在<code>TomcatWebServer#start()</code>方法中只是去检测启动的状态？我们来看下<code>ServletWebServerFactory#getWebServer()</code>的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebServer <span class="title">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.disableMBeanRegistry) &#123;</span><br><span class="line">    Registry.disableRegistry();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 简单略过</span></span><br><span class="line">  Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">  File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span>) ? <span class="keyword">this</span>.baseDirectory : createTempDir(<span class="string">"tomcat"</span>);</span><br><span class="line">  tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">  Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">  connector.setThrowOnFailure(<span class="keyword">true</span>);</span><br><span class="line">  tomcat.getService().addConnector(connector);</span><br><span class="line">  customizeConnector(connector);</span><br><span class="line">  tomcat.setConnector(connector);</span><br><span class="line">  tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">  configureEngine(tomcat.getEngine());</span><br><span class="line">  <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">    tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">  &#125;</span><br><span class="line">  prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">  <span class="comment">// 获取TomcatWebServer实例</span></span><br><span class="line">  <span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不重要</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TomcatWebServer <span class="title">getTomcatWebServer</span><span class="params">(Tomcat tomcat)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// autoStart = getPort() &gt;= 0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatWebServer</span><span class="params">(Tomcat tomcat, <span class="keyword">boolean</span> autoStart)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(tomcat, <span class="string">"Tomcat Server must not be null"</span>);</span><br><span class="line">  <span class="keyword">this</span>.tomcat = tomcat;</span><br><span class="line">  <span class="keyword">this</span>.autoStart = autoStart;</span><br><span class="line">  <span class="comment">// 最重要的方法</span></span><br><span class="line">  initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>initialize()方法源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动服务器以触发初始化侦听器</span></span><br><span class="line">      <span class="keyword">this</span>.tomcat.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 所有Tomcat线程都是守护进程线程。我们创建一个阻塞非守护进程来停止立即关闭</span></span><br><span class="line">      startDaemonAwaitThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      stopSilently();</span><br><span class="line">      destroySilently();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> WebServerException(<span class="string">"Unable to start embedded Tomcat"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于找到了，语句<code>this.tomcat.start()</code>就是启动Tomcat容器的关监语句。</p></li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>通过对SpringApplication.run()方法执行顺序的分析来看，先构建Spring上下文加载Bean，也就是扫描包，然后再在refreshContext()方法中创建Tomcat容器并启动容器。</p><p>由此我们可以验证出假设2是正确的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;疑惑&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#疑惑&quot;&gt;&lt;/a&gt; 疑惑&lt;/h4&gt;
&lt;p&gt;SpringBoot中内置了Tomcat容器，那么Tomcat是在什么时间点启动的？是先扫描包加载类再启动Tomcat？，还是先启动Tomcat
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM指针碰撞和空闲列表</title>
    <link href="http://luxiaowan.github.io/2020/05/12/JVM%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8/"/>
    <id>http://luxiaowan.github.io/2020/05/12/JVM指针碰撞和空闲列表/</id>
    <published>2020-05-12T02:40:00.000Z</published>
    <updated>2020-05-12T03:17:43.831Z</updated>
    
    <content type="html"><![CDATA[<p>Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，在堆上为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，将对象放进去。常用的分配方法有指针碰撞和空闲列表两种实现方式。</p><h4 id="指针碰撞"><a class="markdownIt-Anchor" href="#指针碰撞"></a> 指针碰撞</h4><p>适用于堆内存完整的情况，已分配的内存和空闲内存分表在不同的一侧，通过一个指针指向分界点，当需要分配内存时，把指针往空闲的一端移动与对象大小相等的距离即可，用于Serial和ParNew等不会产生内存碎片的垃圾收集器。</p><img src="/images/image-20200512111153143.png" alt="image-20200512111153143" style="zoom:50%;"><h4 id="空闲列表"><a class="markdownIt-Anchor" href="#空闲列表"></a> 空闲列表</h4><p>适用于堆内存不完整的情况，已分配的内存和空闲内存相互交错，JVM通过维护一张内存列表记录可用的内存块信息，当分配内存时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录，最常见的使用此方案的垃圾收集器就是CMS。</p><img src="/images/image-20200512111650404.png" alt="image-20200512111650404" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，在堆上为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，将对象放进去。常用的分配方法有指针碰撞和空闲列表两种实现方式。&lt;/p&gt;
&lt;h4 id=&quot;指针碰撞&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>监听Redis中key过期事件</title>
    <link href="http://luxiaowan.github.io/2020/05/11/%E7%9B%91%E5%90%ACRedis%E4%B8%ADkey%E8%BF%87%E6%9C%9F%E4%BA%8B%E4%BB%B6/"/>
    <id>http://luxiaowan.github.io/2020/05/11/监听Redis中key过期事件/</id>
    <published>2020-05-11T15:20:00.000Z</published>
    <updated>2020-05-11T17:11:16.136Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中偶尔会遇到这样一个场景：用户下单之后，若30分钟内未完成支付，则取消订单。</p><p>做过电商业务的同学，尤其是做统一下单业务的同学一般都会接触过这个场景的需求，一般的处理方式是将订单数据存储到数据库中（MySQL之类的），然后由一个定时Job不断的去扫描符合条件的订单，修改订单状态为已取消。当然这只是其中一个处理办法，我们还可以使用到延时队列来处理。</p><p>那么如果我们使用Redis是否可以实现这一功能？我们知道在使用Redis的过程中，大多是由客户端主动的去操作服务端，比如set、del、get、expire等操作。而当一个key过期被删除的时候，由服务端主动的去通知客户端，这个要怎么做？</p><p>之前在一个项目中，是自己写了一个定时Job不断是去轮询要监听的某些key，然后如果发现Redis中不存在要get的key，则执行一段业务逻辑，我们的扫描频率取决于Job的执行频率，所以并不能保证key在过期时被立即监听到，如果n秒执行一次，则key最大可能会在2n-1秒之后被执行，会有一定的延迟，那么我们能否让Redis主动的在缓存失效的时候通知我们呢？</p><h4 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h4><p>由服务端主动通知客户端，那么就是需要通过一个事件来触发某项通知，事件通过Redis的订阅和发布功能来进行分发，我们查看Redis的配置文件中有一个EVENT NOTIFICATION配置，也名键空间通知</p><p><img src="/images/image-20200512002406401.png" alt="image-20200512002406401"></p><p>注释上说：Redis可以通知发布/订阅客户端关于键空间中发生的事件，如果Redis开启了键空间事件通知，且客户端订阅了某些键的事件，则在相应的键发生变动时，会通过发布/订阅向客户端发送两条消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:foo del</span><br><span class="line">PUBLISH __keyevent@0__:del foo</span><br></pre></td></tr></table></figure><p>客户端可以在一组类中选择Redis的通知事件，每个类都需要由唯一字符进行标识。</p><h5 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h5><p>当开启键空间通知功能时，需要额外的消耗一些CPU，所以此功能默认为关闭状态，可以通过修改redis.conf文件或者使用config set命令来开启或关闭键空间通知功能</p><ul><li>当<code>notify-keyspace-events</code>的值为空字符串时，功能关闭</li><li>当参数的值不是空字符串时，功能开启，且参数的值的取值范围是固定的</li></ul><blockquote><p>参数的可选值</p></blockquote><table><thead><tr><th>字符</th><th>通知事件</th></tr></thead><tbody><tr><td><code>K</code></td><td>键空间通知，所有通知以 <code>__keyspace@__</code> 为前缀</td></tr><tr><td><code>E</code></td><td>键事件通知，所有通知以 <code>__keyevent@__</code> 为前缀</td></tr><tr><td><code>g</code></td><td><code>DEL</code> 、 <code>EXPIRE</code> 、 <code>RENAME</code> 等类型无关的通用命令的通知</td></tr><tr><td><code>$</code></td><td>字符串命令的通知</td></tr><tr><td><code>l</code></td><td>列表命令的通知</td></tr><tr><td><code>s</code></td><td>集合命令的通知</td></tr><tr><td><code>h</code></td><td>哈希命令的通知</td></tr><tr><td><code>z</code></td><td>有序集合命令的通知</td></tr><tr><td><code>x</code></td><td>过期事件：每当有过期键被删除时发送</td></tr><tr><td><code>e</code></td><td>驱逐(evict)事件：每当有键因为 <code>maxmemory</code> 政策而被删除时发送</td></tr><tr><td><code>A</code></td><td>参数 <code>g$lshzxe</code> 的别名</td></tr></tbody></table><p>输入的参数中至少要有一个<code>K</code>或<code>E</code>来指定通知类型，否则配置不会生效</p><h5 id="过期通知事件"><a class="markdownIt-Anchor" href="#过期通知事件"></a> 过期通知事件</h5><p>在Redis中有两种方式将key删除：</p><ol><li>当一个键被访问时，Redis会对这个键进行检查，如果键已经过期，则将该键删除</li><li>Redis后台会定期删除那些已经过期的键</li></ol><p>当过期键被删除时，Redis会产生一个expired通知。在此要理解一点，就是并不是当key的TTL变为0时就会立即被删除，所以Redis产生expired通知的时间为键被删除的时候而不是键的TTL变为0的时候。</p><p>依据上述表格，我们可以将<code>notify-keyspace-events</code>设置为<code>Ex</code>，表示键过期事件通知。</p><h5 id="java应用中通知监控"><a class="markdownIt-Anchor" href="#java应用中通知监控"></a> Java应用中通知监控</h5><p>Spring Data Redis 实现发布订阅功能非常简单，只有这样的几个类：<code>Topic</code>、<code>MessageListener</code>、<code>RedisMessageListenerContainer</code>。下面对它们进行解释：</p><p><code>org.springframework.data.redis.listener.Topic</code>消息发送者与接收者之间的 channel 定义，有两个实现类：</p><ol><li><code>org.springframework.data.redis.listener.ChannelTopic</code>：一个确定的字符串</li><li><code>org.springframework.data.redis.listener.PatternTopic</code>：基于模式匹配</li></ol><p><code>org.springframework.data.redis.connection.MessageListener</code>一个回调接口，消息监听器，用于接收发送到 channel 的消息，接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.redis.connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听Redis的订阅通知</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Costin Leau</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christoph Strobl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当从Redis接收到通知后的回调方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message message must not be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern pattern matching the channel (if specified) - can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, @Nullable <span class="keyword">byte</span>[] pattern)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.data.redis.listener.RedisMessageListenerContainer</code>用于消息监听，需要将 <code>Topic</code>和<code>MessageListener</code>注册到<code>RedisMessageListenerContainer</code>中，当 Topic 上有消息时，由<code>RedisMessageListenerContainer</code>通知<code>MessageListener</code>，客户端通过onMessage()拿到消息后，自行处理。</p><ul><li><p>引入redis的依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>RedisMessageListenerContainer</code>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.RedisMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisListenerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建key过期事件监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.KeyExpirationEventMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.RedisMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpirationListener</span> <span class="keyword">extends</span> <span class="title">KeyExpirationEventMessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisKeyExpirationListener</span><span class="params">(RedisMessageListenerContainer listenerContainer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(listenerContainer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        String key = message.toString();</span><br><span class="line">        System.out.println(<span class="string">"监听到key: "</span> + key + <span class="string">" 过期!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在工作中偶尔会遇到这样一个场景：用户下单之后，若30分钟内未完成支付，则取消订单。&lt;/p&gt;
&lt;p&gt;做过电商业务的同学，尤其是做统一下单业务的同学一般都会接触过这个场景的需求，一般的处理方式是将订单数据存储到数据库中（MySQL之类的），然后由一个定时Job不断的去扫描符合条
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jcmd</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjcmd/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jcmd/</id>
    <published>2020-05-11T10:21:00.000Z</published>
    <updated>2020-05-11T12:21:17.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>在jdk1.7之后，jdk命令家族新增了一个特牛的命令：jcmd，它是一个多功能的根据，汇集了jps、jmap、jstack、jinfo、jstat等多个命令的功能，也就是我们之前要使用多个JVM命令才能达到的目的，现在只需要使用一个jcmd命令即可。</p><p><img src="/images/image-20200511182956340.png" alt="image-20200511182956340"></p><ul><li>jcmd &lt;pid | main class&gt; &lt;command … | PerfCounter.print | -f file&gt;<ul><li>pid：Java进程ID</li><li>main class：Java进程的main类，main类名称可以使用通配符，如果正在运行的进程中有多个进程的main类名称相同，则会将诊断命令请求发送到所有的命中进程中</li><li>command：诊断指令参数，可以通过<code>jcmd pid help</code>查看进程支持的参数</li><li>PerfCounter.print：打印Java进程上可用的性能计数器，该计数器的列表会随着Java进程的不同而发生变化</li><li>-f file：从文件file中读取命令并在目标Java进程上执行这些命令。在文件中，每个命令必须单独的写在一行里，以<code>#</code>开头的行会被忽略，当所有行都被调用完毕之后，或者读取到stop命令，将会终止对file的处理</li></ul></li><li>-l：列出JVM进程</li><li>-h：显示帮助信息</li></ul><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><ol><li><p>jcmd -l</p><p>查看当前机器上所有的jvm进程信息，与<code>jps -l</code>、<code>jcmd</code>命令效果一样</p><p><img src="/images/image-20200511193521904.png" alt="image-20200511193521904"></p></li><li><p>jcmd pid PerfCounter.print</p><p>查看指定进程的性能统计信息，相当于<code>jstat -J-Djstat.showUnsupported=true -snap pid</code>效果一样</p><p><img src="/images/image-20200511193725364.png" alt="image-20200511193725364"></p></li><li><p>jcmd pid help</p><p>查看指定进程支持的操作参数</p><p><img src="/images/image-20200511193818369.png" alt="image-20200511193818369"></p></li><li><p>jcmd pid help command</p><p>查看指定命令的帮助信息</p><p><img src="/images/image-20200511193938227.png" alt="image-20200511193938227"></p></li><li><p>jcmd pid VM.uptime</p><p>查看虚拟机的运行时长</p><p><img src="/images/image-20200511194101355.png" alt="image-20200511194101355"></p></li><li><p>jcmd pid VM.classloader_stats</p><p>查看类加载器信息，等同于<code>jmap -clstats</code>命令</p><p><img src="/images/image-20200511194314593.png" alt="image-20200511194314593"></p></li><li><p>jcmd pid Thread.print</p><p>打印Java进程的线程信息，与<code>jstack</code>效果一样</p><p><img src="/images/image-20200511194510978.png" alt="image-20200511194510978"></p></li><li><p>jcmd pid GC.class_histogram</p><p>查看进程中的类统计信息，与<code>jmap -histo</code>效果一样</p><p><img src="/images/image-20200511194712997.png" alt="image-20200511194712997"></p></li><li><p>jcmd pid GC.heap_dump filepath</p><p>生成堆转储文件，与<code>jmap -dump:format=b,file=a.hprof</code>效果一样</p><p><img src="/images/image-20200511194938288.png" alt="image-20200511194938288"></p></li><li><p>jcmd pid GC.heap_info</p><p>查看JVM的堆信息，与<code>jmap -heap</code>效果一样</p><p><img src="/images/image-20200511195121583.png" alt="image-20200511195121583"></p></li><li><p>jcmd pid GC.finalizer_info</p><p>查看正在等待回收的对象信息，与<code>jmap -finalizerinfo</code>效果一样</p></li><li><p>jcmd pid GC.run</p><p>告诉垃圾收集器进行垃圾收集，等于是对JVM执行了<code>System.gc()</code></p></li><li><p>jcmd pid VM.version</p><p>查看JVM当前版本，和<code>jinfo pid | grep version</code>效果一样</p><p><img src="/images/image-20200511200800384.png" alt="image-20200511200800384"></p></li><li><p>jcmd pid VM.system_properties</p><p>查看JVM系统属性信息，和<code>jinfo</code>效果一样</p><p><img src="/images/image-20200511200911867.png" alt="image-20200511200911867"></p></li><li><p>jcmd pid VM.flags</p><p>查看JVM的启动参数，与<code>jinfo -flags</code>效果一样</p><p><img src="/images/image-20200511202039543.png" alt="image-20200511202039543"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;在jdk1.7之后，jdk命令家族新增了一个特牛的命令：jcmd，它是一个多功能的根据，汇集了jps、jmap、jstack、jinfo、jst
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jmap</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjmap/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jmap/</id>
    <published>2020-05-11T07:40:00.000Z</published>
    <updated>2020-05-11T10:02:02.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>jmap是一个多功能命令，它可以生成Java应用的dump文件，也可以查看堆内对象的统计信息、查看ClassLoader信息和finalizer队列等，但是jmap会将整个JVM的线程全部暂停，所以在生产环境中慎重jmap命令。</p><img src="/images/image-20200511155155703.png" alt="image-20200511155155703" style="zoom:50%;"><blockquote><p>参数</p></blockquote><ul><li>option：选项参数</li><li>pid：进程ID</li><li>executable：生成核心dump的Java可执行文件</li><li>core：需要打印配置信息的核心文件</li><li>server_id：唯一服务ID，若一台主机上开启了多个远程debug服务</li><li>remote server IP or hostname：远程debug服务的主机名或IP</li></ul><blockquote><p>option选项</p></blockquote><ul><li>none：查看进程的内存映像信息，和Solaris的pmap命令类似</li><li>heap：显示JVM堆详细信息</li><li>histo[:live]：打印堆中对象的统计信息，<code>:live</code>子选项是指定仅打印出存活的对象</li><li>clstats：打印类加载器信息</li><li>finalizerinfo：显示正在准备被回收的对象信息</li><li>dump:&lt;dump-options&gt;：生成堆转储快照<ul><li>live：仅转储堆中存活的对象</li><li>format=b：二进制方式</li><li>file：堆转储快照文件</li></ul></li><li>F：当dump或histo没有响应时，使用该参数可以强制执行，但是若子选项是<code>:live</code>则使用-F也无效</li><li>h | help：显示命令的帮助信息</li><li>j&lt;flag&gt;：给运行中的JVM传参数给jmap</li></ul><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><blockquote><p>准备：启动一个死循环的main方法</p><p>通过jps命令查看应用的pid</p><p>pid：10456</p></blockquote><ol><li><p>jmap pid</p><p>查看进程的内存映像信息</p><img src="/images/image-20200511162040121.png" alt="image-20200511162040121" style="zoom:50%;"></li><li><p>jmap -heap pid</p><p>显示JVM堆详细信息</p><p><img src="/images/image-20200511162552365.png" alt="image-20200511162552365"></p></li><li><p>jmap -histo:live pid</p><p>显示堆中存活的对象的统计信息，信息包含每个存活的Java类、对象数量、内存大小（从大到小排列，单位：字节）、类全限定名</p><p><img src="/images/image-20200511173916727.png" alt="image-20200511173916727"></p></li><li><p>jmap -clstats pid</p><p>打印类加载器信息，信息包含类加载器名称、所加载的类的数量、所加载的类的大小、父加载器、存活状态、加载器地址等</p><p><img src="/images/image-20200511174142448.png" alt="image-20200511174142448"></p></li><li><p>jmap -finalizerinfo pid</p><p>打印正在等待被回收的对象信息</p><p><img src="/images/image-20200511174414285.png" alt="image-20200511174414285"></p><p>表示当前并无待回收对象</p></li><li><p>jmap -dump:format=b,file=heapdump.hprof pid</p><p>生成堆转储快照dump文件，以hprof二进制格式转储Java堆信息到指定的文件中，可以使用live子选项指定只将堆中存活的对象转储出来，生成的文件可以使用jhat命令或者MAT工具解析</p><p><img src="/images/image-20200511175932610.png" alt="image-20200511175932610"></p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>在jmap执行时，JVM为了保证dump的信息的可靠性，会暂停应用的所有线程，如果堆内对象过大的话，这个过程会非常耗时，在生产环境慎用。</p><p>但是当生产服务处了问题，这个时候不得不使用的话，那就用吧，应用都出问题了，还在意会不会STW干啥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h3&gt;
&lt;p&gt;jmap是一个多功能命令，它可以生成Java应用的dump文件，也可以查看堆内对象的统计信息、查看ClassLoader信息和finalizer
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM命令之jstack</title>
    <link href="http://luxiaowan.github.io/2020/05/11/JVM%E5%91%BD%E4%BB%A4%E4%B9%8Bjstack/"/>
    <id>http://luxiaowan.github.io/2020/05/11/JVM命令之jstack/</id>
    <published>2020-05-10T16:11:00.000Z</published>
    <updated>2020-05-11T18:15:48.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h3><p>jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出Java应用中线程堆栈信息，主要用法：</p><img src="/images/image-20200511001238117.png" alt="image-20200511001238117" style="zoom:50%;"><ul><li>-F：强制打印线程堆栈信息，当<code>jstack [-l] &lt;pid&gt;</code>无响应时使用</li><li>-m：打印Java和native框架的所有堆栈信息</li><li>-l：长列表，打印关于锁的附加信息</li><li>-h or -help：打印帮助信息</li></ul><p><code>pid</code>是需要被打印堆栈信息的Java进程id，可以使用jps查看，通过jstack命令可以获取当前进程的所有线程信息，每个线程堆信息中可以看到线程ID、线程状态、是否持有锁等信息。</p><h3 id="死锁排查"><a class="markdownIt-Anchor" href="#死锁排查"></a> 死锁排查</h3><p>线程死锁的情况很简单，我们通过一张图即可理解：</p><img src="/images/image-20200511011015785.png" alt="image-20200511011015785" style="zoom:50%;"><p>首先我们写一段死锁代码，代码逻辑很简单，写两个线程，提供两个ReentrantLock对象，在线程1中先对lock1加锁，然后再对lock2加锁，而在线程2中先对lock2加锁，再对lock1加锁，使这两个线程互相竞争锁lock1和lock2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Lock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock1.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc1获取到lock1"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock2.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc1获取到lock2"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"cc1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock2.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc2获取到lock2"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                lock1.lock();</span><br><span class="line">                System.out.println(<span class="string">"cc2获取到lock1"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"cc2"</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序之后，控制台输出内容：</p><img src="/images/image-20200511004249590.png" alt="image-20200511004249590" style="zoom:50%;"><p>然后就一直停顿在这里，下面我们使用jstack排查一下：</p><ol><li><p>使用jps查看进程pid</p><img src="/images/image-20200511004456408.png" alt="image-20200511004456408" style="zoom:50%;"><p>我们看到进程的pid为75169，接下来就可以根据该pid打印出堆栈信息</p></li><li><p>通过jstack查看进程的堆栈信息</p><p>执行命令<code>jstack -l 75169</code>，查看控制台输出的信息</p><img src="/images/image-20200511005029659.png" alt="image-20200511005029659" style="zoom:50%;"></li><li><p>排查死锁</p><ul><li>直接方法</li></ul><p>查看红框内的信息，发现在堆栈信息中已经告诉了我们死锁的信息，及发生死锁的线程名称和正在等待的锁，以及等待的锁的当前拥有者的线程名称。</p><p>查看黄框内的信息，这是我们排查代码问题的关键所在，也就是在堆栈信息中，会告诉我们发生死锁的代码位置，便于我们定位发生死锁的代码。</p><ul><li>间接方法</li></ul><p>如果堆栈中未告诉我们死锁的关联线程，那么我们可以通过线程正在等待的锁的信息在堆栈信息中进行搜索，本示例中，线程cc2的堆栈信息中<code>- parking to wait for &lt;0x000000076b2839a8&gt;</code>告诉我们当前线程cc2正在等待锁0x000000076b2839a8，并且当前已经霸占了锁0x000000076b2839d8；</p><img src="/images/image-20200511005806128.png" alt="image-20200511005806128" style="zoom:50%;"><p>而线程cc1的堆栈信息中<code>- parking to wait for &lt;0x000000076b2839d8&gt;</code>告诉我们它正在等待锁0x000000076b2839d8，且当前已经持有了锁0x000000076b2839a8。</p><img src="/images/image-20200511005950037.png" alt="image-20200511005950037" style="zoom:50%;"><p>通过线程cc1和cc2的堆栈信息我们能够直观的分析出它们相互霸占了对方想要获取的锁，并且在未获得所需要的锁之前，相互之间都不会释放已经持有的锁，因此导致了程序出现了死锁。</p></li></ol><h5 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h5><p>以上就是我们通常情况下排查线程死锁的基本操作，主要操作顺序为：</p><ol><li>使用jps查看进程pid</li><li>使用<code>jstack -l pid</code>查看线程堆栈信息</li><li>通过堆栈信息分析死锁情况</li></ol><h3 id="排查cpu过高"><a class="markdownIt-Anchor" href="#排查cpu过高"></a> 排查CPU过高</h3><p>当运行中的线程过多时，CPU负载会极速飙升，如果我们不及时解决就会导致因CPU过高而唤醒的系统的自我保护，将进程杀死。在实际工作当中，我们经常会遇到此种情况，当然我们不能看到CPU达到100%或者300%了就认为是CPU负载过高，这要根据我们服务器的CPU个数和每个CPU的负载来判断CPU是否过高。</p><blockquote><p>查看服务器负载：使用top命令查看机器负载</p><p><img src="/images/image-20200511013557261.png" alt="image-20200511013557261"></p><ul><li>load average后面分表代表1分钟、5分钟、15分钟的系统平均负载情况，一般不超过CPU个数*0.7即可认为是正常，使用uptime命令也可以查看该属性</li><li>按键1可以查看每个CPU的负载情况，若有一个CPU使用量超过75%，那么就需要排查了</li></ul></blockquote><p>我们写一个死循环来将CPU吃满：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullCpuTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>运行程序之后，通过top命令查看CPU负载</p><img src="/images/image-20200511021314252.png" alt="image-20200511021314252" style="zoom:50%;"><p>我们看到load average并不是很高，因为刚启动，待会就飙起来了，但是CPU0的usage已经达到了94.7%，我们的Java进程的pid为23731。</p></li><li><p>通过<code>top -Hp 23731</code>查看进程内的线程负载情况</p><p><img src="/images/image-20200511021510357.png" alt="image-20200511021510357"></p><p>发现pid为23732的线程占用的CPU最高，那么我们就找到了问题所在</p></li><li><p>查看线程的堆栈信息</p><ul><li><p>通过<code>jstack hpid</code>查看线程中处于RUNNABLE状态的线程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 23732是线程的pid</span></span><br><span class="line">jstack 23732</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200511021836792.png" alt="image-20200511021836792"></p></li><li><p>通过<code>jstack pid</code>定位具体的线程</p><ol><li><p>打印线程23732的16进制数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf '%x\n' 23732</span><br></pre></td></tr></table></figure></li><li><p>通过jstack排查具体的线程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 23731是进程的pid</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5cb4是线程pid的十六进制数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C2是输出命中行的上下行数，-C2表示上下各打印两行</span></span><br><span class="line">jstack 23731 | grep '0x5cb4' -C2 --color</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200511022609016.png" alt="image-20200511022609016"></p></li></ol></li><li><p>通过<code>kill -3 pid</code>查看线程堆栈信息</p></li></ul></li></ol><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><p>一般生产环境不会让直接在服务器上操作，所以可以将堆栈信息输出到文件中，然后再详细分析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt; 简述&lt;/h3&gt;
&lt;p&gt;jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出Java应用中线程堆栈信息，主要用法：&lt;/p&gt;
&lt;img src=&quot;/ima
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java垃圾回收名词</title>
    <link href="http://luxiaowan.github.io/2020/05/10/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%8D%E8%AF%8D/"/>
    <id>http://luxiaowan.github.io/2020/05/10/Java垃圾回收名词/</id>
    <published>2020-05-10T14:50:00.000Z</published>
    <updated>2020-05-10T15:17:07.978Z</updated>
    
    <content type="html"><![CDATA[<p>我们在学习JVM的GC相关知识时，必定会接触到几个GC的专有名词：Minor GC、Major GC、Young GC、Old GC、Full GC、Stop The World（STW），现在我们来了解一下这些名词具体指的是什么。</p><h4 id="minor-gc-young-gc"><a class="markdownIt-Anchor" href="#minor-gc-young-gc"></a> Minor GC &amp;&amp; Young GC</h4><p>Minor GC和Young GC都是指新生代的内存回收，两个名词指的是同一件事情，我们都知道现在的商业化虚拟机中，新生代被分为Eden和Survivor区，关于Minor GC我们需要知道以下几点：</p><ol><li>当Eden区无法为新创建的对象分配空间时，会触发Minor GC。Eden区空间越小，Minor GC的频率越高</li><li>当Eden区空间不足触发Minor GC时，新生代中会有部分对象晋升到老年代，所以Minor GC之后，老年代的空间使用量通常会有所升高</li><li>新生代的大部分垃圾收集器都会触发STW，但是新生代的大部分对象通常情况下都是朝生夕死的，所以Eden区的大部分对象都可以认为是垃圾对象，只有很少的一部分对象会被复制到Survivor区和老年代，这种情况下STW的时间会很短；而当Minor GC之后Eden区仍存活非常多的对象，那么垃圾收集器就会将这些对象复制到Survivor区或老年代，此时STW的时间就会变的很长，因为复制大量对象相比复制少量对象更耗时。</li></ol><h4 id="major-gc-old-gc"><a class="markdownIt-Anchor" href="#major-gc-old-gc"></a> Major GC &amp;&amp; Old GC</h4><p>这两个名词都指的是老年代空间回收，也属于是同一件事。很多情况下，Major GC是由Minor GC触发的，比如当发生Minor GC时，会将新生代的部分满足条件的对象晋升到老年代，如果此时老年代的可用空间不足，那么就会触发Major GC，因此说在大部分情况下Major GC都是由Minor GC触发的。</p><h4 id="full-gc"><a class="markdownIt-Anchor" href="#full-gc"></a> Full GC</h4><p>Full GC是比较特殊的一种，它等于是Minor GC和Major GC的结合，主要用于回收新生代、老年代和永久代。</p><ol><li>当老年代空间不足时，会触发Full GC</li><li>在代码中显式调用<code>System.gc()</code>时，JVM会建议执行Full GC</li><li>方法区空间不足时，会触发Full GC，但是在jdk1.8之后采用Metaspace来代替方法区，所以在此之后一般不会因为方法区空间不足而触发Full GC</li><li>通过Minor GC之后存活的对象大于之前每次晋升时老年代的平均可用空间时，会自动触发Full GC</li></ol><h4 id="stop-the-worldstw"><a class="markdownIt-Anchor" href="#stop-the-worldstw"></a> Stop-The-World（STW）</h4><p>STW意为停止全世界，对于JVM来说，它的世界里存活的都是一个个线程，所以意思也就是在进行GC时，会将虚拟机中其他的工作线程全部暂停，当GC结束之后，再继续恢复工作。</p><p>所以对于一个垃圾收集器来说，STW的时间是一个非常重要的性能指标，并且STW直接影响的是虚拟机的吞吐量（吞吐量 = 虚拟机运行时间 / (STW时间 + 虚拟机运行时间)），也就是STW时间越短，虚拟机吞吐量越高，执行效率越高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在学习JVM的GC相关知识时，必定会接触到几个GC的专有名词：Minor GC、Major GC、Young GC、Old GC、Full GC、Stop The World（STW），现在我们来了解一下这些名词具体指的是什么。&lt;/p&gt;
&lt;h4 id=&quot;minor-gc
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Synchronized作用在静态和非静态方法上的区别</title>
    <link href="http://luxiaowan.github.io/2020/05/09/Synchronized%E4%BD%9C%E7%94%A8%E5%9C%A8%E9%9D%99%E6%80%81%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://luxiaowan.github.io/2020/05/09/Synchronized作用在静态和非静态方法上的区别/</id>
    <published>2020-05-09T15:21:00.000Z</published>
    <updated>2020-05-10T14:33:04.503Z</updated>
    
    <content type="html"><![CDATA[<p>synchronized关键字的用法主要有以下几种：</p><ol><li><p>作用在非静态方法上</p><p>非静态方法是只能提供类的实例进行调用，所以实际上就是对调用方法的对象加锁，俗称对象锁</p></li><li><p>作用在静态方法上</p><p>静态方法是可以通过类名直接调用，所以实际上就是对调用方法的类加锁，俗称类锁</p></li><li><p>作用在代码块</p><p>根据传入的是类对象或类实例判断加锁方式</p></li></ol><h4 id="场景分析"><a class="markdownIt-Anchor" href="#场景分析"></a> 场景分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态同步方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncStaticClazz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static---method1--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static---method2--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static---method3--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非静态同步方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncNormalClazz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非静态实例同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"normal---method1--"</span> + Thread.currentThread());</span><br><span class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类级别的同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncNormalClazz.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"normal---method2--"</span> + Thread.currentThread());</span><br><span class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类级别的同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncNormalClazz.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"normal---method3--"</span> + Thread.currentThread());</span><br><span class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类实例级别的同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"normal---method4--"</span> + Thread.currentThread());</span><br><span class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">2000</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>场景1</p><ul><li><p>描述：使用类对象在不同线程中访问不同的静态同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz.method1();</span><br><span class="line">&#125;, <span class="string">"ssc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz.method2();</span><br><span class="line">&#125;, <span class="string">"ssc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：静态同步方法的加锁范围是整个类，所以无论是使用对象或类去访问静态同步方法，锁都会加到类对象上。就好比是房子的大门，房子内不论有多少房间，只要有一个人打开大门进入到房子里，其他人就只能等他出来之后再进去，而已经进去的人拥有所有房间的使用权。</p></li></ul></li><li><p>场景2</p><ul><li><p>描述：在不同线程中用不同的类实例访问相同静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz c = <span class="keyword">new</span> SyncStaticClazz();</span><br><span class="line">    c.method1();</span><br><span class="line">&#125;, <span class="string">"ssc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncStaticClazz c = <span class="keyword">new</span> SyncStaticClazz();</span><br><span class="line">    c.method1();</span><br><span class="line">&#125;, <span class="string">"ssc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：和场景1相同，静态方法虽然可以被类实例访问，但锁依然是类锁</p></li></ul></li><li><p>场景3</p><ul><li><p>描述：同一个对象在不同线程中访问不同的非静态同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method1();</span><br><span class="line">&#125;, <span class="string">"snc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：非静态方法上加的是对象锁，当对象调用一个非静态的同步方法时，其他的非静态同步方法需要等待被执行。</p></li></ul></li><li><p>场景4</p><ul><li><p>描述：不同对象在不同线程中访问同一个非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method1();</span><br><span class="line">&#125;, <span class="string">"snc1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method1();</span><br><span class="line">&#125;, <span class="string">"snc2"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：不互斥</p></li><li><p>解析：因为通过不同的对象调用的是非静态方法，虽然调用的是同一个方法，但是非静态方法加的锁是对象锁，针对的是对象并不是方法，所以可以并发执行，不会互斥。如果像场景1中的比喻的话，就是两个对象是两套房子，户型相同而已。</p></li></ul></li><li><p>场景5</p><ul><li><p>描述：不同对象在不同线程中访问同一个非静态非同步方法，方法内通过synchronized锁定代码块，且锁定对象为类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc3"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc4"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：因为方法<code>method2()</code>内的synchronized锁的是<code>SyncNormalClazz.class</code>，也就是锁定的是类对象，所以与场景2相同</p></li></ul></li><li><p>场景6</p><ul><li><p>描述：同一个对象在不同线程中访问不同的非静态非同步方法，方法内通过synchronized锁定代码块，且锁定对象为类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncNormalClazz snc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method2();</span><br><span class="line">&#125;, <span class="string">"snc2"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    snc.method3();</span><br><span class="line">&#125;, <span class="string">"snc3"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：互斥</p></li><li><p>解析：因为方法<code>method2()</code>内的synchronized锁的是<code>SyncNormalClazz.class</code>，也就是锁定的是类对象，所以与场景2相同</p></li></ul></li><li><p>场景7</p><ul><li><p>描述：同一个对象在不同线程中访问不同方法，一个调用静态方法，一个调用非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncStaticClazz ssc = <span class="keyword">new</span> SyncStaticClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method2();</span><br><span class="line">&#125;, <span class="string">"ssc2"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method3();</span><br><span class="line">&#125;, <span class="string">"ssc3"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：不互斥</p></li><li><p>解析：虽然是同一个对象调用，但是两个方法的锁类型不同，静态方法是类锁，非静态方法是对象锁，所以不会互斥</p></li></ul></li><li><p>场景8</p><ul><li><p>描述：同一个对象在不同线程中访问不同synchronized代码块方法，一个调用类对象同步，一个调用类实例同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncNormalClazz ssc = <span class="keyword">new</span> SyncNormalClazz();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method3();</span><br><span class="line">&#125;, <span class="string">"snc3"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    ssc.method4();</span><br><span class="line">&#125;, <span class="string">"snc4"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>结果：不互斥</p></li><li><p>解析：与场景8相同</p></li></ul></li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ul><li>对象锁仅锁当前对象，不同对象之间不会互斥</li><li>静态方法上的锁是类锁，非静态方法上的锁是对象锁</li><li>所有静态同步方法互斥，无论是通过类调用还是对象调用</li><li>静态方法上加synchronized与在非静态方法内加synchronized(Xxx.class)效果一致，都是类锁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;synchronized关键字的用法主要有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;作用在非静态方法上&lt;/p&gt;
&lt;p&gt;非静态方法是只能提供类的实例进行调用，所以实际上就是对调用方法的对象加锁，俗称对象锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作用在静态方法上&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM参数介绍</title>
    <link href="http://luxiaowan.github.io/2020/05/09/JVM%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
    <id>http://luxiaowan.github.io/2020/05/09/JVM参数介绍/</id>
    <published>2020-05-09T01:30:00.000Z</published>
    <updated>2020-05-14T15:51:44.663Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-jvm常用参数"><a class="markdownIt-Anchor" href="#1-jvm常用参数"></a> 1. JVM常用参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th><strong>默认值</strong></th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小</td><td></td><td>此处的大小是Eden + Survivor，和jmap -heap中显示的New Gen是不同的。 整个堆大小=年轻代大小 + 老年代大小 + 持久代大小(1.7及之前)，增大年轻代后，将会减小老年代大小，此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>年轻代大小</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td>jdk1.7及之前</td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td>jdk1.7及之前</td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5以后每个线程堆栈大小为1M，之前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右 一般小的应用， 如果栈不是很深， 应该是128k够用的，大的应用建议使用256k。</td></tr><tr><td>-XX:ThreadStackSize</td><td>Thread Stack Size</td><td></td><td></td></tr><tr><td>-XX:NewRatio</td><td>年轻代与老年代的比值</td><td></td><td>-XX:NewRatio=4表示年轻代与老年代所占比值为1:4，年轻代占整个堆栈的1/5，Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:LargePageSizeInBytes</td><td>内存页的大小不可设置过大， 会影响Perm的大小</td><td></td><td>=128m</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td>原始类型的快速优化</td><td></td><td></td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄</td><td>15</td><td>如果设置为0的话，则年轻代对象不经过Survivor区，直接进入老年代. 对于老年代比较多的应用，可以提高效率。此值默认为15，取值范围为0~15</td></tr><tr><td>-XX:+AggressiveOpts</td><td>加快编译</td><td></td><td></td></tr><tr><td>-XX:+UseBiasedLocking</td><td>锁机制的性能改善</td><td></td><td></td></tr><tr><td>-Xnoclassgc</td><td>禁用垃圾回收</td><td></td><td></td></tr><tr><td>-XX:SoftRefLRUPolicyMSPerMB</td><td>每兆堆空闲空间中SoftReference的存活时间</td><td>1s</td><td></td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效 另一种直接在旧生代分配的情况是大的数组对象，且数组中无外部引用对象.</td></tr><tr><td>-XX:+UseTLAB</td><td>开启TLAB</td><td></td><td>默认开启</td></tr><tr><td>-XX:TLABSize</td><td>TLAB大小</td><td></td><td>手动指定TLAB的大小</td></tr><tr><td>-XX:TLABWasteTargetPercent</td><td>TLAB占eden区的百分比</td><td>1%</td><td></td></tr><tr><td>-XX:TLABRefillWasteFraction</td><td>TLAB允许浪费的大小比例</td><td>64</td><td>默认TLAB空间的1/64空间</td></tr><tr><td>-XX:-ResizeTLAB</td><td>禁用ResizeTLAB</td><td></td><td></td></tr><tr><td>-XX:+CollectGen0First</td><td>FullGC时是否先YGC</td><td>false</td><td></td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>在发生OOM时到处堆栈信息</td><td></td><td></td></tr><tr><td>-XX:HeapDumpPath</td><td>堆栈信息输出地址</td><td></td><td></td></tr></tbody></table><h4 id="2-parallel收集器参数"><a class="markdownIt-Anchor" href="#2-parallel收集器参数"></a> 2. Parallel收集器参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th>说明</th></tr></thead><tbody><tr><td>-XX:+UseParallelGC</td><td>Full GC采用parallel MSC</td><td>选择垃圾收集器为并行收集器。此配置仅对年轻代有效，即上述配置下，年轻代使用并发收集，而老年代仍旧使用串行收集</td></tr><tr><td>-XX:+UseParNewGC</td><td>设置年轻代为并行收集</td><td>可与CMS收集同时使用，JVM会根据系统配置自行设置，所以无需再设置此值</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td>此值最好配置与处理器数目相等</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>老年代垃圾收集方式为并行收集(Parallel Compacting)</td><td></td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td>如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值.</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>自动选择年轻代区大小和相应的Survivor区比例</td><td>设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开.</td></tr><tr><td>-XX:GCTimeRatio</td><td>设置垃圾回收时间占程序运行时间的百分比</td><td>公式为1/(1+n)</td></tr><tr><td>-XX:+ScavengeBeforeFullGC</td><td>Full GC前调用YGC</td><td>=true</td></tr></tbody></table><h4 id="3-cms收集器参数"><a class="markdownIt-Anchor" href="#3-cms收集器参数"></a> 3. CMS收集器参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th>说明</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>使用Serial收集器</td><td>年轻代</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>使用CMS收集器</td><td></td></tr><tr><td>-XX:+AggressiveHeap</td><td></td><td>试图是使用大量的物理内存 长时间大内存使用的优化，能检查计算资源（内存， 处理器数量） 至少需要256MB内存 大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td></tr><tr><td>-XX:CMSFullGCsBeforeCompaction</td><td>多少次后进行内存压缩</td><td>由于CMS收集器不对内存空间进行压缩，整理，所以运行一段时间以后会产生&quot;碎片&quot;，使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩，整理.</td></tr><tr><td>-XX:+CMSParallelRemarkEnabled</td><td>降低标记停顿</td><td></td></tr><tr><td>-XX+UseCMSCompactAtFullCollection</td><td>在FULL GC的时候， 对老年代的压缩</td><td>CMS是不会移动内存的，会产生内存碎片， 增加这个参数可以消除碎片</td></tr><tr><td>-XX:+UseCMSInitiatingOccupancyOnly</td><td>使用手动定义初始化定义开始CMS收集</td><td>禁止hostspot自行触发CMS GC</td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction=70</td><td>使用cms作为垃圾回收 使用70％后开始CMS收集</td><td>=92。为了保证不出现promotion failed错误</td></tr><tr><td>-XX:CMSInitiatingPermOccupancyFraction</td><td>设置Perm Gen使用到达多少比率时触发</td><td>=92</td></tr><tr><td>-XX:+CMSIncrementalMode</td><td>设置为增量模式</td><td>用于单CPU情况</td></tr><tr><td>-XX:+CMSClassUnloadingEnabled</td><td></td><td></td></tr></tbody></table><h4 id="4-其他参数"><a class="markdownIt-Anchor" href="#4-其他参数"></a> 4. 其他参数</h4><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th>说明</th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td>输出GC基本信息</td><td>输出形式：[GC (Allocation Failure)  1024K-&gt;612K(5632K)， 0.0021628 secs]</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出GC详细信息</td><td>输出形式：[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;492K(1536K)] 1024K-&gt;556K(5632K)， 0.0024829 secs] [Times: user=0.00 sys=0.00， real=0.00 secs]</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>在GC信息上输出系统运行时间</td><td>输出形式：0.185: [GC (Allocation Failure)  1620K-&gt;853K(5632K)， 0.0008322 secs]</td></tr><tr><td>-XX:+PrintGCApplicationStoppedTime</td><td>打印垃圾回收期间程序暂停的时间.可与上面混合使用</td><td>输出形式：Total time for which application threads were stopped: 0.0006927 seconds， Stopping threads took: 0.0000094 seconds</td></tr><tr><td>-XX:+PrintGCApplicationConcurrentTime</td><td>打印每次垃圾回收前，程序未中断的执行时间.可与上面混合使用</td><td>输出形式：Application time: 0.0183349 seconds</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>打印GC前后的详细堆栈信息，可单独使用</td><td></td></tr><tr><td>-Xloggc:filepath</td><td>把相关日志信息记录到文件以便分析. 与上面几个配合使用</td><td></td></tr><tr><td>-XX:+PrintClassHistogram</td><td>garbage collects before printing the histogram.</td><td>等同于jmap -histo</td></tr><tr><td>-XX:+PrintTLAB</td><td>查看TLAB空间的使用情况</td><td>输出：TLAB: gc thread: 0x00007fe8d4008800 [id: 3331] desired_size: 20KB slow allocs: 8  refill waste: 320B alloc: 0.99983     1024KB refills: 42 waste  0.5% gc: 0B slow: 4576B fast: 0B<br>TLAB totals: thrds: 1  refills: 42 max: 42 slow allocs: 8 max 8 waste:  0.5% gc: 0B max: 0B slow: 4576B max: 4576B fast: 0B max: 0B</td></tr><tr><td>-XX:+PrintTenuringDistribution</td><td>查看每次minor GC后新的存活周期的阈值</td><td>输出：Desired survivor size 524288 bytes， new threshold 5 (max 15)</td></tr></tbody></table><h4 id="5-常用配置"><a class="markdownIt-Anchor" href="#5-常用配置"></a> 5. 常用配置</h4><ul><li>堆设置<ul><li>-Xms：堆初始大小，-Xms10m</li><li>-Xmx：堆最大大小，-Xmx20m</li><li>-Xmn：新生代大小，-Xmn5m：NewSize=MaxNewSize=5m</li><li>-XX:NewSize：新生代初始大小 ，-XX:NewSize=5m</li><li>-XX:MaxNewSize：新生代最大大小，-XX:MaxNewSize=10m</li><li>-XX:NewRatio：新生代和老年代大小比值，-XX:NewRatio=4：新生代和老年代比值为1:4，新生代占堆的1/5</li><li>-XX:ServivorRatio：新生代中Eden和Survivor大小比值，-XX:SurvivorRatio=8：Eden和Survivor的比例为2:8，一个Survivor区占整个新生代大小的1/10</li><li>-XX:MaxTenuringThreshold：新生代对象转移到老年代的年龄，默认为15，值域0~15，设置为0的话就表示新生代对象从Eden不经过Survivor区而直接转移到老年代，-XX:MaxTenuringThreshold=10：新生代对象年龄达到10时，也就是经历10次YGC之后，转移到老年代</li></ul></li><li>垃圾收集器设置<ul><li>-XX:+UseSerialGC：新生代使用Serial收集器，可与CMS和Serial Old搭配使用</li><li>-XX:+UseParNewGC：新生代使用ParNew收集器</li><li>-XX:+UseParallelGC：新生代使用Parallel Scavenge收集器<ul><li>-XX:+ParallelGCThreads：设置并行收集器收集时使用的线程数，可以设置为CPU个数，-XX:+ParallelGCThreads=8：使用8个线程进行垃圾收集</li><li>-XX:MaxGCPauseMillis：设置并行收集的最大暂停时间，-XX:MaxGCPauseTime=20，单位：毫秒</li><li>-XX:GCTimeRatio：设置垃圾回收占用运行时间的百分比，-XX:GCTimeRatio=9：垃圾回收占用总运行时间的1/10</li></ul></li><li>-XX:+UseParallelOldGC：老年代使用Parallel Old收集器</li><li>-XX:+UseConcMarkSweepGC：老年代使用CMS收集器<ul><li>-XX:+CMSIncrementalMode：设置为增量模式，适用于单CPU环境</li><li>-XX:+UseCMSCompactAtFullCollection：在发生FGC时对老年代进行压缩</li><li>-XX:CMSFullGCsBeforeCompaction：设置在多少次FGC后，对老年代进行压缩，依赖于-XX:+UseCMSCompactAtFullCollection，-XX:CMSFullGCsBeforeCompaction=5：5次FGC后对老年代进行压缩</li></ul></li><li>-XX:+UseSerialOldGC：老年代使用Serial Old收集器</li></ul></li><li>垃圾收集信息<ul><li>-XX:+PrintGC：输出GC信息</li><li>-XX:+PrintGCDetails：输出GC详细信息</li><li>-XX:+PrintGCTimeStamps：输出GC执行时间点（虚拟机启动之后的时间点）</li><li>-Xloggc:filepath：将GC信息输出到某个文件中，不在控制台输出</li></ul></li><li>TLAB设置<ul><li>-XX:+UseTLAB：启用TLAB</li><li>-XX:+PrintTLAB：输出TLAB使用信息</li><li>-XX:-ResizeTLAB：禁用resizeTLAB</li><li>-XX:TLABSize：指定TLAB大小</li><li>-XX:TLABWasteTargetPrecent：设置TLAB空间占Eden区的比例大小，默认为1%</li><li>-XX:TLABRefillWasteFraction：设置TLAB空间允许被浪费的最大空间比例，默认TLAB空间的1/64空间</li></ul></li><li>OOM设置<ul><li>-XX:+HeapDumpOnOutOfMemoryError：当发生OOM时自动生成堆栈信息</li><li>-XX:HeapDumpPath：当发生OOM时堆栈信息文件输出路径，-XX:HeapDumpPath=/var/data/heapd/</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-jvm常用参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-jvm常用参数&quot;&gt;&lt;/a&gt; 1. JVM常用参数&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;参数名称&lt;/strong&gt;&lt;/th&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>J.U.C之Condition详解</title>
    <link href="http://luxiaowan.github.io/2020/05/08/J.U.C%E4%B9%8BCondition%E8%AF%A6%E8%A7%A3/"/>
    <id>http://luxiaowan.github.io/2020/05/08/J.U.C之Condition详解/</id>
    <published>2020-05-07T16:44:00.000Z</published>
    <updated>2020-05-08T16:36:57.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-由一道算法题开聊"><a class="markdownIt-Anchor" href="#一-由一道算法题开聊"></a> 一、由一道算法题开聊</h3><p>我们提供一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      System.out.print(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      System.out.print(<span class="string">"bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个不同的线程将会共用一个<code>FooBar</code>实例。其中一个线程将会调用<code>foo()</code>方法，另一个线程将会调用<code>bar()</code>方法。请设计修改程序，以确保 “foobar” 被输出 n 次。</p><p><strong>示例 1:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">1</span></span><br><span class="line">输出: <span class="string">"foobar"</span></span><br><span class="line">解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 <span class="keyword">bar() </span>方法，<span class="string">"foobar"</span> 将被输出一次。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="symbol">:</span> <span class="built_in">n</span> = <span class="number">2</span></span><br><span class="line">输出<span class="symbol">:</span> <span class="string">"foobarfoobar"</span></span><br><span class="line">解释<span class="symbol">:</span> <span class="string">"foobar"</span> 将被输出两次。</span><br></pre></td></tr></table></figure><hr><ul><li><em><strong>解析1</strong></em>——方法互调</li></ul><p>由题意可以知道，两个线程分别调用foo()和bar()方法，按照输出要求需要使的foo()方法在bar()方法之前执行，这样我们能否在foo()方法中调用bar()方法，然后再bar()方法中调用foo()方法？我们试一下，修改代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>     n;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      System.out.print(<span class="string">"foo"</span>);</span><br><span class="line">      bar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      System.out.print(<span class="string">"bar"</span>);</span><br><span class="line">      foo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   FooBar fooBar = <span class="keyword">new</span> FooBar(<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">new</span> Thread(() -&gt; fooBar.foo()).start();</span><br><span class="line">   <span class="keyword">new</span> Thread(() -&gt; fooBar.bar()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="/images/image-20200508010813617.png" alt="image-20200508010813617" style="zoom: 40%;"><p>发生了栈溢出，这是因为我们在两个方法之间互相调用，不断的将方法压入栈中，最终造成栈溢出，整个过程如下：</p><img src="/images/image-20200508012241430.png" alt="image-20200508012241430" style="zoom:40%;"><p>可见此办法不可行。</p><ul><li><em><strong>解析2</strong></em>——循环阻塞</li></ul><p>使用一个临时变量来控制方法的执行进度，然后通过死循环来临时中断方法的执行，修改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;&#125;</span><br><span class="line">            System.out.print(<span class="string">"foo"</span>);</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;&#125;</span><br><span class="line">            System.out.print(<span class="string">"bar"</span>);</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">foobarfoobar</span></span><br></pre></td></tr></table></figure><p>好像执行成功了，但是当我们把<code>n</code>放大时，会出现两个线程都进入到while循环之中，之所以出现这种情况是因为变量<code>flag</code>在线程之间出现了数据不同步的问题。针对这个问题，Java提供了关键字<code>volatile</code>来保证变量在线程之间的修改同步，这里就不介绍volatile了，只要我们把变量flag修改为<code>private volatile boolean flag = true;</code>即可解决。</p><ul><li><em><strong>解析3</strong></em>——Lock+Condition+临时变量</li></ul><p>以上方案我们都没有使用到锁，因为题目已经定义好了方法，所以我们给方法加<code>synchronized</code>方案不可取，并且我们在输出的时候要保证foo()方法先执行，仅通过<code>synchronized</code>来保证顺序，实现上有些困难，所以我们采用J.U.C包下的Lock类，通过Condition类来控制方法的执行和等待，然后通过一个临时变量<code>flag</code>控制方法的执行顺序，修改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>       n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock      lock      = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>   flag      = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printFoo.run();</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printBar.run();</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">foobarfoobar</span></span><br></pre></td></tr></table></figure><p>此方案中的参数flag并没有被<code>volatile</code>关键字修饰，且未出现方案2中的修改不同步的问题，这是因为我们在修改flag的时候被加锁了，所以同时只能被一个线程修改。在for循环中通过while循环来控制线程的状态，这里其实只要判断flag的值来决定是否需要将线程挂起，那么我们用if来判断是否可以？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>       n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock      lock      = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>   flag      = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"foo"</span>);</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"bar"</span>);</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果正常，所以这里我们不论是用while还是用if都可以，只要控制好flag的值即可。</p><h3 id="二-condition概述"><a class="markdownIt-Anchor" href="#二-condition概述"></a> 二、Condition概述</h3><p>在上述方案3中，我们使用到了Lock和Condition两个类，Lock我们都知道，它是控制多线程访问共享资源的一个工具，此类在jdk1.5之后提供，它在使用上有几个原则：</p><ul><li>要访问共享资源，必须先获得锁</li><li>同一时刻只能有一个线程获取到锁</li><li>一般情况下Lock是排它锁</li><li>但是也可以使用ReadWriteLock对共享资源进行并发访问</li></ul><p>Lock的使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//TODO 访问共享资源</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//释放锁</span></span><br><span class="line">      l.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁.调用该方法的线程会得到锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可中断的获取锁，该方法可以响应中断(可以中断当前线程)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试非阻塞地获取锁</span></span><br><span class="line"><span class="comment">     * 调用后方法立即返回:</span></span><br><span class="line"><span class="comment">     *如果能正常获取到锁，则立即返回true</span></span><br><span class="line"><span class="comment">     *如果没能正常获取到锁，则立即返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定的超时时间内获取锁</span></span><br><span class="line"><span class="comment">     * 如果锁可以立即获得，则直接返回true，否则，在以下三种情况下会返回:</span></span><br><span class="line"><span class="comment">     * 1. 在指定的超时时间内获取到了锁(true)</span></span><br><span class="line"><span class="comment">     * 2. 在指定的超时时间内线程被interrupt()了(false)</span></span><br><span class="line"><span class="comment">     * 3. 超时(false)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回和当前Lock对象绑定的Condition实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jdk1.5之前，我们如果想要实现线程的等待和恢复只能通过Object的相关wait和notify方法与synchronized关键字配合使用，Object类中提供的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object.wait()</span><br><span class="line">java.lang.Object.wait(<span class="keyword">long</span>)</span><br><span class="line">java.lang.Object.wait(<span class="keyword">long</span>, <span class="keyword">int</span>)</span><br><span class="line">java.lang.Object.notify()</span><br><span class="line">java.lang.Object.notifyAll()</span><br></pre></td></tr></table></figure><p>而从jdk1.5开始，我们通过<code>java.util.concurrent.locks.Condition</code>接口来替代Object来实现类似功能。在整个juc中的锁世界中，AQS是所有锁的基础，主要的实现在AQS中的ConditionObject类，ConditionObject的等待队列是一个FIFO队列，队列的每个节点都是等待在Condition对象上的线程的引用，在调用Condition的await()方法之后，线程释放锁，构造成相应的节点进入等待队列等待</p><p>Condition源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使当前线程进入等待状态并释放锁，直到接收到唤醒信号或线程被中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使当前线程进入等待状态并释放锁，直到接收到唤醒信号，</span></span><br><span class="line"><span class="comment">     * 如果在等待过程中线程被中断，此方法会继续执行，线程扔处于等待状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和wait()方法相同，但是在等待时间（纳秒）内未收到通知，则终止等待并返回0或负数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和wait()方法相同，但是在等待时间（指定时间和单位）内未收到通知，则终止等待并返回0或负数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和wait()方法相同，但是在指定某个时间点未收到通知，则终止等待并返回0或负数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唤醒一个在await()等待队列中的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唤醒所有在await()等待队列中的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-由一道算法题开聊&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-由一道算法题开聊&quot;&gt;&lt;/a&gt; 一、由一道算法题开聊&lt;/h3&gt;
&lt;p&gt;我们提供一个类：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>统计Java代码行数</title>
    <link href="http://luxiaowan.github.io/2020/05/05/%E7%BB%9F%E8%AE%A1Java%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/"/>
    <id>http://luxiaowan.github.io/2020/05/05/统计Java代码行数/</id>
    <published>2020-05-05T06:13:00.000Z</published>
    <updated>2020-05-05T06:15:17.718Z</updated>
    
    <content type="html"><![CDATA[<p>统计Java应用中的代码行数，仅除去注释，非有效代码行数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeStatics</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 总文件数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sumFile = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 总行数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sumLine = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeStatics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计代码行数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inFile</span></span><br><span class="line"><span class="comment">     *            输入的文件，包含子文件和子文件夹</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bw</span></span><br><span class="line"><span class="comment">     *            缓冲输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">codeStatics</span><span class="params">(File inFile, BufferedWriter bw)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (File file : inFile.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">".java"</span>)) &#123;<span class="comment">//为java 文件时</span></span><br><span class="line">                <span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file), <span class="string">"utf-8"</span>));<span class="comment">//以utf-8 格式读入，若文件编码为gkb 则改为gbk</span></span><br><span class="line">                String s = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    s = s.replaceAll(<span class="string">"\\s"</span>, <span class="string">""</span>);<span class="comment">// \\s表示 空格,回车,换行等空白符,</span></span><br><span class="line">                    <span class="comment">// 将空白符替换为空字符""</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">""</span>.equals(s) || s.startsWith(<span class="string">"//"</span>) || s.startsWith(<span class="string">"/*"</span>) || s.startsWith(<span class="string">"/**"</span>)</span><br><span class="line">                            || s.startsWith(<span class="string">"*"</span>)) &#123;<span class="comment">//过滤掉注释</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        line++;</span><br><span class="line">                        System.out.println(line + <span class="string">"："</span> + s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                br.close();<span class="comment">//关闭读入流</span></span><br><span class="line">                System.out.println(file.getName() + <span class="string">"\t\t"</span> + line);<span class="comment">// \t制表符(TAB)</span></span><br><span class="line"></span><br><span class="line">                bw.newLine();<span class="comment">// 写入换行符</span></span><br><span class="line">                bw.write(file.getName() + <span class="string">"\t\t"</span> + line);<span class="comment">// 写入类名称</span></span><br><span class="line">                bw.newLine();<span class="comment">// 换行</span></span><br><span class="line">                bw.flush();<span class="comment">// 把缓冲区的数据强行写出</span></span><br><span class="line"></span><br><span class="line">                sumFile++;</span><br><span class="line">                sumLine += line;</span><br><span class="line">                System.out.println(<span class="string">"统计:"</span> + sumFile + <span class="string">"个类\t"</span> + sumLine + <span class="string">"行"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isDirectory()) &#123;<span class="comment">// 当file 为目录时，递归遍历</span></span><br><span class="line"></span><br><span class="line">                codeStatics(file, bw);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File inFile = <span class="keyword">new</span> File(<span class="string">"/Users/cc/Documents/projects/project/demo"</span>);<span class="comment">// 要统计的项目</span></span><br><span class="line">            FileOutputStream ps = <span class="keyword">new</span> FileOutputStream(<span class="string">"/Users/cc/Documents/result.txt"</span>);<span class="comment">// 将统计结果输出到txt文件</span></span><br><span class="line">            BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(ps, <span class="string">"utf-8"</span>));</span><br><span class="line">            bw.write(<span class="string">"类名\t\t行数"</span>);</span><br><span class="line"></span><br><span class="line">            codeStatics(inFile, bw);<span class="comment">// 递归入口</span></span><br><span class="line"></span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.write(<span class="string">"一共："</span> + sumFile + <span class="string">"个类\t\t"</span> + sumLine + <span class="string">"行代码！"</span>);</span><br><span class="line"></span><br><span class="line">            bw.flush();</span><br><span class="line">            bw.close();<span class="comment">//关闭输出流</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;统计Java应用中的代码行数，仅除去注释，非有效代码行数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器介绍</title>
    <link href="http://luxiaowan.github.io/2020/05/02/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://luxiaowan.github.io/2020/05/02/JVM垃圾收集器介绍/</id>
    <published>2020-05-02T08:30:00.000Z</published>
    <updated>2020-05-06T17:01:17.377Z</updated>
    
    <content type="html"><![CDATA[<p>曾经看到过一句话：如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。目前商业化虚拟机中常用的垃圾收集器有8种：新生代：Serial、ParNew、Parallel Scavenge，老年代：CMS、Serial Old、Parallel Old，整堆：G1、ZGC。</p><img src="/images/image-20200506000424241.png" alt="image-20200506000424241" style="zoom:50%;"><p>图中连线的两个收集器是可以搭配使用，其所处区域表示收集器的作用域。</p><h4 id="1-垃圾收集器运行方式"><a class="markdownIt-Anchor" href="#1-垃圾收集器运行方式"></a> 1. 垃圾收集器运行方式</h4><p>垃圾收集器在运行方式上又细分为串行、并行、并发三种。</p><ul><li>串行收集器：GC线程和其他用户线程是串行的，也就是在进行垃圾回收的时候，其他的线程需要排队等待，直到收集器的线程完成工作，这类收集器停顿时间长、吞吐量低，适用于单C机器使用，使用JVM参数<code>-XX:+UseSerialGC</code>开启，</li><li>并行收集器是采用多线程串行的方式进行垃圾回收，适用于多C机器，在多个线程执行垃圾检测回收时，可能会因为线程之间竞争CPU资源而发生长时间的停顿，体验极差，不推荐使用，可以使用JVM参数<code>-XX:+UseParallelGC</code>、<code>-XX:+UseParallelOldGC</code>开启，并且可以使用<code>-XX:ParallelGCThreads=&lt;thread_nums&gt;</code>指定GC的线程数量，一般不要高于CPU数量，否则就容易gg；是jdk1.8中默认使用的垃圾收集器；</li><li>并发收集器是目前使用较多的一类收集器，与并行收集器不同的是它采用多个线程并行执行去进行垃圾检测和回收，停顿时间短，吞吐量大，可以使用JVM参数<code>-XX:+UseConcMarkSweepGC</code>开启，可以搭配<code>-XX:+UseParNewGC</code>一同使用；</li></ul><h4 id="2-吞吐量"><a class="markdownIt-Anchor" href="#2-吞吐量"></a> 2. 吞吐量</h4><p>说到垃圾收集就不得不提吞吐量这个概念，吞吐量是指用户代码运行时间与虚拟机总运行时间的比值：吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，比如虚拟机总共运行了100分钟，期间进行了一次垃圾收集，耗时0.01分钟，那么吞吐量就是99.99%。</p><p>吞吐量越高则表示GC总耗时越少，服务性能则越高。</p><h4 id="3-gc类型"><a class="markdownIt-Anchor" href="#3-gc类型"></a> 3. GC类型</h4><ol><li><p>Minor GC：也叫作Young GC，只作用于新生代</p><p>我们知道新生代分为一个Eden区和两个Survivor区，常规对象被创建之后都会有限分配到Eden区，但是Eden区的空间大小是有限的，当Eden可用空间不足时，就会触发Minor GC，Minor GC之后在Eden区仍存活的对象会被移动到Survivor区。</p><p>在发生Minor GC时，Eden区和Survivor的from区存活的对象全部被复制到当前Survivor的to区，然后将Survivor的from和to区指针互换。</p><ul><li><p>在发生Minor GC的时候，若from区内对象年龄达到了晋升老年代的条件<code>-XX:MaxTurningThreshold</code>，则将这部分对象转移到老年代；</p></li><li><p>若在Minor GC后，Eden区和Survivor的from区存活对象的总空间大于Survivor的to区的大小，则优先将对象复制到to区，待to区存满之后，将剩余的对象转移到老年代，这叫过早提升。</p></li></ul></li><li><p>Old GC：只有CMS的concurrent collection这个模式，只作用于老年代</p><p>CMS是一款基于并发、使用标记清楚算法的垃圾收集算法， 只针对老年代进行垃圾回收，</p></li><li><p>Mixed GC：混合GC模式，同时收集新生代和老年代，目前只有G1是这种模式</p></li><li><p>Full GC：收集整个堆，包括新生代、老年代和永久代(Metaspace)</p></li></ol><h4 id="4-垃圾收集器介绍"><a class="markdownIt-Anchor" href="#4-垃圾收集器介绍"></a> 4. 垃圾收集器介绍</h4><h6 id="新生代收集器"><a class="markdownIt-Anchor" href="#新生代收集器"></a> 新生代收集器</h6><ul><li><p>Serial收集器</p><p>Serial收集器是初代收集器，历史最为悠久。它是一个采用了复制算法的单线程收集器，非常适用于单个CPU的环境，它会导致STW（Stop The World），在进行垃圾收集时必须暂停其他所有的工作线程，直至垃圾收集结束为止。收集工作由虚拟机在后台自动发起和完成，用户不可见。由于每次垃圾回收时都要暂停，若垃圾对象过多，那么进程暂停时间可能过长，这对很多应用来说是很不能接受的。</p><p>Serial收集器的运行过程（Serial + Serial Old）：</p><p><img src="/images/image-20200505034217123.png" alt="image-20200505034217123"></p><p>Serial可以与老年代的CMS和Serial Old收集器配合工作，可以使用JVM参数<code>-XX:+UseSerialGC</code>开启。</p><p>🌰：<code>java -jar -XX:+UseSerialGC -XX:+UseConcMarkSweepGC xxx.jar</code></p></li><li><p>ParNew收集器</p><p>ParNew是Serial的多线程版本，拥有Serial的所有功能（控制参数、收集算法、STW、对象分配规则、回收策略等），可以与老年代的CMS和Serial Old收集器配合工作。</p><p>在单CPU环境中，ParNew不会比Serial更高效；在多CPU环境下，随着CPU的数量增加，GC线程数增加，STW的时间会大大缩小。</p><p>ParNew默认开启的GC线程数与CPU的数量相同，可以使用JVM参数<code>-XX:+UseParNewGC</code>开启，并可以使用JVM参数<code>-XX:ParallelGCThreads</code>指定GC线程数</p><p>ParNew收集器的运行过程（ParNew + Serial Old）：</p><p><img src="/images/image-20200505034308215.png" alt="image-20200505034308215"></p><p>🌰：<code>java -jar -XX:+UseParNewGC -XX:ParallelGCThreads=2 -XX:+UseConcMarkSweepGC xxx.jar</code></p></li><li><p>Parallel Scavenge收集器</p><p>Parallel Scavenge收集器是一款并行的多线程新生代收集器，也是使用的复制算法，强关注吞吐量， 高吞吐量可以更高效的利用CPU，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。吞吐量=运行用户代码时间/(运行用户代码时间+GC时间)。</p><p>Parallel Scavenge是jdk1.8的默认新生代垃圾收集器，只能与老年代的Serial Old和Parallel Old两款收集器配合工作，不可与CMS搭配使用。</p><p>收集器通过JVM参数<code>-XX:MaxGCPauseMillis</code>和<code>-XX:GCTimeRatio</code>来控制最大GC停顿时间及吞吐量大小，另外还可以使用JVM参数<code>-XX:+UseAdaptiveSizePolicy</code>打开GC自适应调节策略。</p><ul><li><code>-XX:MaxGCPauseMillis</code>：参数值必须大于0，单位毫秒，但是这个值只能提醒收集器尽可能的保证在这个毫秒内完成GC，并不能一定保证每次GC都在这个时间内，系统会动态调小新生代内存，并缩小GC间隔，以降低吞吐量来保证STW的时间。为什么说是降低吞吐量，因为GC频率高了，GC总时间就长了，所以吞吐量就低了。</li><li><code>-XX:GCTimeRatio</code>：参数值范围是0~100的整数，表示GC总时间占虚拟机运行时间的比率，比如将值设置为49，那么允许的最大GC时间占总时间的2%（1/(1+49)）。</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：GC自适应调节策略，当打开这个参数之后，就不需要指定新生代的大小(<code>-Xmn</code>)、Eden与Survivor的比例(<code>-XX:SurvivorRatio</code>)、晋升了老年代对象年龄(<code>-XX:PretenureSizeThreshold</code>)等参数，虚拟机会根据当前虚拟机的运行情况收集性能监控信息，动态调整这些参数寻找最优的停顿时间和吞吐量。</li></ul></li></ul><h6 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h6><p>从上文中我们发现新生代的三个GC收集器都是使用的复制算法，这样可以提高回收效率，并且这也是以新生代的区域划分为基础的，我们知道新生代分为1个Eden区和2个Survivor区，每次Minor GC之后都会将Eden区存活的对象复制到Survivor区，然后将Survivor的from区存活的对象复制到to区，然后清空Eden和Survivor的from区，将Survivor的to区和from区切换身份，所以使用复制算法简单高效。</p><h6 id="老年代收集器"><a class="markdownIt-Anchor" href="#老年代收集器"></a> 老年代收集器</h6><ul><li><p>CMS收集器</p><p>CMS(Concurrent Mark Sweep)收集器是一款以获取最短回收停顿时间为目标的收集器，注重虚拟机的响应速度，收集器基于“标记-清除”算法，特别容易产生内存碎片。</p><p>CMS收集器工作流程大概分为以下4个步骤：</p><ol><li>初始化标记（CMS initial mark）：会导致STW，仅仅只标记一下存活对象（从GC Roots能直接关联到的对象）</li><li>并发标记（CMS Concurrent mark）：不会STW，进行GC Roots Tracing的过程，耗时最长</li><li>重新标记（CMS remark）：会导致STW，再次标记主要是修正并发标记期间因为用户线程运行而导致标记的对象发生的变动，这一阶段的停顿时间也较长，但是比并发标记短很多</li><li>并发清除（CMS Concurrent Sweep）</li></ol><p><img src="/images/image-20200505040204157.png" alt="image-20200505040204157"></p><ul><li>优点<ol><li>并发收集</li><li>低停顿</li></ol></li><li>缺点<ol><li>对CPU资源敏感</li><li>无法处理浮动垃圾</li><li>会产生内存碎片</li></ol></li></ul></li><li><p>Serial Old收集器</p><p>Serial Old是Serial收集器的老年代收集器，它是一个单线程收集器，使用“标记-整理”算法，起初此款收集器主要用于client模式下的虚拟机，在server模式下，可以与新生代的Parallel Scavenge收集器搭配使用，并且也可以作为CMS收集器的备用方案，在发生Concurrent Mode Failure时自动切换到Serial Old收集器。</p><p>工作流程与Serial相同，Serial+Serial Old：</p><p><img src="/images/image-20200505034217123.png" alt="image-20200505034217123"></p></li><li><p>Parallel Old收集器</p><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在jdk1.6才开始出现，在此之前如果新生代使用Parallel Scavenge收集器的话，老年代就只能选择Serial Old这一个收集器，而在Parallel Old出现之后，在注重吞吐量以及CPU资源敏感的场景下，都可以优先考虑Parallel Scavenge+Parallel Old</p></li></ul><h6 id="整堆收集器"><a class="markdownIt-Anchor" href="#整堆收集器"></a> 整堆收集器</h6><p>说到整堆收集器就只有说说G1收集器了，G1收集器具有并行与并发、分代收集、空间整合和可预测的停顿等特点。</p><ul><li>收集器既并行又并发，能够充分利用多CPU，缩短STW的停顿时间</li><li>因为G1能够管理整个堆，而不需要和其他的收集器搭配使用，虽然依然采用了分代模式，但它把堆分成了大小相等的若干个独立区域，相邻区域很可能是一个是新生代，一个是老年代。</li><li>整个过程中不会产生内存碎片，整体使用的“标记-整理”算法，局部使用的是复制算法，这两种算法都不会产生内存碎片，适合长时间运行。</li><li>低停顿的同时实现高吞吐量；G1除了追求低停顿处，还能建立可预测的停顿时间模型；可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒</li></ul><h4 id="5-减少gc次数的手段"><a class="markdownIt-Anchor" href="#5-减少gc次数的手段"></a> 5. 减少GC次数的手段</h4><ol><li>对象不使用时将其置为null</li><li>尽量不用System.gc()</li><li>尽量少用静态变量</li><li>使用StringBuffer代替String拼装字符串</li><li>分散对象创建和删除的时间</li><li>尽量少勇finallize方法</li><li>使用基本类型替代基本类型封装类</li><li>加大堆内存</li><li>慎用软引用、弱引用和虚引用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;曾经看到过一句话：如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。目前商业化虚拟机中常用的垃圾收集器有8种：新生代：Serial、ParNew、Parallel Scavenge，老年代：CMS、Serial Old、Parallel Old，整
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://luxiaowan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集算法浅谈</title>
    <link href="http://luxiaowan.github.io/2020/05/02/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%B5%85%E8%B0%88/"/>
    <id>http://luxiaowan.github.io/2020/05/02/JVM垃圾收集算法浅谈/</id>
    <published>2020-05-02T03:15:00.000Z</published>
    <updated>2020-05-09T14:40:10.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>JVM是做Java的同学都必须要了解的东西，为什么这么说，因为我们只有知道了Java程序运行环境的配置和工作逻辑，才能对运行环境进行相关的优化和配置修改，让JVM在不同的服务器环境使用不同的配置，从而达到JVM环境最优化。</p><p>说到JVM就不得不说一下GC（garbage collection），垃圾收集的意思是找到垃圾对象并回收掉它们，然后释放这些对象占用的内存。但是常规的垃圾收集器基本是找到正在被使用的对象，然后把其他的对象全部当作是垃圾对象清理掉。</p><p>写过C语言的同学都知道，在C语言中，我们需要手动的去管理内存，在使用内存之前我们需要先申请（malloc）一定大小的内存，使用完成之后需要手动的把使用的内存释放掉（free），如果忘记释放内存则很快会导致内存溢出。而Java将这份操作内存的工作交给了JVM，减少开发者的编码复杂度，降低发生内存溢出的概率。</p><h2 id="gc算法"><a class="markdownIt-Anchor" href="#gc算法"></a> GC算法</h2><ol><li><p>引用计数法</p><p>为每个对象添加一个引用计数器，在对象被引用时，计数器+1，引用结束后，计数器-1，最终清除掉引用计数器为0的对象，并级联删除该对象引用的所有的对象，只保留引用计数不为0的对象。</p><p>这种算法看起来是不是很屌，是的，非常简单，只需要在对象被引用的时候串行修改引用计数器的值即可，但也容易出现一种问题：循环引用！循环引用就是几个废对象之间循环引用，尽管他们的引用计数器都不为0，但是在整个程序中却没有被使用，但是他们永远不会被回收，这样的对象多了之后很容易造成内存泄漏。</p><img src="/images/image-20200506220501980.png" alt="image-20200506220501980" style="zoom:50%;"><p>正是因为循环引用的存在，JVM放弃了使用引用计数法。</p></li><li><p>标记-清除</p><p>标记-清理算法的基本思想是先STW，然后将存活的对象标记出来，接着清理掉未被标记的对象，整个过程都需要STW，效率很低，并且如果未被标记的对象比较分散，那么垃圾对象在被清理之后会造成大量的堆内存碎片，最终会导致无法给大对象分配内存。</p><img src="/images/image-20200506223517154.png" alt="image-20200506223517154" style="zoom:50%;"></li><li><p>标记-整理</p><p>标记-整理算法和标记-清除算法类似，只不过比标清多了一个步骤：在将所有存活的对象标记并清除完成之后，会将尚存活的对象全部都移动到堆内存的一端，并更新引用存活对象的指针。</p><img src="/images/image-20200506225506971.png" alt="image-20200506225506971" style="zoom:50%;"><p>引用指针更新：</p><img src="/images/image-20200506225749565.png" alt="image-20200506225749565" style="zoom:50%;"><p>标记-整理算法解决了标记-清除会造成内存碎片的缺点</p></li><li><p>复制</p><p>复制算法使用频率较高，算法思想也比较前倾，主要思想是将内存划分为相等大小的两块，每次只使用其中一块，当这一块内存不足时，就将其中存活的对象复制到另外一块内存中，且从其一端排列，并更新对象的引用指针，当存活对象全部都复制完成之后，将这块内存清空，然后激活被复制的这块内存空间，此后新创建的对象均分配到这块内存中，直到这块内存不足，重复使然。</p><p>复制算法将内存分为两块，每次只能使用其中一块，所以在使用过程中会一直浪费一半的内存无法使用，当虚拟机内存较小时，会频繁的发生GC，目前仅被使用在回收新生代内存。</p><img src="/images/image-20200506232601238.png" alt="image-20200506232601238" style="zoom:50%;"></li><li><p>可达性分析法</p><p>可达性的思想是通过一批“GC Roots”的对象作为起点，然后依次向下遍历，遍历到的对象均视为是存活的，遍历所走过的路径称为是引用链，最终将未遍历到的对象全部回收。</p><img src="/images/image-20200507003626531.png" alt="image-20200507003626531" style="zoom:50%;"><p>算法的本质是通过“GC Roots”找出所有存活的对象，然后把其他的对象全部认定为“垃圾对象”（这里有很多人认为是找到垃圾对象并回收，这是错误的）。此算法最重要的一步就是必须能够枚举出所有的“GC Roots”，否则就可能会将还存活的对象回收掉。</p><p>虚拟机内存中可以作为“GC Roots”的对象有以下几种：</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中的静态变量引用的对象</li><li>方法区中常量引用的对象</li></ul><p>在实际的开发中要特别注意这些对象，不要让无关紧要的大对象浪费了资源。</p></li><li><p>分代收集</p><p>根据对象的生存周期将内存划分为不同的区域，目前较流行的是分为新生代和老年代，然后根据各个年代的特点采用最适合的收集算法</p><ul><li>新生代：大部分对象都是朝生夕死，每次进行GC时都会被回收掉大量的对象，只有少量的对象会存活下来，这种适合复制算法，将新生代内存再划分为Eden区和两个Survivor区，Eden到Survivor和Survivor之间均采用复制算法，Eden区比较大，适合存储大量生命周期较短的对象，YGC后存活下来的少量对象被复制到Survivor区，Survivor区很小，每次复制仅需要付出少量存活对象的复制成本就可以完成收集</li><li>老年代中存储的对象大多是经历了多次GC之后存活下来的，并且还会存储部分大对象，这类对象被回收的概率较小，频次也较低，并且没有额外的内存空间为这块内存中的对象做分配担保，所以这个空间不应该出现内存碎片，否则很快就会没有内存可分配给新进入的对象，所以此块内存适用于“标记-整理”算法进行回收。</li></ul><img src="/images/image-20200509223555901.png" alt="image-20200509223555901" style="zoom:50%;"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;JVM是做Java的同学都必须要了解的东西，为什么这么说，因为我们只有知道了Java程序运行环境的配置和工作逻辑，才能对运行环境进行相关的优化和
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="GC" scheme="http://luxiaowan.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>MacBook突然没了声音</title>
    <link href="http://luxiaowan.github.io/2020/05/02/MacBook%E7%AA%81%E7%84%B6%E6%B2%A1%E4%BA%86%E5%A3%B0%E9%9F%B3/"/>
    <id>http://luxiaowan.github.io/2020/05/02/MacBook突然没了声音/</id>
    <published>2020-05-01T18:10:00.000Z</published>
    <updated>2020-05-02T07:49:49.276Z</updated>
    
    <content type="html"><![CDATA[<p>甭想了，这是Mac OS X的一个bug，可以通过重启解决，但是重启大法毕竟是不到万不得已的时候才使用的。</p><ol><li>打开活动监视器（不知道咋打开的就在【应用程序】中搜吧）</li><li>在活动监视器中搜索audio，然后找到coreaudiod，点击退出</li><li>退出之后会自动重启，然后就好了</li></ol><p><img src="/images/image-20200502021755810.png" alt="image-20200502021755810"></p><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo killall coreaudiod</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;甭想了，这是Mac OS X的一个bug，可以通过重启解决，但是重启大法毕竟是不到万不得已的时候才使用的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开活动监视器（不知道咋打开的就在【应用程序】中搜吧）&lt;/li&gt;
&lt;li&gt;在活动监视器中搜索audio，然后找到coreaudiod，点击退
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中什么样的对象有资格进入老年代</title>
    <link href="http://luxiaowan.github.io/2020/05/02/Java%E4%B8%AD%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E8%B5%84%E6%A0%BC%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3/"/>
    <id>http://luxiaowan.github.io/2020/05/02/Java中什么样的对象有资格进入老年代/</id>
    <published>2020-05-01T17:33:00.000Z</published>
    <updated>2020-05-02T07:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>当前我们使用的JVM的垃圾收集算法都是采用“分代”算法，将Java堆逻辑划分为年轻代（新生代）和老年代，并将对象按照其生命周期分配到对应的内存区域。那么什么对象会被分配到年轻代，什么对象被分配到老年代？</p><ol><li><p>一定次数的minor gc后</p><p>常规对象被创建之后是存储在年轻代的Eden区，每一个对象都有年龄，在YGC后，survivor1区还存活的对象的年龄全部+1，当对象年龄达到15时，被移交到老年代，15是系统默认的，我们可以通过JVM参数<code>-XX:MaxTenuringThreshold</code>来设置</p></li><li><p>minor gc后survivor放不下</p><p>在MinorGC之后存活的对象超过了survivor区的大小，会将这些对象直接转移到老年代</p></li><li><p>survivor内同年龄对象大小</p><p>如果再survivor区，有某一年龄的对象的总大小超过了survivor区大小的50%，则将这个年龄以上的对象全部转移到老年代</p></li><li><p>大对象</p><p>所谓大对象就是指需要比较大的连续内存空间的Java对象，比如很长的字符串或数组，我们可以通过JVM参数<code>-XX:PretenureSizeThreshold</code>指定大对象的容量，单位是字节。</p></li><li><p>老年代分配担保规则</p><p>在每一次执行Minor GC前，JVM都会检查一下老年代的剩余内存空间是否大于年轻代所有对象的总大小，目的是为了防止年轻代的对象在GC之后全部满足进入到老年代的条件，然后全部转移到老年代把老年代撑爆。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启是否允许冒险进行MinorGC，在jdk1.6 update24版本之后取消该参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只要老年代的连续空间大于年轻代对象总大小或历次晋升到来年代对象的平均大小就进行YGC(MinorGC)，否则进行FGC(MajorGC)</span></span><br><span class="line">-XX:-HandlePromotionFailure</span><br></pre></td></tr></table></figure><img src="/images/image-20200502154756565.png" alt="image-20200502154756565" style="zoom:50%;"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当前我们使用的JVM的垃圾收集算法都是采用“分代”算法，将Java堆逻辑划分为年轻代（新生代）和老年代，并将对象按照其生命周期分配到对应的内存区域。那么什么对象会被分配到年轻代，什么对象被分配到老年代？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一定次数的minor gc后&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>聊聊Java中的TLAB</title>
    <link href="http://luxiaowan.github.io/2020/04/29/%E8%81%8A%E8%81%8AJava%E4%B8%AD%E7%9A%84TLAB/"/>
    <id>http://luxiaowan.github.io/2020/04/29/聊聊Java中的TLAB/</id>
    <published>2020-04-29T11:15:00.000Z</published>
    <updated>2020-05-01T14:55:35.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-tlab介绍"><a class="markdownIt-Anchor" href="#一-tlab介绍"></a> 一、TLAB介绍</h3><p>TLAB（Thread Local Allocation Buffer）是在Hotspot1.6引入的新技术，目的是提升在堆上创建对象的性能。</p><p>如果一个对象被创建到堆上时，需要在堆上申请指定大小的内存供新创建的对象使用，在这个过程中，堆会通过加锁或指针碰撞的方式防止同一块被重复申请，在JVM中，内存分配是一个非常频繁的动作，而给堆加锁或者校验碰撞指针的方式必定会影响内存创建效率，TLAB的出现就是为了优化这个问题。</p><h3 id="二-tlab细节"><a class="markdownIt-Anchor" href="#二-tlab细节"></a> 二、TLAB细节</h3><p>TLAB是线程的一块私有内存，这块内存在堆中，可以通过JVM参数-XX:+UseTLAB开启。</p><ul><li><p>在线程启动的时候会在堆中为其申请一块指定大小的内存，这块内存只给当前线程使用，属于线程私有的，如果线程需要为线程内的对象分配内存，就再自己的空间上分配，这样就不存在内存竞争的情况了，大大的提升了分配效率；</p><p><img src="/images/image-20200430000859329.png" alt="image-20200430000859329"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize_tlab</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">    tlab().initialize();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当TLAB空间容量不足时，就新申请一个TLAB，原来的那个TLAB区里的对象还维持现状，因为对象只能感知到自己在Eden区。</p></li><li><p>TLAB空间的内存非常小，默认大小仅有Eden区的1%，也可以通过JVM参数-XX:TLABWasteTargetPercent设置TLAB空间占Eden空间的百分比大小，一般用默认的就可以。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启TLAB</span></span><br><span class="line">-XX:+UseTLAB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭TLAB</span></span><br><span class="line">-XX:-UseTLAB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置每个TLAB区域占Eden区的大小比例</span></span><br><span class="line">-XX:TLABWasteTargetPercent</span><br></pre></td></tr></table></figure></li></ul><h3 id="三-tlab规则"><a class="markdownIt-Anchor" href="#三-tlab规则"></a> 三、TLAB规则</h3><ol><li><p>我们下载openjdk，到查看文件<code>hotspot/src/share/vm/memory/threadLocalAllocBuffer.hpp</code>，这是TLAB的源码实现，看一下类中的属性：</p><p><img src="/images/image-20200429221957003.png" alt="image-20200429221957003"></p><p>从类中我们看到四个HeapWord实例，对于我们来说只需要关心start、top和end，我们结合和源码分析一下每个变量的用途。</p><ul><li><p>根据它们的注释我们可以知道start是TLAB的地址，end是申请的TLAB空间的尾部，也就是通过start和end就可以标识出这个TLAB所管理的区域，防止其他线程再来分配这块空间。</p></li><li><p>top是归属线程最后一次申请空间的尾位置，当top撞上end的时候就表示这个TLAB的空间用完了，这时会申请一个新的TLAB。</p></li></ul></li><li><p>每一个TLAB空间大小都是固定的，默认的是Eden区大小的的1%，既然大小是固定的，那么肯定会出现空间浪费的情况，比如TLAB大小是100kb，已经被使用了90kb，此时有一个12kb的对象来申请空间，但是TLAB的剩余空间已经不足以分配给这个对象了，此时怎么办？是新申请一个TLAB，还是直接分配到Eden区？在设计TLAB的时候就已经考虑到这种情况了，使用变量<code>refill_waste_limit</code>来控制一个TLAB允许被浪费的空间大小。</p><ul><li><p>如果<code>refill_waste_limit</code>的值是5kb的话，那么一个TLAB允许浪费的最大空间就是5kb，但是上述情况下TLAB还剩10kb的空间，不满足浪费条件，那么这个TLAB就不能被遗弃，还需要继续使用，所以不能申请新的TLAB，那么这个12kb的对象就只能被分配到Eden区；</p></li><li><p>如果<code>refill_waste_limit</code>的值是10kb，那么上述情况已经满足了空间可浪费的大小限制，此时就会直接遗弃当前的TLAB，重新申请一个新的来存放申请对象；</p></li><li><p>如果对象需要的空间特别大，超过了整个TLAB的大小，那么就会被直接放到Eden区。</p></li></ul></li><li><p>TLAB是允许浪费一部分空间的，这会导致在大量TLAB都浪费了部分空间的时候Eden区空间不连续，影响整个Eden区的使用。</p></li></ol><img src="/images/image-20200501225512825.png" alt="image-20200501225512825" style="zoom:50%;"><h3 id="四-总结"><a class="markdownIt-Anchor" href="#四-总结"></a> 四、总结</h3><p>基本上TLAB介绍到这里就可以了，再深入一点的话就要到C++代码层面了。</p><p><img src="/images/image-20200429003839422.png" alt="image-20200429003839422"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-tlab介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-tlab介绍&quot;&gt;&lt;/a&gt; 一、TLAB介绍&lt;/h3&gt;
&lt;p&gt;TLAB（Thread Local Allocation Buffer）是在Hotspot1.6引入的新技术
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>一道面试题引发的逃逸分析</title>
    <link href="http://luxiaowan.github.io/2020/04/29/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>http://luxiaowan.github.io/2020/04/29/一道面试题引发的逃逸分析/</id>
    <published>2020-04-29T02:27:00.000Z</published>
    <updated>2020-04-29T05:54:55.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试题"><a class="markdownIt-Anchor" href="#面试题"></a> 面试题</h3><p>在Java中，通过new创建的对象一定分配在堆上吗？</p><h3 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h3><p>是不是很想回答：是的！然后看到题中的“一定”二字犹豫了？这是一个开放性的面试题，你可以回答一定是的，但是要有个前提，这个前提先不揭秘，下面我们先来看几个概念性的东西：逃逸分析、栈上分配和TLAB(Thread Local Allocation Buffer)。</p><h4 id="1-逃逸分析是什么"><a class="markdownIt-Anchor" href="#1-逃逸分析是什么"></a> 1. 逃逸分析是什么</h4><p>逃逸分析（Escape Analysis）是一种可以通过分析对象的作用域来决定将其分配到何处的性能优化技术，为什么说是性能优化技术，因为通过开启逃逸分析，可以节省堆的使用，看到这里的小朋友是不是有很多问号？？？？别急，先来看看逃逸分析是怎么工作的。</p><p>在Java中，我们很少提到指针这个概念，那是因为所有的指针相关的东西都被JVM帮我们做了，而分析指针动态范围的方法就称之为逃逸分析，简单来说就是当一个对象的指针被多个方法或线程引用时，我们就称这个指针发生了逃逸。逃逸是指逃出了当前代码块的作用域，被其他的代码块引用了。</p><h4 id="2-对象如何逃逸"><a class="markdownIt-Anchor" href="#2-对象如何逃逸"></a> 2. 对象如何逃逸</h4><p>在实际开发中，一个对象的作用域主要包括：全局变量、方法返回值、引用参数、方法体内等，这三个不同作用域的对象在经过逃逸分析之后，会得出三种不同的分析结果。</p><ul><li>全局逃逸（Global Escape）：当一个对象的作用范围跳出了当前方法或者当前线程，则可以判定该对象发生了全局逃逸，比如全局变量、方法返回值等。</li><li>参数逃逸（Arg Escape）：当一个对象被作为方法参数进行传递或被参数引用时。</li><li>没有逃逸（NoEscape）：对象的作用范围在一个方法体内。</li></ul><h4 id="3-编译器如何优化逃逸的对象"><a class="markdownIt-Anchor" href="#3-编译器如何优化逃逸的对象"></a> 3. 编译器如何优化逃逸的对象</h4><p>对象发生了逃逸，也就是被多个线程或方法共享了，那么这个对象必定要分配到能够被线程共享的内存区域，否则这个对象无法被其他线程读取使用。纵观JVM内存模型，官方规定的被线程共享的内存模块有堆和元空间（低版本中有方法区），而被用来存储对象的内存区域就是堆了，所以要是想让对象被线程共享，那么将其放在堆中就可以实现。反而之就是这个对象是线程私有的，那么将其放在虚拟机栈中即可，而对象是一个聚合量（由基础类型和对象的引用等标量聚合而成），它又可以被再次分解成标量，这又叫作标量替换，如果没有发生逃逸的对象在分析之后发现可以不用连续的为其分配空间，对象内的变量可以单独的分析和优化，那么就会使用标量替换将一个对象拆分成若干个部分分别在栈或寄存器上分配空间；并且线程私有的对象不存在资源竞争的情况，所以给这个对象加锁就完全没必要了，这种情况下，虚拟机会自动消除这个对象上的锁。</p><p>综上我们可以整理为：</p><ul><li>没有发生逃逸的对象可以直接分配在虚拟机栈上，随着线程的结束一并回收；</li><li>若开启了标量替换规则，且逃逸分析后判定不需要为某个对象分配连续的存储空间，则会将对象进行标量拆分，然后分别存储在栈或寄存器上；</li><li>未发生逃逸的对象是线程私有的，不会出现并发竞争资源的情况，所以不需要为对象加锁，对象上的锁会被虚拟机忽略。</li></ul><h4 id="4-栈上分配"><a class="markdownIt-Anchor" href="#4-栈上分配"></a> 4. 栈上分配</h4><p>上面说到没有发生逃逸的对象可以直接被分配在线程私有的虚拟机栈上，那么方法栈上的对象在方法执行结束之后，栈帧弹出，对象就被自动回收了，这样做的好处是JVM内存回收效率提高，也减少了GC的的频率。</p><h4 id="5-如何开启逃逸分析和标量替换"><a class="markdownIt-Anchor" href="#5-如何开启逃逸分析和标量替换"></a> 5. 如何开启逃逸分析和标量替换</h4><p>在jdk1.8 Server模式下，逃逸分析是默认开启的（其他版本待测试），我们可以通过JVM参数手动的开启和关闭。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis：开启逃逸分析，默认</span><br><span class="line">-XX:-DoEscapeAnalysis：关闭逃逸分析</span><br><span class="line">-XX:+EliminateAllocations：开启标量替换，允许将对象打散分配到栈或寄存器上，默认</span><br><span class="line">-XX:-EliminateAllocations：关闭标量替换</span><br></pre></td></tr></table></figure><h4 id="6-小"><a class="markdownIt-Anchor" href="#6-小"></a> 6. 小🌰</h4><ul><li><p>非栈上分配</p><p>JVM参数：<code>-server -Xmx50m -Xms50m -XX:+PrintGC -XX:-DoEscapeAnalysis -XX:-EliminateAllocations</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocOnJVM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="/images/image-20200429131241750.png" alt="image-20200429131241750" style="zoom:50%;"><p>发生了多次GC，且最终执行时间为15毫秒，从GC的情况来看，对象b是被分配到了堆上，且因为堆空间不足而引起的GC。</p></li><li><p>栈上分配</p><p>JVM参数：<code>-server -Xmx50m -Xms50m -XX:+PrintGC -XX:+DoEscapeAnalysis -XX:+EliminateAllocations</code></p><p>代码和上面一致，我们来看下执行结果：</p><img src="/images/image-20200429131322123.png" alt="image-20200429131322123" style="zoom: 67%;"><p>整个代码执行完只用了5毫秒，且未发生GC，同样的配置，同样的代码，执行的结果却不相同，说明栈上分配确实可以提升代码的执行效率。</p></li><li><p>同步锁消除</p><p>在上文中我们提到栈上分配会将对象上的同步锁消除掉，在jdk1.8中，同步锁消除是默认开启的，我们可以使用命令关闭，同步锁消除必须在开启逃逸分析的前提下才有效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+EliminateLocks：开启同步锁消除，默认</span><br><span class="line">-XX:-EliminateLocks：关闭同步锁消除</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocOnJVM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">            b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开启逃逸分析且关闭锁消除的情况下执行结果：</p><p>JVM参数：<code>-server -Xmx50m -Xms50m -XX:+PrintGC -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks</code></p><p><img src="/images/image-20200429132238656.png" alt="image-20200429132238656"></p><p>在开启逃逸分析且开启锁消除的情况下执行结果：</p><p>JVM参数：<code>-server -Xmx50m -Xms50m -XX:+PrintGC -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks</code></p><p><img src="/images/image-20200429131833250.png" alt="image-20200429131833250"></p><p>两种情况下对比发现，在开启同步锁消除之后，synchronized好像没有生效，验证成功。</p></li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>通过我们对这个面试题的解析，发现并不是所有的对象都被分配到堆上，虚拟机为了加快程序运行效率，减少GC带来的额外开销，推出了栈上分配，而栈上分配又是基于逃逸分析的分析结果来决定是否执行的，被分配到栈上的对象如果带有同步锁，可以通过JVM参数配置让同步锁失效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面试题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面试题&quot;&gt;&lt;/a&gt; 面试题&lt;/h3&gt;
&lt;p&gt;在Java中，通过new创建的对象一定分配在堆上吗？&lt;/p&gt;
&lt;h3 id=&quot;解析&quot;&gt;&lt;a class=&quot;markdownIt-Ancho
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java对象创建过程</title>
    <link href="http://luxiaowan.github.io/2020/04/28/Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://luxiaowan.github.io/2020/04/28/Java对象创建过程/</id>
    <published>2020-04-28T09:10:00.000Z</published>
    <updated>2020-04-28T16:40:09.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、概述</h3><p>在Java中，一个对象只要被正确的实例化之后才能被使用，在对象实例化的时候，会先检查相关的类信息是否已经被加载并初始化，在类初始化完毕之后才会继续完成对象的实例化，类的一生主要经历加载、连接（验证、准备、解析）、初始化、使用和卸载五个过程，创建类的对象就是在使用这个阶段。</p><img src="/images/image-20200428213918172.png" alt="image-20200428213918172" style="zoom:50%;"><blockquote><p>加载（Loading）：通过类的全限定名查找和读取class文件，将读取的字节流所代表的静态存储结构转化为方法区的运行时数据结构，然后在内存中生成一个代表这个类的Class对象，作为方法区这个类的访问入口，并将这个Class对象存放在方法区中（方法区主要存储类信息、常量、静态变量）。这个过程可以通过自定义的类加载器进行操作。</p><p>连接（Linking）：把类的二进制数据合并入JRE中，这个过程包括三个阶段：</p><ol><li>验证：该阶段验证被加载后的类的结构是否正确，类数据是否符合虚拟机的规定，保证该类不会危险到虚拟机的安全。</li><li>准备：验证完成之后立即为类的静态变量(static)在方法区分配内存，并给变量赋默认值（o、false、0.0f、’’、null或指定的值等），比如<code>static boolean flag = true;</code>，在准备阶段就会给变量flag赋默认值false，然后在初始化阶段将变量flag赋值于true；但是对于静态常量(static final)来说，会在此阶段将常量赋予最终值，比如<code>static final int num = 10;</code>，在该阶段之后，静态常量num的值就一直是10了。</li><li>解析：将类的二进制数据中的符号引用转换为直接饮用。符号引用是以一组符号来描述所引用的目标，与虚拟机实现的内存布局无关，引用的目标不一定已经存在于内存中；直接饮用是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，与虚拟机实现的内存布局有关，引用的目标必定已经存在于内存中。</li></ol><p>初始化（Initialization）：类初始化的主要工作是为静态变量赋代码设定的值，如上面讲到的<code>static boolean flag = true;</code>，在连接的准备阶段，静态变量flag的值被设置为false，但是在初始化阶段会将flag的值设置为true，也就是我们代码中设定的初始值。初始化节点会调用类构造器&lt;cInit&gt;()，该构造器是由编译器自动收集类中的所有类变量的赋值和静态代码块中的语句合并生成的，编译器收集的顺序由代码语句在源文件中的顺序决定的。</p><p>☆除了加载阶段可以用户自定义之外，其他阶段的动作完全由虚拟机主导控制。</p></blockquote><h3 id="二-对象的创建方式"><a class="markdownIt-Anchor" href="#二-对象的创建方式"></a> 二、对象的创建方式</h3><p>在Java代码中可以通过多种方式完成对象的创建，最常用也是最直观的一种方式就是通过new关键字来调用类的构造器显示的创建对象，在Java规范中称此方式为：由执行类实例创建表达式而引起的对象创建。另外我们还可以通过使用反射、clone方法、序列化等方式去创建对象。</p><ol><li><p>使用new关键字</p><p>该方式是我们最常见也是最简单的一种方式，我们可以调用一个类的任意构造器(无参或有参)去创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cc c = <span class="keyword">new</span> Cc();</span><br><span class="line">或</span><br><span class="line">Cc c = <span class="keyword">new</span> Cc(<span class="string">"cc"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>当虚拟机执行到new指令时，首先在常量池中查找Cc的符号引用，若能定位到Cc类的符号引用，说明这个类已经被加载到方法区了，若没有找到则先去加载Cc这个类。</p></li><li><p>使用反射</p><ul><li><p>使用Class类的newInstance方法</p><p>可以利用反射机制通过调用Class类的newInstance方法来创建对象，并且这个newInstance方法调用的是目标类无参的构造器，所以要是想使用该方式创建某个类的对象，就必须要保证这个类要有一个无参的构造器，否则会报错<code>NoSuchMethodException: cc.kevinlu.ccspringbootwar.Cc.&lt;init&gt;()</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cc c = (Cc) Class.forName(<span class="string">"cc.lu.clazz.ni.Cc"</span>).newInstance();</span><br><span class="line">或</span><br><span class="line">Cc cc = Cc.class.newInstance();</span><br></pre></td></tr></table></figure><p>我们会发现在使用<code>Class.forName().newInstance()</code>的时候需要进行一次强制类型转换，Class类的newInstance方法内部也是通过调用Constructor的newInstance无参构造器。</p></li><li><p>使用Constructor类的newInstance方法</p><p><code>java.lang.reflect.Constructor</code>类中也有一个newInstance方法可以用来创建对象，该方法与Class类的newInstance方法类似，但是Constructor中的newInstance方法更加强大，因为它既可以调用无参的构造器也可以调用有参数的构造器，通吃。并且Constructor是一个泛型类，不需要我们再进行对象的强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 调用无参构造器</span></span><br><span class="line">      Constructor&lt;Cc&gt; c1 = Cc.class.getConstructor();</span><br><span class="line">        Cc cc1 = c1.newInstance();</span><br><span class="line">        System.out.println(cc1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用有参构造器</span></span><br><span class="line">        Constructor&lt;Cc&gt; constructor = Cc.class.getConstructor(String.class);</span><br><span class="line">        Cc ccc = constructor.newInstance(<span class="string">"cc"</span>);</span><br><span class="line">        System.out.println(ccc);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cc&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用clone方法</p><p>我们可以调用一个对象的clone方法进行对象的深拷贝或浅拷贝，并且如果我们想要使用clone方法，必须实现接口<code>java.lang.Cloneable</code>，这是一个标识性质的接口，告诉虚拟机这个类的实例对象支持克隆，就像接口<code>java.io.Serializable</code>用来标识类的实例对象可以被序列化一样，没有实现Cloneable的类的对象在调用clone方法的时候会报<code>java.lang.CloneNotSupportedException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Constructor&lt;Cc&gt; constructor = Cc.class.getConstructor(String.class);</span><br><span class="line">        Cc c = constructor.newInstance(<span class="string">"cc"</span>);</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        Cc cc = (Cc) c.clone();</span><br><span class="line">        System.out.println(cc);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重点：必须实现java.lang.Cloneable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cc&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用序列化</p><p>当我们反序列化一个对象时，虚拟机会帮我们创建一个单独的对象，过程中不会调用任何的构造器，被序列化和反序列化的类必须实现接口<code>java.io.Serializable</code>，目的是告诉虚拟机这个类的实例对象可以被序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Constructor&lt;Cc&gt; constructor = Cc.class.getConstructor(String.class);</span><br><span class="line">        Cc c = constructor.newInstance(<span class="string">"cc"</span>);</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cc.bf"</span>));</span><br><span class="line">        oos.writeObject(c);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cc.bf"</span>));</span><br><span class="line">        Cc cc = (Cc) ois.readObject();</span><br><span class="line">        System.out.println(cc);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cc&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.lu.clazz.ni;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Class的newInstance方式一</span></span><br><span class="line">        Cc c = (Cc) Class.forName(<span class="string">"cc.lu.clazz.ni.Cc"</span>).newInstance();</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Class的newInstance方式二</span></span><br><span class="line">        Cc cc = Cc.class.newInstance();</span><br><span class="line">        System.out.println(cc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Constructor无参构造器</span></span><br><span class="line">        Constructor&lt;Cc&gt; c1 = Cc.class.getConstructor();</span><br><span class="line">        Cc cc1 = c1.newInstance();</span><br><span class="line">        System.out.println(cc1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Constructor有参构造器</span></span><br><span class="line">        Constructor&lt;Cc&gt; constructor = Cc.class.getConstructor(String.class);</span><br><span class="line">        Cc ccc = constructor.newInstance(<span class="string">"cc"</span>);</span><br><span class="line">        System.out.println(ccc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clone</span></span><br><span class="line">        Cc cm = (Cc) ccc.clone();</span><br><span class="line">        System.out.println(cm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cc.bf"</span>));</span><br><span class="line">        oos.writeObject(ccc);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cc.bf"</span>));</span><br><span class="line">        Cc c3 = (Cc) ois.readObject();</span><br><span class="line">        System.out.println(c3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cc&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-对象的创建过程"><a class="markdownIt-Anchor" href="#三-对象的创建过程"></a> 三、对象的创建过程</h3><ol><li><p>实例变量与实例代码块的初始化</p><p>对象被创建时，虚拟机为其分配内存来存放实例变量（自己的和继承而来的），在分配内存的同时会对实例变量进行默认值设置，默认值有两种设置方式，一种是直接赋值，另一种是使用实例代码块赋值，编译后查看字节码会发现实例代码块会按照声明的顺序对实例变量赋值操作去重之后，将最后实例代码块中的语句放到类的构造器中，例如下方代码，最终实例变量的值为：name=“cc”,sex=“男1”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        sex = <span class="string">"男"</span>;</span><br><span class="line">        name = <span class="string">"cc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        sex = <span class="string">"男1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例代码块中如果使用一个实例变量赋值给另外一个实例变量的话，那么作为值的这个实例变量的声明必须要在实例代码块之前，否则会在编译的时候就报错<code>Illegal forward reference</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">"cc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 此处sex1会报错</span></span><br><span class="line">        sex = sex1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String sex1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要绕过这种检查，可以创建sex1的getter方法，在代码块中调用这个getter方法，但是会出现另外一种情况：sex会获取到sex1在连接阶段设置的默认值，所以慎用。</p></li><li><p>构造器初始化</p><p>Java的类是具有继承关系的，所有类的超类都是Object，在字节码中，构造器会被命名为&lt;init&gt;()方法，参数和代码中声明的一致，没有我们没有在类中显式定义构造器的话，虚拟机会为类创建一个默认的无参构造器。Java规则规定在实例化类之前，必须先要实例化其父类，以保证实例的完整性。Java强制要求除Object之外的所有类的构造器的第一句必须是父类的构造器调用语句（super(…)），如果把super()语句放到其他行，那么编译的时候就会提示错误<code>Call to 'super()' must be first statement in constructor body</code>。</p><p>我们分析一个情景：看如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ① super();</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"cc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ②</span></span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种情况，Java只允许在构造器Cc(String name)内调用超类的构造器，①处的代码会报错。</p></li></ol><h3 id="四-小结"><a class="markdownIt-Anchor" href="#四-小结"></a> 四、小结</h3><p>类实例化的过程可以总结为：</p><ol><li>首先在常量池中定位类的符号引用</li><li>判定是否需要进行类加载</li><li>虚拟机为新生对象分配内存（对象所需要的内存大小在类加载完就可以确定）</li><li>初始化实例变量</li><li>虚拟机设置对象头信息</li><li>执行代码块进行自定义初始化</li><li>完成</li></ol><img src="/images/image-20200429002706141.png" alt="image-20200429002706141" style="zoom:50%;"><h3 id="五-对象创建过程中内存的分配"><a class="markdownIt-Anchor" href="#五-对象创建过程中内存的分配"></a> 五、对象创建过程中内存的分配</h3><p>文字理解起来不如看图，直接看图理解吧：</p><p><img src="/images/image-20200429003839422.png" alt="image-20200429003839422"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-概述&quot;&gt;&lt;/a&gt; 一、概述&lt;/h3&gt;
&lt;p&gt;在Java中，一个对象只要被正确的实例化之后才能被使用，在对象实例化的时候，会先检查相关的类信息是否已经被加载并初始化，在类初始化完
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac上怎么配置MySQL</title>
    <link href="http://luxiaowan.github.io/2020/04/28/Mac%E4%B8%8A%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AEMySQL/"/>
    <id>http://luxiaowan.github.io/2020/04/28/Mac上怎么配置MySQL/</id>
    <published>2020-04-28T08:05:00.000Z</published>
    <updated>2020-04-28T08:39:29.530Z</updated>
    
    <content type="html"><![CDATA[<p>在Mac上可以通过官方dmg文件或者Homebrew的方式安装MySQL，具体方式就不介绍了，可以谷歌一下，安装完成之后，在电脑上却找不到MySQL的配置文件my.cnf，可以通过命令<code>find / -iname my.cnf</code>进行全盘查找。难道我们Mac上的MySQL不需要配置文件？</p><p>我们进入到MySQL的安装路径下，查看<code>support-files/mysql.server</code>文件内容，在文件中有一块说明了my.cnf文件的默认位置：</p><img src="/images/image-20200428162211287.png" alt="image-20200428162211287" style="zoom:50%;"><p>大致意思就是如果mysql没有安装在<code>/usr/local/mysql</code>目录下的话，需要手动在<code>/etc</code>目录下创建my.cnf文件来配置安装的MySQL，并且在服务启动的时候会默认先去读取<code>/etc/my.cnf</code>，若文件存在则直接使用该文件中的配置，从这条规则来看，我们只需要在<code>/etc</code>目录下创建一个my.cnf文件，并将我们需要自定义的配置写到里面即可</p><img src="/images/image-20200428163629688.png" alt="image-20200428163629688" style="zoom:50%;"><p>附赠一份官方的my.cnf配置文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Example MySQL config file <span class="keyword">for</span> medium systems.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is <span class="keyword">for</span> a system with little memory (32M - 64M) <span class="built_in">where</span> MySQL plays</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> an important part, or systems up to 128M <span class="built_in">where</span> MySQL is used together with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> other programs (such as a web server)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MySQL programs look <span class="keyword">for</span> option files <span class="keyword">in</span> a <span class="built_in">set</span> of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> locations <span class="built_in">which</span> depend on the deployment platform.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can copy this option file to one of those</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> locations. For information about these locations, see:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://dev.mysql.com/doc/mysql/en/option-files.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> In this file, you can use all long options that a program supports.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you want to know <span class="built_in">which</span> options a program supports, run the program</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> with the <span class="string">"--help"</span> option.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The following options will be passed to all MySQL clients</span></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash">password = your_password</span></span><br><span class="line">port= 3306</span><br><span class="line">socket= /tmp/mysql.sock </span><br><span class="line"><span class="meta">#</span><span class="bash"> Here follows entries <span class="keyword">for</span> some specific programs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The MySQL server</span></span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">init_connect='SET NAMES utf8</span><br><span class="line">port= 3306</span><br><span class="line">socket= /tmp/mysql.sock</span><br><span class="line">skip-external-locking</span><br><span class="line">key_buffer_size = 16M</span><br><span class="line">max_allowed_packet = 1M</span><br><span class="line">table_open_cache = 64</span><br><span class="line">sort_buffer_size = 512K</span><br><span class="line">net_buffer_length = 8K</span><br><span class="line">read_buffer_size = 256K</span><br><span class="line">read_rnd_buffer_size = 512K</span><br><span class="line">myisam_sort_buffer_size = 8M</span><br><span class="line">character-set-server=utf8</span><br><span class="line">init_connect='SET NAMES utf8' </span><br><span class="line"><span class="meta">#</span><span class="bash"> Don<span class="string">'t listen on a TCP/IP port at all. This can be a security enhancement,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> all processes that need to connect to mysqld run on the same host.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> All interaction with mysqld must be made via Unix sockets or named pipes.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that using this option without enabling named pipes on Windows</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (via the <span class="string">"enable-named-pipe"</span> option) will render mysqld useless!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">skip-networking</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication Master Server (default)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> binary logging is required <span class="keyword">for</span> replication</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> binary logging format - mixed recommended</span></span><br><span class="line">binlog_format= MIXED</span><br><span class="line"><span class="meta">#</span><span class="bash">mixed</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> required unique id between 1 and 2^32 - 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> defaults to 1 <span class="keyword">if</span> master-host is not <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> but will not <span class="keyword">function</span> as a master <span class="keyword">if</span> omitted</span></span><br><span class="line">server-id = 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication Slave (comment out master section to use this)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To configure this host as a replication slave, you can choose between</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> two methods :</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1) Use the CHANGE MASTER TO <span class="built_in">command</span> (fully described <span class="keyword">in</span> our manual) -</span></span><br><span class="line"><span class="meta">#</span><span class="bash">the syntax is:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">where</span> you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;port&gt; by the master<span class="string">'s port number (3306 by default).</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Example:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">CHANGE MASTER TO MASTER_HOST=<span class="string">'125.564.12.1'</span>, MASTER_PORT=3306,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">MASTER_USER=<span class="string">'joe'</span>, MASTER_PASSWORD=<span class="string">'secret'</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) Set the variables below. However, <span class="keyword">in</span> <span class="keyword">case</span> you choose this method, <span class="keyword">then</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">start replication <span class="keyword">for</span> the first time (even unsuccessfully, <span class="keyword">for</span> example</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> you mistyped the password <span class="keyword">in</span> master-password and the slave fails to</span></span><br><span class="line"><span class="meta">#</span><span class="bash">connect), the slave will create a master.info file, and any later</span></span><br><span class="line"><span class="meta">#</span><span class="bash">change <span class="keyword">in</span> this file to the variables<span class="string">' values below will be ignored and</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">overridden by the content of the master.info file, unless you shutdown</span></span><br><span class="line"><span class="meta">#</span><span class="bash">the slave server, delete master.info and restart the slaver server.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">For that reason, you may want to leave the lines below untouched</span></span><br><span class="line"><span class="meta">#</span><span class="bash">(commented) and instead use CHANGE MASTER TO (see above)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> required unique id between 2 and 2^32 - 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (and different from the master)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> defaults to 2 <span class="keyword">if</span> master-host is <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> but will not <span class="keyword">function</span> as a slave <span class="keyword">if</span> omitted</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server-id = 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The replication master <span class="keyword">for</span> this slave - required</span></span><br><span class="line"><span class="meta">#</span><span class="bash">master-host = &lt;hostname&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The username the slave will use <span class="keyword">for</span> authentication when connecting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to the master - required</span></span><br><span class="line"><span class="meta">#</span><span class="bash">master-user = &lt;username&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The password the slave will authenticate with when connecting to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the master - required</span></span><br><span class="line"><span class="meta">#</span><span class="bash">master-password = &lt;password&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The port the master is listening on.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> optional - defaults to 3306</span></span><br><span class="line"><span class="meta">#</span><span class="bash">master-port =&lt;port&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> binary logging - not required <span class="keyword">for</span> slaves, but recommended</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">log</span>-bin=mysql-bin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Uncomment the following <span class="keyword">if</span> you are using InnoDB tables</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_data_home_dir = /usr/<span class="built_in">local</span>/mysql/data</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_data_file_path = ibdata1:10M:autoextend</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_log_group_home_dir = /usr/<span class="built_in">local</span>/mysql/data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can <span class="built_in">set</span> .._buffer_pool_size up to 50 - 80 %</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of RAM but beware of setting memory usage too high</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_buffer_pool_size = 16M</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_additional_mem_pool_size = 2M</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set .._log_file_size to 25 % of buffer pool size</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_log_file_size = 5M</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_log_buffer_size = 8M</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_flush_log_at_trx_commit = 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innodb_lock_wait_timeout = 50</span></span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">max_allowed_packet = 16M</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line"><span class="meta">#</span><span class="bash"> Remove the next comment character <span class="keyword">if</span> you are not familiar with SQL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">safe-updates</span></span><br><span class="line">default-character-set=utf8 </span><br><span class="line"></span><br><span class="line">[myisamchk]</span><br><span class="line">key_buffer_size = 20M</span><br><span class="line">sort_buffer_size = 20M</span><br><span class="line">read_buffer = 2M</span><br><span class="line">write_buffer = 2M</span><br><span class="line"></span><br><span class="line">[mysqlhotcopy]</span><br><span class="line">interactive-timeout</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Mac上可以通过官方dmg文件或者Homebrew的方式安装MySQL，具体方式就不介绍了，可以谷歌一下，安装完成之后，在电脑上却找不到MySQL的配置文件my.cnf，可以通过命令&lt;code&gt;find / -iname my.cnf&lt;/code&gt;进行全盘查找。难道我们M
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>聊一聊MySQL事务</title>
    <link href="http://luxiaowan.github.io/2020/04/27/%E8%81%8A%E4%B8%80%E8%81%8AMySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>http://luxiaowan.github.io/2020/04/27/聊一聊MySQL事务/</id>
    <published>2020-04-27T07:30:00.000Z</published>
    <updated>2020-04-27T15:30:46.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-事务为何物"><a class="markdownIt-Anchor" href="#一-事务为何物"></a> 一、事务为何物</h3><p>事务（Transaction）是保障程序中一组操作的原子性的约束，它使事务中的所有操作都指向同一个结果，也就是要么所有的操作都执行成功，要么所有的操作都执行失败，不允许出现其他结果。例如银行转账，从A账户扣除金额，向B账户添加金额，这两个数据库操作的总和构成一个完整的逻辑过程，不可拆分，这个过程被称为一个事务。在MySQL中，目前只有InnoDB引擎支持事务。</p><h3 id="二-事务的特性"><a class="markdownIt-Anchor" href="#二-事务的特性"></a> 二、事务的特性</h3><p>数据库管理系统在写入或更新数据的过程中，为保证事务是正确可靠的，需要具备四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p><ul><li>原子性（Atomicity）：一个事物中的所有操作，要么全部完成，要么全部失败，不会在中间某个环节结束。若事务在执行过程中发生异常，所有的操作都会被回滚到事务开始前的状态，就像这个事务从没执行过一样。</li><li>一致性（Consistency）：事务操作的数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定，也就是在事务开始之前和结束之后，数据库的完整性没有被破坏。</li><li>隔离性（Isolation）：数据库允许多个事务并发执行，隔离性是为了防止多个事务并发执行导致数据的不一致，事务之间是相互隔离的。事务隔离有四种级别：未提交读（Read UnCommitted）、已提交读（Read Commited）、可重复读（Repeatable Read）、串行化（Serializable）</li><li>持久性：事务成功提交之后，对数据的修改是永久性的，即便系统故障也不会丢失。</li></ul><h3 id="三-为什么要有四种隔离级别"><a class="markdownIt-Anchor" href="#三-为什么要有四种隔离级别"></a> 三、为什么要有四种隔离级别</h3><p>SQL标准定义了4种隔离级别用来限定不同的事务场景，按照隔离级别从低到高为：读未提交、读已提交、可重复读、串行化，级别越高，所支持的并发度越低。</p><blockquote><p>不同的隔离级别会造成不同的影响，体现在数据上就是脏读、不可重复读和幻读。</p></blockquote><ul><li>脏读：A事务读取了B事务中未提交的数据，在A事务提交之前，B事务进行了回滚，此时A事务中的数据就不正确了，所以被定义为脏数据。</li><li>不可重复读：A事务在第一次读取之后到第二次读取之前，B事务对该数据进行了修改，导致A事务两次读取的数据不一致，这就是不可重复读</li><li>幻读：幻读一般发生在范围查询的情况下，A事务第一次读取一批数据，在第二次读取之前，B事务向数据库中插入了新的符合A事务查询条件的数据，此时A事务第二次读取出来的数据条数不一致，这种情况对于A事务来说就是出现了幻读。</li></ul><blockquote><p>事务隔离级别</p></blockquote><ul><li>读未提交（Read UnCommitted）：该隔离级别下的事务可以看到其他事务未提交的执行结果，会引起脏读、不可重复读和幻读，在实际应用中几乎不会使用该级别的事务。</li><li>读已提交（Read Committed）：这是大多数数据库系统的默认隔离级别（如Oracle、阿里云的MySQL）等，但不是官方MySQL默认的。它不允许事务看到未提交的事务中的数据，使事务只能看见已经提交的事务所做的改变。该隔离级别会引起不可重复读和幻读。</li><li>可重复读（Repeatable Read）：这是官方MySQL的默认事务隔离级别，它确保同一事务多次读取的数据的一致性，解决了不可重复读的问题。该隔离级别解决的主要是对数据库进行UPDATE操作造成的数据改变，但还是会引起幻读的情况发生，在InnoDB存储引擎下默认提供MVCC（多版本并发控制）机制解决了幻读的问题。</li><li>串行化（Serializable）：这是最高的隔离级别，串行的意思也就是每次只允许一个事务对数据进行操作，事务按照先来后到的规则进行排队一次执行，这样在事务之间就不会相互冲突，从而解决了幻读的问题。但是串行化执行事务的方式会严重影响事务的执行效率，高并发操作下会造成事务堆积和超时，一般在实际应用中很少使用，虽然它很安全。</li></ul><p>通过上面我们了解了事务隔离级别，也知道每种隔离级别所解决的事情，做一下汇总：</p><table><thead><tr><th style="text-align:center">事务隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">读已提交</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">串行化</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><h3 id="四-如何查看和设置数据库的隔离级别"><a class="markdownIt-Anchor" href="#四-如何查看和设置数据库的隔离级别"></a> 四、如何查看和设置数据库的隔离级别</h3><ol><li><p>查看数据库当前的事务隔离级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200427173518185.png" alt="image-20200427173518185"></p></li><li><p>修改数据库的事务隔离级别</p><p>修改语句格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set [global | session] transaction isolation level [read uncommitted | read committed | repeatable read | serializable]</span><br></pre></td></tr></table></figure><p><code>session</code>：当前session内的事务</p><p><code>global</code>：应用于之后新创建的session，已经存在的session不受影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed</span><br></pre></td></tr></table></figure><p>修改成功之后，我们再看一下当前的隔离级别已经被修改为RC了。</p><p><img src="/images/image-20200427174522929.png" alt="image-20200427174522929"></p></li></ol><h3 id="五-小"><a class="markdownIt-Anchor" href="#五-小"></a> 五、小🌰</h3><ol><li><p>创建一张表备用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table cc_isolation_test</span><br><span class="line">(</span><br><span class="line">    id   int auto_increment primary key,</span><br><span class="line">    name varchar(30) null</span><br><span class="line">) engine=innodb default charset=utf8</span><br><span class="line">    comment &apos;事务隔离级别测试表&apos;;</span><br><span class="line"></span><br><span class="line"># 插入一条数据</span><br><span class="line">insert into cc_isolation_test(name) values(&apos;cc&apos;);</span><br></pre></td></tr></table></figure></li><li><p>RU级别</p><ul><li><p>修改session的事务隔离级别为RU</p><p>打开两个session窗口，将事务隔离级别均修改为RU。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别为RU</span><br><span class="line">set session transaction isolation level read uncommitted ;</span><br><span class="line"># 验证</span><br><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200427184245389.png" alt="image-20200427184245389"></p></li><li><p>脏读验证</p><ol><li><p>在两个窗口中均开启一个事务，在A事务中进行查询操作，在B事务中进行更新操作但不提交</p></li><li><p>A事务：进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><p>这时查到的数据为正常数据：</p><img src="/images/image-20200427185221292.png" alt="image-20200427185221292" style="zoom:50%;"></li><li><p>B事务：进行更新操作但不提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update cc_isolation_test set name=&apos;cc1&apos; where id=1;</span><br></pre></td></tr></table></figure><p>执行完之后可以看一下我们的表中，数据是未被修改的，因为B事务尚未提交</p><img src="/images/image-20200427190836436.png" alt="image-20200427190836436" style="zoom:50%;"></li><li><p>A事务：再次进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427190607659.png" alt="image-20200427190607659" style="zoom:50%;"><p>查询出来的数据中，name竟然变成了cc1，也就是说A事务中读取到了B事务中尚未提交的数据，如果此时B事务回滚，A事务中name的值仍然是读到的cc1，也就出现了脏数据，所以RU级别下会出现脏读的问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>update cc_isolation_test set name=‘cc1’ where id=1;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>rollback;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li><li><p>不可重复读验证</p><p>上面演示脏读的过程中，在A事务中对数据进行了两次读取，且两次读取到的name的值不一致，所以RU也造成了不可重复读的问题。</p></li><li><p>幻读验证</p><ol><li><p>A事务：进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427185221292.png" alt="image-20200427185221292" style="zoom:50%;"></li><li><p>B事务：进行插入操作但不提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into cc_isolation_test(name) values(&apos;cc1&apos;);</span><br></pre></td></tr></table></figure><p>事务未提交，我们的表中还没出现插入的新数据</p><img src="/images/image-20200427190836436.png" alt="image-20200427190836436" style="zoom:50%;"></li><li><p>A事务：再次进行查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><p>查询出来两条数据，和之前查询的条数不一样，但是我们数据库中仅仅只有一条数据，这就是所谓的幻读，此时若将B事务回滚掉，A事务拿着B事务未提交的数据继续操作，定会出现问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(name) values(‘cc1’);</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>rollback;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li></ul></li><li><p>RC级别</p><ul><li><p>修改session的事务隔离级别为RC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别为RC</span><br><span class="line">set session transaction isolation level read committed ;</span><br><span class="line"># 验证</span><br><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure></li></ul><img src="/images/image-20200427215936571.png" alt="image-20200427215936571" style="zoom:50%;"><ul><li><p>脏读验证</p><p>操作步骤和RU的一致，但是结果却不相同，我们在B事务中对<code>id=1</code>的数据进行修改但是不提交事务，在A事务中是读取不到B事务对该条数据的修改，所以RC级别不会出现脏读的问题。</p></li><li><p>不可重复读验证</p><ol><li><p>A事务：第一次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193013689.png" alt="image-20200427193013689" style="zoom:50%;"></li><li><p>B事务：修改数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">update cc_isolation_test set name=&apos;cc1&apos; where id=1;</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：第二次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193112958.png" alt="image-20200427193112958" style="zoom:50%;"><p>在A事务中读取到了B事务提交的数据，与第一次读取到的数据不一致，也就是说每次读取都是从数据库中读取最新的数据，这也证明了再RC级别下会出现不可重复读的问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td></td><td>update cc_isolation_test set name=‘cc1’ where id=1;</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li><li><p>幻读验证</p><ol><li><p>A事务：第一次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193423746.png" alt="image-20200427193423746" style="zoom:50%;"></li><li><p>B事务：修改数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">insert into cc_isolation_test(name) values(&apos;cc2&apos;);</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：第二次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193523968.png" alt="image-20200427193523968" style="zoom:50%;"><p>两次查询的数据条数不同，在A事务中读取到了B事务新插入的数据，相对于第一次查询结果来说，出现了幻读的问题。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(name) values(‘cc2’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li></ul></li><li><p>RR级别</p><ul><li><p>修改session的事务隔离级别为RR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别为RC</span><br><span class="line">set session transaction isolation level read committed ;</span><br><span class="line"># 验证</span><br><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427210838009.png" alt="image-20200427210838009" style="zoom:50%;"></li><li><p>脏读验证</p><p>操作步骤和RC的一致，但是结果却不相同，我们在B事务中对<code>id=1</code>的数据进行修改但是不提交事务，在A事务中是读取不到B事务对该条数据的修改，所以RR级别不会出现脏读的问题。</p></li><li><p>不可重复读验证</p><ol><li><p>A事务：第一次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193112958.png" alt="image-20200427193112958" style="zoom:50%;"></li><li><p>B事务：修改数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">update cc_isolation_test set name=&apos;cc2&apos; where id=1;</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：第二次查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427193112958.png" alt="image-20200427193112958" style="zoom:50%;"><p>通过两次读取之后发现在B事务提交前后读取到的数据是一致的，这样证明了RR级别是支持重复读的，nice~</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td></td><td>update cc_isolation_test set name=‘cc2’ where id=1;</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li><li><p>幻读验证</p><ol><li><p>A事务：进行查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from cc_isolation_test where id=1;</span><br></pre></td></tr></table></figure></li><li><p>B事务：插入数据并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction ;</span><br><span class="line">insert into cc_isolation_test(id, name) values(1, &apos;cc2&apos;);</span><br><span class="line">commit ;</span><br></pre></td></tr></table></figure></li><li><p>A事务：插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into cc_isolation_test(id, name) values(1, &apos;cc2&apos;);</span><br></pre></td></tr></table></figure><p>主键冲突了，但是在A事务中确实没查询到id=1的数据，其实这个时候数据库中已经有了id=1的数据，但在A事务中却没有查询到，这就是幻读。</p></li><li><p>图解</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test where id=1;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(id, name) values(1, ‘cc2’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>insert into cc_isolation_test(id, name) values(1, ‘cc2’);</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ol></li></ul></li><li><p>Serializable级别</p><ul><li><p>修改session的事务隔离级别为Serializable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br></pre></td></tr></table></figure><img src="/images/image-20200427215912469.png" alt="image-20200427215912469" style="zoom:50%;"></li><li><p>操作</p><p>先开启事务A，进行查询，但不提交；再开启事务B，然后进行插入操作，会发现操作被阻塞了，如下图中insert语句最后的时间就是等待的时间，事务B必须在事务A提交或回滚之后才能继续执行，这也就是串行化的意义：同时只能有一个事务处于执行中，其他线程都要等待。并发度最低但安全性最高。</p><img src="/images/image-20200427215828454.png" alt="image-20200427215828454" style="zoom:50%;"><p>图解：</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td></td><td>insert into cc_isolation_test(name) values(‘cc2’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from cc_isolation_test;</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-事务为何物&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-事务为何物&quot;&gt;&lt;/a&gt; 一、事务为何物&lt;/h3&gt;
&lt;p&gt;事务（Transaction）是保障程序中一组操作的原子性的约束，它使事务中的所有操作都指向同一个结果，也就是要么
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
</feed>
