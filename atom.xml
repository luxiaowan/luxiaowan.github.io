<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>串一串</title>
  
  <subtitle>断舍离</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luxiaowan.github.io/"/>
  <updated>2020-03-29T15:30:11.136Z</updated>
  <id>http://luxiaowan.github.io/</id>
  
  <author>
    <name>cc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <link href="http://luxiaowan.github.io/2020/03/29/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://luxiaowan.github.io/2020/03/29/TCP三次握手和四次挥手/</id>
    <published>2020-03-29T12:20:00.000Z</published>
    <updated>2020-03-29T15:30:11.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>传输控制协议(Transmission Control Protocol，简称TCP)是一种面向连接的、可靠的、基于字节流的传输层通信协议，应用层向TCP层发送用于网间传输的用8位字节表示的数据流，TCP将数据流做分隔处理后透传给IP层，然后由IP层将数据传输给目标端TCP层。</p><p>TCP为保证不发生丢包，会对所有的包进行编号，接收端依据编号按序接收，全部数据包接收完成后按序号进行合并，这里可能会发生粘包、拆包的问题(暂不介绍)。接收端在每次接收到数据包的时候都会返回给发送端一个确认信息(ACK)，若发送端在一定时间内未接收到ACK信息，则主观认为数据发送失败或数据丢失，会重新发送丢失序号的包。</p><h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3><p>TCP在发送数据之前，需要先建立连接，客户端主动，TCP使用三次握手的方式建立连接，三次握手的意思就是客户端和服务端进行三次通信，三次握手的目的是为了确认通信双方的发送和接收能力是否正常。主要过程：</p><img src="/Users/chuan/Documents/projects_code/git-project/github_blog/source/images/tcp_connect.png" alt="tcp_connect" style="zoom:67%;"><ul><li><p>第一次握手：客户端：服务端，我想要向你发送数据</p><ul><li>客户端向服务端发送一个SYN包，并指明客户端的初始化序列号ISN，随后客户端进入SYN_SEND状态。</li><li>同部位SYN=1，初始序列号seq=x，此报文不能携带任何的数据，却会消耗掉一个序列号</li></ul></li><li><p>第二次握手：服务端：客户端，我准备好了，你可以把数据发过来了</p><ul><li>服务端接收到客户端发送的消息，需要返回一个SYN/ACK包进行响应，否则客户端会以为消息跑丢了造成重发，SYN/ACK以服务端的为准，SYN=1, ACK=x+1</li><li>服务端响应消息也属于是一次通信，所以服务端需要将自己的序列号放入到报文中携带给客户端，初始化序列号seq=y</li><li>总的响应报文：SYN=1 ACK=x+1 seq=y</li><li>服务端进入SYN_RECV状态</li></ul></li><li><p>第三次握手：客户端：服务端，我知道了，敌人还有三秒到达战场</p><ul><li>客户端接收到服务端的响应之后，要告诉服务端老子收到你的响应了，不要以为消息丢了，等着接收数据吧您嘞</li><li>这次握手等于是服务端响应的翻版，报文包括ACK=y+1 seq=x+1</li><li>客户端和服务端均进入ESTABLISHED（TCP连接成功）状态</li></ul></li></ul><blockquote><p>为什么使用三次握手，两次是否可以？</p><p>*** 之所以进行三次握手，是保证客户端和服务端均可以进行一次发送、接收和发送接收反馈，目的是让客户端和服务端各自确认自己的发送和接收能力都正常**</p></blockquote><h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3><p>TCP发送完数据之后，需要将连接断开，当然断开连接的也需要客户端主动发起，因为数据是否发送完毕只有发送者知道。断开连接需要通过四次挥手(也可以叫四次握手)来保证合理性。</p><img src="/Users/chuan/Documents/projects_code/git-project/github_blog/source/images/tcp_disconnect.png" alt="tcp_disconnect" style="zoom:67%;"><ul><li>第一次挥手：客户端：我数据发送完了，可以断开连接了，我先进入准备断开状态<ul><li>客户端发送完数据之后，向服务端发送断开请求报文，FIN=1 seq=u</li><li>客户端进入FIN-WAIT-1状态，等待服务端的响应</li><li>表示客户端没有数据要发给服务端了</li></ul></li><li>第二次挥手：服务端：我收到了，我同意你的请求，但我要看下我是否还有数据尚在发送，你等会<ul><li>服务端接收到客户端的断开请求之后，根据序列号进行反馈，ACK=1 seq=v ack=u+1</li><li>服务端反馈之后进入CLOSE-WAIT状态，客户端接收到反馈之后进入FIN-WAIT-2状态，等待服务端的确认断开请求</li></ul></li><li>第三次挥手：服务端：我的数据也都发完了，可以断开了<ul><li>服务端再处理完自己的事情之后，向客户端发送确认断开报文，FIN=1 ACK=1 seq=w ack=u+1</li><li>这里的ack=u+1，发现和第二次挥手时候的ack一模一样，这也就是和客户端的断开请求对应起来，否则把别的给断开了岂不是很尴尬</li><li>服务端进入LAST-ACK状态，等待客户端的回应</li></ul></li><li>第四次挥手：客户端：我知道了，断开<ul><li>客户端接收到确认断开报文后，向服务端反馈断开报文，ACK=1 seq=u+1 ack=w+1</li><li>服务端接收到反馈后关闭连接</li><li>客户端等待2MSL后关闭连接</li></ul></li></ul><p>看一个官方描述图片：</p><img src="/Users/chuan/Documents/projects_code/git-project/github_blog/source/images/tcp_disconnect.jpg" alt="tcp_disconnect" style="zoom:75%;"><h5 id="为什么要等待2msl"><a class="markdownIt-Anchor" href="#为什么要等待2msl"></a> 为什么要等待2MSL</h5><ul><li><p>目的是防止ACK消息丢失，服务端重发消息后可以再次接收并反馈；</p></li><li><p>如果在第三次挥手反馈后客户端立刻关闭，如果反馈报文丢失，那么服务端可能就会一直处于重发第三次挥手的报文中，服务端将无法正常进入关闭状态</p></li><li><p>如果第四次挥手的报文丢失，服务端会再次发送确认关闭消息，客户端重新等待2MSL</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h3&gt;
&lt;p&gt;传输控制协议(Transmission Control Protocol，简称TCP)是一种面向连接的、可靠的、基于字节流的传输层通信协议，应用
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis哨兵简介</title>
    <link href="http://luxiaowan.github.io/2020/03/29/Redis%E5%93%A8%E5%85%B5%E7%AE%80%E4%BB%8B/"/>
    <id>http://luxiaowan.github.io/2020/03/29/Redis哨兵简介/</id>
    <published>2020-03-28T17:05:00.000Z</published>
    <updated>2020-03-28T19:20:52.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>Redis Sentinel是Redis官方建议的高可用(HA)解决方案，在我们搭建Redis集群时，Redis本身并未集成主备切换功能，sentinel本身是独立运行的，能够监控多个Redis集群，发现master宕机后能够自动切换，选举一个slave成为新的master，当原master恢复之后，sentinel会自动将其作为slave加入到集群中，整个过程不需要人工参与，完全自动化。</p><h3 id="主要介绍"><a class="markdownIt-Anchor" href="#主要介绍"></a> 主要介绍</h3><ol><li><p>sentinel主要功能</p><ul><li>定期监控Redis服务是否运行正常</li><li>定期监控其他sentinel服务是否正常</li><li>能够自动切换master节点</li><li>sentinel节点不存储数据</li></ul></li><li><p>sentinel集群</p><p>这个不难理解，如果我们用一个非高可用的sentinel去实现Redis的高可用，明显是不科学的，当这一台sentinel宕机之后，Redis显然无法继续保持它的高可用，所以我们在部署sentinel的时候也会采用集群的方式</p><blockquote><p>优势：</p><p>​即使有sentinel服务宕机，只要还有一台sentinel运行正常，就可以使Redis继续保持高可用</p></blockquote></li><li><p>sentinel版本问题</p><p>sentinel在Redis2.6版本中引入的，当时是sentinel 1，貌似有蛮多问题，毕竟初版</p><p>在Redis2.8版本中升级到sentinel 2，之后就非常稳定了</p><p>不过现在Redis已经发展了很久，版本也越来越高，sentinel已经非常值得信赖了</p></li><li><p>sentinel中的定时任务</p><ul><li>每隔10秒向各个Redis服务器(master和slave节点)发送INFO命令，根据回应获取master和slave信息，通过master的回复可以获取到新增的slave节点</li><li>每隔02秒向Redis的master服务器发送命令(hello消息)，用于发现和监视其他sentinel，sentinel之间的监控不在额外创建订阅</li><li>每隔01秒向Redis和sentinel所有服务发送PING消息(sentinel本身的ip、端口、id等内容)，通过回复PONG判断服务是否在线</li></ul></li><li><p>下线判断</p><ul><li>主观下线：当前sentinel断定master下线</li><li>客观下线：满足sentinel配置文件中quorum数量的sentinel均断定master下线</li></ul></li><li><p>配置文件解读</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel运行的端口，默认为26379</span></span><br><span class="line"><span class="attr">port</span> <span class="string">26377      </span></span><br><span class="line"></span><br><span class="line"><span class="attr">dir</span> <span class="string">"/private/tmp"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logfile</span> <span class="string">"/var/log/redis/sentinel_26377.log"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以守护进程执行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 守护进程运行的pid保存文件</span></span><br><span class="line"><span class="attr">pidfile</span> <span class="string">"/var/run/redis-sentinel.pid"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line"><span class="comment"># 该行的意思是：&lt;master-name&gt;：自定义</span></span><br><span class="line"><span class="comment">#&lt;ip&gt;：master主机的IP</span></span><br><span class="line"><span class="comment">#&lt;redis-port&gt;：master的端口</span></span><br><span class="line"><span class="comment">#&lt;quorum&gt;：表示在sentinel集群中，使master由主观下线变为客观下线的sentinel数量。</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor cc_master 127.0.0.1 6379 2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line"><span class="comment"># sentinel会向master发送心跳PING来确认master是否存活，如果master在&lt;milliseconds&gt;时间内回应的不是PONG，那么这个sentinel会主观地认为这个master下线了。&lt;milliseconds&gt;的单位是毫秒，默认30秒。</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">down-after-milliseconds cc_master 15000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line"><span class="comment"># failover过期时间，当failover开始后，在此时间内仍然没有触发任何failover操作，当前sentinel将会认为此次failoer失败。默认180秒，即3分钟。</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">failover-timeout cc_master 60000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numreplicas&gt;</span></span><br><span class="line"><span class="comment"># 在发生failover主备切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">parallel-syncs cc_master 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line"><span class="comment"># sentinel连接的master节点的登录密码</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">auth-pass cc_master redis</span></span><br></pre></td></tr></table></figure></li><li><p>故障转移</p><ul><li>sentinel使用Raft投票选举出一个leader去执行故障转移<ul><li>每一个将master标记为主观下线的sentinel节点发起投票</li><li>其他sentinel节点收到投票后，若尚未参与投票(也就是尚未投票给其他sentinel)，则同意，否则拒绝</li><li>最终收到过半同意的sentinel节点作为leader</li><li>若有两个sentinel收到了过半投票，那么就再重新选举</li></ul></li><li>选举新的master节点<ul><li>选择replica-priority配置数字最高的slave节点为master，默认为100</li><li>若replica-priority相同，则选择偏移量最大的slave节点，偏移量是指slave从master同步的进度，偏移量越大说明数据越完整，可以通过Redis的info命令查看(slave_repl_offset)当前slave的偏移量</li><li>若偏移量相同，则选择最先启动的slave作为master</li><li>更改master后，通知其他slave节点同步为新的master节点的slave节点</li><li>原master节点恢复之后自动加入到集群中，成为新master的slave节点</li></ul></li></ul></li></ol><h3 id="实战"><a class="markdownIt-Anchor" href="#实战"></a> 实战</h3><p>在本机上启动3个Redis实例，采用1主2从的模式，以下只记录redis.conf和sentinel.conf中关键内容</p><ol><li><p>redis.conf</p><ul><li><p>redis-master.conf配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br></pre></td></tr></table></figure></li><li><p>redis-slave1.conf配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">63791</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="comment"># 从节点归属的master节点</span></span><br><span class="line"><span class="attr">replicaof</span> <span class="string">127.0.0.1 6379</span></span><br></pre></td></tr></table></figure></li><li><p>redis-slave2.conf配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">63792</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式：replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="comment"># 从节点归属的master节点</span></span><br><span class="line"><span class="attr">replicaof</span> <span class="string">127.0.0.1 6379</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>sentinel.conf</p><ul><li><p>sentinel0.conf</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">26379</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">myid 842c9102c48eb0cedeb06fe55e7d2258595ac267</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控master</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor cc_master 127.0.0.1 6379 2</span></span><br></pre></td></tr></table></figure></li><li><p>sentinel1.conf</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">26378</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">myid 842c9102c48eb0cedeb06fe55e7d2258595ac266</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控master</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor cc_master 127.0.0.1 6379 2</span></span><br></pre></td></tr></table></figure></li><li><p>sentinel2.conf</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">26377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">myid 842c9102c48eb0cedeb06fe55e7d2258595ac265</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控master</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor cc_master 127.0.0.1 6379 2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动</p><ol><li><p>启动sentinel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel ~/Documents/develop_tools/tools/redis-5.0.5/sentinel0.conf</span><br><span class="line"></span><br><span class="line">redis-sentinel ~/Documents/develop_tools/tools/redis-5.0.5/sentinel1.conf</span><br><span class="line"></span><br><span class="line">redis-sentinel ~/Documents/develop_tools/tools/redis-5.0.5/sentinel2.conf</span><br></pre></td></tr></table></figure></li><li><p>启动Redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server ~/Documents/develop_tools/tools/redis-5.0.5/redis-master.conf</span><br><span class="line"></span><br><span class="line">redis-server ~/Documents/develop_tools/tools/redis-5.0.5/redis-slave1.conf</span><br><span class="line"></span><br><span class="line">redis-server ~/Documents/develop_tools/tools/redis-5.0.5/redis-slave2.conf</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="redis通过info查看信息"><a class="markdownIt-Anchor" href="#redis通过info查看信息"></a> Redis通过info查看信息</h3><p>127.0.0.1:6379&gt;info all</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Server服务器信息</span></span><br><span class="line"><span class="attr">redis_version</span>:<span class="string">5.0.5# Redis 服务器版本</span></span><br><span class="line"><span class="attr">redis_git_sha1</span>:<span class="string">00000000 # Git SHA1</span></span><br><span class="line"><span class="attr">redis_git_dirty</span>:<span class="string">0# Git dirty flag</span></span><br><span class="line"><span class="attr">redis_build_id</span>:<span class="string">6c6e38af7cea0726# Redis构建ID</span></span><br><span class="line"><span class="attr">redis_mode</span>:<span class="string">standalone# Redis运行模式</span></span><br><span class="line"><span class="attr">os</span>:<span class="string">Darwin 19.3.0 x86_64# 运行环境操作系统版本</span></span><br><span class="line"><span class="attr">arch_bits</span>:<span class="string">64# 架构（32 或 64 位）</span></span><br><span class="line"><span class="attr">multiplexing_api</span>:<span class="string">kqueue# Redis 所使用的事件处理机制</span></span><br><span class="line"><span class="attr">atomicvar_api</span>:<span class="string">atomic-builtin</span></span><br><span class="line"><span class="attr">gcc_version</span>:<span class="string">4.2.1# 编译的GCC版本</span></span><br><span class="line"><span class="attr">process_id</span>:<span class="string">61985# 服务器进程的 PID</span></span><br><span class="line"><span class="attr">run_id</span>:<span class="string">433b78ec513c8b782f3a46ba6b4ade1f12439aca# Redis 服务器的随机标识符(用于Sentinel和集群)</span></span><br><span class="line"><span class="attr">tcp_port</span>:<span class="string">6379# Redis端口</span></span><br><span class="line"><span class="attr">uptime_in_seconds</span>:<span class="string">108# Redis运行时长，秒</span></span><br><span class="line"><span class="attr">uptime_in_days</span>:<span class="string">0# Redis运行市场，天</span></span><br><span class="line"><span class="attr">hz</span>:<span class="string">10</span></span><br><span class="line"><span class="attr">configured_hz</span>:<span class="string">10</span></span><br><span class="line"><span class="attr">lru_clock</span>:<span class="string">8363059# 以分钟为单位进行自增的时钟，用于 LRU 管理</span></span><br><span class="line"><span class="attr">executable</span>:<span class="string">/Users/chuan/redis-server# 运行命令</span></span><br><span class="line"><span class="attr">config_file</span>:<span class="string"># 启动使用的配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line"><span class="attr">connected_clients</span>:<span class="string">7# 已连接客户端的数量</span></span><br><span class="line"><span class="attr">client_recent_max_input_buffer</span>:<span class="string">2# 当前连接的客户端当中，最长的输出列表</span></span><br><span class="line"><span class="attr">client_recent_max_output_buffer</span>:<span class="string">0# 当前连接的客户端当中，最大输入缓存</span></span><br><span class="line"><span class="attr">blocked_clients</span>:<span class="string">0# 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory (太多了，不做解释了)</span></span><br><span class="line"><span class="attr">used_memory</span>:<span class="string">2235920# 由 Redis 分配器分配的内存总量，以字节（byte）为单位</span></span><br><span class="line"><span class="attr">used_memory_human</span>:<span class="string">2.13M# 以可读的格式返回 Redis 分配的内存总量</span></span><br><span class="line"><span class="attr">used_memory_rss</span>:<span class="string">3153920# 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和top 、 ps 等命令的输出一致。</span></span><br><span class="line"><span class="attr">used_memory_rss_human</span>:<span class="string">3.01M # 以可读的格式返回rss</span></span><br><span class="line"><span class="attr">used_memory_peak</span>:<span class="string">2317840# Redis 的内存消耗峰值（以字节为单位）</span></span><br><span class="line"><span class="attr">used_memory_peak_human</span>:<span class="string">2.21M</span></span><br><span class="line"><span class="attr">used_memory_peak_perc</span>:<span class="string">96.47%</span></span><br><span class="line"><span class="attr">used_memory_overhead</span>:<span class="string">2221526</span></span><br><span class="line"><span class="attr">used_memory_startup</span>:<span class="string">987776</span></span><br><span class="line"><span class="attr">used_memory_dataset</span>:<span class="string">14394</span></span><br><span class="line"><span class="attr">used_memory_dataset_perc</span>:<span class="string">1.15%</span></span><br><span class="line"><span class="attr">allocator_allocated</span>:<span class="string">2271808</span></span><br><span class="line"><span class="attr">allocator_active</span>:<span class="string">3116032</span></span><br><span class="line"><span class="attr">allocator_resident</span>:<span class="string">3116032</span></span><br><span class="line"><span class="attr">total_system_memory</span>:<span class="string">17179869184</span></span><br><span class="line"><span class="attr">total_system_memory_human</span>:<span class="string">16.00G</span></span><br><span class="line"><span class="attr">used_memory_lua</span>:<span class="string">37888</span></span><br><span class="line"><span class="attr">used_memory_lua_human</span>:<span class="string">37.00K</span></span><br><span class="line"><span class="attr">used_memory_scripts</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">used_memory_scripts_human</span>:<span class="string">0B</span></span><br><span class="line"><span class="attr">number_of_cached_scripts</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">maxmemory</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">maxmemory_human</span>:<span class="string">0B</span></span><br><span class="line"><span class="attr">maxmemory_policy</span>:<span class="string">noeviction</span></span><br><span class="line"><span class="attr">allocator_frag_ratio</span>:<span class="string">1.37</span></span><br><span class="line"><span class="attr">allocator_frag_bytes</span>:<span class="string">844224</span></span><br><span class="line"><span class="attr">allocator_rss_ratio</span>:<span class="string">1.00</span></span><br><span class="line"><span class="attr">allocator_rss_bytes</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">rss_overhead_ratio</span>:<span class="string">1.01</span></span><br><span class="line"><span class="attr">rss_overhead_bytes</span>:<span class="string">37888</span></span><br><span class="line"><span class="attr">mem_fragmentation_ratio</span>:<span class="string">1.39</span></span><br><span class="line"><span class="attr">mem_fragmentation_bytes</span>:<span class="string">882112</span></span><br><span class="line"><span class="attr">mem_not_counted_for_evict</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">mem_replication_backlog</span>:<span class="string">1048576</span></span><br><span class="line"><span class="attr">mem_clients_slaves</span>:<span class="string">33844</span></span><br><span class="line"><span class="attr">mem_clients_normal</span>:<span class="string">151226</span></span><br><span class="line"><span class="attr">mem_aof_buffer</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">mem_allocator</span>:<span class="string">libc</span></span><br><span class="line"><span class="attr">active_defrag_running</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">lazyfree_pending_objects</span>:<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line"><span class="attr">loading</span>:<span class="string">0# 服务器是否正在载入持久化文件</span></span><br><span class="line"><span class="attr">rdb_changes_since_last_save</span>:<span class="string">1# 距离最后一次成功创建持久化文件之后，改变了多少个键值</span></span><br><span class="line"><span class="attr">rdb_bgsave_in_progress</span>:<span class="string">0# 服务器是否正在创建RDB文件</span></span><br><span class="line"><span class="attr">rdb_last_save_time</span>:<span class="string">1585421263# 最近一次成功创建RDB文件的UNIX时间</span></span><br><span class="line"><span class="attr">rdb_last_bgsave_status</span>:<span class="string">ok# 最后一次创建RDB文件的结果是成功还是失败</span></span><br><span class="line"><span class="attr">rdb_last_bgsave_time_sec</span>:<span class="string">0# 最后一次创建RDB文件耗费的秒数</span></span><br><span class="line"><span class="attr">rdb_current_bgsave_time_sec</span>:<span class="string">-1# 记录当前创建RDB操作已经耗费了多长时间（单位为秒）</span></span><br><span class="line"><span class="attr">rdb_last_cow_size</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">aof_enabled</span>:<span class="string">0# AOF是否处于打开状态</span></span><br><span class="line"><span class="attr">aof_rewrite_in_progress</span>:<span class="string">0# 服务器是否正在创建AOF文件</span></span><br><span class="line"><span class="attr">aof_rewrite_scheduled</span>:<span class="string">0# 是否需要执行预约的AOF重写操作</span></span><br><span class="line"><span class="attr">aof_last_rewrite_time_sec</span>:<span class="string">-1# 最后一次重启AOF的秒数</span></span><br><span class="line"><span class="attr">aof_current_rewrite_time_sec</span>:<span class="string">-1# 记录当前正在重写AOF的秒数</span></span><br><span class="line"><span class="attr">aof_last_bgrewrite_status</span>:<span class="string">ok# 最后一次重写AOF文件的结果</span></span><br><span class="line"><span class="attr">aof_last_write_status</span>:<span class="string">ok# 最后一次写入结果</span></span><br><span class="line"><span class="attr">aof_last_cow_size</span>:<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats(可以不做了解)</span></span><br><span class="line"><span class="attr">total_connections_received</span>:<span class="string">9</span></span><br><span class="line"><span class="attr">total_commands_processed</span>:<span class="string">720</span></span><br><span class="line"><span class="attr">instantaneous_ops_per_sec</span>:<span class="string">6</span></span><br><span class="line"><span class="attr">total_net_input_bytes</span>:<span class="string">34197</span></span><br><span class="line"><span class="attr">total_net_output_bytes</span>:<span class="string">229238</span></span><br><span class="line"><span class="attr">instantaneous_input_kbps</span>:<span class="string">0.34</span></span><br><span class="line"><span class="attr">instantaneous_output_kbps</span>:<span class="string">1.19</span></span><br><span class="line"><span class="attr">rejected_connections</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">sync_full</span>:<span class="string">2# 主从完全同步成功次数</span></span><br><span class="line"><span class="attr">sync_partial_ok</span>:<span class="string">0# 主从部分同步成功次数</span></span><br><span class="line"><span class="attr">sync_partial_err</span>:<span class="string">0# 主从部分同步失败次数</span></span><br><span class="line"><span class="attr">expired_keys</span>:<span class="string">0# 运行以来过期的key的数量</span></span><br><span class="line"><span class="attr">expired_stale_perc</span>:<span class="string">0.00# 过期的比率</span></span><br><span class="line"><span class="attr">expired_time_cap_reached_count</span>:<span class="string">0# 过期计数</span></span><br><span class="line"><span class="attr">evicted_keys</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">keyspace_hits</span>:<span class="string">1</span></span><br><span class="line"><span class="attr">keyspace_misses</span>:<span class="string">1</span></span><br><span class="line"><span class="attr">pubsub_channels</span>:<span class="string">1</span></span><br><span class="line"><span class="attr">pubsub_patterns</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">latest_fork_usec</span>:<span class="string">278</span></span><br><span class="line"><span class="attr">migrate_cached_sockets</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">slave_expires_tracked_keys</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">active_defrag_hits</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">active_defrag_misses</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">active_defrag_key_hits</span>:<span class="string">0</span></span><br><span class="line"><span class="attr">active_defrag_key_misses</span>:<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication（master节点）</span></span><br><span class="line"><span class="attr">role</span>:<span class="string">master# 角色 master和slave</span></span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="string">2# slave节点数</span></span><br><span class="line"><span class="attr">slave0</span>:<span class="string">ip=127.0.0.1,port=63791,state=online,offset=20163,lag=1# 从节点1</span></span><br><span class="line"><span class="attr">slave1</span>:<span class="string">ip=127.0.0.1,port=63792,state=online,offset=20163,lag=0# 从节点2</span></span><br><span class="line"><span class="attr">master_replid</span>:<span class="string">895f219aa1e7ed5ecda50dcb1f77eea9f1ef9c3d# 主实例启动随机字符串</span></span><br><span class="line"><span class="attr">master_replid2</span>:<span class="string">0000000000000000000000000000000000000000# 主实例启动随机字符串2</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="string">20163# 主从同步偏移量,此值如果和上面的offset相同说明主从一致没延迟，与master_replid可被用来标识主实例复制流中的位置。</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:<span class="string">-1# 主从同步偏移量2,此值如果和上面的offset相同说明主从一致没延迟</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="string">1# 复制积压缓冲区是否开启</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="string">1048576# 复制积压缓冲大小</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="string">1# 复制缓冲区里偏移量的大小</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="string">20163# 此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication（slave节点）</span></span><br><span class="line"><span class="attr">role</span>:<span class="string">slave# 角色 master和slave</span></span><br><span class="line"><span class="attr">master_host</span>:<span class="string">127.0.0.1# master节点IP</span></span><br><span class="line"><span class="attr">master_port</span>:<span class="string">6379# master节点端口</span></span><br><span class="line"><span class="attr">master_link_status</span>:<span class="string">up# master通信</span></span><br><span class="line"><span class="attr">master_last_io_seconds_ago</span>:<span class="string">1# 主库多少秒未发送数据到从库</span></span><br><span class="line"><span class="attr">master_sync_in_progress</span>:<span class="string">0# 从服务器是否在与主服务器进行同步</span></span><br><span class="line"><span class="attr">slave_repl_offset</span>:<span class="string">42262# slave复制偏移量</span></span><br><span class="line"><span class="attr">slave_priority</span>:<span class="string">100# slave优先级</span></span><br><span class="line"><span class="attr">slave_read_only</span>:<span class="string">1# 从库是否设置只读</span></span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="string">0# 连接的slave实例个数</span></span><br><span class="line"><span class="attr">master_replid</span>:<span class="string">895f219aa1e7ed5ecda50dcb1f77eea9f1ef9c3d</span></span><br><span class="line"><span class="attr">master_replid2</span>:<span class="string">0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="string">42262# master偏移量，与slave_repl_offset相同则表示同步完整</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:<span class="string">-1</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="string">1# 复制积压缓冲区是否开启</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="string">1048576# 复制积压缓冲大小</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="string">1# 复制缓冲区里偏移量的大小</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="string">42262# 此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line"><span class="attr">used_cpu_sys</span>:<span class="string">0.104404# 将所有redis主进程在核心态所占用的CPU时求和累计起来</span></span><br><span class="line"><span class="attr">used_cpu_user</span>:<span class="string">0.079472# 将所有redis主进程在用户态所占用的CPU时求和累计起来</span></span><br><span class="line"><span class="attr">used_cpu_sys_children</span>:<span class="string">0.002037# 将后台进程在核心态所占用的CPU时求和累计起来</span></span><br><span class="line"><span class="attr">used_cpu_user_children</span>:<span class="string">0.000648# 将后台进程在用户态所占用的CPU时求和累计起来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster</span></span><br><span class="line"><span class="attr">cluster_enabled</span>:<span class="string">0# 实例是否启用集群模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line"><span class="attr">db0</span>:<span class="string">keys=1,expires=0,avg_ttl=0# db0的key的数量,以及带有生存期的key的数,平均存活时间</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;Redis Sentinel是Redis官方建议的高可用(HA)解决方案，在我们搭建Redis集群时，Redis本身并未集成主备切换功能，sen
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
      <category term="Sentinel" scheme="http://luxiaowan.github.io/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>线程池运行的线程和队列中等待的线程是同一个吗</title>
    <link href="http://luxiaowan.github.io/2020/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%AD%E7%AD%89%E5%BE%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%90%97/"/>
    <id>http://luxiaowan.github.io/2020/03/28/线程池运行的线程和队列中等待的线程是同一个吗/</id>
    <published>2020-03-27T16:52:00.000Z</published>
    <updated>2020-03-27T18:42:31.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3><p>在高并发场景下，线程池是会被频繁使用到的，简单介绍下线程池：</p><ul><li><p>线程池基础参数：核心线程数、最大线程数、线程最大存活时间、时间单位、阻塞队列、线程池工厂、拒绝策略</p></li><li><p>创建方式：</p><ul><li>ThreadPoolExecutor类：ThreadPoolExecutor tpe = new ThreadPoolExecutor(1, 1, 0, TimeUtil.SECONDS, new ArrayBlockingQueue(), new DefaultThreadFactory())</li><li>Executors类：<ul><li>newFixedThreadPool(1);</li><li>newSingleThreadExecutor();</li><li>newCachedThreadPool();</li><li>newScheduledThreadPool(1);</li></ul></li><li>等待队列：<ul><li>ArrayBlockingQueue：由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：由链表结构组成的有界阻塞队列</li><li>DelayQueue：使用优先级队列实现的无界阻塞队列</li><li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li><li>SynchronousQueue：不存储元素的阻塞队列</li></ul></li><li>拒绝策略：<ul><li>DiscardPolicy：丢弃被拒绝任务</li><li>DiscardOldestPolicy：丢弃队列头部的任务</li><li>AbortPolicy：抛出RejectedExecutionException</li><li>CallerRunsPolicy：在调用execute方法的线程中运行被拒绝的任务</li></ul></li></ul></li><li><p>工作原理：</p><p><img src="/images/tpe-process.png" alt="tpe-process"></p></li></ul><h3 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h3><ul><li><p>线程池创建过程</p><ol><li><p>创建语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pools = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUtil.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">  核心线程数：<span class="number">5</span></span><br><span class="line">  最大线程数：<span class="number">10</span></span><br><span class="line">  非核心线程最大存活时间：<span class="number">10</span>秒</span><br><span class="line">  阻塞队列：LinkedBlockingQueue</span><br><span class="line">  线程池工厂：DefaultThreadFactory</span><br><span class="line">  拒绝策略：AbortPolicy</span><br></pre></td></tr></table></figure></li><li><p>在线程池真正运行之前，核心线程尚未创建，因为默认是在实际使用的时候才会去创建，但是如果我们想要在线程池创建的时候就初始化核心线程，可以调用ThreadPoolExecutor的实例方法<code>prestartAllCoreThreads()</code>，如果我们想要让核心线程在空闲时可以过期，那么我们可以调用ThreadPoolExecutor的实例方法<code>allowCoreThreadTimeOut(boolean value)</code>来设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置核心线程是否允许过期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 若value为true，但是线程最大存活时间不大于0，那么则抛异常</span></span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">  <span class="comment">// 如果设置的新值和当前值不同，则执行计划</span></span><br><span class="line">  <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">    allowCoreThreadTimeOut = value;</span><br><span class="line">    <span class="comment">// 若value为true，则终止线程池内的所有空闲Worker</span></span><br><span class="line">    <span class="keyword">if</span> (value)</span><br><span class="line">      interruptIdleWorkers();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化核心线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 循环创建工作线程Worker</span></span><br><span class="line">  <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">    ++n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建线程Worker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  retry:<span class="comment">// goto语法</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;<span class="comment">// 无限循环，循环体内控制退出</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">// 当前线程数</span></span><br><span class="line">      <span class="comment">// 校验当前正在执行的线程数是否超过了2^29 - 1，或者根据创建的是否为核心线程来与核心线程数和最大线程数做校验，如果已经超过了相关的值，则返回false拒绝创建</span></span><br><span class="line">      <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 改变当前运行的线程数，这里使用的CAS来保证线程安全，设置成功则跳出最外层循环</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">break</span> retry;</span><br><span class="line">      c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">      <span class="comment">// 当前线程池状态和方法最初的对比，若不等，则重新执行for循环体</span></span><br><span class="line">      <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">        <span class="keyword">continue</span> retry;</span><br><span class="line">      <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">  Worker w = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Worker线程实例</span></span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    <span class="comment">// Worker实例的属性，在Worker构造器中通过getThreadFactory().newThread(this);来创建</span></span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 加锁，保证线程安全</span></span><br><span class="line">      <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">        <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">        <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验rs是否为RUNNING，或者停止且队列中无任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">          <span class="comment">// 将新创建的Worker实例放入HashSet集合中</span></span><br><span class="line">          workers.add(w);</span><br><span class="line">          <span class="keyword">int</span> s = workers.size();</span><br><span class="line">          <span class="comment">// 更新最大线程运行数</span></span><br><span class="line">          <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = s;</span><br><span class="line">          workerAdded = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 工作线程创建成功后，调用线程的start()方法开启线程</span></span><br><span class="line">      <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">        t.start();<span class="comment">// tag-cc307</span></span><br><span class="line">        workerStarted = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 创建失败的话，则处理失败计划</span></span><br><span class="line">    <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">      addWorkerFailed(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由addWorker方法我们可以看出，线程池的核心执行器是Worker内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker类定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--</span></span><br><span class="line"><span class="class">  <span class="title">final</span>修饰：不可被扩展</span></span><br><span class="line"><span class="class">  继承自<span class="title">AQS</span>：保证线程运行的隔离性，线程池的线程安全核心</span></span><br><span class="line"><span class="class">  实现自<span class="title">Runnable</span>，所以<span class="title">Worker</span>也是一个线程类</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-- 构造器</span></span><br><span class="line"><span class="class">  <span class="title">Worker</span>(<span class="title">Runnable</span> <span class="title">firstTask</span>) </span>&#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">  <span class="comment">// 使用线程池工厂创建新线程，并将创建的线程赋值给实例属性thread，也就是在我们调用了thread的start()方法之后，会运行Worker类中的run()方法</span></span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看到这里，就应该去看Worker类中的run方法了，我们看到在run方法中调用了runWorker方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心关键方法，final修饰，不允许被overload和override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  Thread wt = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 全文搜索tag-cc307</span></span><br><span class="line">  Runnable task = w.firstTask;</span><br><span class="line">  w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 加锁前先释放锁，查看Worker中的tryRelease方法</span></span><br><span class="line">  w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">  <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 无限循环，这里的无限循环的实现方法主要在getTask()方法中，getTask()是从阻塞队列中获取等待的任务，这里我们可以看到阻塞队列中存储的是一个个Runnable实例</span></span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 线程加锁</span></span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">      <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">      <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">      <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">      <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">           (Thread.interrupted() &amp;&amp;</span><br><span class="line">            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">          !wt.isInterrupted())</span><br><span class="line">        wt.interrupt();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行前计划</span></span><br><span class="line">        beforeExecute(wt, task);</span><br><span class="line">        Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 直接调用任务的run方法，这里其实就是将队列中Runnable实例当成普通的非线程对象，我们都知道直接调用线程的run方法会以普通方法的形式去执行，这里之所以这样写，是因为我们当前已经处于一个线程中了，没必要再去启用一个线程去执行任务，否则线程池就没有存在的必要了</span></span><br><span class="line">          task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterExecute(task, thrown);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 记录线程Worker的成功任务数</span></span><br><span class="line">        w.completedTasks++;</span><br><span class="line">        w.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取队列中的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">      decrementWorkerCount();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心：判断是否允许核心线程过期 或 当前工作线程数是否超过了核心线程数，timed决定了是否回收核心线程</span></span><br><span class="line">    <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">        &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 若需要销毁工作线程，则使用poll方法使阻塞队列消失</span></span><br><span class="line">      <span class="comment">// 否则通过take方法继续阻塞，直到队列中有新数据</span></span><br><span class="line">      Runnable r = timed ?</span><br><span class="line">        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">      workQueue.take();</span><br><span class="line">      <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">      timedOut = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">      timedOut = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>从以上的内容中我们可以看出来：线程池运行的线程和队列中等待的线程不是同一个，线程池中实际运行的线程是Worker实例</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程池&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池&quot;&gt;&lt;/a&gt; 线程池&lt;/h3&gt;
&lt;p&gt;在高并发场景下，线程池是会被频繁使用到的，简单介绍下线程池：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线程池基础参数：核心线程数、最大线程数、线
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis相关东西</title>
    <link href="http://luxiaowan.github.io/2020/03/26/Redis%E7%9B%B8%E5%85%B3%E4%B8%9C%E8%A5%BF/"/>
    <id>http://luxiaowan.github.io/2020/03/26/Redis相关东西/</id>
    <published>2020-03-26T14:15:00.000Z</published>
    <updated>2020-03-28T16:03:57.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li>Redis是什么</li><li>五种数据类型</li><li>Redis为何这么快</li><li>Redis和Memcached的区别</li><li>淘汰策略</li><li>持久化</li><li>主从复制</li><li>哨兵</li></ul><hr><h4 id="redis是什么"><a class="markdownIt-Anchor" href="#redis是什么"></a> Redis是什么</h4><p>​Redis是由C语言编写的一个开源的高性能键值对的内存数据库，是一款NoSQL(not-only sql | no sql)数据库，可以用作缓存、数据库、消息中间件。</p><p>​Redis作为一款内存数据库，其优势为：</p><pre><code>1. 性能优秀，数据都存于内存中，读写速度快，理论读取速度能达到10W/秒；2. 单线程操作，线程安全，采用IO多路复用实现垃圾回收和持久化；3. 支持丰富的数据类型：字符串(string)、列表(list)、散列(hash)、集合(set)、有序集合(zset)；4. 支持数据持久化，并且提供RDB和AOF两种持久化方式；5. 可以用于分布式锁，也可以利用Redis的发布-订阅特性实现消息队列；6. 主从复制，哨兵，高可用。</code></pre><h4 id="五种数据类型"><a class="markdownIt-Anchor" href="#五种数据类型"></a> 五种数据类型</h4><ul><li>字符串(string)类型：Redis的字符串类型是最基本的类型，可以理解为一个key对应一个value，value可以是字符也可以是数字，该类型可以存储图片或者序列化后的对象等二进制数据，支持的value大小最大512M，当value小于44字节(3.2版本+是44，3.0版本-是39)时，字符串编码为embstr，大于的时候字符串编码为raw，常用的命令有set、get等。</li><li>散列(hash)类型：hash是一个键值对的集合，特别适合用于存储对象，可以直接获取到对象的某个属性的值，常用的命令有hset、hget、hgetall等。</li><li>列表(list)类型：</li><li>集合(set)类型：</li><li>有序集合(zset)类型：</li></ul><h4 id="redis为何那么快"><a class="markdownIt-Anchor" href="#redis为何那么快"></a> Redis为何那么快</h4><p>​Redis之所以是单线程的还那么快，完全是因为Redis是纯内存操作，没有CPU上下文切换带来的消耗，也没有磁盘寻址等带来的IO开销，官方理论QPS为10W+。</p><p>​既然Redis的性能瓶颈是内存和网络带宽，那么就没必要设计成多线程模式，否则会多出CPU切换，且只要涉及到多线程必然会因为资源竞争而衍生出资源锁的使用，频繁的加锁、释放锁还是非常浪费时间的，所以既然多线程会带来那么多问题，还是使用单线程得了，并且Redis本身就是K-V存储，查询时间复杂度限制在O(1)的情况，所以Redis才那么快。</p><h4 id="redis和memcached的区别"><a class="markdownIt-Anchor" href="#redis和memcached的区别"></a> Redis和Memcached的区别</h4><ul><li>存储方式：Memcache将数据存储在内存中，若服务器出现故障，则数据全部丢失，无法持久化。Redis提供了RDB和AOF两种方式进行数据持久化，就算是服务器宕机，在恢复之后依然可以保证数据的完整性；</li><li>数据类型：Memcache仅支持字符串存储，而Redis支持字符串、列表、散列、集合、有序集合等类型，使用起来更方便和多样化；</li><li>value大小：Redis的字符串类型可以存储512M的内容，而Memcache最高仅能存储1M的内容，不过虽然Redis支持很大的value，但是一般不会那么用；</li><li>底层协议不同：Redis拥有自己的VM，Memcache使用系统函数</li></ul><h4 id="淘汰策略"><a class="markdownIt-Anchor" href="#淘汰策略"></a> 淘汰策略</h4><p>Redis目前有6种淘汰策略，据说新版本中有8种</p><ul><li>volatile-lru：从设置了过期时间的所有key中将最近最少使用(least recently used)的key淘汰掉</li><li>volatile-ttl：从设置了过期时间的所有key中将剩余存活时间最少(time to live)的key淘汰掉</li><li>volatile-random：从设置了过期时间的所有key中随机淘汰掉部分key</li><li>allkeys-lru：从所有的key中将最近最少使用的key淘汰掉</li><li>allkeys-random：从所有的key中随机淘汰掉部分key</li><li>noeviction：不执行数据淘汰，当内存不足时直接拒绝新的插入请求，并返回错误信息</li><li>volatile-lfu：从设置了过期时间的所有key中将访问频率最少(least frequently used)的key淘汰掉</li><li>allkeys-lfu：从所有的key中将访问频率最少的key淘汰掉</li></ul><h4 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h4><p>Redis支持两种持久化方式，持久化的目的是将内存中的数据写入到磁盘中，防止服务出现故障后的数据丢失的情况。</p><ul><li><p>RDB方式：RDB是Redis的默认持久化方式，属于是定时保存，每隔一段时间将fork出一个子进程去将内存中的数据写入到一个临时dump.rdb(名字在配置文件中设置)文件中，待子进程执行完成之后，将这个临时的dump文件替换掉原来的dump文件，这样做的目的是可以实现copy-on-write，子进程运行过程中使用的内存资源与Redis主进程无关</p><p>*<em><font color="red"><em>通过bgsave和save命令可以手动触发执行RDB</em></font></em></p><p><img src="/images/image-20200327015702174.png" alt="image-20200327015702174"></p><p>配置信息：redis.conf文件中</p><blockquote><p>解读：</p><p>save 900 1：900秒内若至少有1个key发生变化，则触发备份</p><p>save 300 10：300秒内若至少有10个key发生变化，则触发备份</p><p>save 60 10000：60秒内若至少有1万个key发生变化，则触发备份</p></blockquote><p><img src="/images/redis-rdb-conf.png" alt="image-20200327001846508"></p><blockquote><p>劣势：</p><ol><li>RDB持久化方式适合于整库备份，dump文件用于故障恢复，但是由于RDB方式并不是实时的整库备份，所以我们拿到的dump文件总是会和内存中的数据不一致，如果你想要避免服务器发生故障的时候丢失数据，那么仅仅使用RDB是万万不行的，需要配合AOF使用。</li><li>为了使用子进程在磁盘上持久存储，RDB经常需要fork()。如果数据集很大，Fork()可能很耗时，并且可能导致Redis停止为客户端提供服务几毫秒甚至一秒钟(如果数据集很大，而且CPU性能不是很好)。AOF还需要fork()，但是您可以调整重写日志的频率，而不需要牺牲持久性。</li></ol><p>优势：</p><ol><li><p>RDB是一个非常紧凑的单文件时间点表示您的Redis数据。RDB文件非常适合备份。例如，您可能希望在最近的24小时内每小时存档一次RDB文件，并在30天内每天保存一次RDB快照。这允许您在发生灾难时轻松地恢复不同版本的数据集。</p></li><li><p>RDB对于灾难恢复非常有用，它是一个紧凑的文件，可以传输到远程数据中心上。</p></li><li><p>RDB最大限度地提高了Redis性能，因为为了保持Redis父进程所需做的惟一工作就是创建一个将完成所有其余工作的子进程。父实例永远不会执行磁盘I/O或类似的操作。</p></li><li><p>与AOF相比，RDB允许对大数据集进行更快的重启。</p></li></ol></blockquote></li><li><p>AOF方式：AOF方式在Redis中是默认未开启的，在开启AOF后，会将内容写入到appendonly.aof文件中，文件的内容是服务器接收到的所有对数据进行修改的命令集合，按照时间顺序追加到文件尾部，并且在故障恢复的时候，会优先读取appendonly.aof文件中的内容，因为aof的默认策略是每秒钟写入一次，所以当采用aof进行持久化的时候，最多也仅仅丢失一秒的数据。</p><p>配置信息：redis.conf文件中</p><p><img src="/images/redis-aof-conf.png" alt="image-20200327003834988"></p><blockquote><p>劣势：</p><p>随着服务运行时间越来越久，内存中的数据变更次数越来越多，会造成aof文件越来越大，当然我们可以在配置文件redis.conf中设置aof文件重写策略，默认当aof文件大小达到64mb且增长比例超过了之前是100%的时候进行重写，重写的规则是将内存中的数据的当前值全部以对应的set命令写入到新的aof文件中，比如当前aof文件100mb，重写之后80mb，那么只有当文件再次达到160mb(160&gt;=80*2&amp;&amp;160&gt;64)的时候才会再次进行重写，</p><p><img src="/images/redis-aof-rewrite.png" alt="image-20200327005212374"></p></blockquote></li></ul><blockquote><p>AOF文件损坏修复：</p><p>​如果在AOF文件写入的过程中突然宕机，可能会导致aof文件损坏，我们可以使用redis-check-aof --fix命令来修复</p></blockquote><p>####### 故障恢复</p><ul><li><p>若同时开启了RDB和AOF，那么在故障恢复的时候先使用AOF文件进行恢复，这样可以保证丢失最少的数据，但是如果我们想尽快的恢复Redis服务，可以允许丢失一部分数据，那么可以禁用AOF，只使用RDB，使用RDB之所以比AOF快，是因为AOF是一条条命令的去执行的，直到最终状态，RDB是一次性把所有数据的最终状态刷到内存的</p></li><li><p>AOF日志文件的命令通过可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p></li><li></li></ul><h4 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制"></a> 主从复制</h4><p>​redis单节点存在单点故障问题，为了解决单点问题，一般都需要对redis配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率。</p><p>​<strong>复制过程</strong></p><ol><li><p>从节点执行slaveof [masterIP] [masterPort]，保存主节点信息 ；</p></li><li><p>从节点中的定时任务发现主节点信息，建立和主节点的socket连接；</p></li><li><p>从节点发送Ping信号，主节点返回Pong，两边能互相通信；</p></li><li><p>连接建立后，主节点将所有数据发送给从节点（数据同步）；</p></li><li><p>主节点把当前的数据同步给从节点后，便完成了复制的建立过程；</p></li><li><p>接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</p></li></ol><h4 id="哨兵"><a class="markdownIt-Anchor" href="#哨兵"></a> 哨兵</h4><ul><li>主从复制存在的问题<ol><li>一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预；</li><li>主节点的写能力受到单机的限制；</li><li>主节点的存储能力受到单机的限制；</li><li>原生复制的弊端在早期的版本中也会比较突出，比如：redis复制中断后，从节点会发起psync。此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</li></ol></li><li>改善方式</li></ul><p>哨兵模式是一种特殊的模式，Redis提供了哨兵命令，哨兵是一个独立的进程，原理是通过哨兵发送命令，然后等待Redis服务器的响应，进而实现对Redis实例的监控。</p><ul><li><p>运行方式</p><ul><li><p>通过命令的发送，Redis实例返回监控的运行状态，所有的Redis服务器</p></li><li><p>当master机器宕机后，会随机选择一个slave节点作为master，然后通过发布订阅模式通知其他slave节点，修改配置信息，更改跟随的主机</p></li><li><p>单哨兵模式相对来说不太可靠，毕竟会出现一言堂的情况，所以我们在使用哨兵的时候一般会采用多少兵模式，每一个哨兵都监控所有的Redis服务器，哨兵之间互相监控，当一个节点宕机后，只有指定数量的哨兵全部将其标记为下线，才会将节点移除</p></li></ul></li><li><p>故障切换过程</p><ul><li>主节点服务器宕机</li><li>哨兵1检测到主节点宕机，然后将其标记为客观下线，这个时候主节点还是主节点，并未进行failover过程</li><li>其他哨兵检测到主节点宕机，全部哨兵都会将主节点标记为客观下线</li><li>标记为客观下线的哨兵数量达到指定数量(sentinel.conf中配置，尽量设置为N/2+1)的时候，由一个哨兵(Raft选举)进行投票，根据投票结果决定是否进行主节点切换(选择优先级最高的，优先级可以通过slave-priority来设置，若优先级相同，则以复制偏移量最大的为主，若偏移量也全部相同，则选择服务ID最小的那个)</li><li>主节点切换完成之后，通过<em>发布订阅模式</em>让各个哨兵和从服务器更换主服务器配置，这个过程称为主观下线</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Redis是什么&lt;/li&gt;
&lt;li&gt;五种数据类型&lt;/li&gt;
&lt;li&gt;Redis为何这么快&lt;/li&gt;
&lt;li&gt;Redis和Memcac
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://luxiaowan.github.io/categories/Redis/"/>
    
    
      <category term="面试" scheme="http://luxiaowan.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>服务治理思考</title>
    <link href="http://luxiaowan.github.io/2020/03/24/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E6%80%9D%E8%80%83/"/>
    <id>http://luxiaowan.github.io/2020/03/24/服务治理思考/</id>
    <published>2020-03-24T05:21:00.000Z</published>
    <updated>2020-03-24T06:29:57.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>服务治理概念当下主要针对的是分布式架构下的多服务、微服务等。分布式系统由若干个大大小小的服务组成，服务之间通过HTTP或TCP的方式进行相互通信，促使整个系统活络起来。当分布式系统中的服务随着业务的发展不断变多时，我们就需要对服务进行相关的管理，不能一味的任由其野蛮增长。</p><h3 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h3><h4 id="1-节点管理即服务提供者在注册中心及客户端创建的服务节点"><a class="markdownIt-Anchor" href="#1-节点管理即服务提供者在注册中心及客户端创建的服务节点"></a> 1. 节点管理，即服务提供者在注册中心及客户端创建的服务节点。</h4><p>节点注册于注册中心，缓存于客户端，目的为若注册中心与服务端出现网络连通故障，但客户端与服务端网络连通正常，此时注册中心已将节点移除，但客户端在下一次同步注册中心节点之前仍可通过自身缓存的服务节点发送请求。</p><ul><li><p>注册中心管理：服务提供者定时向注册中心发送心跳通知来证明其是存活状态，每次收到心跳通知均与上一次收到通知的时间进行比较，如果时差超出注册中心允许的最大值，则认为该服务提供者发生故障，将其从注册中心移除，随即通知监听客户端。</p></li><li><p>客户端管理：若注册中心与服务端网络连通出现问题，但客户端与服务端网络连接正常，直至下一次与注册中心同步之前仍可继续使用该节点。若客户端与服务端网络连通故障，但注册中心与服务端网络连通正常，则客户端会将该节点从缓存中移除直至下一次与注册中心进行同步，周而复始。</p></li></ul><h4 id="2-负载均衡顾名思义平衡所有服务端处理请求的负载防止某个服务端因接受过多请求导致服务故障"><a class="markdownIt-Anchor" href="#2-负载均衡顾名思义平衡所有服务端处理请求的负载防止某个服务端因接受过多请求导致服务故障"></a> 2. 负载均衡，顾名思义：平衡所有服务端处理请求的负载，防止某个服务端因接受过多请求导致服务故障。</h4><ul><li><p>随机算法：字面意思，简洁明了，就是采用随机数的方式选择本次请求所要转发的服务端，此法非常公平，不会因为服务端配置的优劣而对其另眼相看，绝对的公平！</p></li><li><p>加权法：又叫轮询算法。本法则事在人为，完全按照主人的喜好行事，又称拍马屁，就好比食堂打饭，所有人围绕一个圈，如果打饭阿姨看到每个人的长相都一样，那么他对所有人都没有私心，从第一个开始每人给一勺，如此循环下去，谁都不会多谁也不会少，大家都均等，这就是大家的对注册中心来说权重都一样；如果打饭阿姨喜欢帅哥，看到长得帅的（比如我）每次都会多给一勺，其他人仍是一勺，此种情况对于注册中心而言，我的权重大于其他服务提供者，所以每一批请求中都会多分发给权重大的服务端。（此例不太恰当，换为吃饭：胖子和瘦子，胖子多吃，瘦子少吃，好像更好）。</p></li><li><p>最少活跃算法：这个拿吃饭来说吧，吃得多的碗落不下了，然后就少盛点，吃的少趁机多吃点均衡一下。上面也说了，打饭阿姨因为我长得帅，每次给别人打着饭呢都会不定时的拐到我这边给我加上一碗，递过来一碗饭，我桌子上的碗的数量就+1，等我吃完一碗饭将空碗回收后，桌子上的碗的数量就-1，但是打饭阿姨给的次数太过频繁，导致我面前很多碗，其他人面前的碗则很少，有人就向领导投诉，领导痛斥一顿后，阿姨则给面前碗最少的人开始打饭，这时此人碗的数量+1，然后阿姨重新统计，下一碗给统计后面前碗最少的人，这样大家都不至于被冷落，一旦落后，立刻照顾到。</p></li><li><p>一致性Hash算法：对每次请求的参数均计算hash，hash值相同的转发到同一个节点。上体育课1234报数排队，报到相同数字的站在一队，若某一队解散，由4队变成3队，则解散的这一队的人重新123报数，归并相关各队。（为什么不用吃饭举例了？因为再吃就撑死了！）</p></li></ul><h4 id="3-服务路由"><a class="markdownIt-Anchor" href="#3-服务路由"></a> 3. 服务路由</h4><ul><li><p>灰度访问：类似于单双号限行和不限行。一条马路刚修好，实行为期一个礼拜的单双号限行，一个礼拜之内无故障，则取消限行，大家都可以走。</p></li><li><p>就近原则：每次请求到达，客户端先关门在自己的局域网内查找可用的服务提供者，若有则直接调用，若未查到则出门浪。</p></li></ul><blockquote><p>配置分为静态配置和动态配置，这里不做解释了，字面意思！</p></blockquote><h4 id="4-服务容错有容奶大要有一颗包容的心没错是不是没发现奶非乃"><a class="markdownIt-Anchor" href="#4-服务容错有容奶大要有一颗包容的心没错是不是没发现奶非乃"></a> 4. 服务容错：有容奶大！要有一颗包容的心！没错，是不是没发现奶非乃！😳</h4><ul><li><p>failover：拆开来就是fail over，也就是请求服务端a，然后a故障了，那就直接将请求转发给服务端b，结果b也故障了，那就再转发给c，直到成功！当然也可以设置最大转发次数，比如设置最大转发次数是两次，那么（划重点）在服务端2也故障时就不会转发给c了，直接返回给客户端告知失败！此方式为幂等的，也就是每一个服务提供方返回的数据均相等。</p></li><li><p>failback：遇到请求故障，那么就告知客户端请求失败，不再重试，然后根据返回的指令进行下一步操作。</p></li><li><p>failcache：遇到故障，就把请求缓存起来，间隔一段时间再发起请求，防止频繁请求影响服务端恢复。</p></li><li><p>failfast：遇到故障就返回，管他誓言有多真！绝不重试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;服务治理概念当下主要针对的是分布式架构下的多服务、微服务等。分布式系统由若干个大大小小的服务组成，服务之间通过HTTP或TCP的方式进行相互通信
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://luxiaowan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="服务治理" scheme="http://luxiaowan.github.io/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OLTP和OLAP区别</title>
    <link href="http://luxiaowan.github.io/2020/03/24/OLTP%E5%92%8COLAP%E5%8C%BA%E5%88%AB/"/>
    <id>http://luxiaowan.github.io/2020/03/24/OLTP和OLAP区别/</id>
    <published>2020-03-24T03:15:00.000Z</published>
    <updated>2020-03-24T04:44:39.771Z</updated>
    
    <content type="html"><![CDATA[<p>我们在《<a href="http://luxiaowan.github.io/2020/03/24/MongoDB%E5%92%8CElasticsearch%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/">MongoDB和Elasticsearch简单对比</a>》一文中提到了OLAP和OLTP，然后我去问了几个技术人员，基本上知道这两个名词的人少之又少，当然这也情有可原，毕竟IT行业里名词太多了，我们来说一下这两者的区别</p><h3 id="词义"><a class="markdownIt-Anchor" href="#词义"></a> 词义</h3><ol><li>OLTP：on-line Transaction Processing，联机(在线)事务处理</li><li>OLAP：on-line Analytical Processing，联机(在线)分析处理</li></ol><blockquote><p>从名词上我们就可以看出，OLTP主要是执行日常基本的事务处理，OLAP主要是执行日常的数据分析</p></blockquote><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><ol><li>OLAP<ul><li>实时性不高。比如ES中常见的使用日期检索日志</li><li>数据量大。ES利用其倒排索引的特点强化全文检索能力，即使有大量的日志打到ES中，我们仍然可以很快的查询出对应数据，效率贼高</li><li>动态检索纬度。我们在做数据分析时，数据的检索纬度是非常重要的一个条件，因为我们一般都是需要依据某一纬度做数据分析，这样才能将分析出来的数据提供给决策使用，不同的决策者需要的纬度不同，所以OLAP需要支持动态的检索纬度</li></ul></li><li>OLTP<ul><li>实时性高。既然是联机事务处理，那么对实时性要求肯定是一个高指标要求，会尽量杜绝出现数据变更不实时的情况</li><li>数据量不是很大。数据量过大会影响CRUD的性能</li><li>对确定性的数据进行操作。</li><li>高并发且满足ACID。</li></ul></li></ol><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><ol><li>OLTP一般是指我们常说的关系型数据库，或者说是支持频繁CRUD的数据存储媒介。</li><li>OLAP一般用于大数据处理和数据仓库，目前OLAP系统内的数据大多是针对OLTP内存储的数据做出进一步分析和应用，然后提供信息支持最终决策，对其大多是查多改少</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在《&lt;a href=&quot;http://luxiaowan.github.io/2020/03/24/MongoDB%E5%92%8CElasticsearch%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/&quot;&gt;MongoDB和Elasticsea
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB和Elasticsearch对比</title>
    <link href="http://luxiaowan.github.io/2020/03/24/MongoDB%E5%92%8CElasticsearch%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://luxiaowan.github.io/2020/03/24/MongoDB和Elasticsearch简单对比/</id>
    <published>2020-03-24T02:09:00.000Z</published>
    <updated>2020-03-24T03:14:25.705Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>MongoDB和Elasticsearch都属于是NoSQL类型的数据存储媒介，两者有很大的一个相似度，但使用方式和场景还是有所区别的。</p><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><ol><li>MongoDB创立的初衷是为了干掉关系型数据库，和RDBMS算是竞争关系。</li><li>Elasticsearch起初就是以检索查询为主要应用场景出道，和RDBMS有点互相协助的意思。</li></ol><h3 id="相同点"><a class="markdownIt-Anchor" href="#相同点"></a> 相同点</h3><ol><li>数据存储格式为json</li><li>聚合和全文检索</li><li>CRUD</li><li>分片和复制</li><li>简单的join操作</li><li>适用于大数据量的处理</li><li>不支持事务</li></ol><h3 id="不同点"><a class="markdownIt-Anchor" href="#不同点"></a> 不同点</h3><ol><li>开发语言不同：ES的Java语言(restful)，Mongo是C++语言(driver)，从开发角度来看，ES对Java更方便</li><li>分片方式：ES是hash，Mongo是range和hash</li><li>分布式：ES的主副分片自动组合和配置，Mongo需要手动配置集群“路由+服务配置+sharding”</li><li>索引：ES自建倒排索引，检索力度强，Mongo手动创建索引（B树），不支持倒排索引，这点和RDBMS类似</li><li>检索字段：ES全文检索，可用的检索插件较多，Mongo对索引字段个数有限制，全文检索效率低乃至不采用</li><li>时效性：ES非实时，有丢数据的风险，Mongo实时，理论上无丢数据的风险</li></ol><h3 id="终"><a class="markdownIt-Anchor" href="#终"></a> 终</h3><p>ES偏向于检索、查询和数据分析，适用于OLAP（on-line Analytical Processing）系统，Mongo偏向于大数据下的CRUD，适用于OLTP（on-line Transaction Processing）系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;MongoDB和Elasticsearch都属于是NoSQL类型的数据存储媒介，两者有很大的一个相似度，但使用方式和场景还是有所区别的。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="NoSQL" scheme="http://luxiaowan.github.io/categories/NoSQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL简单优化技巧</title>
    <link href="http://luxiaowan.github.io/2020/03/23/MySQL%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <id>http://luxiaowan.github.io/2020/03/23/MySQL简单优化技巧/</id>
    <published>2020-03-22T18:08:00.000Z</published>
    <updated>2020-03-23T14:48:44.504Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>一提到MySQL优化，大多数同学都比较依赖于DBA，但是对于程序员来说，掌握SQL的编写技巧其实很重要。</p><h3 id="技巧"><a class="markdownIt-Anchor" href="#技巧"></a> 技巧</h3><ol><li>比较运算符能用“=”就不要用“&lt;&gt;”，因为“=”能够增大列索引的使用概率</li><li>如果只查询一条数据，那么就使用“limit 1”，告知查询游标找到第一个之后就返回，以免进行全表扫描</li><li>给列选择合适的类型，比如可以使用TINYINT代替INT，节省磁盘和内存的消耗</li><li>拆解复杂SQL，减少join的出现</li><li>若查询字段全部为某联合索引字段，则避免使用“SELECT * ”，*会造成回表</li><li>WHERE、ORDER BY、JOIN的列尽量使用索引字段</li><li>使用EXPLAIN查看执行计划</li><li>可以使用ENUM的时候不要用VARCHAR</li><li>字段尽量设置为NOT NULL，尤其是索引字段</li><li>长度比较大的字段尽量拆分为副表，如果这个字段不会被经常使用</li><li>经常发生变动的数据库尽量把查询缓存关闭，否则在每次变动的时候都要删除缓存，查询的时候也要查询和更新缓存，浪费时间</li><li>索引字段的长度尽量不要太长，毕竟一个索引数据页只有16k，如果一个索引内容过长，那么可能就会造成一个数据页只能存储一个索引字段，浪费空间</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;一提到MySQL优化，大多数同学都比较依赖于DBA，但是对于程序员来说，掌握SQL的编写技巧其实很重要。&lt;/p&gt;
&lt;h3 id=&quot;技巧&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luxiaowan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器浅谈</title>
    <link href="http://luxiaowan.github.io/2020/03/22/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B5%85%E8%B0%88/"/>
    <id>http://luxiaowan.github.io/2020/03/22/JVM垃圾收集器浅谈/</id>
    <published>2020-03-22T03:15:00.000Z</published>
    <updated>2020-03-24T06:20:21.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>JVM是做Java的同学都必须要了解的东西，为什么这么说，因为我们只有知道了Java程序运行环境的配置和工作逻辑，才能对运行环境进行相关的优化和配置修改，让JVM在不同的服务器环境使用不同的配置，从而达到JVM环境最优化。</p><p>说到JVM就不得不说一下GC（garbage collection），垃圾收集的意思是找到垃圾并清理掉，但是常规的垃圾收集器却是找到正在被使用的对象，然后把其他的对象全部当作是垃圾对象清理掉。</p><p>写过C语言的同学都知道，在C语言中，我们需要手动的去管理内存，在使用内存之前我们需要先申请（malloc）一定大小的内存，使用完成之后需要手动的把使用的内存释放掉（free），如果忘记释放内存则很快会导致内存溢出，</p><h2 id="gc算法"><a class="markdownIt-Anchor" href="#gc算法"></a> GC算法</h2><ol><li><p>引用计数法</p><p>为每个对象添加一个引用计数器，在对象被引用时，计数器+1，引用结束后，计数器-1，最终清除掉引用计数器为0的对象，并级联删除该对象引用的所有的对象，只保留引用计数不为0的对象。</p><p>这种算法看起来是不是很屌，是的，非常简单，只需要在对象被引用的时候串行修改引用计数器的值即可，但也容易出现一种问题：循环引用！循环引用就是几个废对象之间循环引用，尽管他们的引用计数器都不为0，但是在整个程序中却没有被使用，但是他们永远不会被回收，这样的对象多了之后很容易造成内存泄漏。</p></li><li><p>标记-清除</p></li><li><p>标记-清理-整理</p></li><li><p>可达性分析法</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;JVM是做Java的同学都必须要了解的东西，为什么这么说，因为我们只有知道了Java程序运行环境的配置和工作逻辑，才能对运行环境进行相关的优化和
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="GC" scheme="http://luxiaowan.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>RMI远程服务调用简述</title>
    <link href="http://luxiaowan.github.io/2020/03/20/RMI%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%AE%80%E8%BF%B0/"/>
    <id>http://luxiaowan.github.io/2020/03/20/RMI远程服务调用简述/</id>
    <published>2020-03-19T16:15:00.000Z</published>
    <updated>2020-03-19T17:50:31.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rmi是什么"><a class="markdownIt-Anchor" href="#rmi是什么"></a> RMI是什么</h2><p>RMI(Remote Method Invocation)意为远程方式调用，顾名思义，是Java版的RPC实现技术，是建立分布式Java应用程序的方便途径。RMI是基于接口的，一般是接口定义和实现分开在不同的工程中。</p><p>相似：Hessian，Burlap，Httpinvoker，webservice</p><h2 id="为什么使用rmi"><a class="markdownIt-Anchor" href="#为什么使用rmi"></a> 为什么使用RMI</h2><p>它允许运行在一台虚拟机上的方法调用运行在另一台虚拟机上的对象方法，这样可以让每个任务运行在更适合的虚拟机上。</p><h2 id="rmi怎么用"><a class="markdownIt-Anchor" href="#rmi怎么用"></a> RMI怎么用</h2><ul><li>定义一个java.rmi.Remote的子接口，也就是定义一个接口AnimalService，继承自Remote，接口中的所有方法必须显式的抛出java.rmi.RemoteException异常，否则服务会注册失败，谨记!</li><li>创建AnimalService的实现类DogServiceImpl，这个类需要继承java.rmi.server.UnicastRemoteObject</li><li>将服务AnimalService注册到rmi中心</li><li>客户端引用接口定义jar包</li><li>客户端获取AnimalService的远程服务</li><li>进行相关方法调用</li></ul><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><p>因为RMI是Java版的RPC通讯技术，所以他只适用于Java程序上，如果想跨语言通讯，那就只能另谋它法了</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><ul><li>接口（工程：rmi-api）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中所有的方法必须声明throws RemoteException</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">laugh</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现（工程：rmi-service）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cc.kevinlu.spidemo.spi.AnimalService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">AnimalService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DogServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">laugh</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Server</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cc.kevinlu.spidemo.spi.AnimalService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AnimalService dogService = <span class="keyword">new</span> DogServiceImpl();</span><br><span class="line">        AnimalService lionService = <span class="keyword">new</span> LionServiceImpl();</span><br><span class="line">      <span class="comment">// 设置服务提供的端口</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">8891</span>);</span><br><span class="line">      <span class="comment">// 设置rmi的host为127.0.0.1，否则可能会出现connect refused错误</span></span><br><span class="line">        System.setProperty(<span class="string">"java.rmi.server.host"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">      <span class="comment">// 发布服务</span></span><br><span class="line">        Naming.bind(<span class="string">"rmi://127.0.0.1:8891/dogs"</span>, dogService);</span><br><span class="line">        System.out.println(<span class="string">"dog service publish success!"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端（rmi-client：引用rmi-api）</li></ul><ol><li><p>正常情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnimalService dogService = (AnimalService) Naming.lookup(<span class="string">"rmi://127.0.0.1:8891/dogs"</span>);</span><br><span class="line">dogService.laugh();</span><br></pre></td></tr></table></figure></li><li><p>反射的方式去回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = Naming.lookup(<span class="string">"rmi://127.0.0.1:8891/dogs"</span>);</span><br><span class="line">Method method = obj.getClass().getMethod(<span class="string">"laugh"</span>);</span><br><span class="line">method.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;rmi是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rmi是什么&quot;&gt;&lt;/a&gt; RMI是什么&lt;/h2&gt;
&lt;p&gt;RMI(Remote Method Invocation)意为远程方式调用，顾名思义，是Java版的RPC实现技术，是建
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>设置生成CGLib和JDK代理生成的class文件</title>
    <link href="http://luxiaowan.github.io/2020/03/17/%E8%AE%BE%E7%BD%AE%E7%94%9F%E6%88%90CGLib%E5%92%8CJDK%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6/"/>
    <id>http://luxiaowan.github.io/2020/03/17/设置生成CGLib和JDK代理生成的class文件/</id>
    <published>2020-03-17T13:20:00.000Z</published>
    <updated>2020-03-17T13:54:16.360Z</updated>
    
    <content type="html"><![CDATA[<p>jdk和cglib代理方式属于是老生常谈了，这里就不说了，我们说一下特别的。</p><p>我们都知道cglib是针对于类，jdk是针对于接口，</p><p>cglib在目标类被代理后会自动生成目标类的子类，也就是<code>xxxclass$$EnhancerByCGLIB$$c03f68c4.class</code></p><p>jdk代理后会自动生成目标接口的实现，也就是<code>$Proxy0.class</code></p><p>我们平时代码在编译过程中是不会生成代理类的class文件，只有在运行中才会生成</p><p>我们可以通过在启动类中设置代理类生成路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置CGLib代理类的生成位置</span></span><br><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"./cg"</span>);</span><br><span class="line"><span class="comment">// 设置JDK代理类的输出</span></span><br><span class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jdk和cglib代理方式属于是老生常谈了，这里就不说了，我们说一下特别的。&lt;/p&gt;
&lt;p&gt;我们都知道cglib是针对于类，jdk是针对于接口，&lt;/p&gt;
&lt;p&gt;cglib在目标类被代理后会自动生成目标类的子类，也就是&lt;code&gt;xxxclass$$EnhancerByCGL
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux更换yum源</title>
    <link href="http://luxiaowan.github.io/2020/03/12/Centos%E6%9B%B4%E6%8D%A2yum%E6%BA%90/"/>
    <id>http://luxiaowan.github.io/2020/03/12/Centos更换yum源/</id>
    <published>2020-03-12T05:05:00.000Z</published>
    <updated>2020-03-12T13:35:37.430Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们安装的Linux虚拟机或购买的云服务器上默认使用的yum源在国内有时候会传输很慢，现在大多我们在使用Linux之前都会修改一下yum源，以下以centos为例，将yum源修改为阿里云的。可以到https://developer.aliyun.com/mirror/中查看帮助</p></blockquote><h4 id="备份机器中的源文件"><a class="markdownIt-Anchor" href="#备份机器中的源文件"></a> 备份机器中的源文件</h4><p>备份的目的是为了操作失败后可以随时回滚</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure><h4 id="下载新的-centos-baserepo-到-etcyumreposd"><a class="markdownIt-Anchor" href="#下载新的-centos-baserepo-到-etcyumreposd"></a> 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</h4><p>我们的yum源配置文件在/etc/yum.repos.d/目录中，所以我们将阿里云的repo文件下载到该目录下（可以根据系统版本到http://mirrors.aliyun.com/repo/查看对应的文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要下载与系统版本一致的repo文件</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><h4 id="运行yum-makecache生成缓存"><a class="markdownIt-Anchor" href="#运行yum-makecache生成缓存"></a> 运行yum makecache生成缓存</h4><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>若出现Couldn’t resolve host '<a href="http://mirrors.cloud.aliyuncs.com" target="_blank" rel="noopener">mirrors.cloud.aliyuncs.com</a>’的信息，则表示网络不通，可以使用下面命令修改repo文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们安装的Linux虚拟机或购买的云服务器上默认使用的yum源在国内有时候会传输很慢，现在大多我们在使用Linux之前都会修改一下yum源，以下以centos为例，将yum源修改为阿里云的。可以到https://developer.aliyun.c
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://luxiaowan.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>kubernates调整nodePort端口范围</title>
    <link href="http://luxiaowan.github.io/2020/03/11/kubernates%E8%B0%83%E6%95%B4nodePort%E7%AB%AF%E5%8F%A3%E8%8C%83%E5%9B%B4/"/>
    <id>http://luxiaowan.github.io/2020/03/11/kubernates调整nodePort端口范围/</id>
    <published>2020-03-11T08:02:00.000Z</published>
    <updated>2020-03-11T08:12:05.657Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，k8s 集群 nodePort 分配的端口范围为：30000-32767，如果我们指定的端口不在这个范围就会报错：</p><blockquote><p>Error: release kong failed: Service “xxx” is invalid: spec.ports[0].nodePort: Invalid value: 12306: provided port is not in the valid range. The range of valid ports is 30000-32767</p></blockquote><p>所以我们修改 /etc/kubernetes/manifests/kube-apiserver.yaml 文件，在 command 下添加 <code>--service-node-port-range=1-65535</code> 参数，添加 nodePort 范围参数后会自动生效，无需进行其他操作：<br><code>vim /etc/kubernetes/manifests/kube-apiserver.yaml</code></p><p><img src="/images/image-20200311160941739.png" alt="image-20200311160941739"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默认情况下，k8s 集群 nodePort 分配的端口范围为：30000-32767，如果我们指定的端口不在这个范围就会报错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Error: release kong failed: Service “xxx” is invalid:
      
    
    </summary>
    
    
      <category term="kubernates" scheme="http://luxiaowan.github.io/categories/kubernates/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos7.7安装kubernates集群</title>
    <link href="http://luxiaowan.github.io/2020/03/11/Centos7.7%E5%AE%89%E8%A3%85kubernates%E9%9B%86%E7%BE%A4/"/>
    <id>http://luxiaowan.github.io/2020/03/11/Centos7.7安装kubernates集群/</id>
    <published>2020-03-11T05:11:00.000Z</published>
    <updated>2020-03-11T06:52:52.764Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h4><p>本文主要讲解使用kubeadm搭建高可用的集群，这种方式是最简单最快的。</p><h4 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h4><p>我们安装k8s的机器资源条件如下：</p><ul><li>centos7.7</li><li>内存不低于2G，CPU不少于2核，否则在安装的时候会报错</li><li>集群中的所有机器都要保证网络连通性</li><li>相关端口开放</li><li>swap关闭</li></ul><ol><li><p>更新系统</p><p>在开始安装服务之前，我们先更新一下yum源，然后安装相关的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装git(可选)</span></span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure></li><li><p>禁用swap分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭swap分区，该命令只是临时关闭，机器重启后还会自动打开</span></span><br><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久性关闭swap分区，禁止机器重启后自动打开</span></span><br><span class="line">sed -i '/ swap / s/^/#/' /etc/fstab</span><br></pre></td></tr></table></figure></li><li><p>更换yum源为国内镜像</p><p>centos的yum源默认为国外的，如果你的服务器是在国内，那么可能访问不了，所以我们需要把yum的源更换为国内的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里有一个注意点，就是下面的Centos-7.repo，这里因为我们使用的centos7，如果你的系统是centos8，那么就改成Centos-8.repo，也就是改成相对应的版本，否则yum安装不了软件</span></span><br><span class="line">cd /etc/yum.repos.d  &amp;&amp; \</span><br><span class="line">sudo mv CentOS-Base.repo CentOS-Base.repo.bak &amp;&amp; \</span><br><span class="line">sudo wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo &amp;&amp; \</span><br><span class="line">yum clean all &amp;&amp; \</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></li><li><p>安装docker环境</p><p>k8s内部可以支持多种容器，我们最常使用的就是docker，所以我们这里也以docker为基础</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装docker依赖包</span></span><br><span class="line">yum install yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加docker库</span></span><br><span class="line">yum-config-manager --add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新源</span></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装docker</span></span><br><span class="line">yum install containerd.io-1.2.10 \</span><br><span class="line">  docker-ce-19.03.4 \</span><br><span class="line">  docker-ce-cli-19.03.4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置docker daemon</span></span><br><span class="line">mkdir /etc/docker</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  "exec-opts": ["native.cgroupdriver=systemd"],</span><br><span class="line">  "log-driver": "json-file",</span><br><span class="line">  "log-opts": &#123;</span><br><span class="line">    "max-size": "100m"</span><br><span class="line">  &#125;,</span><br><span class="line">  "storage-driver": "overlay2",</span><br><span class="line">  "storage-opts": [</span><br><span class="line">    "overlay2.override_kernel_check=true"</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建docker.service.d</span></span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用docker.service</span></span><br><span class="line">systemctl enable docker.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载&amp;重启docker</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>安装完之后使用docker -v查看版本</p></li><li><p>更换docker为国内源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置</span></span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">"registry-mirrors": ["https://registry.docker-cn.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker</span></span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure></li><li><p>安装kubeadm、kubelet、和kubectl</p><blockquote><p>kubeadm 负责引导集群，kubelet 在集群的所有节点运行，负责启动 pods 和 containers，kubectl 则负责与集群交互，我们需要在所有节点安装这些组件</p></blockquote><ol><li><p>配置k8s国内源</p><p>我们把k8s的源修改为阿里云的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置国内源</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>关闭SELinux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config</span><br></pre></td></tr></table></figure></li><li><p>配置网络参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl --system</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保 br_netfilter 模块已经加载</span></span><br><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure></li><li><p>安装并启动kubeadm、kubelet、和kubectl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">systemctl enable --now kubelet</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用kubeadm初始化集群</p><blockquote><p>因为我的服务器在国内，且由于 kubeadm 初始化集群的依赖镜像在国内访问不了，所以初始化集群之前先使用国内源拉取依赖镜像</p></blockquote><ol><li><p>拉取依赖镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取依赖镜像列表</span></span><br><span class="line">kubeadm config images list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用阿里源下载 K8s 依赖镜像</span></span><br><span class="line">kubeadm config images list |sed -e 's/^/docker pull /g' -e 's#k8s.gcr.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g' |sh -x</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过docker tag修改镜像与国外镜像名称相同，这样的目的是在初始化的时候，docker会先在本地查找，若本地已有镜像则不会再去远程拉取，等于来了一招瞒天过海</span></span><br><span class="line">docker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk '&#123;print "docker tag ",$1":"$2,$1":"$2&#125;' |sed -e 's#registry.cn-hangzhou.aliyuncs.com/google_containers#k8s.gcr.io#2' |sh -x</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除原镜像，这个可选</span></span><br><span class="line">docker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk '&#123;print "docker rmi ", $1":"$2&#125;' |sh -x</span><br></pre></td></tr></table></figure></li><li><p>master节点初始化</p><p>我们使用kubeadm init指令初始化master节点，具体的参数可参考官方文档：<a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> local_ip是本机局域网ip，kubectl_version是我们镜像的版本</span></span><br><span class="line">kubeadm init --apiserver-advertise-address=&lt;local_ip&gt; --kubernetes-version=&lt;kubectl_version&gt; --pod-network-cidr=10.244.0.0/16 --v=5</span><br></pre></td></tr></table></figure><p>执行成功之后，日志会打印出下面语句，并且会告知我们节点加入的方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root或非root用户均可执行</span></span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure></li><li><p>开启使用master节点资源</p><p>默认master节点是不参与pod调度的，这样对于master节点的资源来说有点太过浪费，所以我们通过下面的命令使master节点也参与pod调度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure></li></ol></li><li><p>添加网络组件</p><p>我们通过kubectl get nodes查看集群内的节点，当前应该只有master一个节点，但是节点的状态为NotReady，查看coredns的pod（kubectl get pod --all-namespaces），会发现coredns处于pending状态，原因就是我们还未安装网络组件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网络组件我们选择WeaveNet，安装完之后稍等一会就可以了</span></span><br><span class="line">kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"</span><br></pre></td></tr></table></figure></li><li><p>向集群中添加node节点</p><p>每一台node都需要操作从1~6的步骤，然后我们使用kubeadm join来添加到集群中，这里的token是在master节点创建的，我们可以使用<code>kubeadm token list</code>命令查看可用的token，如果没有可用的token，那么我们使用<code>kubeadm token create</code>创建新的token，一个token的有效期为24小时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.0.54:6443 --token 9dmyq2.c50cvh32r62o6jlx \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4640dd5d3788968d86ce3cb792c1e368586ee6731de5a07ad8ad331926a2f233</span><br></pre></td></tr></table></figure></li><li><p>验证</p><p>加入之后我们在master节点通过<code>kubectl get nodes</code>来查看所有的节点，验证是否加入成功。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础&quot;&gt;&lt;/a&gt; 基础&lt;/h4&gt;
&lt;p&gt;本文主要讲解使用kubeadm搭建高可用的集群，这种方式是最简单最快的。&lt;/p&gt;
&lt;h4 id=&quot;安装步骤&quot;&gt;&lt;a class=&quot;markdow
      
    
    </summary>
    
    
      <category term="kubernates" scheme="http://luxiaowan.github.io/categories/kubernates/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos中安装rz和sz替代ftp</title>
    <link href="http://luxiaowan.github.io/2020/03/10/Centos%E4%B8%AD%E5%AE%89%E8%A3%85rz%E5%92%8Csz%E6%9B%BF%E4%BB%A3ftp/"/>
    <id>http://luxiaowan.github.io/2020/03/10/Centos中安装rz和sz替代ftp/</id>
    <published>2020-03-10T04:44:00.000Z</published>
    <updated>2020-03-10T04:47:26.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>lrzsz 官网入口：<a href="http://freecode.com/projects/lrzsz/" target="_blank" rel="noopener">http://freecode.com/projects/lrzsz/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装lrzsz</span></span><br><span class="line">yum install -y lrzsz</span><br></pre></td></tr></table></figure><p>安装完成之后就可以直接使用了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上传文件</span></span><br><span class="line">rz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载文件</span></span><br><span class="line">sz</span><br></pre></td></tr></table></figure><p>操作很简单</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;lrzsz 官网入口：&lt;a href=&quot;http://freecode.com/projects/lrzsz/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://freecode.com/projects/lrzsz/&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://luxiaowan.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s中YAML文件解释</title>
    <link href="http://luxiaowan.github.io/2020/03/10/k8s%E4%B8%ADYAML%E6%96%87%E4%BB%B6%E8%A7%A3%E9%87%8A/"/>
    <id>http://luxiaowan.github.io/2020/03/10/k8s中YAML文件解释/</id>
    <published>2020-03-09T16:30:00.000Z</published>
    <updated>2020-03-09T16:34:54.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="yaml语法规则"><a class="markdownIt-Anchor" href="#yaml语法规则"></a> YAML语法规则</h4><blockquote><p>大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tal键，只允许使用空格 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 ”#” 表示注释，从这个字符一直到行尾，都会被解析器忽略</p><p>在Kubernetes中，只需要知道两种结构类型即可： Lists Maps</p></blockquote><p>####YAML属性解释</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yaml格式的pod定义文件完整内容：</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>       <span class="comment">#必选，版本号，例如v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       <span class="comment">#必选，Pod</span></span><br><span class="line"><span class="attr">metadata:</span>       <span class="comment">#必选，元数据</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">string</span>       <span class="comment">#必选，Pod名称</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">string</span>    <span class="comment">#必选，Pod所属的命名空间</span></span><br><span class="line"><span class="attr">  labels:</span>      <span class="comment">#自定义标签</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>     <span class="comment">#自定义标签名字</span></span><br><span class="line"><span class="attr">  annotations:</span>       <span class="comment">#自定义注释列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span>         <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line"><span class="attr">  containers:</span>      <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span>     <span class="comment">#必选，容器名称</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">string</span>    <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">[Always</span> <span class="string">| Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像</span></span><br><span class="line"><span class="string"></span><span class="attr">    command:</span> <span class="string">[string]</span>    <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line"><span class="attr">    args:</span> <span class="string">[string]</span>     <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line"><span class="attr">    workingDir:</span> <span class="string">string</span>     <span class="comment">#容器的工作目录</span></span><br><span class="line"><span class="attr">    volumeMounts:</span>    <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>     <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">string</span>    <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="string">boolean</span>    <span class="comment">#是否为只读模式</span></span><br><span class="line"><span class="attr">    ports:</span>       <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>     <span class="comment">#端口号名称</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="string">int</span>   <span class="comment">#容器需要监听的端口号</span></span><br><span class="line"><span class="attr">      hostPort:</span> <span class="string">int</span>    <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">string</span>     <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line"><span class="attr">    env:</span>       <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>     <span class="comment">#环境变量名称</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">string</span>    <span class="comment">#环境变量的值</span></span><br><span class="line"><span class="attr">    resources:</span>       <span class="comment">#资源限制和请求的设置</span></span><br><span class="line"><span class="attr">      limits:</span>      <span class="comment">#资源限制的设置</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">string</span>     <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line"><span class="attr">      requests:</span>      <span class="comment">#资源请求的设置</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">string</span>     <span class="comment">#内存清楚，容器启动的初始可用数量</span></span><br><span class="line"><span class="attr">    livenessProbe:</span>     <span class="comment">#对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class="line"><span class="attr">      exec:</span>      <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">[string]</span>  <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line"><span class="attr">      httpGet:</span>       <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">        port:</span> <span class="string">number</span></span><br><span class="line"><span class="attr">        host:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">        scheme:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">        HttpHeaders:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">      tcpSocket:</span>     <span class="comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class="line"><span class="attr">         port:</span> <span class="string">number</span></span><br><span class="line"><span class="attr">       initialDelaySeconds:</span> <span class="number">0</span>  <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line"><span class="attr">       timeoutSeconds:</span> <span class="number">0</span>   <span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class="line"><span class="attr">       periodSeconds:</span> <span class="number">0</span>    <span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class="line"><span class="attr">       successThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">       failureThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">       securityContext:</span></span><br><span class="line"><span class="attr">         privileged:</span><span class="literal">false</span></span><br><span class="line"><span class="attr">    restartPolicy:</span> <span class="string">[Always</span> <span class="string">| Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span></span><br><span class="line"><span class="string"></span><span class="attr">    nodeSelector:</span> <span class="string">obeject</span>  <span class="comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span></span><br><span class="line"><span class="attr">    imagePullSecrets:</span>    <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">    hostNetwork:</span><span class="literal">false</span>      <span class="comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class="line"><span class="attr">    volumes:</span>       <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>     <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line"><span class="attr">      emptyDir:</span> <span class="string">&#123;&#125;</span>     <span class="comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class="line"><span class="attr">      hostPath:</span> <span class="string">string</span>     <span class="comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">string</span>     <span class="comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class="line"><span class="attr">      secret:</span>      <span class="comment">#类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span></span><br><span class="line"><span class="attr">        scretname:</span> <span class="string">string</span>  </span><br><span class="line"><span class="attr">        items:</span>     </span><br><span class="line"><span class="attr">        - key:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">      configMap:</span>     <span class="comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">        items:</span></span><br><span class="line"><span class="attr">        - key:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;yaml语法规则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#yaml语法规则&quot;&gt;&lt;/a&gt; YAML语法规则&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tal键，只允许使用空格 缩进的
      
    
    </summary>
    
    
      <category term="kubernates" scheme="http://luxiaowan.github.io/categories/kubernates/"/>
    
    
  </entry>
  
  <entry>
    <title>Git修改已提交用户信息</title>
    <link href="http://luxiaowan.github.io/2020/02/11/Git%E4%BF%AE%E6%94%B9%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    <id>http://luxiaowan.github.io/2020/02/11/Git修改已提交用户信息/</id>
    <published>2020-02-11T08:46:00.000Z</published>
    <updated>2020-02-11T10:03:16.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修改git用户名和邮箱"><a class="markdownIt-Anchor" href="#修改git用户名和邮箱"></a> 修改Git用户名和邮箱</h3><ol><li>修改某一项目配置</li></ol><p>终端进入到项目所在目录下，执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config user.name "cc"</span><br><span class="line"></span><br><span class="line">git config user.email "cc@cc.cc"</span><br></pre></td></tr></table></figure><ol start="2"><li>修改全局配置</li></ol><p>打开终端，执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "cc"</span><br><span class="line"></span><br><span class="line">git config --global user.email "cc@cc.cc"</span><br></pre></td></tr></table></figure><h3 id="修改项目最近一次提交信息"><a class="markdownIt-Anchor" href="#修改项目最近一次提交信息"></a> 修改项目最近一次提交信息</h3><ol><li>修改提交用户</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author="username &lt;email&gt;"</span><br></pre></td></tr></table></figure><ol start="2"><li>修改提交备注信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>然后执行之后跳转到新的页面</p><p><img src="/images/image-20200211171804477.png" alt="image-20200211171804477"></p><p>修改顶部备注信息然后保存即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;修改git用户名和邮箱&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#修改git用户名和邮箱&quot;&gt;&lt;/a&gt; 修改Git用户名和邮箱&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;修改某一项目配置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;终端进入到项目所在目录下，执行以
      
    
    </summary>
    
    
      <category term="Git" scheme="http://luxiaowan.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux禁止root用户远程登录</title>
    <link href="http://luxiaowan.github.io/2020/02/11/Linux%E7%A6%81%E6%AD%A2root%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
    <id>http://luxiaowan.github.io/2020/02/11/Linux禁止root用户远程登录/</id>
    <published>2020-02-11T03:35:00.000Z</published>
    <updated>2020-02-11T05:05:54.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="添加一个新用户"><a class="markdownIt-Anchor" href="#添加一个新用户"></a> 添加一个新用户</h3><ol><li><p>添加新用户</p><p>useradd cc</p></li><li><p>设置新用户密码</p><p>passwd cc</p></li></ol><h3 id="修改etcsudoers文件"><a class="markdownIt-Anchor" href="#修改etcsudoers文件"></a> 修改/etc/sudoers文件</h3><p>找到## Allow root to run any commands anywhere</p><p>在<code>root ALL=(ALL) ALL</code>下方添加语句<code>cc ALL=(ALL) ALL</code></p><p><img src="/images/image-20200211113749629.png" alt="image-20200211113749629"></p><blockquote><p>此文件为readonly文件，保存使用<code>wq!</code>命令</p></blockquote><h3 id="修改etcsshsshd_config文件"><a class="markdownIt-Anchor" href="#修改etcsshsshd_config文件"></a> 修改/etc/ssh/sshd_config文件</h3><p>找到<code>PermitRootLogin yes</code>修改为<code>PermitRootLogin no</code></p><p>保存之后执行<code>service sshd restart</code>命令即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;添加一个新用户&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#添加一个新用户&quot;&gt;&lt;/a&gt; 添加一个新用户&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加新用户&lt;/p&gt;
&lt;p&gt;useradd cc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置新用户
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://luxiaowan.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>MacBook连接iPhone不稳定</title>
    <link href="http://luxiaowan.github.io/2020/02/11/MacBook%E8%BF%9E%E6%8E%A5iPhone%E4%B8%8D%E7%A8%B3%E5%AE%9A/"/>
    <id>http://luxiaowan.github.io/2020/02/11/MacBook连接iPhone不稳定/</id>
    <published>2020-02-11T01:32:00.000Z</published>
    <updated>2020-02-11T01:34:27.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p>MacBook经常在使用USB连接iPhone的时候不稳定，连接一跳一跳的</p><h1 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h1><p>在电脑终端下运行<code>sudo killall -STOP -c usbd</code>，然后输入电脑密码，然后重新插上连接线，就OK了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题&quot;&gt;&lt;/a&gt; 问题&lt;/h1&gt;
&lt;p&gt;MacBook经常在使用USB连接iPhone的时候不稳定，连接一跳一跳的&lt;/p&gt;
&lt;h1 id=&quot;解决&quot;&gt;&lt;a class=&quot;markdown
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://luxiaowan.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>头条、美团、滴滴、京东等大厂面试题</title>
    <link href="http://luxiaowan.github.io/2019/12/25/%E5%88%B7%E9%A2%98/"/>
    <id>http://luxiaowan.github.io/2019/12/25/刷题/</id>
    <published>2019-12-24T16:35:00.000Z</published>
    <updated>2019-12-24T16:36:27.409Z</updated>
    
    <content type="html"><![CDATA[<h4 id="头条"><a class="markdownIt-Anchor" href="#头条"></a> 头条</h4><ol><li><p>聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。</p></li><li><p>讲项目中的难点、挑战，你是如何解决的？</p></li><li><p>Redis 中有几种类型 &amp; 各自底层怎么实现的 &amp; 项目中哪个地方用了什么类型，怎么使用的？</p></li><li><p>Redis如何实现分布式锁，zk如何实现分布式锁，两者的区别。如果service还没执行完，分布式锁在Redis中已经过期了，怎么解决这种问题？</p></li><li><p>synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁。</p></li><li><p>锁升级的过程。</p></li><li><p>Java运行时区域及各个区域的作用、对GC的了解、Java内存模型及为什么要这么设计？</p></li><li><p>对索引的理解，组合索引，索引的最佳实践</p></li><li><p>countDownLatch用过没有，在项目中如何使用的，对AQS的了解。</p></li><li><p>写生产者消费者问题，考虑高并发的情况，可以使用Java 类库，白纸写代码。</p></li><li><p>设计一个发号器，考虑集群和高并发的情况，要求发号器生成的id是递增趋势，通过id可以区分出来是今天生成的id还是昨天生成的id，但是生成的id中不能直接带有日期，要具有一定的混淆功能，白纸写代码。</p></li><li><p>一个二位数组，每个元素都可以往上下左右四个方向走，寻找最长递增路径。如下图所示，最长递增路径即红色字体路径。白纸写代码。</p><p>![image-20190924230411189](/Users/chuan/Library/Application Support/typora-user-images/image-20190924230411189.png)</p></li></ol><h4 id="美团"><a class="markdownIt-Anchor" href="#美团"></a> 美团</h4><ol><li><p>数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？</p></li><li><p>聚簇索引/非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p></li><li><p>MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？</p></li><li><p>MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁</p></li><li><p>谈下对GC的了解，何为垃圾，有哪些GC算法，有哪些垃圾回收器，cms和g1的区别，还有一个直击灵魂的问题，看过cms的源码吗？</p></li><li><p>有没有排查过线上OOM的问题，如何排查的？</p></li><li><p>有没有使用过JVM自带的工具，如何使用的？</p></li><li><p>假设有下图所示的一个Full GC 的图，纵向是内存使用情况，横向是时间，你如何排查这个Full GC 的问题，怎么去解决你说出来的这些问题？</p><p>![image-20190924230348754](/Users/chuan/Library/Application Support/typora-user-images/image-20190924230348754.png)</p></li><li><p>说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的？</p></li><li><p>对CAS的理解，CAS带来的问题，如何解决这些问题？</p></li><li><p>volatile底层、synchronized底层、锁升级的过程、MESI</p></li><li><p>Ehcache支持哪些缓存？</p></li><li><p>JUC有研究没有，讲一讲？</p></li><li><p>聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。</p></li><li><p>讲项目中的难点、挑战，如何解决的，项目这一块会问的特别细。</p></li><li><p>如何保证RocketMQ 消息的顺序性，如何解决重复消费问题。</p></li><li><p>项目中如何保证接口的幂等操作。</p></li><li><p>讲一讲对Redis 的了解，项目中如何使用的，哪个地方使用的，为什么要使用？</p></li><li><p>哨兵机制、Redis 两种备份方式的区别，项目中用的哪种，为什么？</p></li><li><p>讲一讲对分布式锁的了解</p></li><li><p>项目中系统监控怎么做的？</p></li><li><p>如何理解Spring中的AOP 和 IOC，以及DI，读过Spring源码没有？</p></li><li><p>读过MyBatis源码没有？</p></li><li><p>说一个你了解最多的框架，说出你的理解。</p></li><li><p>如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？</p></li><li><p>聊一聊对分库分表的理解。</p></li><li><p>Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启/关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？</p></li><li><p>Dubbo有了解没有？</p></li><li><p>怎么理解Java 中和 MySQL中的乐观锁、悲观锁？</p></li><li><p>一致性hash</p></li></ol><h4 id="滴滴"><a class="markdownIt-Anchor" href="#滴滴"></a> 滴滴</h4><ol><li>聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图，讲数据库设计。</li><li>处理过线上OOM问题没有，如何处理的？</li><li>遇到过线上服务器CPU飙高的情况没有，如何处理的？</li><li>线上有没有遇到其他问题，如何处理的？</li><li>对线程池的理解，项目中哪个地方使用了，如何使用的，用的Excutor框架中的哪个实现类，为什么用这个</li><li>对CAS的理解，CAS带来的问题，如何解决这些问题?</li><li>volatile底层、synchronized底层、锁升级的过程、MESI</li><li>对MySQL索引的理解、对组合索引的理解、索引的最佳实践</li><li>分布式锁的实现、对比Redis分布式锁 &amp; ZK分布式锁</li><li>唯一ID如何实现的，Snowflake实现原理，Snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量</li><li>如果线上一个功能是用栈结构实现的，使用过程中要注意哪些问题，为什么？</li><li>怎么理解线程安全？</li><li>怎么理解接口幂等？项目中如何保证的接口幂等？</li><li>怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？</li><li>如何理解网关，网关带来的好处和坏处，如何解决</li><li>Hystrix功能  &amp; 在项目中怎么使用的 &amp; Hystrix怎么检测断路器是否要开启/关闭 &amp;Hystrix实现原理</li><li>怎么理解命令模式和观察者模式，手写一个观察者模式或者命令模式的代码，策略模式也行</li><li>掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式</li><li>如何设计一个秒杀系统？</li><li>如果我现在就是要实现每秒10w请求，不能熔断限流，如何去设计？</li><li>假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？</li><li>服务A调用服务B中一个接口，服务B调用服务C中一个接口，如何实现若服务B响应服务A成功，则服务C一定响应服务B成功，需要考虑系统性能问题？</li><li>递归使用中有什么需要注意的地方，递归写法一般可以用什么去替换？</li><li>有两个表，table a，table b，写SQL查询出仅在table a中的数据、仅在table b中的数据、既在table a 又在table b 中的数据？</li><li>Spring 源码有了解没有？</li><li>MyBatis源码有了解没有？</li><li>MySQL事务隔离级别、MVCC？</li></ol><h4 id="京东"><a class="markdownIt-Anchor" href="#京东"></a> 京东</h4><ol><li>一个final修饰的属性，定义的时候没有初始化，在无参构造函数中初始化，可以吗，为什么</li><li>说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的，为什么不用其他的集合类</li><li>HashMap，concurrentHashMap底层实现</li><li>List删除是怎么实现的，遍历的时候可以删除吗？为什么?</li><li>Redis中有哪些数据结构，了解过其底层怎么实现的吗，和Java中相似的数据结构的对比？</li><li>Redis是单线程的还是多线程的，为什么这么快？</li><li>Redis Hash中某个key过大，变为String类型的大key，怎么处理，使用中如何避免出现这种问题?</li><li>设计模式在项目中哪个地方用到了，怎么使用的，能不能画一个你熟悉的设计模式的UML图，手写单例模式，手写静态内部类实现的单例模式。</li><li>讲一讲MySQL索引，实际工作中，哪些场景用了B+Tree索引，哪些场景用了hash索引？</li><li>explain 可以看到哪些信息，什么信息说明什么，explain的结果列讲一下</li><li>Spring源码看过没有，会多少讲多少？</li><li>MyBatis源码看过没有，会多少讲多少？</li><li>CAS的缺点，如何解决？</li><li>AQS、countDownLatch如何实现？</li><li>线程池如何实现，核心线程数和最大线程数设置成多少，为什么这么设置，项目中哪个地方使用了线程池，使用时需要注意什么</li><li>MySQL事务隔离级别，幻读，脏读，项目中用什么事务隔离级别，为什么？</li><li>volatile底层原理、synchronized实现机制</li><li>对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？</li><li>Feign 和 Dubbo，了解多少说多少？</li><li>Eureka 和 Zookeeper，了解多少说多少？</li><li>Hystrix 和 sentinel，了解多少说多少？</li><li>Spring Cloud Alibaba，了解多少说多少？</li><li>对分库分表、读写分离的了解，了解多少说多少？</li><li>画一下Java 线程几个状态及状态之间互相转换的图？</li><li>聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图，讲数据库设计具体到部分表中有哪些字段？</li><li>部门体量比较大，可能需要加班，到凌晨两三点的那种，也可能通宵，通宵是大促期间，你能接受吗？</li><li>也会加班到十点，这个不是大促期间，但也不是每天，非常态情况，你能接受吗，你在哪里住，过来要多久，有男朋友吗？</li></ol><h4 id="火币"><a class="markdownIt-Anchor" href="#火币"></a> 火币</h4><ol><li>Kafka 如何保证消息顺序消费、在consumer group 中新增一个consumer  会提高消费消息的速度吗、那如果我想提高消息消费的速度，我要怎么办？</li><li>Redis几种数据结构及底层，项目中如何使用的Redis？</li><li>哨兵机制、选举算法</li><li>一致性hash</li><li>Redis是单线程的还是多线程的，为什么速度这么快？</li><li>多路复用的几种方式以及区别？</li><li>对线程池的理解，在项目中如何使用的，多个线程之间如何共享数据，多个进程之间如何共享数据？</li><li>HashMap、concurrentHashMap的区别及底层实现、HashMap和HashTable 的区别？</li><li>什么是红黑树，什么是B-Tree，为什么HashMap中用红黑树不用其他树？</li><li>对MySQL索引的理解，为什么MySQL索引中用B+Tree，不用B-Tree 或者其他树，为什么不用hash 索引？</li><li>数据库和缓存的双写一致性问题？</li></ol><h4 id="每日一淘"><a class="markdownIt-Anchor" href="#每日一淘"></a> 每日一淘</h4><ol><li>用过哪些Object类的方法，如何使用的</li><li>Java如何实现序列化的，Serialization底层如何实现的</li><li>countDownLatch如何实现的</li><li>项目中监控报警机制如何做的，说说你的了解</li><li>线上服务器CPU飙高，如何处理这个问题</li><li>服务A调用服务B，用户请求服务A，发现返回较慢，如何定位这个问题</li><li>TIME_WAIT是什么状态还记得吗，什么情况下网络会出现这个状态</li></ol><h4 id="linkedme"><a class="markdownIt-Anchor" href="#linkedme"></a> linkedme</h4><ol><li>内核态和用户态、cas 和 sout 哪个用到了内核态和用户态的切换</li><li>哪些典型的应用用的是UDP？</li><li>线程池有了解吗，项目中如何使用的？</li><li>计算密集型/IO密集型任务分别如何设置线程池的核心线程数和最大线程数，为什么这么设置？</li><li>假如我下午5点要和5个人一起开会，但是这5个人现在都出去了，不在公司，但是今天会回来，问，我如何开这场会，用Java 并发方面的知识回答。</li></ol><h4 id="算法题"><a class="markdownIt-Anchor" href="#算法题"></a> 算法题</h4><ol><li><p>[1,1,2,2,3,4,4,5,5,5]  找出不重复的元素（黄包车）</p></li><li><p>反转链表，要求时间复杂度O(N)，空间复杂度O(1)  （火币）</p></li><li><p>非递归实现斐波那契数列 （爱奇艺）</p></li><li><p>这一周股市价格为[2,6,1,4,8]，求哪一天买入哪一天卖出，可获得最大收益，最大收益为多少 （爱奇艺）</p></li><li><p>按照箭头方向查找二叉树 （金山云）</p><p>![image-20190924230728819](/Users/chuan/Library/Application Support/typora-user-images/image-20190924230728819.png)</p></li><li><p>表a b c之间用ID关联，求阴影部分的数据  （金山云）</p><p>![image-20190924230750484](/Users/chuan/Library/Application Support/typora-user-images/image-20190924230750484.png)</p></li><li><p>一个整形无序数组，里面三个数只和等于一个目标值，求这三个数  （小米）</p></li><li><p>链表问题  （小米）</p><p>![image-20190924230830166](/Users/chuan/Library/Application Support/typora-user-images/image-20190924230830166.png)</p></li><li><p>扑克牌问题  （小米）<br>有十张扑克牌，从上面开始抽，抽出一张放桌子上，然后再抽出一张放扑克牌的最下面，这样循环往复的操作，直到手里的牌都没有了。这时，桌子上牌的顺序正好是1 2 3 4 5 6 7 8 9 10。要求写代码求出原顺序</p></li><li><p>手写大顶堆 （linkedMe）</p></li><li><p>手写LRU 算法 （火币）</p></li><li><p>字符串相加  （滴滴）<br>两个数字类型的字符串，直接转int或者double肯定都放不下，然后求这两个数的和，返回值还是字符串，15分钟时间，要求无Bug</p></li><li><p>寻找目标值位置  （滴滴）<br>有一个二维数组，数组横向有序，纵向有序，求目标值的位置，10分钟时间</p></li><li><p>求字符串“efabcbaefehiabcba”中最长的回文数，不去重（美团）</p></li><li><p>反转int类型的值x，不要借用String，只用int 即可。&amp;&amp; 针对该程序，写出其应有的测试用例 （美团）</p></li><li><p>top K 问题（每日一淘）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;头条&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#头条&quot;&gt;&lt;/a&gt; 头条&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="http://luxiaowan.github.io/categories/Java/"/>
    
    
      <category term="面试" scheme="http://luxiaowan.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
